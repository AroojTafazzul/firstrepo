/*
	Copyright (c) 2004-2011, The Dojo Foundation All Rights Reserved.
	Available via Academic Free License >= 2.1 OR the modified BSD license.
	see: http://dojotoolkit.org/license for details
*/

/*
	This is an optimized version of Dojo, built for deployment and not for
	development. To get sources and documentation, please visit:

		http://dojotoolkit.org
*/

dojo.provide("misys.layer.common");
if(!dojo._hasResource["dojo.cldr.supplemental"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cldr.supplemental"] = true;
dojo.provide("dojo.cldr.supplemental");


dojo.getObject("cldr.supplemental", true, dojo);

dojo.cldr.supplemental.getFirstDayOfWeek = function(/*String?*/locale){
// summary: Returns a zero-based index for first day of the week
// description:
//		Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
//		e.g. Sunday (returns 0), or Monday (returns 1)

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
	var firstDay = {/*default is 1=Monday*/
		mv:5,
		ae:6,af:6,bh:6,dj:6,dz:6,eg:6,er:6,et:6,iq:6,ir:6,jo:6,ke:6,kw:6,
		ly:6,ma:6,om:6,qa:6,sa:6,sd:6,so:6,sy:6,tn:6,ye:6,
		ar:0,as:0,az:0,bw:0,ca:0,cn:0,fo:0,ge:0,gl:0,gu:0,hk:0,
		il:0,'in':0,jm:0,jp:0,kg:0,kr:0,la:0,mh:0,mn:0,mo:0,mp:0,
		mt:0,nz:0,ph:0,pk:0,sg:0,th:0,tt:0,tw:0,um:0,us:0,uz:0,
		vi:0,zw:0
// variant. do not use?		gb:0,
	};

	var country = dojo.cldr.supplemental._region(locale);
	var dow = firstDay[country];
	return (dow === undefined) ? 1 : dow; /*Number*/
};

dojo.cldr.supplemental._region = function(/*String?*/locale){
	locale = dojo.i18n.normalizeLocale(locale);
	var tags = locale.split('-');
	var region = tags[1];
	if(!region){
		// IE often gives language only (#2269)
		// Arbitrary mappings of language-only locales to a country:
		region = {de:"de", en:"us", es:"es", fi:"fi", fr:"fr", he:"il", hu:"hu", it:"it",
			ja:"jp", ko:"kr", nl:"nl", pt:"br", sv:"se", zh:"cn"}[tags[0]];
	}else if(region.length == 4){
		// The ISO 3166 country code is usually in the second position, unless a
		// 4-letter script is given. See http://www.ietf.org/rfc/rfc4646.txt
		region = tags[2];
	}
	return region;
};

dojo.cldr.supplemental.getWeekend = function(/*String?*/locale){
// summary: Returns a hash containing the start and end days of the weekend
// description:
//		Returns a hash containing the start and end days of the weekend according to local custom using locale,
//		or by default in the user's locale.
//		e.g. {start:6, end:0}

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/weekend{Start,End}
	var weekendStart = {/*default is 6=Saturday*/
		'in':0,
		af:4,dz:4,ir:4,om:4,sa:4,ye:4,
		ae:5,bh:5,eg:5,il:5,iq:5,jo:5,kw:5,ly:5,ma:5,qa:5,sd:5,sy:5,tn:5
	};

	var weekendEnd = {/*default is 0=Sunday*/
		af:5,dz:5,ir:5,om:5,sa:5,ye:5,
		ae:6,bh:5,eg:6,il:6,iq:6,jo:6,kw:6,ly:6,ma:6,qa:6,sd:6,sy:6,tn:6
	};

	var country = dojo.cldr.supplemental._region(locale);
	var start = weekendStart[country];
	var end = weekendEnd[country];
	if(start === undefined){start=6;}
	if(end === undefined){end=0;}
	return {start:start, end:end}; /*Object {start,end}*/
};

}

if(!dojo._hasResource["dojo.date"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date"] = true;
dojo.provide("dojo.date");

dojo.getObject("date", true, dojo);

/*=====
dojo.date = {
	// summary: Date manipulation utilities
}
=====*/

dojo.date.getDaysInMonth = function(/*Date*/dateObject){
	//	summary:
	//		Returns the number of days in the month used by dateObject
	var month = dateObject.getMonth();
	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	if(month == 1 && dojo.date.isLeapYear(dateObject)){ return 29; } // Number
	return days[month]; // Number
};

dojo.date.isLeapYear = function(/*Date*/dateObject){
	//	summary:
	//		Determines if the year of the dateObject is a leap year
	//	description:
	//		Leap years are years with an additional day YYYY-02-29, where the
	//		year number is a multiple of four with the following exception: If
	//		a year is a multiple of 100, then it is only a leap year if it is
	//		also a multiple of 400. For example, 1900 was not a leap year, but
	//		2000 is one.

	var year = dateObject.getFullYear();
	return !(year%400) || (!(year%4) && !!(year%100)); // Boolean
};

// FIXME: This is not localized
dojo.date.getTimezoneName = function(/*Date*/dateObject){
	//	summary:
	//		Get the user's time zone as provided by the browser
	// dateObject:
	//		Needed because the timezone may vary with time (daylight savings)
	//	description:
	//		Try to get time zone info from toString or toLocaleString method of
	//		the Date object -- UTC offset is not a time zone.  See
	//		http://www.twinsun.com/tz/tz-link.htm Note: results may be
	//		inconsistent across browsers.

	var str = dateObject.toString(); // Start looking in toString
	var tz = ''; // The result -- return empty string if nothing found
	var match;

	// First look for something in parentheses -- fast lookup, no regex
	var pos = str.indexOf('(');
	if(pos > -1){
		tz = str.substring(++pos, str.indexOf(')'));
	}else{
		// If at first you don't succeed ...
		// If IE knows about the TZ, it appears before the year
		// Capital letters or slash before a 4-digit year
		// at the end of string
		var pat = /([A-Z\/]+) \d{4}$/;
		if((match = str.match(pat))){
			tz = match[1];
		}else{
		// Some browsers (e.g. Safari) glue the TZ on the end
		// of toLocaleString instead of putting it in toString
			str = dateObject.toLocaleString();
			// Capital letters or slash -- end of string,
			// after space
			pat = / ([A-Z\/]+)$/;
			if((match = str.match(pat))){
				tz = match[1];
			}
		}
	}

	// Make sure it doesn't somehow end up return AM or PM
	return (tz == 'AM' || tz == 'PM') ? '' : tz; // String
};

// Utility methods to do arithmetic calculations with Dates

dojo.date.compare = function(/*Date*/date1, /*Date?*/date2, /*String?*/portion){
	//	summary:
	//		Compare two date objects by date, time, or both.
	//	description:
	//  	Returns 0 if equal, positive if a > b, else negative.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	portion:
	//		A string indicating the "date" or "time" portion of a Date object.
	//		Compares both "date" and "time" by default.  One of the following:
	//		"date", "time", "datetime"

	// Extra step required in copy for IE - see #3112
	date1 = new Date(+date1);
	date2 = new Date(+(date2 || new Date()));

	if(portion == "date"){
		// Ignore times and compare dates.
		date1.setHours(0, 0, 0, 0);
		date2.setHours(0, 0, 0, 0);
	}else if(portion == "time"){
		// Ignore dates and compare times.
		date1.setFullYear(0, 0, 0);
		date2.setFullYear(0, 0, 0);
	}
	
	if(date1 > date2){ return 1; } // int
	if(date1 < date2){ return -1; } // int
	return 0; // int
};

dojo.date.add = function(/*Date*/date, /*String*/interval, /*int*/amount){
	//	summary:
	//		Add to a Date in intervals of different size, from milliseconds to years
	//	date: Date
	//		Date object to start with
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//	amount:
	//		How much to add to the date.

	var sum = new Date(+date); // convert to Number before copying to accomodate IE (#3112)
	var fixOvershoot = false;
	var property = "Date";

	switch(interval){
		case "day":
			break;
		case "weekday":
			//i18n FIXME: assumes Saturday/Sunday weekend, but this is not always true.  see dojo.cldr.supplemental

			// Divide the increment time span into weekspans plus leftover days
			// e.g., 8 days is one 5-day weekspan / and two leftover days
			// Can't have zero leftover days, so numbers divisible by 5 get
			// a days value of 5, and the remaining days make up the number of weeks
			var days, weeks;
			var mod = amount % 5;
			if(!mod){
				days = (amount > 0) ? 5 : -5;
				weeks = (amount > 0) ? ((amount-5)/5) : ((amount+5)/5);
			}else{
				days = mod;
				weeks = parseInt(amount/5);
			}
			// Get weekday value for orig date param
			var strt = date.getDay();
			// Orig date is Sat / positive incrementer
			// Jump over Sun
			var adj = 0;
			if(strt == 6 && amount > 0){
				adj = 1;
			}else if(strt == 0 && amount < 0){
			// Orig date is Sun / negative incrementer
			// Jump back over Sat
				adj = -1;
			}
			// Get weekday val for the new date
			var trgt = strt + days;
			// New date is on Sat or Sun
			if(trgt == 0 || trgt == 6){
				adj = (amount > 0) ? 2 : -2;
			}
			// Increment by number of weeks plus leftover days plus
			// weekend adjustments
			amount = (7 * weeks) + days + adj;
			break;
		case "year":
			property = "FullYear";
			// Keep increment/decrement from 2/29 out of March
			fixOvershoot = true;
			break;
		case "week":
			amount *= 7;
			break;
		case "quarter":
			// Naive quarter is just three months
			amount *= 3;
			// fallthrough...
		case "month":
			// Reset to last day of month if you overshoot
			fixOvershoot = true;
			property = "Month";
			break;
//		case "hour":
//		case "minute":
//		case "second":
//		case "millisecond":
		default:
			property = "UTC"+interval.charAt(0).toUpperCase() + interval.substring(1) + "s";
	}

	if(property){
		sum["set"+property](sum["get"+property]()+amount);
	}

	if(fixOvershoot && (sum.getDate() < date.getDate())){
		sum.setDate(0);
	}

	return sum; // Date
};

dojo.date.difference = function(/*Date*/date1, /*Date?*/date2, /*String?*/interval){
	//	summary:
	//		Get the difference in a specific unit of time (e.g., number of
	//		months, weeks, days, etc.) between two dates, rounded to the
	//		nearest integer.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//		Defaults to "day".

	date2 = date2 || new Date();
	interval = interval || "day";
	var yearDiff = date2.getFullYear() - date1.getFullYear();
	var delta = 1; // Integer return value

	switch(interval){
		case "quarter":
			var m1 = date1.getMonth();
			var m2 = date2.getMonth();
			// Figure out which quarter the months are in
			var q1 = Math.floor(m1/3) + 1;
			var q2 = Math.floor(m2/3) + 1;
			// Add quarters for any year difference between the dates
			q2 += (yearDiff * 4);
			delta = q2 - q1;
			break;
		case "weekday":
			var days = Math.round(dojo.date.difference(date1, date2, "day"));
			var weeks = parseInt(dojo.date.difference(date1, date2, "week"));
			var mod = days % 7;

			// Even number of weeks
			if(mod == 0){
				days = weeks*5;
			}else{
				// Weeks plus spare change (< 7 days)
				var adj = 0;
				var aDay = date1.getDay();
				var bDay = date2.getDay();

				weeks = parseInt(days/7);
				mod = days % 7;
				// Mark the date advanced by the number of
				// round weeks (may be zero)
				var dtMark = new Date(date1);
				dtMark.setDate(dtMark.getDate()+(weeks*7));
				var dayMark = dtMark.getDay();

				// Spare change days -- 6 or less
				if(days > 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = -1;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 0;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = -1;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = -2;
							break;
						// Range contains weekend
						case (dayMark + mod) > 5:
							adj = -2;
					}
				}else if(days < 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = 0;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 1;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = 2;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = 1;
							break;
						// Range contains weekend
						case (dayMark + mod) < 0:
							adj = 2;
					}
				}
				days += adj;
				days -= (weeks*2);
			}
			delta = days;
			break;
		case "year":
			delta = yearDiff;
			break;
		case "month":
			delta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);
			break;
		case "week":
			// Truncate instead of rounding
			// Don't use Math.floor -- value may be negative
			delta = parseInt(dojo.date.difference(date1, date2, "day")/7);
			break;
		case "day":
			delta /= 24;
			// fallthrough
		case "hour":
			delta /= 60;
			// fallthrough
		case "minute":
			delta /= 60;
			// fallthrough
		case "second":
			delta /= 1000;
			// fallthrough
		case "millisecond":
			delta *= date2.getTime() - date1.getTime();
	}

	// Round for fractional values and DST leaps
	return Math.round(delta); // Number (integer)
};

}

if(!dojo._hasResource["dojo.date.locale"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.date.locale"] = true;
dojo.provide("dojo.date.locale");







dojo.getObject("date.locale", true, dojo);

// Localization methods for Date.   Honor local customs using locale-dependent dojo.cldr data.


// Load the bundles containing localization information for
// names and formats

//NOTE: Everything in this module assumes Gregorian calendars.
// Other calendars will be implemented in separate modules.

(function(){
	// Format a pattern without literals
	function formatPattern(dateObject, bundle, options, pattern){
		return pattern.replace(/([a-z])\1*/ig, function(match){
			var s, pad,
				c = match.charAt(0),
				l = match.length,
				widthList = ["abbr", "wide", "narrow"];
			switch(c){
				case 'G':
					s = bundle[(l < 4) ? "eraAbbr" : "eraNames"][dateObject.getFullYear() < 0 ? 0 : 1];
					break;
				case 'y':
					s = dateObject.getFullYear();
					switch(l){
						case 1:
							break;
						case 2:
							if(!options.fullYear){
								s = String(s); s = s.substr(s.length - 2);
								break;
							}
							// fallthrough
						default:
							pad = true;
					}
					break;
				case 'Q':
				case 'q':
					s = Math.ceil((dateObject.getMonth()+1)/3);
//					switch(l){
//						case 1: case 2:
							pad = true;
//							break;
//						case 3: case 4: // unimplemented
//					}
					break;
				case 'M':
					var m = dateObject.getMonth();
					if(l<3){
						s = m+1; pad = true;
					}else{
						var propM = ["months", "format", widthList[l-3]].join("-");
						s = bundle[propM][m];
					}
					break;
				case 'w':
					var firstDay = 0;
					s = dojo.date.locale._getWeekOfYear(dateObject, firstDay); pad = true;
					break;
				case 'd':
					s = dateObject.getDate(); pad = true;
					break;
				case 'D':
					s = dojo.date.locale._getDayOfYear(dateObject); pad = true;
					break;
				case 'E':
					var d = dateObject.getDay();
					if(l<3){
						s = d+1; pad = true;
					}else{
						var propD = ["days", "format", widthList[l-3]].join("-");
						s = bundle[propD][d];
					}
					break;
				case 'a':
					var timePeriod = (dateObject.getHours() < 12) ? 'am' : 'pm';
					s = options[timePeriod] || bundle['dayPeriods-format-wide-' + timePeriod];
					break;
				case 'h':
				case 'H':
				case 'K':
				case 'k':
					var h = dateObject.getHours();
					// strange choices in the date format make it impossible to write this succinctly
					switch (c){
						case 'h': // 1-12
							s = (h % 12) || 12;
							break;
						case 'H': // 0-23
							s = h;
							break;
						case 'K': // 0-11
							s = (h % 12);
							break;
						case 'k': // 1-24
							s = h || 24;
							break;
					}
					pad = true;
					break;
				case 'm':
					s = dateObject.getMinutes(); pad = true;
					break;
				case 's':
					s = dateObject.getSeconds(); pad = true;
					break;
				case 'S':
					s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;
					break;
				case 'v': // FIXME: don't know what this is. seems to be same as z?
				case 'z':
					// We only have one timezone to offer; the one from the browser
					s = dojo.date.locale._getZone(dateObject, true, options);
					if(s){break;}
					l=4;
					// fallthrough... use GMT if tz not available
				case 'Z':
					var offset = dojo.date.locale._getZone(dateObject, false, options);
					var tz = [
						(offset<=0 ? "+" : "-"),
						dojo.string.pad(Math.floor(Math.abs(offset)/60), 2),
						dojo.string.pad(Math.abs(offset)% 60, 2)
					];
					if(l==4){
						tz.splice(0, 0, "GMT");
						tz.splice(3, 0, ":");
					}
					s = tz.join("");
					break;
//				case 'Y': case 'u': case 'W': case 'F': case 'g': case 'A': case 'e':
//					console.log(match+" modifier unimplemented");
				default:
					throw new Error("dojo.date.locale.format: invalid pattern char: "+pattern);
			}
			if(pad){ s = dojo.string.pad(s, l); }
			return s;
		});
	}

/*=====
	dojo.date.locale.__FormatOptions = function(){
	//	selector: String
	//		choice of 'time','date' (default: date and time)
	//	formatLength: String
	//		choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'
	//	datePattern:String
	//		override pattern with this string
	//	timePattern:String
	//		override pattern with this string
	//	am: String
	//		override strings for am in times
	//	pm: String
	//		override strings for pm in times
	//	locale: String
	//		override the locale used to determine formatting rules
	//	fullYear: Boolean
	//		(format only) use 4 digit years whenever 2 digit years are called for
	//	strict: Boolean
	//		(parse only) strict parsing, off by default
		this.selector = selector;
		this.formatLength = formatLength;
		this.datePattern = datePattern;
		this.timePattern = timePattern;
		this.am = am;
		this.pm = pm;
		this.locale = locale;
		this.fullYear = fullYear;
		this.strict = strict;
	}
=====*/

dojo.date.locale._getZone = function(/*Date*/dateObject, /*boolean*/getName, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Returns the zone (or offset) for the given date and options.  This
	//		is broken out into a separate function so that it can be overridden
	//		by timezone-aware code.
	//
	// dateObject:
	//		the date and/or time being formatted.
	//
	// getName:
	//		Whether to return the timezone string (if true), or the offset (if false)
	//
	// options:
	//		The options being used for formatting
	if(getName){
		return dojo.date.getTimezoneName(dateObject);
	}else{
		return dateObject.getTimezoneOffset();
	}
};


dojo.date.locale.format = function(/*Date*/dateObject, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Format a Date object as a String, using locale-specific settings.
	//
	// description:
	//		Create a string from a Date object using a known localized pattern.
	//		By default, this method formats both date and time from dateObject.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//
	// dateObject:
	//		the date and/or time to be formatted.  If a time only is formatted,
	//		the values in the year, month, and day fields are irrelevant.  The
	//		opposite is true when formatting only dates.

	options = options || {};

	var locale = dojo.i18n.normalizeLocale(options.locale),
		formatLength = options.formatLength || 'short',
		bundle = dojo.date.locale._getGregorianBundle(locale),
		str = [],
		sauce = dojo.hitch(this, formatPattern, dateObject, bundle, options);
	if(options.selector == "year"){
		return _processPattern(bundle["dateFormatItem-yyyy"] || "yyyy", sauce);
	}
	var pattern;
	if(options.selector != "date"){
		pattern = options.timePattern || bundle["timeFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}
	if(options.selector != "time"){
		pattern = options.datePattern || bundle["dateFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}

	return str.length == 1 ? str[0] : bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
		function(match, key){ return str[key]; }); // String
};

dojo.date.locale.regexp = function(/*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Builds the regular needed to parse a localized date

	return dojo.date.locale._parseInfo(options).regexp; // String
};

dojo.date.locale._parseInfo = function(/*dojo.date.locale.__FormatOptions?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale),
		bundle = dojo.date.locale._getGregorianBundle(locale),
		formatLength = options.formatLength || 'short',
		datePattern = options.datePattern || bundle["dateFormat-" + formatLength],
		timePattern = options.timePattern || bundle["timeFormat-" + formatLength],
		pattern;
	if(options.selector == 'date'){
		pattern = datePattern;
	}else if(options.selector == 'time'){
		pattern = timePattern;
	}else{
		pattern = bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
			function(match, key){ return [timePattern, datePattern][key]; });
	}

	var tokens = [],
		re = _processPattern(pattern, dojo.hitch(this, _buildDateTimeRE, tokens, bundle, options));
	return {regexp: re, tokens: tokens, bundle: bundle};
};

dojo.date.locale.parse = function(/*String*/value, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Date object,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Date object from a string using a known localized pattern.
	//		By default, this method parses looking for both date and time in the string.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//		When two digit years are used, a century is chosen according to a sliding
	//		window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	//		year < 100CE requires strict mode.
	//
	// value:
	//		A string representation of a date

	// remove non-printing bidi control chars from input and pattern
	var controlChars = /[\u200E\u200F\u202A\u202E]/g,
		info = dojo.date.locale._parseInfo(options),
		tokens = info.tokens, bundle = info.bundle,
		re = new RegExp("^" + info.regexp.replace(controlChars, "") + "$",
			info.strict ? "" : "i"),
		match = re.exec(value && value.replace(controlChars, ""));

	if(!match){ return null; } // null

	var widthList = ['abbr', 'wide', 'narrow'],
		result = [1970,0,1,0,0,0,0], // will get converted to a Date at the end
		amPm = "",
		valid = dojo.every(match, function(v, i){
		if(!i){return true;}
		var token=tokens[i-1];
		var l=token.length;
		switch(token.charAt(0)){
			case 'y':
				if(l != 2 && options.strict){
					//interpret year literally, so '5' would be 5 A.D.
					result[0] = v;
				}else{
					if(v<100){
						v = Number(v);
						//choose century to apply, according to a sliding window
						//of 80 years before and 20 years after present year
						var year = '' + new Date().getFullYear(),
							century = year.substring(0, 2) * 100,
							cutoff = Math.min(Number(year.substring(2, 4)) + 20, 99),
							num = (v < cutoff) ? century + v : century - 100 + v;
						result[0] = num;
					}else{
						//we expected 2 digits and got more...
						if(options.strict){
							return false;
						}
						//interpret literally, so '150' would be 150 A.D.
						//also tolerate '1950', if 'yyyy' input passed to 'yy' format
						result[0] = v;
					}
				}
				break;
			case 'M':
				if(l>2){
					var months = bundle['months-format-' + widthList[l-3]].concat();
					if(!options.strict){
						//Tolerate abbreviating period in month part
						//Case-insensitive comparison
						v = v.replace(".","").toLowerCase();
						months = dojo.map(months, function(s){ return s.replace(".","").toLowerCase(); } );
					}
					v = dojo.indexOf(months, v);
					if(v == -1){
//						console.log("dojo.date.locale.parse: Could not parse month name: '" + v + "'.");
						return false;
					}
				}else{
					v--;
				}
				result[1] = v;
				break;
			case 'E':
			case 'e':
				var days = bundle['days-format-' + widthList[l-3]].concat();
				if(!options.strict){
					//Case-insensitive comparison
					v = v.toLowerCase();
					days = dojo.map(days, function(d){return d.toLowerCase();});
				}
				v = dojo.indexOf(days, v);
				if(v == -1){
//					console.log("dojo.date.locale.parse: Could not parse weekday name: '" + v + "'.");
					return false;
				}

				//TODO: not sure what to actually do with this input,
				//in terms of setting something on the Date obj...?
				//without more context, can't affect the actual date
				//TODO: just validate?
				break;
			case 'D':
				result[1] = 0;
				// fallthrough...
			case 'd':
				result[2] = v;
				break;
			case 'a': //am/pm
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
				if(!options.strict){
					var period = /\./g;
					v = v.replace(period,'').toLowerCase();
					am = am.replace(period,'').toLowerCase();
					pm = pm.replace(period,'').toLowerCase();
				}
				if(options.strict && v != am && v != pm){
//					console.log("dojo.date.locale.parse: Could not parse am/pm part.");
					return false;
				}

				// we might not have seen the hours field yet, so store the state and apply hour change later
				amPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';
				break;
			case 'K': //hour (1-24)
				if(v == 24){ v = 0; }
				// fallthrough...
			case 'h': //hour (1-12)
			case 'H': //hour (0-23)
			case 'k': //hour (0-11)
				//TODO: strict bounds checking, padding
				if(v > 23){
//					console.log("dojo.date.locale.parse: Illegal hours value");
					return false;
				}

				//in the 12-hour case, adjusting for am/pm requires the 'a' part
				//which could come before or after the hour, so we will adjust later
				result[3] = v;
				break;
			case 'm': //minutes
				result[4] = v;
				break;
			case 's': //seconds
				result[5] = v;
				break;
			case 'S': //milliseconds
				result[6] = v;
//				break;
//			case 'w':
//TODO				var firstDay = 0;
//			default:
//TODO: throw?
//				console.log("dojo.date.locale.parse: unsupported pattern char=" + token.charAt(0));
		}
		return true;
	});

	var hours = +result[3];
	if(amPm === 'p' && hours < 12){
		result[3] = hours + 12; //e.g., 3pm -> 15
	}else if(amPm === 'a' && hours == 12){
		result[3] = 0; //12am -> 0
	}

	//TODO: implement a getWeekday() method in order to test
	//validity of input strings containing 'EEE' or 'EEEE'...

	var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date
	if(options.strict){
		dateObject.setFullYear(result[0]);
	}

	// Check for overflow.  The Date() constructor normalizes things like April 32nd...
	//TODO: why isn't this done for times as well?
	var allTokens = tokens.join(""),
		dateToken = allTokens.indexOf('d') != -1,
		monthToken = allTokens.indexOf('M') != -1;

	if(!valid ||
		(monthToken && dateObject.getMonth() > result[1]) ||
		(dateToken && dateObject.getDate() > result[2])){
		return null;
	}

	// Check for underflow, due to DST shifts.  See #9366
	// This assumes a 1 hour dst shift correction at midnight
	// We could compare the timezone offset after the shift and add the difference instead.
	if((monthToken && dateObject.getMonth() < result[1]) ||
		(dateToken && dateObject.getDate() < result[2])){
		dateObject = dojo.date.add(dateObject, "hour", 1);
	}

	return dateObject; // Date
};

function _processPattern(pattern, applyPattern, applyLiteral, applyAll){
	//summary: Process a pattern with literals in it

	// Break up on single quotes, treat every other one as a literal, except '' which becomes '
	var identity = function(x){return x;};
	applyPattern = applyPattern || identity;
	applyLiteral = applyLiteral || identity;
	applyAll = applyAll || identity;

	//split on single quotes (which escape literals in date format strings)
	//but preserve escaped single quotes (e.g., o''clock)
	var chunks = pattern.match(/(''|[^'])+/g),
		literal = pattern.charAt(0) == "'";

	dojo.forEach(chunks, function(chunk, i){
		if(!chunk){
			chunks[i]='';
		}else{
			chunks[i]=(literal ? applyLiteral : applyPattern)(chunk.replace(/''/g, "'"));
			literal = !literal;
		}
	});
	return applyAll(chunks.join(''));
}

function _buildDateTimeRE(tokens, bundle, options, pattern){
	pattern = dojo.regexp.escapeString(pattern);
	if(!options.strict){ pattern = pattern.replace(" a", " ?a"); } // kludge to tolerate no space before am/pm
	return pattern.replace(/([a-z])\1*/ig, function(match){
		// Build a simple regexp.  Avoid captures, which would ruin the tokens list
		var s,
			c = match.charAt(0),
			l = match.length,
			p2 = '', p3 = '';
		if(options.strict){
			if(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }
			if(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }
		}else{
			p2 = '0?'; p3 = '0{0,2}';
		}
		switch(c){
			case 'y':
				s = '\\d{2,4}';
				break;
			case 'M':
				s = (l>2) ? '\\S+?' : '1[0-2]|'+p2+'[1-9]';
				break;
			case 'D':
				s = '[12][0-9][0-9]|3[0-5][0-9]|36[0-6]|'+p3+'[1-9][0-9]|'+p2+'[1-9]';
				break;
			case 'd':
				s = '3[01]|[12]\\d|'+p2+'[1-9]';
				break;
			case 'w':
				s = '[1-4][0-9]|5[0-3]|'+p2+'[1-9]';
				break;
			case 'E':
				s = '\\S+';
				break;
			case 'h': //hour (1-12)
				s = '1[0-2]|'+p2+'[1-9]';
				break;
			case 'k': //hour (0-11)
				s = '1[01]|'+p2+'\\d';
				break;
			case 'H': //hour (0-23)
				s = '1\\d|2[0-3]|'+p2+'\\d';
				break;
			case 'K': //hour (1-24)
				s = '1\\d|2[0-4]|'+p2+'[1-9]';
				break;
			case 'm':
			case 's':
				s = '[0-5]\\d';
				break;
			case 'S':
				s = '\\d{'+l+'}';
				break;
			case 'a':
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
				s = am + '|' + pm;
				if(!options.strict){
					if(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }
					if(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }
					if(s.indexOf('.') != -1){ s += '|' + s.replace(/\./g, ""); }
				}
				s = s.replace(/\./g, "\\.");
				break;
			default:
			// case 'v':
			// case 'z':
			// case 'Z':
				s = ".*";
//				console.log("parse of date format, pattern=" + pattern);
		}

		if(tokens){ tokens.push(match); }

		return "(" + s + ")"; // add capture
	}).replace(/[\xa0 ]/g, "[\\s\\xa0]"); // normalize whitespace.  Need explicit handling of \xa0 for IE.
}
})();

(function(){
var _customFormats = [];
dojo.date.locale.addCustomFormats = function(/*String*/packageName, /*String*/bundleName){
	// summary:
	//		Add a reference to a bundle containing localized custom formats to be
	//		used by date/time formatting and parsing routines.
	//
	// description:
	//		The user may add custom localized formats where the bundle has properties following the
	//		same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	//		The pattern string should match the format used by the CLDR.
	//		See dojo.date.locale.format() for details.
	//		The resources must be loaded by dojo.requireLocalization() prior to use

	_customFormats.push({pkg:packageName,name:bundleName});
};

dojo.date.locale._getGregorianBundle = function(/*String*/locale){
	var gregorian = {};
	dojo.forEach(_customFormats, function(desc){
		var bundle = dojo.i18n.getLocalization(desc.pkg, desc.name, locale);
		gregorian = dojo.mixin(gregorian, bundle);
	}, this);
	return gregorian; /*Object*/
};
})();

dojo.date.locale.addCustomFormats("dojo.cldr","gregorian");

dojo.date.locale.getNames = function(/*String*/item, /*String*/type, /*String?*/context, /*String?*/locale){
	// summary:
	//		Used to get localized strings from dojo.cldr for day or month names.
	//
	// item:
	//	'months' || 'days'
	// type:
	//	'wide' || 'narrow' || 'abbr' (e.g. "Monday", "Mon", or "M" respectively, in English)
	// context:
	//	'standAlone' || 'format' (default)
	// locale:
	//	override locale used to find the names

	var label,
		lookup = dojo.date.locale._getGregorianBundle(locale),
		props = [item, context, type];
	if(context == 'standAlone'){
		var key = props.join('-');
		label = lookup[key];
		// Fall back to 'format' flavor of name
		if(label[0] == 1){ label = undefined; } // kludge, in the absence of real aliasing support in dojo.cldr
	}
	props[1] = 'format';

	// return by copy so changes won't be made accidentally to the in-memory model
	return (label || lookup[props.join('-')]).concat(); /*Array*/
};

dojo.date.locale.isWeekend = function(/*Date?*/dateObject, /*String?*/locale){
	// summary:
	//	Determines if the date falls on a weekend, according to local custom.

	var weekend = dojo.cldr.supplemental.getWeekend(locale),
		day = (dateObject || new Date()).getDay();
	if(weekend.end < weekend.start){
		weekend.end += 7;
		if(day < weekend.start){ day += 7; }
	}
	return day >= weekend.start && day <= weekend.end; // Boolean
};

// These are used only by format and strftime.  Do they need to be public?  Which module should they go in?

dojo.date.locale._getDayOfYear = function(/*Date*/dateObject){
	// summary: gets the day of the year as represented by dateObject
	return dojo.date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1; // Number
};

dojo.date.locale._getWeekOfYear = function(/*Date*/dateObject, /*Number*/firstDayOfWeek){
	if(arguments.length == 1){ firstDayOfWeek = 0; } // Sunday

	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay(),
		adj = (firstDayOfYear - firstDayOfWeek + 7) % 7,
		week = Math.floor((dojo.date.locale._getDayOfYear(dateObject) + adj - 1) / 7);

	// if year starts on the specified day, start counting weeks at 1
	if(firstDayOfYear == firstDayOfWeek){ week++; }

	return week; // Number
};

}

if(!dojo._hasResource["dijit.form.DropDownButton"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.DropDownButton"] = true;
dojo.provide("dijit.form.DropDownButton");




}

if(!dojo._hasResource["dijit.Calendar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Calendar"] = true;
dojo.provide("dijit.Calendar");









dojo.declare(
	"dijit.Calendar",
	[dijit._Widget, dijit._Templated, dijit._CssStateMixin],
	{
		// summary:
		//		A simple GUI for choosing a date in the context of a monthly calendar.
		//
		// description:
		//		A simple GUI for choosing a date in the context of a monthly calendar.
		//		This widget can't be used in a form because it doesn't serialize the date to an
		//		`<input>` field.  For a form element, use dijit.form.DateTextBox instead.
		//
		//		Note that the parser takes all dates attributes passed in the
		//		[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
		//		so that they are serializable and locale-independent.
		//
		// example:
		//	|	var calendar = new dijit.Calendar({}, dojo.byId("calendarNode"));
		//
		// example:
		//	|	<div dojoType="dijit.Calendar"></div>

		templateString: dojo.cache("dijit", "templates/Calendar.html", "<table cellspacing=\"0\" cellpadding=\"0\" class=\"dijitCalendarContainer\" role=\"grid\" dojoAttachEvent=\"onkeypress: _onKeyPress\" aria-labelledby=\"${id}_year\">\n\t<thead>\n\t\t<tr class=\"dijitReset dijitCalendarMonthContainer\" valign=\"top\">\n\t\t\t<th class='dijitReset dijitCalendarArrow' dojoAttachPoint=\"decrementMonth\">\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarDecrease\" role=\"presentation\"/>\n\t\t\t\t<span dojoAttachPoint=\"decreaseArrowNode\" class=\"dijitA11ySideArrow\">-</span>\n\t\t\t</th>\n\t\t\t<th class='dijitReset' colspan=\"5\">\n\t\t\t\t<div dojoType=\"dijit.form.DropDownButton\" dojoAttachPoint=\"monthDropDownButton\"\n\t\t\t\t\tid=\"${id}_mddb\" tabIndex=\"-1\">\n\t\t\t\t</div>\n\t\t\t</th>\n\t\t\t<th class='dijitReset dijitCalendarArrow' dojoAttachPoint=\"incrementMonth\">\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarIncrease\" role=\"presentation\"/>\n\t\t\t\t<span dojoAttachPoint=\"increaseArrowNode\" class=\"dijitA11ySideArrow\">+</span>\n\t\t\t</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th class=\"dijitReset dijitCalendarDayLabelTemplate\" role=\"columnheader\"><span class=\"dijitCalendarDayLabel\"></span></th>\n\t\t</tr>\n\t</thead>\n\t<tbody dojoAttachEvent=\"onclick: _onDayClick, onmouseover: _onDayMouseOver, onmouseout: _onDayMouseOut, onmousedown: _onDayMouseDown, onmouseup: _onDayMouseUp\" class=\"dijitReset dijitCalendarBodyContainer\">\n\t\t<tr class=\"dijitReset dijitCalendarWeekTemplate\" role=\"row\">\n\t\t\t<td class=\"dijitReset dijitCalendarDateTemplate\" role=\"gridcell\"><span class=\"dijitCalendarDateLabel\"></span></td>\n\t\t</tr>\n\t</tbody>\n\t<tfoot class=\"dijitReset dijitCalendarYearContainer\">\n\t\t<tr>\n\t\t\t<td class='dijitReset' valign=\"top\" colspan=\"7\">\n\t\t\t\t<h3 class=\"dijitCalendarYearLabel\">\n\t\t\t\t\t<span dojoAttachPoint=\"previousYearLabelNode\" class=\"dijitInline dijitCalendarPreviousYear\"></span>\n\t\t\t\t\t<span dojoAttachPoint=\"currentYearLabelNode\" class=\"dijitInline dijitCalendarSelectedYear\" id=\"${id}_year\"></span>\n\t\t\t\t\t<span dojoAttachPoint=\"nextYearLabelNode\" class=\"dijitInline dijitCalendarNextYear\"></span>\n\t\t\t\t</h3>\n\t\t\t</td>\n\t\t</tr>\n\t</tfoot>\n</table>\n"),
		widgetsInTemplate: true,

		// value: Date
		//		The currently selected Date, initially set to invalid date to indicate no selection.
		value: new Date(""),
		// TODO: for 2.0 make this a string (ISO format) rather than a Date

		// datePackage: String
		//		JavaScript namespace to find Calendar routines.  Uses Gregorian Calendar routines
		//		at dojo.date by default.
		datePackage: "dojo.date",

		// dayWidth: String
		//		How to represent the days of the week in the calendar header. See dojo.date.locale
		dayWidth: "narrow",

		// tabIndex: Integer
		//		Order fields are traversed when user hits the tab key
		tabIndex: "0",
		
		// currentFocus: Date
		//		Date object containing the currently focused date, or the date which would be focused
		//		if the calendar itself was focused.   Also indicates which year and month to display,
		//		i.e. the current "page" the calendar is on.
		currentFocus: new Date(),

		baseClass:"dijitCalendar",

		// Set node classes for various mouse events, see dijit._CssStateMixin for more details
		cssStateNodes: {
			"decrementMonth": "dijitCalendarArrow",
			"incrementMonth": "dijitCalendarArrow",
			"previousYearLabelNode": "dijitCalendarPreviousYear",
			"nextYearLabelNode": "dijitCalendarNextYear"
		},

		_isValidDate: function(/*Date*/ value){
			// summary:
			//		Runs various tests on the value, checking that it's a valid date, rather
			//		than blank or NaN.
			// tags:
			//		private
			return value && !isNaN(value) && typeof value == "object" &&
				value.toString() != this.constructor.prototype.value.toString();
		},

		setValue: function(/*Date*/ value){
			// summary:
			//      Deprecated.   Use set('value', ...) instead.
			// tags:
			//      deprecated
			dojo.deprecated("dijit.Calendar:setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
			this.set('value', value);
		},

		_getValueAttr: function(){
			// summary:
			//		Support get('value')

			// this.value is set to 1AM, but return midnight, local time for back-compat
			var value = new this.dateClassObj(this.value);
			value.setHours(0, 0, 0, 0);

			// If daylight savings pushes midnight to the previous date, fix the Date
			// object to point at 1am so it will represent the correct day. See #9366
			if(value.getDate() < this.value.getDate()){
				value = this.dateFuncObj.add(value, "hour", 1);
			}
			return value;
		},

		_setValueAttr: function(/*Date|Number*/ value, /*Boolean*/ priorityChange){
			// summary:
			//		Support set("value", ...)
			// description:
			// 		Set the current date and update the UI.  If the date is disabled, the value will
			//		not change, but the display will change to the corresponding month.
			// value:
			//		Either a Date or the number of seconds since 1970.
			// tags:
			//      protected
			if(value){
				// convert from Number to Date, or make copy of Date object so that setHours() call below
				// doesn't affect original value
				value = new this.dateClassObj(value);
			}
			if(this._isValidDate(value)){
				if(!this._isValidDate(this.value) || this.dateFuncObj.compare(value, this.value)){
					value.setHours(1, 0, 0, 0); // round to nearest day (1am to avoid issues when DST shift occurs at midnight, see #8521, #9366)
	
					if(!this.isDisabledDate(value, this.lang)){
						this._set("value", value);
		
						// Set focus cell to the new value.   Arguably this should only happen when there isn't a current
						// focus point.   This will also repopulate the grid, showing the new selected value (and possibly
						// new month/year).
						this.set("currentFocus", value);
	
						if(priorityChange || typeof priorityChange == "undefined"){
							this.onChange(this.get('value'));
							this.onValueSelected(this.get('value'));	// remove in 2.0
						}
					}
				}
			}else{
				// clear value, and repopulate grid (to deselect the previously selected day) without changing currentFocus
				this._set("value", null);
				this.set("currentFocus", this.currentFocus);
			}
		},

		_setText: function(node, text){
			// summary:
			//		This just sets the content of node to the specified text.
			//		Can't do "node.innerHTML=text" because of an IE bug w/tables, see #3434.
			// tags:
			//      private
			while(node.firstChild){
				node.removeChild(node.firstChild);
			}
			node.appendChild(dojo.doc.createTextNode(text));
		},

		_populateGrid: function(){
			// summary:
			//      Fills in the calendar grid with each day (1-31)
			// tags:
			//      private
			var dateFocussed = "";
			if(dijit.byId('customer_bank') && dijit.byId('customer_bank').get('value') !== '' && misys && misys._config && misys._config.businessDateForBank && misys._config.businessDateForBank &&[dijit.byId('customer_bank').get('value')][0] && misys._config.businessDateForBank &&[dijit.byId('customer_bank').get('value')][0].value !== "")
			{
				dateFocussed = misys._config.businessDateForBank[dijit.byId('customer_bank').get('value')][0].value;
			}
			else if(dijit.byId('issuing_bank_abbv_name') && dijit.byId('issuing_bank_abbv_name').get('value') !== '' && misys && misys._config && misys._config.businessDateForBank &&[dijit.byId('issuing_bank_abbv_name').get('value')][0] && misys._config.businessDateForBank &&[dijit.byId('issuing_bank_abbv_name').get('value')][0].value !== "")
			{
				dateFocussed = misys._config.businessDateForBank[dijit.byId('issuing_bank_abbv_name').get('value')][0].value;
			}
			else if(dijit.byId('remitting_bank_abbv_name') && dijit.byId('remitting_bank_abbv_name').get('value') !== '' && misys && misys._config && misys._config.businessDateForBank  &&[dijit.byId('remitting_bank_abbv_name').get('value')][0] && misys._config.businessDateForBank &&[dijit.byId('remitting_bank_abbv_name').get('value')][0].value !== "")
			{
				dateFocussed = misys._config.businessDateForBank[dijit.byId('remitting_bank_abbv_name').get('value')][0].value;
			}
			else if(dijit.byId('recipient_bank_abbv_name') && dijit.byId('recipient_bank_abbv_name').get('value') !== '' && misys && misys._config && misys._config.businessDateForBank  &&[dijit.byId('recipient_bank_abbv_name').get('value')][0] && misys._config.businessDateForBank &&[dijit.byId('recipient_bank_abbv_name').get('value')][0].value !== "")
			{
				dateFocussed = misys._config.businessDateForBank[dijit.byId('recipient_bank_abbv_name').get('value')][0].value;
			}
			else if(dijit.byId('advising_bank_abbv_name') && dijit.byId('advising_bank_abbv_name').get('value') !== '' && misys && misys._config && misys._config.businessDateForBank  &&[dijit.byId('advising_bank_abbv_name').get('value')][0] && misys._config.businessDateForBank &&[dijit.byId('advising_bank_abbv_name').get('value')][0].value !== "")
			{
				dateFocussed = misys._config.businessDateForBank[dijit.byId('advising_bank_abbv_name').get('value')][0].value;
			}
			else if(dijit.byId('bank_abbv_name') && dijit.byId('bank_abbv_name').get('value') !== '' && misys && misys._config && misys._config.businessDateForBank  &&[dijit.byId('bank_abbv_name').get('value')][0] && misys._config.businessDateForBank &&[dijit.byId('bank_abbv_name').get('value')][0].value !== "")
			{
				dateFocussed = misys._config.businessDateForBank[dijit.byId('bank_abbv_name').get('value')][0].value;
			}
			else if(misys && misys._config && misys._config.bankBusinessDate && misys._config.bankBusinessDate !== "")
			{
				dateFocussed = misys._config.bankBusinessDate;
			}
			var month = new this.dateClassObj(this.currentFocus);
			month.setDate(1);

			var firstDay = month.getDay(),
				daysInMonth = this.dateFuncObj.getDaysInMonth(month),
				daysInPreviousMonth = this.dateFuncObj.getDaysInMonth(this.dateFuncObj.add(month, "month", -1)),
				today = null;
				if(dateFocussed !== ""){
					var yearServer = dateFocussed.substring(0,4);
					var monthServer = dateFocussed.substring(5,7);
					var dateServer = dateFocussed.substring(8,10);
					today = new this.dateClassObj(yearServer,monthServer - 1,dateServer);
				}
				else
				{
					today = new this.dateClassObj();
				}
		
			var dayOffset = dojo.cldr.supplemental.getFirstDayOfWeek(this.lang);
			if(dayOffset > firstDay){ dayOffset -= 7; }

			// Iterate through dates in the calendar and fill in date numbers and style info
			dojo.query(".dijitCalendarDateTemplate", this.domNode).forEach(function(template, i){
				i += dayOffset;
				var date = new this.dateClassObj(month),
					number, clazz = "dijitCalendar", adj = 0;

				if(i < firstDay){
					number = daysInPreviousMonth - firstDay + i + 1;
					adj = -1;
					clazz += "Previous";
				}else if(i >= (firstDay + daysInMonth)){
					number = i - firstDay - daysInMonth + 1;
					adj = 1;
					clazz += "Next";
				}else{
					number = i - firstDay + 1;
					clazz += "Current";
				}

				if(adj){
					date = this.dateFuncObj.add(date, "month", adj);
				}
				date.setDate(number);

				if(!this.dateFuncObj.compare(date, today, "date")){
					clazz = "dijitCalendarCurrentDate " + clazz;
				}

				if(this._isSelectedDate(date, this.lang)){
					clazz = "dijitCalendarSelectedDate " + clazz;
				}

				if(this.isDisabledDate(date, this.lang)){
					clazz = "dijitCalendarDisabledDate " + clazz;
				}

				var clazz2 = this.getClassForDate(date, this.lang);
				if(clazz2){
					clazz = clazz2 + " " + clazz;
				}

				template.className = clazz + "Month dijitCalendarDateTemplate";
				template.dijitDateValue = date.valueOf();				// original code
				dojo.attr(template, "dijitDateValue", date.valueOf());	// so I can dojo.query() it
				var label = dojo.query(".dijitCalendarDateLabel", template)[0],
					text = date.getDateLocalized ? date.getDateLocalized(this.lang) : date.getDate();
				this._setText(label, text);
			}, this);

			// Repopulate month drop down list based on current year.
			// Need to do this to hide leap months in Hebrew calendar.
			var monthNames = this.dateLocaleModule.getNames('months', 'wide', 'standAlone', this.lang, month);
			this.monthDropDownButton.dropDown.set("months", monthNames);

			// Set name of current month and also fill in spacer element with all the month names
			// (invisible) so that the maximum width will affect layout.   But not on IE6 because then
			// the center <TH> overlaps the right <TH> (due to a browser bug).
			this.monthDropDownButton.containerNode.innerHTML =
				(dojo.isIE == 6 ? "" : "<div class='dijitSpacer'>" + this.monthDropDownButton.dropDown.domNode.innerHTML + "</div>") +
				"<div class='dijitCalendarMonthLabel dijitCalendarCurrentMonthLabel'>" +  monthNames[month.getMonth()] + "</div>";

			// Fill in localized prev/current/next years
			var y = month.getFullYear() - 1;
			var d = new this.dateClassObj();
			dojo.forEach(["previous", "current", "next"], function(name){
				d.setFullYear(y++);
				this._setText(this[name+"YearLabelNode"],
					this.dateLocaleModule.format(d, {selector:'year', locale:this.lang}));
			}, this);
		},

		goToToday: function(){
			// summary:
			//      Sets calendar's value to today's date
			this.set('value', new this.dateClassObj());
		},

		constructor: function(/*Object*/args){
			var dateClass = (args.datePackage && (args.datePackage != "dojo.date"))? args.datePackage + ".Date" : "Date";
			this.dateClassObj = dojo.getObject(dateClass, false);
			this.datePackage = args.datePackage || this.datePackage;
			this.dateFuncObj = dojo.getObject(this.datePackage, false);
			this.dateLocaleModule = dojo.getObject(this.datePackage + ".locale", false);
		},

		postMixInProperties: function(){
			// Parser.instantiate sometimes passes in NaN for IE.  Use default value in prototype instead.
			// TODO: remove this for 2.0 (thanks to #11511)
			if(isNaN(this.value)){ delete this.value; }

			this.inherited(arguments);
		},

		buildRendering: function(){
			this.inherited(arguments);
			dojo.setSelectable(this.domNode, false);

			var cloneClass = dojo.hitch(this, function(clazz, n){
				var template = dojo.query(clazz, this.domNode)[0];
	 			for(var i=0; i<n; i++){
					template.parentNode.appendChild(template.cloneNode(true));
				}
			});

			// clone the day label and calendar day templates 6 times to make 7 columns
			cloneClass(".dijitCalendarDayLabelTemplate", 6);
			cloneClass(".dijitCalendarDateTemplate", 6);

			// now make 6 week rows
			cloneClass(".dijitCalendarWeekTemplate", 5);

			// insert localized day names in the header
			var dayNames = this.dateLocaleModule.getNames('days', this.dayWidth, 'standAlone', this.lang);
			var dayOffset = dojo.cldr.supplemental.getFirstDayOfWeek(this.lang);
			dojo.query(".dijitCalendarDayLabel", this.domNode).forEach(function(label, i){
				this._setText(label, dayNames[(i + dayOffset) % 7]);
			}, this);

			var dateObj = new this.dateClassObj(this.currentFocus);

			this.monthDropDownButton.dropDown = new dijit.Calendar._MonthDropDown({
				id: this.id + "_mdd",
				onChange: dojo.hitch(this, "_onMonthSelect")
			});

			this.set('currentFocus', dateObj, false);	// draw the grid to the month specified by currentFocus

			// Set up repeating mouse behavior for increment/decrement of months/years
			var _this = this;
			var typematic = function(nodeProp, dateProp, adj){
				_this._connects.push(
					dijit.typematic.addMouseListener(_this[nodeProp], _this, function(count){
						if(count >= 0){ _this._adjustDisplay(dateProp, adj); }
					}, 0.8, 500)
				);
			};
			typematic("incrementMonth", "month", 1);
			typematic("decrementMonth", "month", -1);
			typematic("nextYearLabelNode", "year", 1);
			typematic("previousYearLabelNode", "year", -1);
		},

		_adjustDisplay: function(/*String*/ part, /*int*/ amount){
			// summary:
			//      Moves calendar forwards or backwards by months or years
			// part:
			//      "month" or "year"
			// amount:
			//      Number of months or years
			// tags:
			//      private
			this._setCurrentFocusAttr(this.dateFuncObj.add(this.currentFocus, part, amount));
		},

		_setCurrentFocusAttr: function(/*Date*/ date, /*Boolean*/ forceFocus){
			// summary:
			//		If the calendar currently has focus, then focuses specified date,
			//		changing the currently displayed month/year if necessary.
			//		If the calendar doesn't have focus, updates currently
			//		displayed month/year, and sets the cell that will get focus.
			// forceFocus:
			//		If true, will focus() the cell even if calendar itself doesn't have focus

			var oldFocus = this.currentFocus,
				oldCell = oldFocus ? dojo.query("[dijitDateValue=" + oldFocus.valueOf() + "]", this.domNode)[0] : null;

			// round specified value to nearest day (1am to avoid issues when DST shift occurs at midnight, see #8521, #9366)
			date = new this.dateClassObj(date);
			date.setHours(1, 0, 0, 0);

			this._set("currentFocus", date);

			// TODO: only re-populate grid when month/year has changed
			this._populateGrid();

			// set tabIndex=0 on new cell, and focus it (but only if Calendar itself is focused)
			var newCell = dojo.query("[dijitDateValue=" + date.valueOf() + "]", this.domNode)[0];
			newCell.setAttribute("tabIndex", this.tabIndex);
			if(this._focused || forceFocus){
				newCell.focus();
			}

			// set tabIndex=-1 on old focusable cell
			if(oldCell && oldCell != newCell){
				if(dojo.isWebKit){	// see #11064 about webkit bug
					oldCell.setAttribute("tabIndex", "-1");
				}else{
						oldCell.removeAttribute("tabIndex");
				}
			}
		},

		focus: function(){
			// summary:
			//		Focus the calendar by focusing one of the calendar cells
			this._setCurrentFocusAttr(this.currentFocus, true);
		},

		_onMonthSelect: function(/*Number*/ newMonth){
			// summary:
			//      Handler for when user selects a month from the drop down list
			// tags:
			//      protected

			// move to selected month, bounding by the number of days in the month
			// (ex: dec 31 --> jan 28, not jan 31)
			this.currentFocus = this.dateFuncObj.add(this.currentFocus, "month",
				newMonth - this.currentFocus.getMonth());
			this._populateGrid();
		},

		_onDayClick: function(/*Event*/ evt){
			// summary:
			//      Handler for day clicks, selects the date if appropriate
			// tags:
			//      protected
			dojo.stopEvent(evt);
			for(var node = evt.target; node && !node.dijitDateValue; node = node.parentNode);
			if(node && !dojo.hasClass(node, "dijitCalendarDisabledDate")){
				this.set('value', node.dijitDateValue);
			}
		},

		_onDayMouseOver: function(/*Event*/ evt){
			// summary:
			//      Handler for mouse over events on days, sets hovered style
			// tags:
			//      protected

			// event can occur on <td> or the <span> inside the td,
			// set node to the <td>.
			var node =
				dojo.hasClass(evt.target, "dijitCalendarDateLabel") ?
				evt.target.parentNode :
				evt.target;

			if(node && (node.dijitDateValue || node == this.previousYearLabelNode || node == this.nextYearLabelNode) ){
				dojo.addClass(node, "dijitCalendarHoveredDate");
				this._currentNode = node;
			}
		},

		_onDayMouseOut: function(/*Event*/ evt){
			// summary:
			//      Handler for mouse out events on days, clears hovered style
			// tags:
			//      protected
	
			if(!this._currentNode){ return; }
			
			// if mouse out occurs moving from <td> to <span> inside <td>, ignore it
			if(evt.relatedTarget && evt.relatedTarget.parentNode == this._currentNode){ return; }
			var cls = "dijitCalendarHoveredDate";
			if(dojo.hasClass(this._currentNode, "dijitCalendarActiveDate")) {
				cls += " dijitCalendarActiveDate";
			}
			dojo.removeClass(this._currentNode, cls);
			this._currentNode = null;
		},
		
		_onDayMouseDown: function(/*Event*/ evt){
			var node = evt.target.parentNode;
			if(node && node.dijitDateValue){
				dojo.addClass(node, "dijitCalendarActiveDate");
				this._currentNode = node;
			}
		},
		
		_onDayMouseUp: function(/*Event*/ evt){
			var node = evt.target.parentNode;
			if(node && node.dijitDateValue){
				dojo.removeClass(node, "dijitCalendarActiveDate");
			}
		},

//TODO: use typematic
		handleKey: function(/*Event*/ evt){
			// summary:
			//		Provides keyboard navigation of calendar.
			// description:
			//		Called from _onKeyPress() to handle keypress on a stand alone Calendar,
			//		and also from `dijit.form._DateTimeTextBox` to pass a keypress event
			//		from the `dijit.form.DateTextBox` to be handled in this widget
			// returns:
			//		False if the key was recognized as a navigation key,
			//		to indicate that the event was handled by Calendar and shouldn't be propogated
			// tags:
			//		protected
			var toClick = false;
			var dk = dojo.keys,
				increment = -1,
				interval,
				newValue = this.currentFocus;
			switch(evt.keyCode){
				case dk.RIGHT_ARROW:
					increment = 1;
					//fallthrough...
				case dk.LEFT_ARROW:
					interval = "day";
					if(!this.isLeftToRight()){ increment *= -1; }
					break;
				case dk.DOWN_ARROW:
					increment = 1;
					//fallthrough...
				case dk.UP_ARROW:
					interval = "week";
					break;
				case dk.PAGE_DOWN:
					increment = 1;
					//fallthrough...
				case dk.PAGE_UP:
					interval = evt.ctrlKey || evt.altKey ? "year" : "month";
					break;
				case dk.END:
					// go to the next month
					newValue = this.dateFuncObj.add(newValue, "month", 1);
					// subtract a day from the result when we're done
					interval = "day";
					//fallthrough...
				case dk.HOME:
					newValue = new this.dateClassObj(newValue);
					newValue.setDate(1);
					break;
				case dk.ENTER:
				case dk.SPACE:
					if(window.isAccessibilityEnabled == true)
					{ 
						toClick = true; 
					}
					this.set("value", this.currentFocus);
					break;
				default:
					return true;
			}

			if(interval){
				newValue = this.dateFuncObj.add(newValue, interval, increment);
			}

			this._setCurrentFocusAttr(newValue);
			
			if(toClick)
			{
				this.domNode.tBodies[0].click();
			}
			
			return false;
		},

		_onKeyPress: function(/*Event*/ evt){
			// summary:
			//		For handling keypress events on a stand alone calendar
			if(!this.handleKey(evt)){
				dojo.stopEvent(evt);
			}
		},

		onValueSelected: function(/*Date*/ date){
			// summary:
			//		Notification that a date cell was selected.  It may be the same as the previous value.
			// description:
			//      Formerly used by `dijit.form._DateTimeTextBox` (and thus `dijit.form.DateTextBox`)
			//      to get notification when the user has clicked a date.  Now onExecute() (above) is used.
			// tags:
			//      protected
		},

		onChange: function(/*Date*/ date){
			// summary:
			//		Called only when the selected date has changed
		},

		_isSelectedDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		Extension point so developers can subclass Calendar to
			//		support multiple (concurrently) selected dates
			// tags:
			//		protected extension
			return this._isValidDate(this.value) && !this.dateFuncObj.compare(dateObject, this.value, "date")
		},

		isDisabledDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		May be overridden to disable certain dates in the calendar e.g. `isDisabledDate=dojo.date.locale.isWeekend`
			// tags:
			//      extension
/*=====
			return false; // Boolean
=====*/
		},

		getClassForDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		May be overridden to return CSS classes to associate with the date entry for the given dateObject,
			//		for example to indicate a holiday in specified locale.
			// tags:
			//      extension

/*=====
			return ""; // String
=====*/
		}
	}
);

dojo.declare("dijit.Calendar._MonthDropDown", [dijit._Widget, dijit._Templated], {
	// summary:
	//		The month drop down

	// months: String[]
	//		List of names of months, possibly w/some undefined entries for Hebrew leap months
	//		(ex: ["January", "February", undefined, "April", ...])
	months: [],

	templateString: "<div class='dijitCalendarMonthMenu dijitMenu' " +
		"dojoAttachEvent='onclick:_onClick,onmouseover:_onMenuHover,onmouseout:_onMenuHover'></div>",

	_setMonthsAttr: function(/*String[]*/ months){
		this.domNode.innerHTML = dojo.map(months, function(month, idx){
				return month ? "<div class='dijitCalendarMonthLabel' month='" + idx +"'>" + month + "</div>" : "";
			}).join("");
	},

	_onClick: function(/*Event*/ evt){
		this.onChange(dojo.attr(evt.target, "month"));
	},

	onChange: function(/*Number*/ month){
		// summary:
		//		Callback when month is selected from drop down
	},

	_onMenuHover: function(evt){
		dojo.toggleClass(evt.target, "dijitCalendarMonthLabelHover", evt.type == "mouseover");
	}
});

}

if(!dojo._hasResource["dijit.form._DateTimeTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._DateTimeTextBox"] = true;
dojo.provide("dijit.form._DateTimeTextBox");







new Date("X"); // workaround for #11279, new Date("") == NaN

/*=====
dojo.declare(
	"dijit.form._DateTimeTextBox.__Constraints",
	[dijit.form.RangeBoundTextBox.__Constraints, dojo.date.locale.__FormatOptions], {
	// summary:
	//		Specifies both the rules on valid/invalid values (first/last date/time allowed),
	//		and also formatting options for how the date/time is displayed.
	// example:
	//		To restrict to dates within 2004, displayed in a long format like "December 25, 2005":
	//	|		{min:'2004-01-01',max:'2004-12-31', formatLength:'long'}
});
=====*/

dojo.declare(
	"dijit.form._DateTimeTextBox",
	[ dijit.form.RangeBoundTextBox, dijit._HasDropDown ],
	{
		// summary:
		//		Base class for validating, serializable, range-bound date or time text box.

		templateString: dojo.cache("dijit.form", "templates/DropDownBox.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\"\n\trole=\"combobox\"\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\n\t\tdojoAttachPoint=\"_buttonNode, _popupStateNode\" role=\"presentation\"\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t${_buttonInputDisabled}\n\t/></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input aria-label=\"Form field error\" class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\n\t\t\tdojoAttachPoint=\"textbox,focusNode\" role=\"textbox\" aria-haspopup=\"true\"\n\t/></div\n></div>\n"),

		// hasDownArrow: [const] Boolean
		//		Set this textbox to display a down arrow button, to open the drop down list.
		hasDownArrow: true,

		// openOnClick: [const] Boolean
		//		Set to true to open drop down upon clicking anywhere on the textbox.
		openOnClick: true,

		/*=====
		// constraints: dijit.form._DateTimeTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including starting/ending dates/times allowed) as well as
		//		formatting options like whether the date is displayed in long (ex: December 25, 2005)
		//		or short (ex: 12/25/2005) format.  See `dijit.form._DateTimeTextBox.__Constraints` for details.
		constraints: {},
		======*/

		// Override ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale  (plus formatting options too?)
		regExpGen: dojo.date.locale.regexp,

		// datePackage: String
		//		JavaScript namespace to find calendar routines.	 Uses Gregorian calendar routines
		//		at dojo.date, by default.
		datePackage: "dojo.date",

		// Override _FormWidget.compare() to work for dates/times
		compare: function(/*Date*/ val1, /*Date*/ val2){
			var isInvalid1 = this._isInvalidDate(val1);
			var isInvalid2 = this._isInvalidDate(val2);
			return isInvalid1 ? (isInvalid2 ? 0 : -1) : (isInvalid2 ? 1 : dojo.date.compare(val1, val2, this._selector));
		},

		// flag to _HasDropDown to make drop down Calendar width == <input> width
		forceWidth: true,

		format: function(/*Date*/ value, /*dojo.date.locale.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Date, according to specified locale (second argument)
			// tags:
			//		protected
			if(!value){ return ''; }
			return this.dateLocaleModule.format(value, constraints);
		},

		"parse": function(/*String*/ value, /*dojo.date.locale.__FormatOptions*/ constraints){
			// summary:
			//		Parses as string as a Date, according to constraints
			// tags:
			//		protected

			return this.dateLocaleModule.parse(value, constraints) || (this._isEmpty(value) ? null : undefined);	 // Date
		},

		// Overrides ValidationTextBox.serialize() to serialize a date in canonical ISO format.
		serialize: function(/*anything*/ val, /*Object?*/ options){
			if(val.toGregorian){
				val = val.toGregorian();
			}
			return dojo.date.stamp.toISOString(val, options);
		},

		// dropDownDefaultValue: Date
		//		The default value to focus in the popupClass widget when the textbox value is empty.
		dropDownDefaultValue : new Date(),

		// value: Date
		//		The value of this widget as a JavaScript Date object.  Use get("value") / set("value", val) to manipulate.
		//		When passed to the parser in markup, must be specified according to `dojo.date.stamp.fromISOString`
		value: new Date(""),	// value.toString()="NaN"

		_blankValue: null,	// used by filter() when the textbox is blank

		// popupClass: [protected extension] String
		//		Name of the popup widget class used to select a date/time.
		//		Subclasses should specify this.
		popupClass: "", // default is no popup = text only


		// _selector: [protected extension] String
		//		Specifies constraints.selector passed to dojo.date functions, should be either
		//		"date" or "time".
		//		Subclass must specify this.
		_selector: "",

		constructor: function(/*Object*/ args){
			var dateClass = args.datePackage ? args.datePackage + ".Date" : "Date";
			this.dateClassObj = dojo.getObject(dateClass, false);
			this.value = new this.dateClassObj("");

			this.datePackage = args.datePackage || this.datePackage;
			this.dateLocaleModule = dojo.getObject(this.datePackage + ".locale", false);
			this.regExpGen = this.dateLocaleModule.regexp;
			this._invalidDate = dijit.form._DateTimeTextBox.prototype.value.toString();
			
			if(misys && misys._config && misys._config.bankBusinessDate)
			{
				var yearServer = misys._config.bankBusinessDate.substring(0,4);
				var monthServer = misys._config.bankBusinessDate.substring(5,7);
				var dateServer = misys._config.bankBusinessDate.substring(8,10);
				this.dropDownDefaultValue = new Date(yearServer,monthServer - 1,dateServer);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);

			if(!this.hasDownArrow){
				this._buttonNode.style.display = "none";
			}

			// If openOnClick is true, we basically just want to treat the whole widget as the
			// button.  We need to do that also if the actual drop down button will be hidden,
			// so that there's a mouse method for opening the drop down.
			if(this.openOnClick || !this.hasDownArrow){
				this._buttonNode = this.domNode;
				this.baseClass += " dijitComboBoxOpenOnClick";
			}
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			constraints.selector = this._selector;
			constraints.fullYear = true; // see #5465 - always format with 4-digit years
			var fromISO = dojo.date.stamp.fromISOString;
			if(typeof constraints.min == "string"){ constraints.min = fromISO(constraints.min); }
 			if(typeof constraints.max == "string"){ constraints.max = fromISO(constraints.max); }
			this.inherited(arguments);
		},

		_isInvalidDate: function(/*Date*/ value){
			// summary:
			//		Runs various tests on the value, checking for invalid conditions
			// tags:
			//		private
			return !value || isNaN(value) || typeof value != "object" || value.toString() == this._invalidDate;
		},

		_setValueAttr: function(/*Date|String*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Sets the date on this textbox. Note: value can be a JavaScript Date literal or a string to be parsed.
			if(value !== undefined){
				if(typeof value == "string"){
					value = dojo.date.stamp.fromISOString(value);
				}
				if(this._isInvalidDate(value)){
					value = null;
				}
				if(value instanceof Date && !(this.dateClassObj instanceof Date)){
					value = new this.dateClassObj(value);
				}
			}
			this.inherited(arguments);
			if(this.dropDown){
				this.dropDown.set('value', value, false);
			}
		},

		_set: function(attr, value){
			// Avoid spurious watch() notifications when value is changed to new Date object w/the same value
			if(attr == "value" && this.value instanceof Date && this.compare(value, this.value) == 0){
				return;
			}
			this.inherited(arguments);
		},

		_setDropDownDefaultValueAttr: function(/*Date*/ val){
			var x = val.toString() == this._invalidDate;
			var y = !val;
			var z = isNaN(val);
			var p = typeof val != "object";
			var q = val.toString() == this._invalidDate;
			if(this._isInvalidDate(val)){
				// convert null setting into today's date, since there needs to be *some* default at all times.
				 // taking the application date to be the default today's date
				if(misys && misys._config && misys._config.bankBusinessDate && misys._config.bankBusinessDate !== ""){
					var yearServer = misys._config.bankBusinessDate.substring(0,4);
					var monthServer = misys._config.bankBusinessDate.substring(5,7);
					var dateServer = misys._config.bankBusinessDate.substring(8,10);
					val = new this.dateClassObj(yearServer,monthServer - 1,dateServer);
				}
				else{
					val = new this.dateClassObj();
				}
			}
			this.dropDownDefaultValue = val;
		},

		openDropDown: function(/*Function*/ callback){
			// rebuild drop down every time, so that constraints get copied (#6002)
			if(this.dropDown){
				this.dropDown.destroy();
			}
			var PopupProto = dojo.getObject(this.popupClass, false),
				textBox = this,
				value = this.get("value");
			this.dropDown = new PopupProto({
				onChange: function(value){
						// this will cause InlineEditBox and other handlers to do stuff so make sure it's last
						dijit.form._DateTimeTextBox.superclass._setValueAttr.call(textBox, value, true);
					},
					id: this.id + "_popup",
					dir: textBox.dir,
					lang: textBox.lang,
				value: value,
				currentFocus: !this._isInvalidDate(value) ? value : this.dropDownDefaultValue,
					constraints: textBox.constraints,
				filterString: textBox.filterString, // for TimeTextBox, to filter times shown

					datePackage: textBox.datePackage,

					isDisabledDate: function(/*Date*/ date){
						// summary:
						// 	disables dates outside of the min/max of the _DateTimeTextBox
						return !textBox.rangeCheck(date, textBox.constraints);
					}
				});

			this.inherited(arguments);
		},

		_getDisplayedValueAttr: function(){
			return this.textbox.value;
		},

		_setDisplayedValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			this._setValueAttr(this.parse(value, this.constraints), priorityChange, value);
		}
	}
);

}

if(!dojo._hasResource["dijit.form.DateTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.DateTextBox"] = true;
dojo.provide("dijit.form.DateTextBox");




dojo.declare(
	"dijit.form.DateTextBox",
	dijit.form._DateTimeTextBox,
	{
		// summary:
		//		A validating, serializable, range-bound date text box with a drop down calendar
		//
		//		Example:
		// |	new dijit.form.DateTextBox({value: new Date(2009, 0, 20)})
		//
		//		Example:
		// |	<input dojotype='dijit.form.DateTextBox' value='2009-01-20'>

		baseClass: "dijitTextBox dijitComboBox dijitDateTextBox",
		popupClass: "dijit.Calendar",
		_selector: "date",

		// value: Date
		//		The value of this widget as a JavaScript Date object, with only year/month/day specified.
		//		If specified in markup, use the format specified in `dojo.date.stamp.fromISOString`.
		//		set("value", ...) accepts either a Date object or a string.
		value: new Date(""),	// value.toString()="NaN",
		buildRendering: function(){
			this.inherited(arguments);
			
			if(window.isAccessibilityEnabled) {
				dijit.setWaiState(this.textbox,"describedby",'date-instructions');
			}
		}	
	}
);

}

if(!dojo._hasResource["dojo.cldr.monetary"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cldr.monetary"] = true;
dojo.provide("dojo.cldr.monetary");

dojo.getObject("cldr.monetary", true, dojo);

dojo.cldr.monetary.getData = function(/*String*/code){
// summary: A mapping of currency code to currency-specific formatting information. Returns a unique object with properties: places, round.
// code: an [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code

// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/currencyData/fractions

	var placesData = {
			ADP:0,AFN:0,ALL:2,AMD:0,BHD:3,BIF:0,BYR:0,CLF:0,CLP:0,
			CRC:0,DJF:0,ESP:0,GNF:0,GYD:0,IQD:3,IRR:3,ISK:0,ITL:0,
			JOD:3,JPY:0,KMF:0,KPW:0,KRW:0,KWD:3,LAK:0,LUF:0,LYD:3,
			MGA:0,MGF:0,MMK:2,MNT:0,MRO:0,OMR:3,PYG:0,RWF:0,
			SLL:0,SOS:0,STD:0,TMM:0,TND:3,TRL:0,TZS:0,UGX:0,UZS:0,
			VND:0,VUV:0,XAF:0,XOF:0,XPF:0,YER:0,ZMK:0,ZWD:0
	};

	var roundingData = {CHF:5};

	var places = placesData[code], round = roundingData[code];
	if(typeof places == "undefined"){ places = 2; }
	if(typeof round == "undefined"){ round = 0; }

	return {places: places, round: round}; // Object
};

}

if(!dojo._hasResource["dojo.currency"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.currency"] = true;
dojo.provide("dojo.currency");





dojo.getObject("currency", true, dojo);

/*=====
dojo.currency = {
	// summary: localized formatting and parsing routines for currencies
	//
	// description: extends dojo.number to provide culturally-appropriate formatting of values
	//	in various world currencies, including use of a currency symbol.  The currencies are specified
	//	by a three-letter international symbol in all uppercase, and support for the currencies is
	//	provided by the data in `dojo.cldr`.  The scripts generating dojo.cldr specify which
	//	currency support is included.  A fixed number of decimal places is determined based
	//	on the currency type and is not determined by the 'pattern' argument.  The fractional
	//	portion is optional, by default, and variable length decimals are not supported.
}
=====*/

dojo.currency._mixInDefaults = function(options){
	options = options || {};
	options.type = "currency";

	// Get locale-dependent currency data, like the symbol
	var bundle = dojo.i18n.getLocalization("dojo.cldr", "currency", options.locale) || {};

	// Mixin locale-independent currency data, like # of places
	var iso = options.currency;
	var data = dojo.cldr.monetary.getData(iso);

	dojo.forEach(["displayName","symbol","group","decimal"], function(prop){
		data[prop] = bundle[iso+"_"+prop];
	});

	data.fractional = [true, false];

	// Mixin with provided options
	return dojo.mixin(data, options);
};

/*=====
dojo.declare("dojo.currency.__FormatOptions", [dojo.number.__FormatOptions], {
	//	type: String?
	//		Should not be set.  Value is assumed to be "currency".
	//	symbol: String?
	//		localized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`
	//		A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.
	//	currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD".
	//		For use with dojo.currency only.
	//	places: Number?
	//		number of decimal places to show.  Default is defined based on which currency is used.
	type: "",
	symbol: "",
	currency: "",
	places: ""
});
=====*/

dojo.currency.format = function(/*Number*/value, /*dojo.currency.__FormatOptions?*/options){
// summary:
//		Format a Number as a currency, using locale-specific settings
//
// description:
//		Create a string from a Number using a known, localized pattern.
//		[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Elements)
//		appropriate to the locale are chosen from the [CLDR](http://unicode.org/cldr)
//		as well as the appropriate symbols and delimiters and number of decimal places.
//
// value:
//		the number to be formatted.

	return dojo.number.format(value, dojo.currency._mixInDefaults(options));
};

dojo.currency.regexp = function(/*dojo.number.__RegexpOptions?*/options){
//
// summary:
//		Builds the regular needed to parse a currency value
//
// description:
//		Returns regular expression with positive and negative match, group and decimal separators
//		Note: the options.places default, the number of decimal places to accept, is defined by the currency type.
	return dojo.number.regexp(dojo.currency._mixInDefaults(options)); // String
};

/*=====
dojo.declare("dojo.currency.__ParseOptions", [dojo.number.__ParseOptions], {
	//	type: String?
	//		Should not be set.  Value is assumed to be currency.
	//	currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD".
	//		For use with dojo.currency only.
	//	symbol: String?
	//		localized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`
	//		A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.
	//	places: Number?
	//		fixed number of decimal places to accept.  The default is determined based on which currency is used.
	//	fractional: Boolean?|Array?
	//		Whether to include the fractional portion, where the number of decimal places are implied by the currency
	//		or explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
	//		By default for currencies, it the fractional portion is optional.
	type: "",
	currency: "",
	symbol: "",
	places: "",
	fractional: ""
});
=====*/

dojo.currency.parse = function(/*String*/expression, /*dojo.currency.__ParseOptions?*/options){
	//
	// summary:
	//		Convert a properly formatted currency string to a primitive Number,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Number from a string using a known, localized pattern.
	//		[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		are chosen appropriate to the locale, as well as the appropriate symbols and delimiters
	//		and number of decimal places.
	//
	// expression: A string representation of a currency value

	return dojo.number.parse(expression, dojo.currency._mixInDefaults(options));
};

}

if(!dojo._hasResource["dijit.form.NumberTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.NumberTextBox"] = true;
dojo.provide("dijit.form.NumberTextBox");




/*=====
dojo.declare(
	"dijit.form.NumberTextBox.__Constraints",
	[dijit.form.RangeBoundTextBox.__Constraints, dojo.number.__FormatOptions, dojo.number.__ParseOptions], {
	// summary:
	//		Specifies both the rules on valid/invalid values (minimum, maximum,
	//		number of required decimal places), and also formatting options for
	//		displaying the value when the field is not focused.
	// example:
	//		Minimum/maximum:
	//		To specify a field between 0 and 120:
	//	|		{min:0,max:120}
	//		To specify a field that must be an integer:
	//	|		{fractional:false}
	//		To specify a field where 0 to 3 decimal places are allowed on input:
	//	|		{places:'0,3'}
});
=====*/

dojo.declare("dijit.form.NumberTextBoxMixin",
	null,
	{
		// summary:
		//		A mixin for all number textboxes
		// tags:
		//		protected

		// Override ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale (plus formatting options too?)
		regExpGen: dojo.number.regexp,

		/*=====
		// constraints: dijit.form.NumberTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including minimum/maximum allowed values) as well as
		//		formatting options like places (the number of digits to display after
		//		the decimal point).  See `dijit.form.NumberTextBox.__Constraints` for details.
		constraints: {},
		======*/

		// value: Number
		//		The value of this NumberTextBox as a Javascript Number (i.e., not a String).
		//		If the displayed value is blank, the value is NaN, and if the user types in
		//		an gibberish value (like "hello world"), the value is undefined
		//		(i.e. get('value') returns undefined).
		//
		//		Symmetrically, set('value', NaN) will clear the displayed value,
		//		whereas set('value', undefined) will have no effect.
		value: NaN,

		// editOptions: [protected] Object
		//		Properties to mix into constraints when the value is being edited.
		//		This is here because we edit the number in the format "12345", which is
		//		different than the display value (ex: "12,345")
		editOptions: { pattern: '#.######' },

		/*=====
		_formatter: function(value, options){
			// summary:
			//		_formatter() is called by format().  It's the base routine for formatting a number,
			//		as a string, for example converting 12345 into "12,345".
			// value: Number
			//		The number to be converted into a string.
			// options: dojo.number.__FormatOptions?
			//		Formatting options
			// tags:
			//		protected extension

			return "12345";		// String
		},
		 =====*/
		_formatter: dojo.number.format,

		_setConstraintsAttr: function(/*Object*/ constraints){
			var places = typeof constraints.places == "number"? constraints.places : 0;
			if(places){ places++; } // decimal rounding errors take away another digit of precision
			if(typeof constraints.max != "number"){
				constraints.max = 9 * Math.pow(10, 15-places);
			}
			if(typeof constraints.min != "number"){
				constraints.min = -9 * Math.pow(10, 15-places);
			}
			this.inherited(arguments, [ constraints ]);
			if(this.focusNode && this.focusNode.value && !isNaN(this.value)){
				this.set('value', this.value);
			}
		},

		_onFocus: function(){
			if(this.disabled){ return; }
			var val = this.get('value');
			if(typeof val == "number" && !isNaN(val)){
				var formattedValue = this.format(val, this.constraints);
				if(formattedValue !== undefined){
					this.textbox.value = formattedValue;
				}
			}
			this.inherited(arguments);
		},

		format: function(/*Number*/ value, /*dojo.number.__FormatOptions*/ constraints){
			// summary:
			//		Formats the value as a Number, according to constraints.
			// tags:
			//		protected

			var formattedValue = String(value);
			if(typeof value != "number"){ return formattedValue; }
			if(isNaN(value)){ return ""; }
			// check for exponential notation that dojo.number.format chokes on
			if(!("rangeCheck" in this && this.rangeCheck(value, constraints)) && constraints.exponent !== false && /\de[-+]?\d/i.test(formattedValue)){
				return formattedValue;
			}
			if(this.editOptions && this._focused){
				constraints = dojo.mixin({}, constraints, this.editOptions);
			}
			return this._formatter(value, constraints);
		},

		/*=====
		_parser: function(value, constraints){
			// summary:
			//		Parses the string value as a Number, according to constraints.
			// value: String
			//		String representing a number
			// constraints: dojo.number.__ParseOptions
			//		Formatting options
			// tags:
			//		protected

			return 123.45;		// Number
		},
		=====*/
		_parser: dojo.number.parse,

		parse: function(/*String*/ value, /*dojo.number.__FormatOptions*/ constraints){
			// summary:
			//		Replacable function to convert a formatted string to a number value
			// tags:
			//		protected extension

			var v = this._parser(value, dojo.mixin({}, constraints, (this.editOptions && this._focused) ? this.editOptions : {}));
			if(this.editOptions && this._focused && isNaN(v)){
				v = this._parser(value, constraints); // parse w/o editOptions: not technically needed but is nice for the user
			}
			return v;
		},

		_getDisplayedValueAttr: function(){
			var v = this.inherited(arguments);
			return isNaN(v) ? this.textbox.value : v;
		},

		filter: function(/*Number*/ value){
			// summary:
			//		This is called with both the display value (string), and the actual value (a number).
			//		When called with the actual value it does corrections so that '' etc. are represented as NaN.
			//		Otherwise it dispatches to the superclass's filter() method.
			//
			//		See `dijit.form.TextBox.filter` for more details.
			return (value === null || value === '' || value === undefined) ? NaN : this.inherited(arguments); // set('value', null||''||undefined) should fire onChange(NaN)
		},

		serialize: function(/*Number*/ value, /*Object?*/ options){
			// summary:
			//		Convert value (a Number) into a canonical string (ie, how the number literal is written in javascript/java/C/etc.)
			// tags:
			//		protected
			return (typeof value != "number" || isNaN(value)) ? '' : this.inherited(arguments);
		},

		_setBlurValue: function(){
			var val = dojo.hitch(dojo.mixin({}, this, { _focused: true }), "get")('value'); // parse with editOptions
			this._setValueAttr(val, true);
		},

		_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			// summary:
			//		Hook so set('value', ...) works.
			if(value !== undefined && formattedValue === undefined){
				formattedValue = String(value);
				if(typeof value == "number"){
					if(isNaN(value)){ formattedValue = '' }
					// check for exponential notation that dojo.number.format chokes on
					else if(("rangeCheck" in this && this.rangeCheck(value, this.constraints)) || this.constraints.exponent === false || !/\de[-+]?\d/i.test(formattedValue)){
						formattedValue = undefined; // lets format comnpute a real string value
					}
				}else if(!value){ // 0 processed in if branch above, ''|null|undefined flow thru here
					formattedValue = '';
					value = NaN;
				}else{ // non-numeric values
					value = undefined;
				}
			}
			this.inherited(arguments, [value, priorityChange, formattedValue]);
		},

		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works.
			//		Returns Number, NaN for '', or undefined for unparsable text
			var v = this.inherited(arguments); // returns Number for all values accepted by parse() or NaN for all other displayed values

			// If the displayed value of the textbox is gibberish (ex: "hello world"), this.inherited() above
			// returns NaN; this if() branch converts the return value to undefined.
			// Returning undefined prevents user text from being overwritten when doing _setValueAttr(_getValueAttr()).
			// A blank displayed value is still returned as NaN.
			if(isNaN(v) && this.textbox.value !== ''){
				if(this.constraints.exponent !== false && /\de[-+]?\d/i.test(this.textbox.value) && (new RegExp("^"+dojo.number._realNumberRegexp(dojo.mixin({}, this.constraints))+"$").test(this.textbox.value))){	// check for exponential notation that parse() rejected (erroneously?)
					var n = Number(this.textbox.value);
					return isNaN(n) ? undefined : n; // return exponential Number or undefined for random text (may not be possible to do with the above RegExp check)
				}else{
					return undefined; // gibberish
				}
			}else{
				return v; // Number or NaN for ''
			}
		},

		isValid: function(/*Boolean*/ isFocused){
			// Overrides dijit.form.RangeBoundTextBox.isValid to check that the editing-mode value is valid since
			// it may not be formatted according to the regExp vaidation rules
			if(!this._focused || this._isEmpty(this.textbox.value)){
				return this.inherited(arguments);
			}else{
				var v = this.get('value');
				if(!isNaN(v) && this.rangeCheck(v, this.constraints)){
					if(this.constraints.exponent !== false && /\de[-+]?\d/i.test(this.textbox.value)){ // exponential, parse doesn't like it
						return true; // valid exponential number in range
					}else{
						return this.inherited(arguments);
					}
				}else{
					return false;
				}
			}
		}
	}
);

dojo.declare("dijit.form.NumberTextBox",
	[dijit.form.RangeBoundTextBox,dijit.form.NumberTextBoxMixin],
	{
		// summary:
		//		A TextBox for entering numbers, with formatting and range checking
		// description:
		//		NumberTextBox is a textbox for entering and displaying numbers, supporting
		//		the following main features:
		//
		//			1. Enforce minimum/maximum allowed values (as well as enforcing that the user types
		//				a number rather than a random string)
		//			2. NLS support (altering roles of comma and dot as "thousands-separator" and "decimal-point"
		//				depending on locale).
		//			3. Separate modes for editing the value and displaying it, specifically that
		//				the thousands separator character (typically comma) disappears when editing
		//				but reappears after the field is blurred.
		//			4. Formatting and constraints regarding the number of places (digits after the decimal point)
		//				allowed on input, and number of places displayed when blurred (see `constraints` parameter).

		baseClass: "dijitTextBox dijitNumberTextBox"
	}
);

}

if(!dojo._hasResource["dijit.form.CurrencyTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.CurrencyTextBox"] = true;
dojo.provide("dijit.form.CurrencyTextBox");




/*=====
dojo.declare(
	"dijit.form.CurrencyTextBox.__Constraints",
	[dijit.form.NumberTextBox.__Constraints, dojo.currency.__FormatOptions, dojo.currency.__ParseOptions], {
	// summary:
	//		Specifies both the rules on valid/invalid values (minimum, maximum,
	//		number of required decimal places), and also formatting options for
	//		displaying the value when the field is not focused (currency symbol,
	//		etc.)
	// description:
	//		Follows the pattern of `dijit.form.NumberTextBox.constraints`.
	//		In general developers won't need to set this parameter
	// example:
	//		To ensure that the user types in the cents (for example, 1.00 instead of just 1):
	//	|		{fractional:true}
});
=====*/

dojo.declare(
	"dijit.form.CurrencyTextBox",
	dijit.form.NumberTextBox,
	{
		// summary:
		//		A validating currency textbox
		// description:
		//		CurrencyTextBox is similar to `dijit.form.NumberTextBox` but has a few
		//		extra features related to currency:
		//
		//		1. After specifying the currency type (american dollars, euros, etc.) it automatically
		//			sets parse/format options such as how many decimal places to show.
		//		2. The currency mark (dollar sign, euro mark, etc.) is displayed when the field is blurred
		//			but erased during editing, so that the user can just enter a plain number.

		// currency: [const] String
		//		the [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD"
		currency: "",

		/*=====
		// constraints: dijit.form.CurrencyTextBox.__Constraints
		//		Despite the name, this parameter specifies both constraints on the input
		//		(including minimum/maximum allowed values) as well as
		//		formatting options.  See `dijit.form.CurrencyTextBox.__Constraints` for details.
		constraints: {},
		======*/
		
		baseClass: "dijitTextBox dijitCurrencyTextBox",

		// Override regExpGen ValidationTextBox.regExpGen().... we use a reg-ex generating function rather
		// than a straight regexp to deal with locale  (plus formatting options too?)
		regExpGen: function(constraints){
			// if focused, accept either currency data or NumberTextBox format
			return '(' + (this._focused? this.inherited(arguments, [ dojo.mixin({}, constraints, this.editOptions) ]) + '|' : '')
				+ dojo.currency.regexp(constraints) + ')';
		},

		// Override NumberTextBox._formatter to deal with currencies, ex: converts "123.45" to "$123.45"
		_formatter: dojo.currency.format,

		_parser: dojo.currency.parse,

		parse: function(/*String*/ value, /*Object*/ constraints){
			// summary:
			// 		Parses string value as a Currency, according to the constraints object
			// tags:
			// 		protected extension
			var v = this.inherited(arguments);
			if(isNaN(v) && /\d+/.test(value)){ // currency parse failed, but it could be because they are using NumberTextBox format so try its parse
				v = dojo.hitch(dojo.mixin({}, this, { _parser: dijit.form.NumberTextBox.prototype._parser }), "inherited")(arguments);
			}
			return v;
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			if(!constraints.currency && this.currency){
				constraints.currency = this.currency;
			}
			this.inherited(arguments, [ dojo.currency._mixInDefaults(dojo.mixin(constraints, { exponent: false })) ]); // get places
		}
	}
);

}

if(!dojo._hasResource["misys.form.CurrencyTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.form.CurrencyTextBox"] = true;
dojo.provide("misys.form.CurrencyTextBox");
dojo.experimental("misys.form.CurrencyTextBox");



dojo.declare("misys.form.CurrencyTextBox", dijit.form.CurrencyTextBox, {
	// summary:
	//		Widget that formats the currency before validating
	// Values like "1.1" or "33.2" are formatted to "1.10" or "33.20" respectively

	validator: function(/*anything*/ value, /*dijit.form.ValidationTextBox.__Constraints*/ constraints){
		// summary:
		//		Overridable function used to validate the text input against the regular expression.
		// tags:
		//		protected
		var decimalValue, amtValue = value;
		if(constraints && constraints.places && value)
		{
			//Get the type of decimal seperator
			var locale = dojo.i18n.normalizeLocale(constraints.locale),
				bundle = dojo.i18n.getLocalization("dojo.cldr", "number", locale),
				decimal = bundle.decimal;
			
			var noOfDecimals =  constraints.places;
			if(value.indexOf(decimal) >= 0)
			{
				decimalValue = value.substring(value.indexOf(decimal) + 1, value.length);
				if(noOfDecimals > decimalValue.length)
				{
					while(decimalValue.length < noOfDecimals)
					{
						amtValue = amtValue + "0";
						decimalValue = decimalValue + "0";
					}
					//this.value = amtValue;
					this.textbox.value = amtValue;
					this._set("displayedValue", this.get("displayedValue"));
				}
			}
		}
		return (new RegExp("^(?:" + this.regExpGen(constraints) + ")"+(this.required?"":"?")+"$")).test(amtValue) &&
		(!this.required || !this._isEmpty(value)) &&
		(this._isEmpty(value) || this.parse(value, constraints) !== undefined);
	}
});


}

if(!dojo._hasResource["dojo.data.util.sorter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.sorter"] = true;
dojo.provide("dojo.data.util.sorter");

dojo.getObject("data.util.sorter", true, dojo);

dojo.data.util.sorter.basicComparator = function(	/*anything*/ a,
													/*anything*/ b){
	//	summary:
	//		Basic comparision function that compares if an item is greater or less than another item
	//	description:
	//		returns 1 if a > b, -1 if a < b, 0 if equal.
	//		'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	//		And compared to each other, null is equivalent to undefined.
	
	//null is a problematic compare, so if null, we set to undefined.
	//Makes the check logic simple, compact, and consistent
	//And (null == undefined) === true, so the check later against null
	//works for undefined and is less bytes.
	var r = -1;
	if(a === null){
		a = undefined;
	}
	if(b === null){
		b = undefined;
	}
	if(a == b){
		r = 0;
	}else if(a > b || a == null){
		r = 1;
	}
	return r; //int {-1,0,1}
};

dojo.data.util.sorter.createSortFunction = function(	/* attributes array */sortSpec,
														/*dojo.data.core.Read*/ store){
	//	summary:
	//		Helper function to generate the sorting function based off the list of sort attributes.
	//	description:
	//		The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	//		it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	//		use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	//		Returns the sorting function for this particular list of attributes and sorting directions.
	//
	//	sortSpec: array
	//		A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	//		The objects should be formatted as follows:
	//		{
	//			attribute: "attributeName-string" || attribute,
	//			descending: true|false;   // Default is false.
	//		}
	//	store: object
	//		The datastore object to look up item values from.
	//
	var sortFunctions=[];

	function createSortFunction(attr, dir, comp, s){
		//Passing in comp and s (comparator and store), makes this
		//function much faster.
		return function(itemA, itemB){
			var a = s.getValue(itemA, attr);
			var b = s.getValue(itemB, attr);
			return dir * comp(a,b); //int
		};
	}
	var sortAttribute;
	var map = store.comparatorMap;
	var bc = dojo.data.util.sorter.basicComparator;
	for(var i = 0; i < sortSpec.length; i++){
		sortAttribute = sortSpec[i];
		var attr = sortAttribute.attribute;
		if(attr){
			var dir = (sortAttribute.descending) ? -1 : 1;
			var comp = bc;
			if(map){
				if(typeof attr !== "string" && ("toString" in attr)){
					 attr = attr.toString();
				}
				comp = map[attr] || bc;
			}
			sortFunctions.push(createSortFunction(attr,
				dir, comp, store));
		}
	}
	return function(rowA, rowB){
		var i=0;
		while(i < sortFunctions.length){
			var ret = sortFunctions[i++](rowA, rowB);
			if(ret !== 0){
				return ret;//int
			}
		}
		return 0; //int
	}; // Function
};

}

if(!dojo._hasResource["dojo.data.util.simpleFetch"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.simpleFetch"] = true;
dojo.provide("dojo.data.util.simpleFetch");


dojo.getObject("data.util.simpleFetch", true, dojo);

dojo.data.util.simpleFetch.fetch = function(/* Object? */ request){
	//	summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.
	//		The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
	//		call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	//		is not designed to work for datastores that respond to a fetch() call by incrementally
	//		loading items, or sequentially loading partial batches of the result
	//		set.  For datastores that mixin simpleFetch, simpleFetch
	//		implements a fetch method that automatically handles eight of the fetch()
	//		arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	//		The class mixing in simpleFetch should not implement fetch(),
	//		but should instead implement a _fetchItems() method.  The _fetchItems()
	//		method takes three arguments, the keywordArgs object that was passed
	//		to fetch(), a callback function to be called when the result array is
	//		available, and an error callback to be called if something goes wrong.
	//		The _fetchItems() method should ignore any keywordArgs parameters for
	//		start, count, onBegin, onItem, onComplete, onError, sort, and scope.
	//		The _fetchItems() method needs to correctly handle any other keywordArgs
	//		parameters, including the query parameter and any optional parameters
	//		(such as includeChildren).  The _fetchItems() method should create an array of
	//		result items and pass it to the fetchHandler along with the original request object
	//		-- or, the _fetchItems() method may, if it wants to, create an new request object
	//		with other specifics about the request that are specific to the datastore and pass
	//		that as the request object to the handler.
	//
	//		For more information on this specific function, see dojo.data.api.Read.fetch()
	request = request || {};
	if(!request.store){
		request.store = this;
	}
	var self = this;

	var _errorHandler = function(errorData, requestObject){
		if(requestObject.onError){
			var scope = requestObject.scope || dojo.global;
			requestObject.onError.call(scope, errorData, requestObject);
		}
	};

	var _fetchHandler = function(items, requestObject){
		var oldAbortFunction = requestObject.abort || null;
		var aborted = false;

		var startIndex = requestObject.start?requestObject.start:0;
		var endIndex = (requestObject.count && (requestObject.count !== Infinity))?(startIndex + requestObject.count):items.length;

		requestObject.abort = function(){
			aborted = true;
			if(oldAbortFunction){
				oldAbortFunction.call(requestObject);
			}
		};

		var scope = requestObject.scope || dojo.global;
		if(!requestObject.store){
			requestObject.store = self;
		}
		if(requestObject.onBegin){
			requestObject.onBegin.call(scope, items.length, requestObject);
		}
		if(requestObject.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(requestObject.sort, self));
		}
		if(requestObject.onItem){
			for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
				var item = items[i];
				if(!aborted){
					requestObject.onItem.call(scope, item, requestObject);
				}
			}
		}
		if(requestObject.onComplete && !aborted){
			var subset = null;
			if(!requestObject.onItem){
				subset = items.slice(startIndex, endIndex);
			}
			requestObject.onComplete.call(scope, subset, requestObject);
		}
	};
	this._fetchItems(request, _fetchHandler, _errorHandler);
	return request;	// Object
};

}

if(!dojo._hasResource["dojo.data.util.filter"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.util.filter"] = true;
dojo.provide("dojo.data.util.filter");

dojo.getObject("data.util.filter", true, dojo);

dojo.data.util.filter.patternToRegExp = function(/*String*/pattern, /*boolean?*/ ignoreCase){
	//	summary:
	//		Helper function to convert a simple pattern to a regular expression for matching.
	//	description:
	//		Returns a regular expression object that conforms to the defined conversion rules.
	//		For example:
	//			ca*   -> /^ca.*$/
	//			*ca*  -> /^.*ca.*$/
	//			*c\*a*  -> /^.*c\*a.*$/
	//			*c\*a?*  -> /^.*c\*a..*$/
	//			and so on.
	//
	//	pattern: string
	//		A simple matching pattern to convert that follows basic rules:
	//			* Means match anything, so ca* means match anything starting with ca
	//			? Means match single character.  So, b?b will match to bob and bab, and so on.
	//      	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	//				To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	//				represented by \\ to be treated as an ordinary \ character instead of an escape.
	//
	//	ignoreCase:
	//		An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	//		By default, it is assumed case sensitive.

	var rxp = "^";
	var c = null;
	for(var i = 0; i < pattern.length; i++){
		c = pattern.charAt(i);
		switch(c){
			case '\\':
				rxp += c;
				i++;
				rxp += pattern.charAt(i);
				break;
			case '*':
				rxp += ".*"; break;
			case '?':
				rxp += "."; break;
			case '$':
			case '^':
			case '/':
			case '+':
			case '.':
			case '|':
			case '(':
			case ')':
			case '{':
			case '}':
			case '[':
			case ']':
				rxp += "\\"; //fallthrough
			default:
				rxp += c;
		}
	}
	rxp += "$";
	if(ignoreCase){
		return new RegExp(rxp,"mi"); //RegExp
	}else{
		return new RegExp(rxp,"m"); //RegExp
	}
	
};

}

if(!dojo._hasResource["dijit.form.ComboBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.ComboBox"] = true;
dojo.provide("dijit.form.ComboBox");











dojo.declare(
	"dijit.form.ComboBoxMixin",
	dijit._HasDropDown,
	{
		// summary:
		//		Implements the base functionality for `dijit.form.ComboBox`/`dijit.form.FilteringSelect`
		// description:
		//		All widgets that mix in dijit.form.ComboBoxMixin must extend `dijit.form._FormValueWidget`.
		// tags:
		//		protected

		// item: Object
		//		This is the item returned by the dojo.data.store implementation that
		//		provides the data for this ComboBox, it's the currently selected item.
		item: null,

		// pageSize: Integer
		//		Argument to data provider.
		//		Specifies number of search results per page (before hitting "next" button)
		pageSize: Infinity,

		// store: [const] Object
		//		Reference to data provider object used by this ComboBox
		store: null,

		// fetchProperties: Object
		//		Mixin to the dojo.data store's fetch.
		//		For example, to set the sort order of the ComboBox menu, pass:
		//	|	{ sort: [{attribute:"name",descending: true}] }
		//		To override the default queryOptions so that deep=false, do:
		//	|	{ queryOptions: {ignoreCase: true, deep: false} }
		fetchProperties:{},

		// query: Object
		//		A query that can be passed to 'store' to initially filter the items,
		//		before doing further filtering based on `searchAttr` and the key.
		//		Any reference to the `searchAttr` is ignored.
		query: {},

		// autoComplete: Boolean
		//		If user types in a partial string, and then tab out of the `<input>` box,
		//		automatically copy the first entry displayed in the drop down list to
		//		the `<input>` field
		autoComplete: true,

		// highlightMatch: String
		// 		One of: "first", "all" or "none".
		//
		//		If the ComboBox/FilteringSelect opens with the search results and the searched
		//		string can be found, it will be highlighted.  If set to "all"
		//		then will probably want to change `queryExpr` parameter to '*${0}*'
		//
		//		Highlighting is only performed when `labelType` is "text", so as to not
		//		interfere with any HTML markup an HTML label might contain.
		highlightMatch: "first",

		// searchDelay: Integer
		//		Delay in milliseconds between when user types something and we start
		//		searching based on that value
		searchDelay: 100,

		// searchAttr: String
		//		Search for items in the data store where this attribute (in the item)
		//		matches what the user typed
		searchAttr: "name",

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the
		//		dojo.data items.
		//		If not specified, the searchAttr attribute is used instead.
		labelAttr: "",

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "text",

		// queryExpr: String
		//		This specifies what query ComboBox/FilteringSelect sends to the data store,
		//		based on what the user has typed.  Changing this expression will modify
		//		whether the drop down shows only exact matches, a "starting with" match,
		//		etc.  Use it in conjunction with highlightMatch.
		//		dojo.data query expression pattern.
		//		`${0}` will be substituted for the user text.
		//		`*` is used for wildcards.
		//		`${0}*` means "starts with", `*${0}*` means "contains", `${0}` means "is"
		queryExpr: "${0}*",

		// ignoreCase: Boolean
		//		Set true if the ComboBox/FilteringSelect should ignore case when matching possible items
		ignoreCase: true,

		// hasDownArrow: Boolean
		//		Set this textbox to have a down arrow button, to display the drop down list.
		//		Defaults to true.
		hasDownArrow: true,

		templateString: dojo.cache("dijit.form", "templates/DropDownBox.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\"\n\trole=\"combobox\"\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\n\t\tdojoAttachPoint=\"_buttonNode, _popupStateNode\" role=\"presentation\"\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t${_buttonInputDisabled}\n\t/></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input aria-label=\"Form field error\" class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\n\t\t\tdojoAttachPoint=\"textbox,focusNode\" role=\"textbox\" aria-haspopup=\"true\"\n\t/></div\n></div>\n"),

		baseClass: "dijitTextBox dijitComboBox",

		// dropDownClass: [protected extension] String
		//		Name of the dropdown widget class used to select a date/time.
		//		Subclasses should specify this.
		dropDownClass: "dijit.form._ComboBoxMenu",

		// Set classes like dijitDownArrowButtonHover depending on
		// mouse action over button node
		cssStateNodes: {
			"_buttonNode": "dijitDownArrowButton"
		},

		// Flags to _HasDropDown to limit height of drop down to make it fit in viewport
		maxHeight: -1,

		// For backwards compatibility let onClick events propagate, even clicks on the down arrow button
		_stopClickEvents: false,

		_getCaretPos: function(/*DomNode*/ element){
			// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
			var pos = 0;
			if(typeof(element.selectionStart) == "number"){
				// FIXME: this is totally borked on Moz < 1.3. Any recourse?
				pos = element.selectionStart;
			}else if(dojo.isIE){
				// in the case of a mouse click in a popup being handled,
				// then the dojo.doc.selection is not the textarea, but the popup
				// var r = dojo.doc.selection.createRange();
				// hack to get IE 6 to play nice. What a POS browser.
				var tr = dojo.doc.selection.createRange().duplicate();
				var ntr = element.createTextRange();
				tr.move("character",0);
				ntr.move("character",0);
				try{
					// If control doesn't have focus, you get an exception.
					// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
					// There appears to be no workaround for this - googled for quite a while.
					ntr.setEndPoint("EndToEnd", tr);
					pos = String(ntr.text).replace(/\r/g,"").length;
				}catch(e){
					// If focus has shifted, 0 is fine for caret pos.
				}
			}
			return pos;
		},

		_setCaretPos: function(/*DomNode*/ element, /*Number*/ location){
			location = parseInt(location);
			dijit.selectInputText(element, location, location);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// Additional code to set disabled state of ComboBox node.
			// Overrides _FormValueWidget._setDisabledAttr() or ValidationTextBox._setDisabledAttr().
			this.inherited(arguments);
			dijit.setWaiState(this.domNode, "disabled", value);
		},

		_abortQuery: function(){
			// stop in-progress query
			if(this.searchTimer){
				clearTimeout(this.searchTimer);
				this.searchTimer = null;
			}
			if(this._fetchHandle){
				if(this._fetchHandle.abort){ this._fetchHandle.abort(); }
				this._fetchHandle = null;
			}
		},

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Handles paste events
			if(!this.searchTimer && (evt.type == 'paste'/*IE|WebKit*/ || evt.type == 'input'/*Firefox*/) && this._lastInput != this.textbox.value){
				this.searchTimer = setTimeout(dojo.hitch(this, function(){
					this._onKey({charOrCode: 229}); // fake IME key to cause a search
				}), 100); // long delay that will probably be preempted by keyboard input
			}
			this.inherited(arguments);
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles keyboard events

			var key = evt.charOrCode;

			// except for cutting/pasting case - ctrl + x/v
			if(evt.altKey || ((evt.ctrlKey || evt.metaKey) && (key != 'x' && key != 'v')) || key == dojo.keys.SHIFT){
				return; // throw out weird key combinations and spurious events
			}
			
			var doSearch = false;
			var pw = this.dropDown;
			var dk = dojo.keys;
			var highlighted = null;
			this._prev_key_backspace = false;
			this._abortQuery();

			// _HasDropDown will do some of the work:
			//		1. when drop down is not yet shown:
			//			- if user presses the down arrow key, call loadDropDown()
			//		2. when drop down is already displayed:
			//			- on ESC key, call closeDropDown()
			//			- otherwise, call dropDown.handleKey() to process the keystroke
			this.inherited(arguments);

			if(this._opened){
				highlighted = pw.getHighlightedOption();
			}
			switch(key){
				case dk.PAGE_DOWN:
				case dk.DOWN_ARROW:
				case dk.PAGE_UP:
				case dk.UP_ARROW:
					// Keystroke caused ComboBox_menu to move to a different item.
					// Copy new item to <input> box.
					if(this._opened){
						this._announceOption(highlighted);
					}
					dojo.stopEvent(evt);
					break;

				case dk.ENTER:
					// prevent submitting form if user presses enter. Also
					// prevent accepting the value if either Next or Previous
					// are selected
					if(highlighted){
						// only stop event on prev/next
						if(highlighted == pw.nextButton){
							this._nextSearch(1);
							dojo.stopEvent(evt);
							break;
						}else if(highlighted == pw.previousButton){
							this._nextSearch(-1);
							dojo.stopEvent(evt);
							break;
						}
					}else{
						// Update 'value' (ex: KY) according to currently displayed text
						this._setBlurValue(); // set value if needed
						this._setCaretPos(this.focusNode, this.focusNode.value.length); // move cursor to end and cancel highlighting
					}
					// default case:
					// if enter pressed while drop down is open, or for FilteringSelect,
					// if we are in the middle of a query to convert a directly typed in value to an item,
					// prevent submit, but allow event to bubble
					if(this._opened || this._fetchHandle){
					evt.preventDefault();
					}
					// fall through

				case dk.TAB:
					var newvalue = this.get('displayedValue');
					//	if the user had More Choices selected fall into the
					//	_onBlur handler
					if(pw && (
						newvalue == pw._messages["previousMessage"] ||
						newvalue == pw._messages["nextMessage"])
					){
						break;
					}
					if(highlighted){
						this._selectOption();
					}
					if(this._opened){
						this._lastQuery = null; // in case results come back later
						this.closeDropDown();
					}
					break;

				case ' ':
					if(highlighted){
						// user is effectively clicking a choice in the drop down menu
						dojo.stopEvent(evt);
						this._selectOption();
						this.closeDropDown();
					}else{
						// user typed a space into the input box, treat as normal character
						doSearch = true;
					}
					break;

				case dk.DELETE:
				case dk.BACKSPACE:
					this._prev_key_backspace = true;
					doSearch = true;
					break;

				default:
					// Non char keys (F1-F12 etc..)  shouldn't open list.
					// Ascii characters and IME input (Chinese, Japanese etc.) should.
					//IME input produces keycode == 229.
					doSearch = typeof key == 'string' || key == 229;
			}
			if(doSearch){
				// need to wait a tad before start search so that the event
				// bubbles through DOM and we have value visible
				this.item = undefined; // undefined means item needs to be set
				this.searchTimer = setTimeout(dojo.hitch(this, "_startSearchFromInput"),1);
			}
		},

		_autoCompleteText: function(/*String*/ text){
			// summary:
			// 		Fill in the textbox with the first item from the drop down
			// 		list, and highlight the characters that were
			// 		auto-completed. For example, if user typed "CA" and the
			// 		drop down list appeared, the textbox would be changed to
			// 		"California" and "ifornia" would be highlighted.

			var fn = this.focusNode;

			// IE7: clear selection so next highlight works all the time
			dijit.selectInputText(fn, fn.value.length);
			// does text autoComplete the value in the textbox?
			var caseFilter = this.ignoreCase? 'toLowerCase' : 'substr';
			if(text[caseFilter](0).indexOf(this.focusNode.value[caseFilter](0)) == 0){
				var cpos = this._getCaretPos(fn);
				// only try to extend if we added the last character at the end of the input
				if((cpos+1) > fn.value.length){
					// only add to input node as we would overwrite Capitalisation of chars
					// actually, that is ok
					fn.value = text;//.substr(cpos);
					// visually highlight the autocompleted characters
					dijit.selectInputText(fn, cpos);
				}
			}else{
				// text does not autoComplete; replace the whole value and highlight
				fn.value = text;
				dijit.selectInputText(fn);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
			// summary:
			//		Callback when a search completes.
			// description:
			//		1. generates drop-down list and calls _showResultList() to display it
			//		2. if this result list is from user pressing "more choices"/"previous choices"
			//			then tell screen reader to announce new option
			this._fetchHandle = null;
			if(	this.disabled ||
				this.readOnly ||
				(dataObject.query[this.searchAttr] != this._lastQuery)
			){
				return;
			}
			var wasSelected = this.dropDown._highlighted_option && dojo.hasClass(this.dropDown._highlighted_option, "dijitMenuItemSelected");
			this.dropDown.clearResultList();
			if(!results.length && !this._maxOptions){ // if no results and not just the previous choices button
				this.closeDropDown();
				return;
			}

			// Fill in the textbox with the first item from the drop down list,
			// and highlight the characters that were auto-completed. For
			// example, if user typed "CA" and the drop down list appeared, the
			// textbox would be changed to "California" and "ifornia" would be
			// highlighted.

			dataObject._maxOptions = this._maxOptions;
			var nodes = this.dropDown.createOptions(
				results,
				dataObject,
				dojo.hitch(this, "_getMenuLabelFromItem")
			);

			// show our list (only if we have content, else nothing)
			this._showResultList();

			// #4091:
			//		tell the screen reader that the paging callback finished by
			//		shouting the next choice
			if(dataObject.direction){
				if(1 == dataObject.direction){
					this.dropDown.highlightFirstOption();
				}else if(-1 == dataObject.direction){
					this.dropDown.highlightLastOption();
				}
				if(wasSelected){
					this._announceOption(this.dropDown.getHighlightedOption());
				}
			}else if(this.autoComplete && !this._prev_key_backspace
				// when the user clicks the arrow button to show the full list,
				// startSearch looks for "*".
				// it does not make sense to autocomplete
				// if they are just previewing the options available.
				&& !/^[*]+$/.test(dataObject.query[this.searchAttr])){
					this._announceOption(nodes[1]); // 1st real item
			}
		},

		_showResultList: function(){
			// summary:
			//		Display the drop down if not already displayed, or if it is displayed, then
			//		reposition it if necessary (reposition may be necessary if drop down's height changed).

			this.closeDropDown(true);

			// hide the tooltip
			this.displayMessage("");

			this.openDropDown();

			dijit.setWaiState(this.domNode, "expanded", "true");
		},

		loadDropDown: function(/*Function*/ callback){
			// Overrides _HasDropDown.loadDropDown().
			// This is called when user has pressed button icon or pressed the down arrow key
			// to open the drop down.
			
			this._startSearchAll();
		},

		isLoaded: function(){
			// signal to _HasDropDown that it needs to call loadDropDown() to load the
			// drop down asynchronously before displaying it
			return false;
		},

		closeDropDown: function(){
			// Overrides _HasDropDown.closeDropDown().  Closes the drop down (assuming that it's open).
			// This method is the callback when the user types ESC or clicking
			// the button icon while the drop down is open.  It's also called by other code.
			this._abortQuery();
			if(this._opened){
				this.inherited(arguments);
				dijit.setWaiState(this.domNode, "expanded", "false");
				dijit.removeWaiState(this.focusNode,"activedescendant");
			}
		},

		_setBlurValue: function(){
			// if the user clicks away from the textbox OR tabs away, set the
			// value to the textbox value
			// #4617:
			//		if value is now more choices or previous choices, revert
			//		the value
			var newvalue = this.get('displayedValue');
			var pw = this.dropDown;
			if(pw && (
				newvalue == pw._messages["previousMessage"] ||
				newvalue == pw._messages["nextMessage"]
				)
			){
				this._setValueAttr(this._lastValueReported, true);
			}else if(typeof this.item == "undefined"){
				// Update 'value' (ex: KY) according to currently displayed text
				this.item = null;
				this.set('displayedValue', newvalue);
			}else{
				if(this.value != this._lastValueReported){
					dijit.form._FormValueWidget.prototype._setValueAttr.call(this, this.value, true);
				}
				this._refreshState();
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's drop down
			this.closeDropDown();
			this.inherited(arguments);
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('item', value)
			// tags:
			//		private
			if(!displayedValue){
				displayedValue = this.store.getValue(item, this.searchAttr);
			}
			var value = this._getValueField() != this.searchAttr? this.store.getIdentity(item) : displayedValue;
			this._set("item", item);
			dijit.form.ComboBox.superclass._setValueAttr.call(this, value, priorityChange, displayedValue);
		},

		_announceOption: function(/*Node*/ node){
			// summary:
			//		a11y code that puts the highlighted option in the textbox.
			//		This way screen readers will know what is happening in the
			//		menu.

			if(!node){
				return;
			}
			// pull the text value from the item attached to the DOM node
			var newValue;
			if(node == this.dropDown.nextButton ||
				node == this.dropDown.previousButton){
				newValue = node.innerHTML;
				this.item = undefined;
				this.value = '';
			}else{
				newValue = this.store.getValue(node.item, this.searchAttr).toString();
				this.set('item', node.item, false, newValue);
			}
			// get the text that the user manually entered (cut off autocompleted text)
			this.focusNode.value = this.focusNode.value.substring(0, this._lastInput.length);
			// set up ARIA activedescendant
			dijit.setWaiState(this.focusNode, "activedescendant", dojo.attr(node, "id"));
			// autocomplete the rest of the option to announce change
			this._autoCompleteText(newValue);
		},

		_selectOption: function(/*Event*/ evt){
			// summary:
			//		Menu callback function, called when an item in the menu is selected.
			if(evt){
				this._announceOption(evt.target);
			}
			this.closeDropDown();
			this._setCaretPos(this.focusNode, this.focusNode.value.length);
			dijit.form._FormValueWidget.prototype._setValueAttr.call(this, this.value, true); // set this.value and fire onChange
		},

		_startSearchAll: function(){
			this._startSearch('');
		},

		_startSearchFromInput: function(){
			this._startSearch(this.focusNode.value.replace(/([\\\*\?])/g, "\\$1"));
		},

		_getQueryString: function(/*String*/ text){
			return dojo.string.substitute(this.queryExpr, [text]);
		},

		_startSearch: function(/*String*/ key){
			// summary:
			//		Starts a search for elements matching key (key=="" means to return all items),
			//		and calls _openResultList() when the search completes, to display the results.
			if(!this.dropDown){
				var popupId = this.id + "_popup",
				dropDownConstructor = dojo.getObject(this.dropDownClass, false);
				this.dropDown = new dropDownConstructor({
					onChange: dojo.hitch(this, this._selectOption),
					id: popupId,
					dir: this.dir
				});
				dijit.removeWaiState(this.focusNode,"activedescendant");
				dijit.setWaiState(this.textbox,"owns",popupId); // associate popup with textbox
			}
			// create a new query to prevent accidentally querying for a hidden
			// value from FilteringSelect's keyField
			var query = dojo.clone(this.query); // #5970
			this._lastInput = key; // Store exactly what was entered by the user.
			this._lastQuery = query[this.searchAttr] = this._getQueryString(key);
			// #5970: set _lastQuery, *then* start the timeout
			// otherwise, if the user types and the last query returns before the timeout,
			// _lastQuery won't be set and their input gets rewritten
			this.searchTimer=setTimeout(dojo.hitch(this, function(query, _this){
				this.searchTimer = null;
				var fetch = {
					queryOptions: {
						ignoreCase: this.ignoreCase,
						deep: true
					},
					query: query,
					onBegin: dojo.hitch(this, "_setMaxOptions"),
					onComplete: dojo.hitch(this, "_openResultList"),
					onError: function(errText){
						_this._fetchHandle = null;
						console.error('dijit.form.ComboBox: ' + errText);
						_this.closeDropDown();
					},
					start: 0,
					count: this.pageSize
				};
				dojo.mixin(fetch, _this.fetchProperties);
				this._fetchHandle = _this.store.fetch(fetch);

				var nextSearch = function(dataObject, direction){
					dataObject.start += dataObject.count*direction;
					// #4091:
					//		tell callback the direction of the paging so the screen
					//		reader knows which menu option to shout
					dataObject.direction = direction;
					this._fetchHandle = this.store.fetch(dataObject);
					this.focus();
				};
				this._nextSearch = this.dropDown.onPage = dojo.hitch(this, nextSearch, this._fetchHandle);
			}, query, this), this.searchDelay);
		},

		_setMaxOptions: function(size, request){
			 this._maxOptions = size;
		},

		_getValueField: function(){
			// summary:
			//		Helper for postMixInProperties() to set this.value based on data inlined into the markup.
			//		Returns the attribute name in the item (in dijit.form._ComboBoxDataStore) to use as the value.
			return this.searchAttr;
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.query={};
			this.fetchProperties={};
		},

		postMixInProperties: function(){
			if(!this.store){
				var srcNodeRef = this.srcNodeRef;

				// if user didn't specify store, then assume there are option tags
				this.store = new dijit.form._ComboBoxDataStore(srcNodeRef);

				// if there is no value set and there is an option list, set
				// the value to the first value to be consistent with native
				// Select

				// Firefox and Safari set value
				// IE6 and Opera set selectedIndex, which is automatically set
				// by the selected attribute of an option tag
				// IE6 does not set value, Opera sets value = selectedIndex
				if(!("value" in this.params)){
					var item = (this.item = this.store.fetchSelectedItem());
					if(item){
						var valueField = this._getValueField();
						this.value = this.store.getValue(item, valueField);
					}
				}
			}

			this.inherited(arguments);
		},

		postCreate: function(){
			// summary:
			//		Subclasses must call this method from their postCreate() methods
			// tags:
			//		protected

			// find any associated label element and add to ComboBox node.
			var label=dojo.query('label[for="'+this.id+'"]');
			if(label.length){
				label[0].id = (this.id+"_label");
				dijit.setWaiState(this.domNode, "labelledby", label[0].id);

			}
			this.inherited(arguments);
		},

		_setHasDownArrowAttr: function(val){
			this.hasDownArrow = val;
			this._buttonNode.style.display = val ? "" : "none";
		},

		_getMenuLabelFromItem: function(/*Item*/ item){
			var label = this.labelFunc(item, this.store),
				labelType = this.labelType;
			// If labelType is not "text" we don't want to screw any markup ot whatever.
			if(this.highlightMatch != "none" && this.labelType == "text" && this._lastInput){
				label = this.doHighlight(label, this._escapeHtml(this._lastInput));
				labelType = "html";
			}
			return {html: labelType == "html", label: label};
		},

		doHighlight: function(/*String*/ label, /*String*/ find){
			// summary:
			//		Highlights the string entered by the user in the menu.  By default this
			//		highlights the first occurrence found. Override this method
			//		to implement your custom highlighting.
			// tags:
			//		protected

			var
				// Add (g)lobal modifier when this.highlightMatch == "all" and (i)gnorecase when this.ignoreCase == true
				modifiers = (this.ignoreCase ? "i" : "") + (this.highlightMatch == "all" ? "g" : ""),
				i = this.queryExpr.indexOf("${0}");
			find = dojo.regexp.escapeString(find); // escape regexp special chars
			return this._escapeHtml(label).replace(
				// prepend ^ when this.queryExpr == "${0}*" and append $ when this.queryExpr == "*${0}"
				new RegExp((i == 0 ? "^" : "") + "("+ find +")" + (i == (this.queryExpr.length - 4) ? "$" : ""), modifiers),
				'<span class="dijitComboBoxHighlightMatch">$1</span>'
			); // returns String, (almost) valid HTML (entities encoded)
		},

		_escapeHtml: function(/*String*/ str){
			// TODO Should become dojo.html.entities(), when exists use instead
			// summary:
			//		Adds escape sequences for special characters in XML: &<>"'
			str = String(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
				.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
			return str; // string
		},

		reset: function(){
			// Overrides the _FormWidget.reset().
			// Additionally reset the .item (to clean up).
			this.item = null;
			this.inherited(arguments);
		},

		labelFunc: function(/*item*/ item, /*dojo.data.store*/ store){
			// summary:
			//		Computes the label to display based on the dojo.data store item.
			// returns:
			//		The label that the ComboBox should display
			// tags:
			//		private

			// Use toString() because XMLStore returns an XMLItem whereas this
			// method is expected to return a String (#9354)
			return store.getValue(item, this.labelAttr || this.searchAttr).toString(); // String
		}
	}
);

dojo.declare(
	"dijit.form._ComboBoxMenu",
	[dijit._Widget, dijit._Templated, dijit._CssStateMixin],
	{
		// summary:
		//		Focus-less menu for internal use in `dijit.form.ComboBox`
		// tags:
		//		private

		templateString: "<ul class='dijitReset dijitMenu' dojoAttachEvent='onmousedown:_onMouseDown,onmouseup:_onMouseUp,onmouseover:_onMouseOver,onmouseout:_onMouseOut' style='overflow: \"auto\"; overflow-x: \"hidden\";'>"
				+"<li class='dijitMenuItem dijitMenuPreviousButton' dojoAttachPoint='previousButton' role='option'></li>"
				+"<li class='dijitMenuItem dijitMenuNextButton' dojoAttachPoint='nextButton' role='option'></li>"
			+"</ul>",

		// _messages: Object
		//		Holds "next" and "previous" text for paging buttons on drop down
		_messages: null,
		
		baseClass: "dijitComboBoxMenu",

		postMixInProperties: function(){
			this.inherited(arguments);
			this._messages = dojo.i18n.getLocalization("dijit.form", "ComboBox", this.lang);
		},

		buildRendering: function(){
			this.inherited(arguments);

			// fill in template with i18n messages
			this.previousButton.innerHTML = this._messages["previousMessage"];
			this.nextButton.innerHTML = this._messages["nextMessage"];
		},

		_setValueAttr: function(/*Object*/ value){
			this.value = value;
			this.onChange(value);
		},

		// stubs
		onChange: function(/*Object*/ value){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked an option in the drop down menu.
			//		Probably should be called onSelect.
			// tags:
			//		callback
		},
		onPage: function(/*Number*/ direction){
			// summary:
			//		Notifies ComboBox/FilteringSelect that user clicked to advance to next/previous page.
			// tags:
			//		callback
		},

		onClose: function(){
			// summary:
			//		Callback from dijit.popup code to this widget, notifying it that it closed
			// tags:
			//		private
			this._blurOptionNode();
		},

		_createOption: function(/*Object*/ item, labelFunc){
			// summary:
			//		Creates an option to appear on the popup menu subclassed by
			//		`dijit.form.FilteringSelect`.

			var menuitem = dojo.create("li", {
				"class": "dijitReset dijitMenuItem" +(this.isLeftToRight() ? "" : " dijitMenuItemRtl"),
				role: "option"
			});
			var labelObject = labelFunc(item);
			if(labelObject.html){
				menuitem.innerHTML = labelObject.label;
			}else{
				menuitem.appendChild(
					dojo.doc.createTextNode(labelObject.label)
				);
			}
			// #3250: in blank options, assign a normal height
			if(menuitem.innerHTML == ""){
				menuitem.innerHTML = "&nbsp;";
			}
			menuitem.item=item;
			return menuitem;
		},

		createOptions: function(results, dataObject, labelFunc){
			// summary:
			//		Fills in the items in the drop down list
			// results:
			//		Array of dojo.data items
			// dataObject:
			//		dojo.data store
			// labelFunc:
			//		Function to produce a label in the drop down list from a dojo.data item

			//this._dataObject=dataObject;
			//this._dataObject.onComplete=dojo.hitch(comboBox, comboBox._openResultList);
			// display "Previous . . ." button
			this.previousButton.style.display = (dataObject.start == 0) ? "none" : "";
			dojo.attr(this.previousButton, "id", this.id + "_prev");
			// create options using _createOption function defined by parent
			// ComboBox (or FilteringSelect) class
			// #2309:
			//		iterate over cache nondestructively
			dojo.forEach(results, function(item, i){
				var menuitem = this._createOption(item, labelFunc);
				dojo.attr(menuitem, "id", this.id + i);
				this.domNode.insertBefore(menuitem, this.nextButton);
			}, this);
			// display "Next . . ." button
			var displayMore = false;
			//Try to determine if we should show 'more'...
			if(dataObject._maxOptions && dataObject._maxOptions != -1){
				if((dataObject.start + dataObject.count) < dataObject._maxOptions){
					displayMore = true;
				}else if((dataObject.start + dataObject.count) > dataObject._maxOptions && dataObject.count == results.length){
					//Weird return from a datastore, where a start + count > maxOptions
					// implies maxOptions isn't really valid and we have to go into faking it.
					//And more or less assume more if count == results.length
					displayMore = true;
				}
			}else if(dataObject.count == results.length){
				//Don't know the size, so we do the best we can based off count alone.
				//So, if we have an exact match to count, assume more.
				displayMore = true;
			}

			this.nextButton.style.display = displayMore ? "" : "none";
			dojo.attr(this.nextButton,"id", this.id + "_next");
			return this.domNode.childNodes;
		},

		clearResultList: function(){
			// summary:
			//		Clears the entries in the drop down list, but of course keeps the previous and next buttons.
			while(this.domNode.childNodes.length>2){
				this.domNode.removeChild(this.domNode.childNodes[this.domNode.childNodes.length-2]);
			}
			this._blurOptionNode();
		},

		_onMouseDown: function(/*Event*/ evt){
			dojo.stopEvent(evt);
		},

		_onMouseUp: function(/*Event*/ evt){
			if(evt.target === this.domNode || !this._highlighted_option){
				// !this._highlighted_option check to prevent immediate selection when menu appears on top
				// of <input>, see #9898.  Note that _HasDropDown also has code to prevent this.
				return;
			}else if(evt.target == this.previousButton){
				this._blurOptionNode();
				this.onPage(-1);
			}else if(evt.target == this.nextButton){
				this._blurOptionNode();
				this.onPage(1);
			}else{
				var tgt = evt.target;
				// while the clicked node is inside the div
				while(!tgt.item){
					// recurse to the top
					tgt = tgt.parentNode;
				}
				this._setValueAttr({ target: tgt }, true);
			}
		},

		_onMouseOver: function(/*Event*/ evt){
			if(evt.target === this.domNode){ return; }
			var tgt = evt.target;
			if(!(tgt == this.previousButton || tgt == this.nextButton)){
				// while the clicked node is inside the div
				while(!tgt.item){
					// recurse to the top
					tgt = tgt.parentNode;
				}
			}
			this._focusOptionNode(tgt);
		},

		_onMouseOut: function(/*Event*/ evt){
			if(evt.target === this.domNode){ return; }
			this._blurOptionNode();
		},

		_focusOptionNode: function(/*DomNode*/ node){
			// summary:
			//		Does the actual highlight.
			if(this._highlighted_option != node){
				this._blurOptionNode();
				this._highlighted_option = node;
				dojo.addClass(this._highlighted_option, "dijitMenuItemSelected");
			}
		},

		_blurOptionNode: function(){
			// summary:
			//		Removes highlight on highlighted option.
			if(this._highlighted_option){
				dojo.removeClass(this._highlighted_option, "dijitMenuItemSelected");
				this._highlighted_option = null;
			}
		},

		_highlightNextOption: function(){
			// summary:
			// 		Highlight the item just below the current selection.
			// 		If nothing selected, highlight first option.

			// because each press of a button clears the menu,
			// the highlighted option sometimes becomes detached from the menu!
			// test to see if the option has a parent to see if this is the case.
			if(!this.getHighlightedOption()){
				var fc = this.domNode.firstChild;
				this._focusOptionNode(fc.style.display == "none" ? fc.nextSibling : fc);
			}else{
				var ns = this._highlighted_option.nextSibling;
				if(ns && ns.style.display != "none"){
					this._focusOptionNode(ns);
				}else{
					this.highlightFirstOption();
				}
			}
			// scrollIntoView is called outside of _focusOptionNode because in IE putting it inside causes the menu to scroll up on mouseover
			dojo.window.scrollIntoView(this._highlighted_option);
		},

		highlightFirstOption: function(){
			// summary:
			// 		Highlight the first real item in the list (not Previous Choices).
			var first = this.domNode.firstChild;
			var second = first.nextSibling;
			this._focusOptionNode(second.style.display == "none" ? first : second); // remotely possible that Previous Choices is the only thing in the list
			dojo.window.scrollIntoView(this._highlighted_option);
		},

		highlightLastOption: function(){
			// summary:
			// 		Highlight the last real item in the list (not More Choices).
			this._focusOptionNode(this.domNode.lastChild.previousSibling);
			dojo.window.scrollIntoView(this._highlighted_option);
		},

		_highlightPrevOption: function(){
			// summary:
			// 		Highlight the item just above the current selection.
			// 		If nothing selected, highlight last option (if
			// 		you select Previous and try to keep scrolling up the list).
			if(!this.getHighlightedOption()){
				var lc = this.domNode.lastChild;
				this._focusOptionNode(lc.style.display == "none" ? lc.previousSibling : lc);
			}else{
				var ps = this._highlighted_option.previousSibling;
				if(ps && ps.style.display != "none"){
					this._focusOptionNode(ps);
				}else{
					this.highlightLastOption();
				}
			}
			dojo.window.scrollIntoView(this._highlighted_option);
		},

		_page: function(/*Boolean*/ up){
			// summary:
			//		Handles page-up and page-down keypresses

			var scrollamount = 0;
			var oldscroll = this.domNode.scrollTop;
			var height = dojo.style(this.domNode, "height");
			// if no item is highlighted, highlight the first option
			if(!this.getHighlightedOption()){
				this._highlightNextOption();
			}
			while(scrollamount<height){
				if(up){
					// stop at option 1
					if(!this.getHighlightedOption().previousSibling ||
						this._highlighted_option.previousSibling.style.display == "none"){
						break;
					}
					this._highlightPrevOption();
				}else{
					// stop at last option
					if(!this.getHighlightedOption().nextSibling ||
						this._highlighted_option.nextSibling.style.display == "none"){
						break;
					}
					this._highlightNextOption();
				}
				// going backwards
				var newscroll=this.domNode.scrollTop;
				scrollamount+=(newscroll-oldscroll)*(up ? -1:1);
				oldscroll=newscroll;
			}
		},

		pageUp: function(){
			// summary:
			//		Handles pageup keypress.
			//		TODO: just call _page directly from handleKey().
			// tags:
			//		private
			this._page(true);
		},

		pageDown: function(){
			// summary:
			//		Handles pagedown keypress.
			//		TODO: just call _page directly from handleKey().
			// tags:
			//		private
			this._page(false);
		},

		getHighlightedOption: function(){
			// summary:
			//		Returns the highlighted option.
			var ho = this._highlighted_option;
			return (ho && ho.parentNode) ? ho : null;
		},

		handleKey: function(evt){
			// summary:
			//		Handle keystroke event forwarded from ComboBox, returning false if it's
			//		a keystroke I recognize and process, true otherwise.
			switch(evt.charOrCode){
				case dojo.keys.DOWN_ARROW:
					this._highlightNextOption();
					return false;
				case dojo.keys.PAGE_DOWN:
					this.pageDown();
					return false;
				case dojo.keys.UP_ARROW:
					this._highlightPrevOption();
					return false;
				case dojo.keys.PAGE_UP:
					this.pageUp();
					return false;
				default:
					return true;
			}
		}
	}
);

dojo.declare(
	"dijit.form.ComboBox",
	[dijit.form.ValidationTextBox, dijit.form.ComboBoxMixin],
	{
		// summary:
		//		Auto-completing text box, and base class for dijit.form.FilteringSelect.
		//
		// description:
		//		The drop down box's values are populated from an class called
		//		a data provider, which returns a list of values based on the characters
		//		that the user has typed into the input box.
		//		If OPTION tags are used as the data provider via markup,
		//		then the OPTION tag's child text node is used as the widget value
		//		when selected.  The OPTION tag's value attribute is ignored.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Some of the options to the ComboBox are actually arguments to the data
		//		provider.

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the select.
			this._set("item", null); // value not looked up in store
			if(!value){ value = ''; } // null translates to blank
			dijit.form.ValidationTextBox.prototype._setValueAttr.call(this, value, priorityChange, displayedValue);
		}
	}
);

dojo.declare("dijit.form._ComboBoxDataStore", null, {
	// summary:
	//		Inefficient but small data store specialized for inlined `dijit.form.ComboBox` data
	//
	// description:
	//		Provides a store for inlined data like:
	//
	//	|	<select>
	//	|		<option value="AL">Alabama</option>
	//	|		...
	//
	//		Actually. just implements the subset of dojo.data.Read/Notification
	//		needed for ComboBox and FilteringSelect to work.
	//
	//		Note that an item is just a pointer to the <option> DomNode.

	constructor: function( /*DomNode*/ root){
		this.root = root;
		if(root.tagName != "SELECT" && root.firstChild){
			root = dojo.query("select", root);
			if(root.length > 0){ // SELECT is a child of srcNodeRef
				root = root[0];
			}else{ // no select, so create 1 to parent the option tags to define selectedIndex
				this.root.innerHTML = "<SELECT>"+this.root.innerHTML+"</SELECT>";
				root = this.root.firstChild;
			}
			this.root = root;
		}
		dojo.query("> option", root).forEach(function(node){
			//	TODO: this was added in #3858 but unclear why/if it's needed;  doesn't seem to be.
			//	If it is needed then can we just hide the select itself instead?
			//node.style.display="none";
			node.innerHTML = dojo.trim(node.innerHTML);
		});

	},

	getValue: function(	/*item*/ item,
						/*attribute-name-string*/ attribute,
						/*value?*/ defaultValue){
		return (attribute == "value") ? item.value : (item.innerText || item.textContent || '');
	},

	isItemLoaded: function(/*anything*/ something){
		return true;
	},

	getFeatures: function(){
		return {"dojo.data.api.Read": true, "dojo.data.api.Identity": true};
	},

	_fetchItems: function(	/*Object*/ args,
							/*Function*/ findCallback,
							/*Function*/ errorCallback){
		// summary:
		//		See dojo.data.util.simpleFetch.fetch()
		if(!args.query){ args.query = {}; }
		if(!args.query.name){ args.query.name = ""; }
		if(!args.queryOptions){ args.queryOptions = {}; }
		var matcher = dojo.data.util.filter.patternToRegExp(args.query.name, args.queryOptions.ignoreCase),
			items = dojo.query("> option", this.root).filter(function(option){
				return (option.innerText || option.textContent || '').match(matcher);
			} );
		if(args.sort){
			items.sort(dojo.data.util.sorter.createSortFunction(args.sort, this));
		}
		findCallback(items, args);
	},

	close: function(/*dojo.data.api.Request || args || null*/ request){
		return;
	},

	getLabel: function(/*item*/ item){
		return item.innerHTML;
	},

	getIdentity: function(/*item*/ item){
		return dojo.attr(item, "value");
	},

	fetchItemByIdentity: function(/*Object*/ args){
		// summary:
		//		Given the identity of an item, this method returns the item that has
		//		that identity through the onItem callback.
		//		Refer to dojo.data.api.Identity.fetchItemByIdentity() for more details.
		//
		// description:
		//		Given arguments like:
		//
		//	|		{identity: "CA", onItem: function(item){...}
		//
		//		Call `onItem()` with the DOM node `<option value="CA">California</option>`
		var item = dojo.query("> option[value='" + args.identity + "']", this.root)[0];
		args.onItem(item);
	},

	fetchSelectedItem: function(){
		// summary:
		//		Get the option marked as selected, like `<option selected>`.
		//		Not part of dojo.data API.
		var root = this.root,
			si = root.selectedIndex;
		return typeof si == "number"
			? dojo.query("> option:nth-child(" + (si != -1 ? si+1 : 1) + ")", root)[0]
			: null;	// dojo.data.Item
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dijit.form._ComboBoxDataStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource["dijit.form.FilteringSelect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.FilteringSelect"] = true;
dojo.provide("dijit.form.FilteringSelect");



dojo.declare(
	"dijit.form.FilteringSelect",
	[dijit.form.MappedTextBox, dijit.form.ComboBoxMixin],
	{
		// summary:
		//		An enhanced version of the HTML SELECT tag, populated dynamically
		//
		// description:
		//		An enhanced version of the HTML SELECT tag, populated dynamically. It works
		//		very nicely with very large data sets because it can load and page data as needed.
		//		It also resembles ComboBox, but does not allow values outside of the provided ones.
		//		If OPTION tags are used as the data provider via markup, then the
		//		OPTION tag's child text node is used as the displayed value when selected
		//		while the OPTION tag's value attribute is used as the widget value on form submit.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Similar features:
		//			- There is a drop down list of possible values.
		//			- You can only enter a value from the drop down list.  (You can't
		//				enter an arbitrary value.)
		//			- The value submitted with the form is the hidden value (ex: CA),
		//				not the displayed value a.k.a. label (ex: California)
		//
		//		Enhancements over plain HTML version:
		//			- If you type in some text then it will filter down the list of
		//				possible values in the drop down list.
		//			- List can be specified either as a static list or via a javascript
		//				function (that can get the list from a server)

		// required: Boolean
		//		True (default) if user is required to enter a value into this field.
		required: true,

		_lastDisplayedValue: "",

		_isValidSubset: function(){
			return this._opened;
		},

		isValid: function(){
			// Overrides ValidationTextBox.isValid()
			return this.item || (!this.required && this.get('displayedValue') == ""); // #5974
		},

		_refreshState: function(){
			if(!this.searchTimer){ // state will be refreshed after results are returned
				this.inherited(arguments);
			}
		},

		_callbackSetLabel: function(
						/*Array*/ result,
						/*Object*/ dataObject,
						/*Boolean?*/ priorityChange){
			// summary:
			//		Callback from dojo.data after lookup of user entered value finishes

			// setValue does a synchronous lookup,
			// so it calls _callbackSetLabel directly,
			// and so does not pass dataObject
			// still need to test against _lastQuery in case it came too late
			if((dataObject && dataObject.query[this.searchAttr] != this._lastQuery) || (!dataObject && result.length && this.store.getIdentity(result[0]) != this._lastQuery)){
				return;
			}
			if(!result.length){
				//#3268: don't modify display value on bad input
				//#3285: change CSS to indicate error
				this.valueNode.value = "";
				dijit.form.TextBox.superclass._setValueAttr.call(this, "", priorityChange || (priorityChange === undefined && !this._focused));
				this._set("item", null);
				this.validate(this._focused);
			}else{
				this.set('item', result[0], priorityChange);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ dataObject){
			// Callback when a data store query completes.
			// Overrides ComboBox._openResultList()

			// #3285: tap into search callback to see if user's query resembles a match
			if(dataObject.query[this.searchAttr] != this._lastQuery){
				return;
			}
			dijit.form.ComboBoxMixin.prototype._openResultList.apply(this, arguments);

			if(this.item === undefined){ // item == undefined for keyboard search
				// If the search returned no items that means that the user typed
				// in something invalid (and they can't make it valid by typing more characters),
				// so flag the FilteringSelect as being in an invalid state
				this.validate(true);
			}
		},

		_getValueAttr: function(){
			// summary:
			//		Hook for get('value') to work.

			// don't get the textbox value but rather the previously set hidden value.
			// Use this.valueNode.value which isn't always set for other MappedTextBox widgets until blur
			return this.valueNode.value;
		},

		_getValueField: function(){
			// Overrides ComboBox._getValueField()
			return "value";
		},

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the select.
			//		Also sets the label to the corresponding value by reverse lookup.
			if(!this._onChangeActive){ priorityChange = null; }
			this._lastQuery = value;

			if(value === null || value === ''){
				this._setDisplayedValueAttr('', priorityChange);
				return;
			}

			//#3347: fetchItemByIdentity if no keyAttr specified
			var self = this;
			this.store.fetchItemByIdentity({
				identity: value,
				onItem: function(item){
					self._callbackSetLabel(item? [item] : [], undefined, priorityChange);
				}
			});
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('item', value)
			// tags:
			//		private
			this.inherited(arguments);
			this.valueNode.value = this.value;
			this._lastDisplayedValue = this.textbox.value;
		},

		_getDisplayQueryString: function(/*String*/ text){
			return text.replace(/([\\\*\?])/g, "\\$1");
		},

		_setDisplayedValueAttr: function(/*String*/ label, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('displayedValue', label) works.
			// description:
			//		Sets textbox to display label. Also performs reverse lookup
			//		to set the hidden value.  label should corresponding to item.searchAttr.

			if(label == null){ label = ''; }

			// This is called at initialization along with every custom setter.
			// Usually (or always?) the call can be ignored.   If it needs to be
			// processed then at least make sure that the XHR request doesn't trigger an onChange()
			// event, even if it returns after creation has finished
			if(!this._created){
				if(!("displayedValue" in this.params)){
					return;
				}
				priorityChange = false;
			}

			// Do a reverse lookup to map the specified displayedValue to the hidden value.
			// Note that if there's a custom labelFunc() this code
			if(this.store){
				this.closeDropDown();
				var query = dojo.clone(this.query); // #6196: populate query with user-specifics
				// escape meta characters of dojo.data.util.filter.patternToRegExp().
				this._lastQuery = query[this.searchAttr] = this._getDisplayQueryString(label);
				// If the label is not valid, the callback will never set it,
				// so the last valid value will get the warning textbox.   Set the
				// textbox value now so that the impending warning will make
				// sense to the user
				this.textbox.value = label;
				this._lastDisplayedValue = label;
				this._set("displayedValue", label);	// for watch("displayedValue") notification
				var _this = this;
				var fetch = {
					query: query,
					queryOptions: {
						ignoreCase: this.ignoreCase,
						deep: true
					},
					onComplete: function(result, dataObject){
						_this._fetchHandle = null;
						dojo.hitch(_this, "_callbackSetLabel")(result, dataObject, priorityChange);
					},
					onError: function(errText){
						_this._fetchHandle = null;
						console.error('dijit.form.FilteringSelect: ' + errText);
						dojo.hitch(_this, "_callbackSetLabel")([], undefined, false);
					}
				};
				dojo.mixin(fetch, this.fetchProperties);
				this._fetchHandle = this.store.fetch(fetch);
			}
		},

		undo: function(){
			this.set('displayedValue', this._lastDisplayedValue);
		}
	}
);

}

if(!dojo._hasResource["dojo.data.ItemFileReadStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.ItemFileReadStore"] = true;
dojo.provide("dojo.data.ItemFileReadStore");





dojo.declare("dojo.data.ItemFileReadStore", null,{
	//	summary:
	//		The ItemFileReadStore implements the dojo.data.api.Read API and reads
	//		data from JSON files that have contents in this format --
	//		{ items: [
	//			{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	//			{ name:'Fozzie Bear', wears:['hat', 'tie']},
	//			{ name:'Miss Piggy', pets:'Foo-Foo'}
	//		]}
	//		Note that it can also contain an 'identifer' property that specified which attribute on the items
	//		in the array of items that acts as the unique identifier for that item.
	//
	constructor: function(/* Object */ keywordParameters){
		//	summary: constructor
		//	keywordParameters: {url: String}
		//	keywordParameters: {data: jsonObject}
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the
		//		value of _value as the initialization parameters.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//		}
	
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = [];
		this._loadFinished = false;
		this._jsonFileUrl = keywordParameters.url;
		this._ccUrl = keywordParameters.url;
		this.url = keywordParameters.url;
		this._jsonData = keywordParameters.data;
		this.data = null;
		this._datatypeMap = keywordParameters.typeMap || {};
		if(!this._datatypeMap['Date']){
			//If no default mapping for dates, then set this as default.
			//We use the dojo.date.stamp here because the ISO format is the 'dojo way'
			//of generically representing dates.
			this._datatypeMap['Date'] = {
											type: Date,
											deserialize: function(value){
												return dojo.date.stamp.fromISOString(value);
											}
										};
		}
		this._features = {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true};
		this._itemsByIdentity = null;
		this._storeRefPropName = "_S"; // Default name for the store reference to attach to every item.
		this._itemNumPropName = "_0"; // Default Item Id for isItem to attach to every item.
		this._rootItemPropName = "_RI"; // Default Item Id for isItem to attach to every item.
		this._reverseRefMap = "_RRM"; // Default attribute for constructing a reverse reference map for use with reference integrity
		this._loadInProgress = false; //Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];
		if(keywordParameters.urlPreventCache !== undefined){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
		if(keywordParameters.hierarchical !== undefined){
			this.hierarchical = keywordParameters.hierarchical?true:false;
		}
		if(keywordParameters.clearOnClose){
			this.clearOnClose = true;
		}
		if("failOk" in keywordParameters){
			this.failOk = keywordParameters.failOk?true:false;
		}
	},
	
	url: "",	// use "" rather than undefined for the benefit of the parser (#3539)

	//Internal var, crossCheckUrl.  Used so that setting either url or _jsonFileUrl, can still trigger a reload
	//when clearOnClose and close is used.
	_ccUrl: "",

	data: null,	// define this so that the parser can populate it

	typeMap: null, //Define so parser can populate.
	
	//Parameter to allow users to specify if a close call should force a reload or not.
	//By default, it retains the old behavior of not clearing if close is called.  But
	//if set true, the store will be reset to default state.  Note that by doing this,
	//all item handles will become invalid and a new fetch must be issued.
	clearOnClose: false,

	//Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.
	//Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
	//Added for tracker: #6072
	urlPreventCache: false,
	
	//Parameter for specifying that it is OK for the xhrGet call to fail silently.
	failOk: false,

	//Parameter to indicate to process data from the url as hierarchical
	//(data items can contain other data items in js form).  Default is true
	//for backwards compatibility.  False means only root items are processed
	//as items, all child objects outside of type-mapped objects and those in
	//specific reference format, are left straight JS data objects.
	hierarchical: true,

	_assertIsItem: function(/* item */ item){
		//	summary:
		//		This function tests whether the item passed in is indeed an item in the store.
		//	item:
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){
			if(!(window.isDrawdown && window.isDrawdown === true)){
			throw new Error("dojo.data.ItemFileReadStore: Invalid item argument.");
			}
		}
	},

	_assertIsAttribute: function(/* attribute-name-string */ attribute){
		//	summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		//	attribute:
		//		The attribute to test for being contained by the store.
		if(typeof attribute !== "string"){
			throw new Error("dojo.data.ItemFileReadStore: Invalid attribute argument.");
		}
	},

	getValue: function(	/* item */ item,
						/* attribute-name-string */ attribute,
						/* value? */ defaultValue){
		//	summary:
		//		See dojo.data.api.Read.getValue()
		var values = this.getValues(item, attribute);
		return (values.length > 0)?values[0]:defaultValue; // mixed
	},

	getValues: function(/* item */ item,
						/* attribute-name-string */ attribute){
		//	summary:
		//		See dojo.data.api.Read.getValues()

		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		// Clone it before returning.  refs: #10474
		return (item[attribute] || []).slice(0); // Array
	},

	getAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getAttributes()
		this._assertIsItem(item);
		var attributes = [];
		for(var key in item){
			// Save off only the real item attributes, not the special id marks for O(1) isItem.
			if((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)){
				attributes.push(key);
			}
		}
		return attributes; // Array
	},

	hasAttribute: function(	/* item */ item,
							/* attribute-name-string */ attribute){
		//	summary:
		//		See dojo.data.api.Read.hasAttribute()
		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return (attribute in item);
	},

	containsValue: function(/* item */ item,
							/* attribute-name-string */ attribute,
							/* anything */ value){
		//	summary:
		//		See dojo.data.api.Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = dojo.data.util.filter.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* item */ item,
								/* attribute-name-string */ attribute,
								/* anything */ value,
								/* RegExp?*/ regexp){
		//	summary:
		//		Internal function for looking at the values contained by the item.
		//	description:
		//		Internal function for looking at the values contained by the item.  This
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		//
		//	item:
		//		The data item to examine for attribute values.
		//	attribute:
		//		The attribute to inspect.
		//	value:
		//		The value to match.
		//	regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		return dojo.some(this.getValues(item, attribute), function(possibleValue){
			if(possibleValue !== null && !dojo.isObject(possibleValue) && regexp){
				if(possibleValue.toString().match(regexp)){
					return true; // Boolean
				}
			}else if(value === possibleValue){
				return true; // Boolean
			}
		});
	},

	isItem: function(/* anything */ something){
		//	summary:
		//		See dojo.data.api.Read.isItem()
		if(something && something[this._storeRefPropName] === this){
			if(this._arrayOfAllItems[something[this._itemNumPropName]] === something){
				return true;
			}
		}
		return false; // Boolean
	},

	isItemLoaded: function(/* anything */ something){
		//	summary:
		//		See dojo.data.api.Read.isItemLoaded()
		return this.isItem(something); //boolean
	},

	loadItem: function(/* object */ keywordArgs){
		//	summary:
		//		See dojo.data.api.Read.loadItem()
		this._assertIsItem(keywordArgs.item);
	},

	getFeatures: function(){
		//	summary:
		//		See dojo.data.api.Read.getFeatures()
		return this._features; //Object
	},

	getLabel: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getLabel()
		if(this._labelAttr && this.isItem(item)){
			return this.getValue(item,this._labelAttr); //String
		}
		return undefined; //undefined
	},

	getLabelAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getLabelAttributes()
		if(this._labelAttr){
			return [this._labelAttr]; //array
		}
		return null; //null
	},

	_fetchItems: function(	/* Object */ keywordArgs,
							/* Function */ findCallback,
							/* Function */ errorCallback){
		//	summary:
		//		See dojo.data.util.simpleFetch.fetch()
		var self = this,
		    filter = function(requestArgs, arrayOfItems){
			var items = [],
			    i, key;
			if(requestArgs.query){
				var value,
				    ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;

				//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
				//same value for each item examined.  Much more efficient.
				var regexpList = {};
				for(key in requestArgs.query){
					value = requestArgs.query[key];
					if(typeof value === "string"){
						regexpList[key] = dojo.data.util.filter.patternToRegExp(value, ignoreCase);
					}else if(value instanceof RegExp){
						regexpList[key] = value;
					}
				}
				for(i = 0; i < arrayOfItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfItems[i];
					if(candidateItem === null){
						match = false;
					}else{
						for(key in requestArgs.query){
							value = requestArgs.query[key];
							if(!self._containsValue(candidateItem, key, value, regexpList[key])){
								match = false;
							}
						}
					}
					if(match){
						items.push(candidateItem);
					}
				}
				findCallback(items, requestArgs);
			}else{
				// We want a copy to pass back in case the parent wishes to sort the array.
				// We shouldn't allow resort of the internal list, so that multiple callers
				// can get lists and sort without affecting each other.  We also need to
				// filter out any null values that have been left as a result of deleteItem()
				// calls in ItemFileWriteStore.
				for(i = 0; i < arrayOfItems.length; ++i){
					var item = arrayOfItems[i];
					if(item !== null){
						items.push(item);
					}
				}
				findCallback(items, requestArgs);
			}
		};

		if(this._loadFinished){
			filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
		}else{
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("dojo.data.ItemFileReadStore: ",
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}

			//See if there was any forced reset of data.
			if(this.data != null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: filter});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl,
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache,
							failOk: this.failOk
						};
					var getHandler = misys.xhrPost(getArgs);
					getHandler.addCallback(function(data){
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							
							filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));
							self._handleQueuedFetches();
						}catch(e){
							self._loadFinished = true;
							self._loadInProgress = false;
							errorCallback(e, keywordArgs);
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						errorCallback(error, keywordArgs);
					});

					//Wire up the cancel to abort of the request
					//This call cancel on the deferred if it hasn't been called
					//yet and then will chain to the simple abort of the
					//simpleFetch keywordArgs
					var oldAbort = null;
					if(keywordArgs.abort){
						oldAbort = keywordArgs.abort;
					}
					keywordArgs.abort = function(){
						var df = getHandler;
						if(df && df.fired === -1){
							df.cancel();
							df = null;
						}
						if(oldAbort){
							oldAbort.call(keywordArgs);
						}
					};
				}
			}else if(this._jsonData){
				try{
					this._loadFinished = true;
					this._getItemsFromLoadedData(this._jsonData);
					this._jsonData = null;
					filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
				}catch(e){
					errorCallback(e, keywordArgs);
				}
			}else{
				errorCallback(new Error("dojo.data.ItemFileReadStore: No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
			}
		}
	},

	_handleQueuedFetches: function(){
		//	summary:
		//		Internal function to execute delayed request in the store.
		//Execute any deferred fetches now.
		if(this._queuedFetches.length > 0){
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i],
				    delayedQuery = fData.args,
				    delayedFilter = fData.filter;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions));
				}else{
					this.fetchItemByIdentity(delayedQuery);
				}
			}
			this._queuedFetches = [];
		}
	},

	_getItemsArray: function(/*object?*/queryOptions){
		//	summary:
		//		Internal function to determine which list of items to search over.
		//	queryOptions: The query options parameter, if any.
		if(queryOptions && queryOptions.deep){
			return this._arrayOfAllItems;
		}
		return this._arrayOfTopLevelItems;
	},

	close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
		 //	summary:
		 //		See dojo.data.api.Read.close()
		 if(this.clearOnClose &&
			this._loadFinished &&
			!this._loadInProgress){
			 //Reset all internalsback to default state.  This will force a reload
			 //on next fetch.  This also checks that the data or url param was set
			 //so that the store knows it can get data.  Without one of those being set,
			 //the next fetch will trigger an error.

			 if(((this._jsonFileUrl == "" || this._jsonFileUrl == null) &&
				 (this.url == "" || this.url == null)
				) && this.data == null){
				 console.debug("dojo.data.ItemFileReadStore: WARNING!  Data reload " +
					" information has not been provided." +
					"  Please set 'url' or 'data' to the appropriate value before" +
					" the next fetch");
			 }
			 this._arrayOfAllItems = [];
			 this._arrayOfTopLevelItems = [];
			 this._loadFinished = false;
			 this._itemsByIdentity = null;
			 this._loadInProgress = false;
			 this._queuedFetches = [];
		 }
	},

	_getItemsFromLoadedData: function(/* Object */ dataObject){
		//	summary:
		//		Function to parse the loaded data into item format and build the internal items array.
		//	description:
		//		Function to parse the loaded data into item format and build the internal items array.
		//
		//	dataObject:
		//		The JS data object containing the raw data to convery into item format.
		//
		// 	returns: array
		//		Array of items in store item format.
		
		// First, we define a couple little utility functions...
		var addingArrays = false,
		    self = this;
		
		function valueIsAnItem(/* anything */ aValue){
			// summary:
			//		Given any sort of value that could be in the raw json data,
			//		return true if we should interpret the value as being an
			//		item itself, rather than a literal value or a reference.
			// example:
			// 	|	false == valueIsAnItem("Kermit");
			// 	|	false == valueIsAnItem(42);
			// 	|	false == valueIsAnItem(new Date());
			// 	|	false == valueIsAnItem({_type:'Date', _value:'1802-05-14'});
			// 	|	false == valueIsAnItem({_reference:'Kermit'});
			// 	|	true == valueIsAnItem({name:'Kermit', color:'green'});
			// 	|	true == valueIsAnItem({iggy:'pop'});
			// 	|	true == valueIsAnItem({foo:42});
			var isItem = (
				(aValue !== null) &&
				(typeof aValue === "object") &&
				(!dojo.isArray(aValue) || addingArrays) &&
				(!dojo.isFunction(aValue)) &&
				(aValue.constructor == Object || dojo.isArray(aValue)) &&
				(typeof aValue._reference === "undefined") &&
				(typeof aValue._type === "undefined") &&
				(typeof aValue._value === "undefined") &&
				self.hierarchical
			);
			return isItem;
		}
		
		function addItemAndSubItemsToArrayOfAllItems(/* Item */ anItem){
			self._arrayOfAllItems.push(anItem);
			for(var attribute in anItem){
				var valueForAttribute = anItem[attribute];
				if(valueForAttribute){
					if(dojo.isArray(valueForAttribute)){
						var valueArray = valueForAttribute;
						for(var k = 0; k < valueArray.length; ++k){
							var singleValue = valueArray[k];
							if(valueIsAnItem(singleValue)){
								addItemAndSubItemsToArrayOfAllItems(singleValue);
							}
						}
					}else{
						if(valueIsAnItem(valueForAttribute)){
							addItemAndSubItemsToArrayOfAllItems(valueForAttribute);
						}
					}
				}
			}
		}

		this._labelAttr = dataObject.label;

		// We need to do some transformations to convert the data structure
		// that we read from the file into a format that will be convenient
		// to work with in memory.

		// Step 1: Walk through the object hierarchy and build a list of all items
		var i,
		    item;
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = dataObject.items;
		if(this._arrayOfTopLevelItems)
		{
			for(i = 0; i < this._arrayOfTopLevelItems.length; ++i){
				item = this._arrayOfTopLevelItems[i];
				if(dojo.isArray(item)){
					addingArrays = true;
				}
				addItemAndSubItemsToArrayOfAllItems(item);
				item[this._rootItemPropName]=true;
			}
		}

		// Step 2: Walk through all the attribute values of all the items,
		// and replace single values with arrays.  For example, we change this:
		//		{ name:'Miss Piggy', pets:'Foo-Foo'}
		// into this:
		//		{ name:['Miss Piggy'], pets:['Foo-Foo']}
		//
		// We also store the attribute names so we can validate our store
		// reference and item id special properties for the O(1) isItem
		var allAttributeNames = {},
		    key;

		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			for(key in item){
				if(key !== this._rootItemPropName){
					var value = item[key];
					if(value !== null){
						if(!dojo.isArray(value)){
							item[key] = [value];
						}
					}else{
						item[key] = [null];
					}
				}
				allAttributeNames[key]=key;
			}
		}

		// Step 3: Build unique property names to use for the _storeRefPropName and _itemNumPropName
		// This should go really fast, it will generally never even run the loop.
		while(allAttributeNames[this._storeRefPropName]){
			this._storeRefPropName += "_";
		}
		while(allAttributeNames[this._itemNumPropName]){
			this._itemNumPropName += "_";
		}
		while(allAttributeNames[this._reverseRefMap]){
			this._reverseRefMap += "_";
		}

		// Step 4: Some data files specify an optional 'identifier', which is
		// the name of an attribute that holds the identity of each item.
		// If this data file specified an identifier attribute, then build a
		// hash table of items keyed by the identity of the items.
		var arrayOfValues;

		var identifier = dataObject.identifier;
		if(identifier){
			this._itemsByIdentity = {};
			this._features['dojo.data.api.Identity'] = identifier;
			for(i = 0; i < this._arrayOfAllItems.length; ++i){
				item = this._arrayOfAllItems[i];
				arrayOfValues = item[identifier];
				var identity = arrayOfValues[0];
				if(!Object.hasOwnProperty.call(this._itemsByIdentity, identity)){
					this._itemsByIdentity[identity] = item;
				}else{
					if(this._jsonFileUrl){
						throw new Error("dojo.data.ItemFileReadStore:  The json data as specified by: [" + this._jsonFileUrl + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}else if(this._jsonData){
						throw new Error("dojo.data.ItemFileReadStore:  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}
		}else{
			this._features['dojo.data.api.Identity'] = Number;
		}

		// Step 5: Walk through all the items, and set each item's properties
		// for _storeRefPropName and _itemNumPropName, so that store.isItem() will return true.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			item[this._storeRefPropName] = this;
			item[this._itemNumPropName] = i;
		}

		// Step 6: We walk through all the attribute values of all the items,
		// looking for type/value literals and item-references.
		//
		// We replace item-references with pointers to items.  For example, we change:
		//		{ name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
		// into this:
		//		{ name:['Kermit'], friends:[miss_piggy] }
		// (where miss_piggy is the object representing the 'Miss Piggy' item).
		//
		// We replace type/value pairs with typed-literals.  For example, we change:
		//		{ name:['Nelson Mandela'], born:[{_type:'Date', _value:'1918-07-18'}] }
		// into this:
		//		{ name:['Kermit'], born:(new Date(1918, 6, 18)) }
		//
		// We also generate the associate map for all items for the O(1) isItem function.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i]; // example: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
			for(key in item){
				arrayOfValues = item[key]; // example: [{_reference:{name:'Miss Piggy'}}]
				for(var j = 0; j < arrayOfValues.length; ++j){
					value = arrayOfValues[j]; // example: {_reference:{name:'Miss Piggy'}}
					if(value !== null && typeof value == "object"){
						if(("_type" in value) && ("_value" in value)){
							var type = value._type; // examples: 'Date', 'Color', or 'ComplexNumber'
							var mappingObj = this._datatypeMap[type]; // examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}
							if(!mappingObj){
								throw new Error("dojo.data.ItemFileReadStore: in the typeMap constructor arg, no object class was specified for the datatype '" + type + "'");
							}else if(dojo.isFunction(mappingObj)){
								arrayOfValues[j] = new mappingObj(value._value);
							}else if(dojo.isFunction(mappingObj.deserialize)){
								arrayOfValues[j] = mappingObj.deserialize(value._value);
							}else{
								throw new Error("dojo.data.ItemFileReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function");
							}
						}
						if(value._reference){
							var referenceDescription = value._reference; // example: {name:'Miss Piggy'}
							if(!dojo.isObject(referenceDescription)){
								// example: 'Miss Piggy'
								// from an item like: { name:['Kermit'], friends:[{_reference:'Miss Piggy'}]}
								arrayOfValues[j] = this._getItemByIdentity(referenceDescription);
							}else{
								// example: {name:'Miss Piggy'}
								// from an item like: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
								for(var k = 0; k < this._arrayOfAllItems.length; ++k){
									var candidateItem = this._arrayOfAllItems[k],
									    found = true;
									for(var refKey in referenceDescription){
										if(candidateItem[refKey] != referenceDescription[refKey]){
											found = false;
										}
									}
									if(found){
										arrayOfValues[j] = candidateItem;
									}
								}
							}
							if(this.referenceIntegrity){
								var refItem = arrayOfValues[j];
								if(this.isItem(refItem)){
									this._addReferenceToMap(refItem, item, key);
								}
							}
						}else if(this.isItem(value)){
							//It's a child item (not one referenced through _reference).
							//We need to treat this as a referenced item, so it can be cleaned up
							//in a write store easily.
							if(this.referenceIntegrity){
								this._addReferenceToMap(value, item, key);
							}
						}
					}
				}
			}
		}
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		 //	summary:
		 //		Method to add an reference map entry for an item and attribute.
		 //	description:
		 //		Method to add an reference map entry for an item and attribute. 		 //
		 //	refItem:
		 //		The item that is referenced.
		 //	parentItem:
		 //		The item that holds the new reference to refItem.
		 //	attribute:
		 //		The attribute on parentItem that contains the new reference.
		 
		 //Stub function, does nothing.  Real processing is in ItemFileWriteStore.
	},

	getIdentity: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Identity.getIdentity()
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			return item[this._itemNumPropName]; // Number
		}else{
			var arrayOfValues = item[identifier];
			if(arrayOfValues){
				return arrayOfValues[0]; // Object || String
			}
		}
		return null; // null
	},

	fetchItemByIdentity: function(/* Object */ keywordArgs){
		//	summary:
		//		See dojo.data.api.Identity.fetchItemByIdentity()

		// Hasn't loaded yet, we have to trigger the load.
		var item,
		    scope;
		if(!this._loadFinished){
			var self = this;
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("dojo.data.ItemFileReadStore: ",
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}
			
			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){

				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl,
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache,
							failOk: this.failOk
					};
					var getHandler = dojo.xhrGet(getArgs);
					getHandler.addCallback(function(data){
						var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							item = self._getItemByIdentity(keywordArgs.identity);
							if(keywordArgs.onItem){
								keywordArgs.onItem.call(scope, item);
							}
							self._handleQueuedFetches();
						}catch(error){
							self._loadInProgress = false;
							if(keywordArgs.onError){
								keywordArgs.onError.call(scope, error);
							}
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						if(keywordArgs.onError){
							var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
							keywordArgs.onError.call(scope, error);
						}
					});
				}

			}else if(this._jsonData){
				// Passed in data, no need to xhr.
				self._getItemsFromLoadedData(self._jsonData);
				self._jsonData = null;
				self._loadFinished = true;
				item = self._getItemByIdentity(keywordArgs.identity);
				if(keywordArgs.onItem){
					scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
					keywordArgs.onItem.call(scope, item);
				}
			}
		}else{
			// Already loaded.  We can just look it up and call back.
			item = this._getItemByIdentity(keywordArgs.identity);
			if(keywordArgs.onItem){
				scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
				keywordArgs.onItem.call(scope, item);
			}
		}
	},

	_getItemByIdentity: function(/* Object */ identity){
		//	summary:
		//		Internal function to look an item up by its identity map.
		var item = null;
		if(this._itemsByIdentity &&
		   Object.hasOwnProperty.call(this._itemsByIdentity, identity)){
			item = this._itemsByIdentity[identity];
		}else if (Object.hasOwnProperty.call(this._arrayOfAllItems, identity)){
			item = this._arrayOfAllItems[identity];
		}
		if(item === undefined){
			item = null;
		}
		return item; // Object
	},

	getIdentityAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Identity.getIdentityAttributes()
		 
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			// If (identifier === Number) it means getIdentity() just returns
			// an integer item-number for each item.  The dojo.data.api.Identity
			// spec says we need to return null if the identity is not composed
			// of attributes
			return null; // null
		}else{
			return [identifier]; // Array
		}
	},
	
	_forceLoad: function(){
		//	summary:
		//		Internal function to force a load of the store if it hasn't occurred yet.  This is required
		//		for specific functions to work properly.
		var self = this;
		//Do a check on the JsonFileUrl and crosscheck it.
		//If it doesn't match the cross-check, it needs to be updated
		//This allows for either url or _jsonFileUrl to he changed to
		//reset the store load location.  Done this way for backwards
		//compatibility.  People use _jsonFileUrl (even though officially
		//private.
		if(this._jsonFileUrl !== this._ccUrl){
			dojo.deprecated("dojo.data.ItemFileReadStore: ",
				"To change the url, set the url property of the store," +
				" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
			this._ccUrl = this._jsonFileUrl;
			this.url = this._jsonFileUrl;
		}else if(this.url !== this._ccUrl){
			this._jsonFileUrl = this.url;
			this._ccUrl = this.url;
		}

		//See if there was any forced reset of data.
		if(this.data != null){
			this._jsonData = this.data;
			this.data = null;
		}

		if(this._jsonFileUrl){
				var getArgs = {
					url: this._jsonFileUrl,
					handleAs: "json-comment-optional",
					preventCache: this.urlPreventCache,
					failOk: this.failOk,
					sync: true
				};
			var getHandler = dojo.xhrGet(getArgs);
			getHandler.addCallback(function(data){
				try{
					//Check to be sure there wasn't another load going on concurrently
					//So we don't clobber data that comes in on it.  If there is a load going on
					//then do not save this data.  It will potentially clobber current data.
					//We mainly wanted to sync/wait here.
					//TODO:  Revisit the loading scheme of this store to improve multi-initial
					//request handling.
					if(self._loadInProgress !== true && !self._loadFinished){
						self._getItemsFromLoadedData(data);
						self._loadFinished = true;
					}else if(self._loadInProgress){
						//Okay, we hit an error state we can't recover from.  A forced load occurred
						//while an async load was occurring.  Since we cannot block at this point, the best
						//that can be managed is to throw an error.
						throw new Error("dojo.data.ItemFileReadStore:  Unable to perform a synchronous load, an async load is in progress.");
					}
				}catch(e){
					console.log(e);
					throw e;
				}
			});
			getHandler.addErrback(function(error){
				throw error;
			});
		}else if(this._jsonData){
			self._getItemsFromLoadedData(self._jsonData);
			self._jsonData = null;
			self._loadFinished = true;
		}
	}
});
//Mix in the simple fetch implementation to this class.
dojo.extend(dojo.data.ItemFileReadStore,dojo.data.util.simpleFetch);

}

if(!dojo._hasResource["misys.data.ItemFileReadStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.data.ItemFileReadStore"] = true;
dojo.provide("misys.data.ItemFileReadStore");
dojo.experimental("misys.data.ItemFileReadStore");



dojo.declare("misys.data.ItemFileReadStore", dojo.data.ItemFileReadStore,{
	//	summary:
	//		A ItemFileReadStore that uses a HHTP POST request instead of GET to
	//		fetch items from a URL
	//
	_fetchItems: function(	/* Object */ keywordArgs,
							/* Function */ findCallback,
							/* Function */ errorCallback){
		//	summary:
		//		See dojo.data.util.simpleFetch.fetch()
		var serverQuery = keywordArgs.serverQuery || keywordArgs.queryOptions || {};
		
		var self = this,
		    filter = function(requestArgs, arrayOfItems){
			var items = [],
			    i, key;
			if(requestArgs.query){
				var value,
				    ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;

				//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
				//same value for each item examined.  Much more efficient.
				var regexpList = {};
				for(key in requestArgs.query){
					value = requestArgs.query[key];
					if(typeof value === "string"){
						regexpList[key] = dojo.data.util.filter.patternToRegExp(value, ignoreCase);
					}else if(value instanceof RegExp){
						regexpList[key] = value;
					}
				}
				for(i = 0; i < arrayOfItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfItems[i];
					if(candidateItem === null){
						match = false;
					}else{
						for(key in requestArgs.query){
							value = requestArgs.query[key];
							if(!self._containsValue(candidateItem, key, value, regexpList[key])){
								match = false;
							}
						}
					}
					if(match){
						items.push(candidateItem);
					}
				}
				findCallback(items, requestArgs);
			}else{
				// We want a copy to pass back in case the parent wishes to sort the array.
				// We shouldn't allow resort of the internal list, so that multiple callers
				// can get lists and sort without affecting each other.  We also need to
				// filter out any null values that have been left as a result of deleteItem()
				// calls in ItemFileWriteStore.
				if (arrayOfItems)
				{
					for(i = 0; i < arrayOfItems.length; ++i){
					var item = arrayOfItems[i];
					if(item !== null){
						items.push(item);
						}
					}
				}
				findCallback(items, requestArgs);
			}
		};
		
		if(this._loadFinished){
			filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
		}else{
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				dojo.deprecated("misys.data.ItemFileReadStore: ",
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}
		
			//See if there was any forced reset of data.
			if(this.data != null){
				this._jsonData = this.data;
				this.data = null;
			}
		
			if(this._jsonFileUrl){
			//If fetches come in before the loading has finished, but while
			//a load is in progress, we have to defer the fetching to be
			//invoked in the callback.
			if(this._loadInProgress){
				this._queuedFetches.push({args: keywordArgs, filter: filter});
			}else{
				this._loadInProgress = true;
				var getArgs = {
						url: self._jsonFileUrl,
						handleAs: "json-comment-optional",
						preventCache: this.urlPreventCache,
						failOk: this.failOk,
						content: serverQuery
					};
					var getHandler = misys.xhrPost(getArgs);
					getHandler.addCallback(function(data){
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							
							filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));
							self._handleQueuedFetches();
						}catch(e){
							self._loadFinished = true;
							self._loadInProgress = false;
							errorCallback(e, keywordArgs);
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						errorCallback(error, keywordArgs);
					});
				
					//Wire up the cancel to abort of the request
					//This call cancel on the deferred if it hasn't been called
					//yet and then will chain to the simple abort of the
					//simpleFetch keywordArgs
					var oldAbort = null;
					if(keywordArgs.abort){
						oldAbort = keywordArgs.abort;
					}
					keywordArgs.abort = function(){
						var df = getHandler;
						if(df && df.fired === -1){
							df.cancel();
							df = null;
						}
						if(oldAbort){
							oldAbort.call(keywordArgs);
						}
					};
				}
			}else if(this._jsonData){
				try{
					this._loadFinished = true;
					this._getItemsFromLoadedData(this._jsonData);
					this._jsonData = null;
					filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
				}catch(e){
					errorCallback(e, keywordArgs);
				}
			}else{
				errorCallback(new Error("misys.data.ItemFileReadStore: No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
			}
		}
	}
});

}

if(!dojo._hasResource["dojo.data.ItemFileWriteStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.data.ItemFileWriteStore"] = true;
dojo.provide("dojo.data.ItemFileWriteStore");



dojo.declare("dojo.data.ItemFileWriteStore", dojo.data.ItemFileReadStore, {
	constructor: function(/* object */ keywordParameters){
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the
		//		value of _value as the initialization parameters.  It is serialized assuming object.toString()
		//		serialization.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//			serialize:	function(object) //The function that converts the object back into the proper file format form.
		//		}

		// ItemFileWriteStore extends ItemFileReadStore to implement these additional dojo.data APIs
		this._features['dojo.data.api.Write'] = true;
		this._features['dojo.data.api.Notification'] = true;
		
		// For keeping track of changes so that we can implement isDirty and revert
		this._pending = {
			_newItems:{},
			_modifiedItems:{},
			_deletedItems:{}
		};

		if(!this._datatypeMap['Date'].serialize){
			this._datatypeMap['Date'].serialize = function(obj){
				return dojo.date.stamp.toISOString(obj, {zulu:true});
			};
		}
		//Disable only if explicitly set to false.
		if(keywordParameters && (keywordParameters.referenceIntegrity === false)){
			this.referenceIntegrity = false;
		}

		// this._saveInProgress is set to true, briefly, from when save() is first called to when it completes
		this._saveInProgress = false;
	},

	referenceIntegrity: true, //Flag that defaultly enabled reference integrity tracking.  This way it can also be disabled pogrammatially or declaratively.

	_assert: function(/* boolean */ condition){
		if(!condition){
			throw new Error("assertion failed in ItemFileWriteStore");
		}
	},

	_getIdentifierAttribute: function(){
		var identifierAttribute = this.getFeatures()['dojo.data.api.Identity'];
		// this._assert((identifierAttribute === Number) || (dojo.isString(identifierAttribute)));
		return identifierAttribute;
	},
	
	
/* dojo.data.api.Write */

	newItem: function(/* Object? */ keywordArgs, /* Object? */ parentInfo){
		// summary: See dojo.data.api.Write.newItem()

		this._assert(!this._saveInProgress);

		if(!this._loadFinished){
			// We need to do this here so that we'll be able to find out what
			// identifierAttribute was specified in the data file.
			this._forceLoad();
		}

		if(typeof keywordArgs != "object" && typeof keywordArgs != "undefined"){
			throw new Error("newItem() was passed something other than an object");
		}
		var newIdentity = null;
		var identifierAttribute = this._getIdentifierAttribute();
		if(identifierAttribute === Number){
			newIdentity = this._arrayOfAllItems.length;
		}else{
			newIdentity = keywordArgs[identifierAttribute];
			if(typeof newIdentity === "undefined"){
				throw new Error("newItem() was not passed an identity for the new item");
			}
			if(dojo.isArray(newIdentity)){
				throw new Error("newItem() was not passed an single-valued identity");
			}
		}
		
		// make sure this identity is not already in use by another item, if identifiers were
		// defined in the file.  Otherwise it would be the item count,
		// which should always be unique in this case.
		if(this._itemsByIdentity){
			this._assert(typeof this._itemsByIdentity[newIdentity] === "undefined");
		}
		this._assert(typeof this._pending._newItems[newIdentity] === "undefined");
		this._assert(typeof this._pending._deletedItems[newIdentity] === "undefined");
		
		var newItem = {};
		newItem[this._storeRefPropName] = this;
		newItem[this._itemNumPropName] = this._arrayOfAllItems.length;
		if(this._itemsByIdentity){
			this._itemsByIdentity[newIdentity] = newItem;
			//We have to set the identifier now, otherwise we can't look it
			//up at calls to setValueorValues in parentInfo handling.
			newItem[identifierAttribute] = [newIdentity];
		}
		this._arrayOfAllItems.push(newItem);

		//We need to construct some data for the onNew call too...
		var pInfo = null;
		
		// Now we need to check to see where we want to assign this thingm if any.
		if(parentInfo && parentInfo.parent && parentInfo.attribute){
			pInfo = {
				item: parentInfo.parent,
				attribute: parentInfo.attribute,
				oldValue: undefined
			};

			//See if it is multi-valued or not and handle appropriately
			//Generally, all attributes are multi-valued for this store
			//So, we only need to append if there are already values present.
			var values = this.getValues(parentInfo.parent, parentInfo.attribute);
			if(values && values.length > 0){
				var tempValues = values.slice(0, values.length);
				if(values.length === 1){
					pInfo.oldValue = values[0];
				}else{
					pInfo.oldValue = values.slice(0, values.length);
				}
				tempValues.push(newItem);
				this._setValueOrValues(parentInfo.parent, parentInfo.attribute, tempValues, false);
				pInfo.newValue = this.getValues(parentInfo.parent, parentInfo.attribute);
			}else{
				this._setValueOrValues(parentInfo.parent, parentInfo.attribute, newItem, false);
				pInfo.newValue = newItem;
			}
		}else{
			//Toplevel item, add to both top list as well as all list.
			newItem[this._rootItemPropName]=true;
			this._arrayOfTopLevelItems.push(newItem);
		}
		
		this._pending._newItems[newIdentity] = newItem;
		
		//Clone over the properties to the new item
		for(var key in keywordArgs){
			if(key === this._storeRefPropName || key === this._itemNumPropName){
				// Bummer, the user is trying to do something like
				// newItem({_S:"foo"}).  Unfortunately, our superclass,
				// ItemFileReadStore, is already using _S in each of our items
				// to hold private info.  To avoid a naming collision, we
				// need to move all our private info to some other property
				// of all the items/objects.  So, we need to iterate over all
				// the items and do something like:
				//    item.__S = item._S;
				//    item._S = undefined;
				// But first we have to make sure the new "__S" variable is
				// not in use, which means we have to iterate over all the
				// items checking for that.
				throw new Error("encountered bug in ItemFileWriteStore.newItem");
			}
			var value = keywordArgs[key];
			if(!dojo.isArray(value)){
				value = [value];
			}
			newItem[key] = value;
			if(this.referenceIntegrity){
				for(var i = 0; i < value.length; i++){
					var val = value[i];
					if(this.isItem(val)){
						this._addReferenceToMap(val, newItem, key);
					}
				}
			}
		}
		this.onNew(newItem, pInfo); // dojo.data.api.Notification call
		return newItem; // item
	},
	
	_removeArrayElement: function(/* Array */ array, /* anything */ element){
		var index = dojo.indexOf(array, element);
		if(index != -1){
			array.splice(index, 1);
			return true;
		}
		return false;
	},
	
	deleteItem: function(/* item */ item){
		// summary: See dojo.data.api.Write.deleteItem()
		this._assert(!this._saveInProgress);
		this._assertIsItem(item);

		// Remove this item from the _arrayOfAllItems, but leave a null value in place
		// of the item, so as not to change the length of the array, so that in newItem()
		// we can still safely do: newIdentity = this._arrayOfAllItems.length;
		var indexInArrayOfAllItems = item[this._itemNumPropName];
		var identity = this.getIdentity(item);

		//If we have reference integrity on, we need to do reference cleanup for the deleted item
		if(this.referenceIntegrity){
			//First scan all the attributes of this items for references and clean them up in the map
			//As this item is going away, no need to track its references anymore.

			//Get the attributes list before we generate the backup so it
			//doesn't pollute the attributes list.
			var attributes = this.getAttributes(item);

			//Backup the map, we'll have to restore it potentially, in a revert.
			if(item[this._reverseRefMap]){
				item["backup_" + this._reverseRefMap] = dojo.clone(item[this._reverseRefMap]);
			}
			
			//TODO:  This causes a reversion problem.  This list won't be restored on revert since it is
			//attached to the 'value'. item, not ours.  Need to back tese up somehow too.
			//Maybe build a map of the backup of the entries and attach it to the deleted item to be restored
			//later.  Or just record them and call _addReferenceToMap on them in revert.
			dojo.forEach(attributes, function(attribute){
				dojo.forEach(this.getValues(item, attribute), function(value){
					if(this.isItem(value)){
						//We have to back up all the references we had to others so they can be restored on a revert.
						if(!item["backupRefs_" + this._reverseRefMap]){
							item["backupRefs_" + this._reverseRefMap] = [];
						}
						item["backupRefs_" + this._reverseRefMap].push({id: this.getIdentity(value), attr: attribute});
						this._removeReferenceFromMap(value, item, attribute);
					}
				}, this);
			}, this);

			//Next, see if we have references to this item, if we do, we have to clean them up too.
			var references = item[this._reverseRefMap];
			if(references){
				//Look through all the items noted as references to clean them up.
				for(var itemId in references){
					var containingItem = null;
					if(this._itemsByIdentity){
						containingItem = this._itemsByIdentity[itemId];
					}else{
						containingItem = this._arrayOfAllItems[itemId];
					}
					//We have a reference to a containing item, now we have to process the
					//attributes and clear all references to the item being deleted.
					if(containingItem){
						for(var attribute in references[itemId]){
							var oldValues = this.getValues(containingItem, attribute) || [];
							var newValues = dojo.filter(oldValues, function(possibleItem){
								return !(this.isItem(possibleItem) && this.getIdentity(possibleItem) == identity);
							}, this);
							//Remove the note of the reference to the item and set the values on the modified attribute.
							this._removeReferenceFromMap(item, containingItem, attribute);
							if(newValues.length < oldValues.length){
								this._setValueOrValues(containingItem, attribute, newValues, true);
							}
						}
					}
				}
			}
		}

		this._arrayOfAllItems[indexInArrayOfAllItems] = null;

		item[this._storeRefPropName] = null;
		if(this._itemsByIdentity){
			delete this._itemsByIdentity[identity];
		}
		this._pending._deletedItems[identity] = item;
		
		//Remove from the toplevel items, if necessary...
		if(item[this._rootItemPropName]){
			this._removeArrayElement(this._arrayOfTopLevelItems, item);
		}
		this.onDelete(item); // dojo.data.api.Notification call
		return true;
	},

	setValue: function(/* item */ item, /* attribute-name-string */ attribute, /* almost anything */ value){
		// summary: See dojo.data.api.Write.set()
		return this._setValueOrValues(item, attribute, value, true); // boolean
	},
	
	setValues: function(/* item */ item, /* attribute-name-string */ attribute, /* array */ values){
		// summary: See dojo.data.api.Write.setValues()
		return this._setValueOrValues(item, attribute, values, true); // boolean
	},
	
	unsetAttribute: function(/* item */ item, /* attribute-name-string */ attribute){
		// summary: See dojo.data.api.Write.unsetAttribute()
		return this._setValueOrValues(item, attribute, [], true);
	},
	
	_setValueOrValues: function(/* item */ item, /* attribute-name-string */ attribute, /* anything */ newValueOrValues, /*boolean?*/ callOnSet){
		this._assert(!this._saveInProgress);
		
		// Check for valid arguments
		this._assertIsItem(item);
		this._assert(dojo.isString(attribute));
		this._assert(typeof newValueOrValues !== "undefined");

		// Make sure the user isn't trying to change the item's identity
		var identifierAttribute = this._getIdentifierAttribute();
		if(attribute == identifierAttribute){
			throw new Error("ItemFileWriteStore does not have support for changing the value of an item's identifier.");
		}

		// To implement the Notification API, we need to make a note of what
		// the old attribute value was, so that we can pass that info when
		// we call the onSet method.
		var oldValueOrValues = this._getValueOrValues(item, attribute);

		var identity = this.getIdentity(item);
		if(!this._pending._modifiedItems[identity]){
			// Before we actually change the item, we make a copy of it to
			// record the original state, so that we'll be able to revert if
			// the revert method gets called.  If the item has already been
			// modified then there's no need to do this now, since we already
			// have a record of the original state.
			var copyOfItemState = {};
			for(var key in item){
				if((key === this._storeRefPropName) || (key === this._itemNumPropName) || (key === this._rootItemPropName)){
					copyOfItemState[key] = item[key];
				}else if(key === this._reverseRefMap){
					copyOfItemState[key] = dojo.clone(item[key]);
				}else{
					copyOfItemState[key] = item[key].slice(0, item[key].length);
				}
			}
			// Now mark the item as dirty, and save the copy of the original state
			this._pending._modifiedItems[identity] = copyOfItemState;
		}
		
		// Okay, now we can actually change this attribute on the item
		var success = false;
		
		if(dojo.isArray(newValueOrValues) && newValueOrValues.length === 0){
			
			// If we were passed an empty array as the value, that counts
			// as "unsetting" the attribute, so we need to remove this
			// attribute from the item.
			success = delete item[attribute];
			newValueOrValues = undefined; // used in the onSet Notification call below

			if(this.referenceIntegrity && oldValueOrValues){
				var oldValues = oldValueOrValues;
				if(!dojo.isArray(oldValues)){
					oldValues = [oldValues];
				}
				for(var i = 0; i < oldValues.length; i++){
					var value = oldValues[i];
					if(this.isItem(value)){
						this._removeReferenceFromMap(value, item, attribute);
					}
				}
			}
		}else{
			var newValueArray;
			if(dojo.isArray(newValueOrValues)){
				var newValues = newValueOrValues;
				// Unfortunately, it's not safe to just do this:
				//    newValueArray = newValues;
				// Instead, we need to copy the array, which slice() does very nicely.
				// This is so that our internal data structure won't
				// get corrupted if the user mucks with the values array *after*
				// calling setValues().
				newValueArray = newValueOrValues.slice(0, newValueOrValues.length);
			}else{
				newValueArray = [newValueOrValues];
			}

			//We need to handle reference integrity if this is on.
			//In the case of set, we need to see if references were added or removed
			//and update the reference tracking map accordingly.
			if(this.referenceIntegrity){
				if(oldValueOrValues){
					var oldValues = oldValueOrValues;
					if(!dojo.isArray(oldValues)){
						oldValues = [oldValues];
					}
					//Use an associative map to determine what was added/removed from the list.
					//Should be O(n) performant.  First look at all the old values and make a list of them
					//Then for any item not in the old list, we add it.  If it was already present, we remove it.
					//Then we pass over the map and any references left it it need to be removed (IE, no match in
					//the new values list).
					var map = {};
					dojo.forEach(oldValues, function(possibleItem){
						if(this.isItem(possibleItem)){
							var id = this.getIdentity(possibleItem);
							map[id.toString()] = true;
						}
					}, this);
					dojo.forEach(newValueArray, function(possibleItem){
						if(this.isItem(possibleItem)){
							var id = this.getIdentity(possibleItem);
							if(map[id.toString()]){
								delete map[id.toString()];
							}else{
								this._addReferenceToMap(possibleItem, item, attribute);
							}
						}
					}, this);
					for(var rId in map){
						var removedItem;
						if(this._itemsByIdentity){
							removedItem = this._itemsByIdentity[rId];
						}else{
							removedItem = this._arrayOfAllItems[rId];
						}
						this._removeReferenceFromMap(removedItem, item, attribute);
					}
				}else{
					//Everything is new (no old values) so we have to just
					//insert all the references, if any.
					for(var i = 0; i < newValueArray.length; i++){
						var value = newValueArray[i];
						if(this.isItem(value)){
							this._addReferenceToMap(value, item, attribute);
						}
					}
				}
			}
			item[attribute] = newValueArray;
			success = true;
		}

		// Now we make the dojo.data.api.Notification call
		if(callOnSet){
			this.onSet(item, attribute, oldValueOrValues, newValueOrValues);
		}
		return success; // boolean
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		//	summary:
		//		Method to add an reference map entry for an item and attribute.
		//	description:
		//		Method to add an reference map entry for an item and attribute. 		 //
		//	refItem:
		//		The item that is referenced.
		//	parentItem:
		//		The item that holds the new reference to refItem.
		//	attribute:
		//		The attribute on parentItem that contains the new reference.
		 
		var parentId = this.getIdentity(parentItem);
		var references = refItem[this._reverseRefMap];

		if(!references){
			references = refItem[this._reverseRefMap] = {};
		}
		var itemRef = references[parentId];
		if(!itemRef){
			itemRef = references[parentId] = {};
		}
		itemRef[attribute] = true;
	},

	_removeReferenceFromMap: function(/* item */ refItem, /* item */ parentItem, /*strin*/ attribute){
		//	summary:
		//		Method to remove an reference map entry for an item and attribute.
		//	description:
		//		Method to remove an reference map entry for an item and attribute.  This will
		//		also perform cleanup on the map such that if there are no more references at all to
		//		the item, its reference object and entry are removed.
		//
		//	refItem:
		//		The item that is referenced.
		//	parentItem:
		//		The item holding a reference to refItem.
		//	attribute:
		//		The attribute on parentItem that contains the reference.
		var identity = this.getIdentity(parentItem);
		var references = refItem[this._reverseRefMap];
		var itemId;
		if(references){
			for(itemId in references){
				if(itemId == identity){
					delete references[itemId][attribute];
					if(this._isEmpty(references[itemId])){
						delete references[itemId];
					}
				}
			}
			if(this._isEmpty(references)){
				delete refItem[this._reverseRefMap];
			}
		}
	},

	_dumpReferenceMap: function(){
		//	summary:
		//		Function to dump the reverse reference map of all items in the store for debug purposes.
		//	description:
		//		Function to dump the reverse reference map of all items in the store for debug purposes.
		var i;
		for(i = 0; i < this._arrayOfAllItems.length; i++){
			var item = this._arrayOfAllItems[i];
			if(item && item[this._reverseRefMap]){
				console.log("Item: [" + this.getIdentity(item) + "] is referenced by: " + dojo.toJson(item[this._reverseRefMap]));
			}
		}
	},
	
	_getValueOrValues: function(/* item */ item, /* attribute-name-string */ attribute){
		var valueOrValues = undefined;
		if(this.hasAttribute(item, attribute)){
			var valueArray = this.getValues(item, attribute);
			if(valueArray.length == 1){
				valueOrValues = valueArray[0];
			}else{
				valueOrValues = valueArray;
			}
		}
		return valueOrValues;
	},
	
	_flatten: function(/* anything */ value){
		if(this.isItem(value)){
			var item = value;
			// Given an item, return an serializable object that provides a
			// reference to the item.
			// For example, given kermit:
			//    var kermit = store.newItem({id:2, name:"Kermit"});
			// we want to return
			//    {_reference:2}
			var identity = this.getIdentity(item);
			var referenceObject = {_reference: identity};
			return referenceObject;
		}else{
			if(typeof value === "object"){
				for(var type in this._datatypeMap){
					var typeMap = this._datatypeMap[type];
					if(dojo.isObject(typeMap) && !dojo.isFunction(typeMap)){
						if(value instanceof typeMap.type){
							if(!typeMap.serialize){
								throw new Error("ItemFileWriteStore:  No serializer defined for type mapping: [" + type + "]");
							}
							return {_type: type, _value: typeMap.serialize(value)};
						}
					} else if(value instanceof typeMap){
						//SImple mapping, therefore, return as a toString serialization.
						return {_type: type, _value: value.toString()};
					}
				}
			}
			return value;
		}
	},
	
	_getNewFileContentString: function(){
		// summary:
		//		Generate a string that can be saved to a file.
		//		The result should look similar to:
		//		http://trac.dojotoolkit.org/browser/dojo/trunk/tests/data/countries.json
		var serializableStructure = {};
		
		var identifierAttribute = this._getIdentifierAttribute();
		if(identifierAttribute !== Number){
			serializableStructure.identifier = identifierAttribute;
		}
		if(this._labelAttr){
			serializableStructure.label = this._labelAttr;
		}
		serializableStructure.items = [];
		for(var i = 0; i < this._arrayOfAllItems.length; ++i){
			var item = this._arrayOfAllItems[i];
			if(item !== null){
				var serializableItem = {};
				for(var key in item){
					if(key !== this._storeRefPropName && key !== this._itemNumPropName && key !== this._reverseRefMap && key !== this._rootItemPropName){
						var attribute = key;
						var valueArray = this.getValues(item, attribute);
						if(valueArray.length == 1){
							serializableItem[attribute] = this._flatten(valueArray[0]);
						}else{
							var serializableArray = [];
							for(var j = 0; j < valueArray.length; ++j){
								serializableArray.push(this._flatten(valueArray[j]));
								serializableItem[attribute] = serializableArray;
							}
						}
					}
				}
				serializableStructure.items.push(serializableItem);
			}
		}
		var prettyPrint = true;
		return dojo.toJson(serializableStructure, prettyPrint);
	},

	_isEmpty: function(something){
		//	summary:
		//		Function to determine if an array or object has no properties or values.
		//	something:
		//		The array or object to examine.
		var empty = true;
		if(dojo.isObject(something)){
			var i;
			for(i in something){
				empty = false;
				break;
			}
		}else if(dojo.isArray(something)){
			if(something.length > 0){
				empty = false;
			}
		}
		return empty; //boolean
	},
	
	save: function(/* object */ keywordArgs){
		// summary: See dojo.data.api.Write.save()
		this._assert(!this._saveInProgress);
		
		// this._saveInProgress is set to true, briefly, from when save is first called to when it completes
		this._saveInProgress = true;
		
		var self = this;
		var saveCompleteCallback = function(){
			self._pending = {
				_newItems:{},
				_modifiedItems:{},
				_deletedItems:{}
			};

			self._saveInProgress = false; // must come after this._pending is cleared, but before any callbacks
			if(keywordArgs && keywordArgs.onComplete){
				var scope = keywordArgs.scope || dojo.global;
				keywordArgs.onComplete.call(scope);
			}
		};
		var saveFailedCallback = function(err){
			self._saveInProgress = false;
			if(keywordArgs && keywordArgs.onError){
				var scope = keywordArgs.scope || dojo.global;
				keywordArgs.onError.call(scope, err);
			}
		};
		
		if(this._saveEverything){
			var newFileContentString = this._getNewFileContentString();
			this._saveEverything(saveCompleteCallback, saveFailedCallback, newFileContentString);
		}
		if(this._saveCustom){
			this._saveCustom(saveCompleteCallback, saveFailedCallback);
		}
		if(!this._saveEverything && !this._saveCustom){
			// Looks like there is no user-defined save-handler function.
			// That's fine, it just means the datastore is acting as a "mock-write"
			// store -- changes get saved in memory but don't get saved to disk.
			saveCompleteCallback();
		}
	},
	
	revert: function(){
		// summary: See dojo.data.api.Write.revert()
		this._assert(!this._saveInProgress);

		var identity;
		for(identity in this._pending._modifiedItems){
			// find the original item and the modified item that replaced it
			var copyOfItemState = this._pending._modifiedItems[identity];
			var modifiedItem = null;
			if(this._itemsByIdentity){
				modifiedItem = this._itemsByIdentity[identity];
			}else{
				modifiedItem = this._arrayOfAllItems[identity];
			}
	
			// Restore the original item into a full-fledged item again, we want to try to
			// keep the same object instance as if we don't it, causes bugs like #9022.
			copyOfItemState[this._storeRefPropName] = this;
			for(key in modifiedItem){
				delete modifiedItem[key];
			}
			dojo.mixin(modifiedItem, copyOfItemState);
		}
		var deletedItem;
		for(identity in this._pending._deletedItems){
			deletedItem = this._pending._deletedItems[identity];
			deletedItem[this._storeRefPropName] = this;
			var index = deletedItem[this._itemNumPropName];

			//Restore the reverse refererence map, if any.
			if(deletedItem["backup_" + this._reverseRefMap]){
				deletedItem[this._reverseRefMap] = deletedItem["backup_" + this._reverseRefMap];
				delete deletedItem["backup_" + this._reverseRefMap];
			}
			this._arrayOfAllItems[index] = deletedItem;
			if(this._itemsByIdentity){
				this._itemsByIdentity[identity] = deletedItem;
			}
			if(deletedItem[this._rootItemPropName]){
				this._arrayOfTopLevelItems.push(deletedItem);
			}
		}
		//We have to pass through it again and restore the reference maps after all the
		//undeletes have occurred.
		for(identity in this._pending._deletedItems){
			deletedItem = this._pending._deletedItems[identity];
			if(deletedItem["backupRefs_" + this._reverseRefMap]){
				dojo.forEach(deletedItem["backupRefs_" + this._reverseRefMap], function(reference){
					var refItem;
					if(this._itemsByIdentity){
						refItem = this._itemsByIdentity[reference.id];
					}else{
						refItem = this._arrayOfAllItems[reference.id];
					}
					this._addReferenceToMap(refItem, deletedItem, reference.attr);
				}, this);
				delete deletedItem["backupRefs_" + this._reverseRefMap];
			}
		}

		for(identity in this._pending._newItems){
			var newItem = this._pending._newItems[identity];
			newItem[this._storeRefPropName] = null;
			// null out the new item, but don't change the array index so
			// so we can keep using _arrayOfAllItems.length.
			this._arrayOfAllItems[newItem[this._itemNumPropName]] = null;
			if(newItem[this._rootItemPropName]){
				this._removeArrayElement(this._arrayOfTopLevelItems, newItem);
			}
			if(this._itemsByIdentity){
				delete this._itemsByIdentity[identity];
			}
		}

		this._pending = {
			_newItems:{},
			_modifiedItems:{},
			_deletedItems:{}
		};
		return true; // boolean
	},
	
	isDirty: function(/* item? */ item){
		// summary: See dojo.data.api.Write.isDirty()
		if(item){
			// return true if the item is dirty
			var identity = this.getIdentity(item);
			return new Boolean(this._pending._newItems[identity] ||
				this._pending._modifiedItems[identity] ||
				this._pending._deletedItems[identity]).valueOf(); // boolean
		}else{
			// return true if the store is dirty -- which means return true
			// if there are any new items, dirty items, or modified items
			if(!this._isEmpty(this._pending._newItems) ||
				!this._isEmpty(this._pending._modifiedItems) ||
				!this._isEmpty(this._pending._deletedItems)){
				return true;
			}
			return false; // boolean
		}
	},

/* dojo.data.api.Notification */

	onSet: function(/* item */ item,
					/*attribute-name-string*/ attribute,
					/*object | array*/ oldValue,
					/*object | array*/ newValue){
		// summary: See dojo.data.api.Notification.onSet()
		
		// No need to do anything. This method is here just so that the
		// client code can connect observers to it.
	},

	onNew: function(/* item */ newItem, /*object?*/ parentInfo){
		// summary: See dojo.data.api.Notification.onNew()
		
		// No need to do anything. This method is here just so that the
		// client code can connect observers to it.
	},

	onDelete: function(/* item */ deletedItem){
		// summary: See dojo.data.api.Notification.onDelete()
		
		// No need to do anything. This method is here just so that the
		// client code can connect observers to it.
	},

	close: function(/* object? */ request){
		 // summary:
		 //		Over-ride of base close function of ItemFileReadStore to add in check for store state.
		 // description:
		 //		Over-ride of base close function of ItemFileReadStore to add in check for store state.
		 //		If the store is still dirty (unsaved changes), then an error will be thrown instead of
		 //		clearing the internal state for reload from the url.

		 //Clear if not dirty ... or throw an error
		 if(this.clearOnClose){
			 if(!this.isDirty()){
				 this.inherited(arguments);
			 }else{
				 //Only throw an error if the store was dirty and we were loading from a url (cannot reload from url until state is saved).
				 throw new Error("dojo.data.ItemFileWriteStore: There are unsaved changes present in the store.  Please save or revert the changes before invoking close.");
			 }
		 }
	}
});

}

if(!dojo._hasResource["dojox.uuid._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.uuid._base"] = true;
dojo.provide("dojox.uuid._base");

// Public constants:
dojox.uuid.NIL_UUID = "00000000-0000-0000-0000-000000000000";
dojox.uuid.version = {
	//	Enumeration for the different UUID versions.
	UNKNOWN: 0,
	TIME_BASED: 1,
	DCE_SECURITY: 2,
	NAME_BASED_MD5: 3,
	RANDOM: 4,
	NAME_BASED_SHA1: 5 };
dojox.uuid.variant = {
	//	Enumeration for the different UUID variants.
	NCS: "0",
	DCE: "10",
	MICROSOFT: "110",
	UNKNOWN: "111" };

dojox.uuid.assert = function(/*Boolean*/ booleanValue, /*String?*/ message){
	// summary:
	//		Throws an exception if the assertion fails.
	// description:
	//		If the asserted condition is true, this method does nothing. If the
	//		condition is false, we throw an error with a error message.
	// booleanValue: Must be true for the assertion to succeed.
	// message: A string describing the assertion.
	// throws: Throws an Error if 'booleanValue' is false.
	if(!booleanValue){
		if(!message){
			message = "An assert statement failed.\n" +
			"The method dojox.uuid.assert() was called with a 'false' value.\n";
		}
		throw new Error(message);
	}
};

dojox.uuid.generateNilUuid = function(){
	// summary:
	//		This function returns the Nil UUID: "00000000-0000-0000-0000-000000000000".
	// description:
	//		The Nil UUID is described in section 4.1.7 of
	//		RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.1.7
	// examples:
	//		var string = dojox.uuid.generateNilUuid();
	return dojox.uuid.NIL_UUID; // String
};

dojox.uuid.isValid = function(/*String*/ uuidString){
	// summary:
	//		Returns true if the UUID was initialized with a valid value.
	uuidString = uuidString.toString();
	var valid = (dojo.isString(uuidString) &&
		(uuidString.length == 36) &&
		(uuidString == uuidString.toLowerCase()));
	if(valid){
		var arrayOfParts = uuidString.split("-");
		valid = ((arrayOfParts.length == 5) &&
			(arrayOfParts[0].length == 8) &&
			(arrayOfParts[1].length == 4) &&
			(arrayOfParts[2].length == 4) &&
			(arrayOfParts[3].length == 4) &&
			(arrayOfParts[4].length == 12));
		var HEX_RADIX = 16;
		for (var i in arrayOfParts) {
			var part = arrayOfParts[i];
			var integer = parseInt(part, HEX_RADIX);
			valid = valid && isFinite(integer);
		}
	}
	return valid; // boolean
};

dojox.uuid.getVariant = function(/*String*/ uuidString){
	// summary:
	//		Returns a variant code that indicates what type of UUID this is.
	//		Returns one of the enumerated dojox.uuid.variant values.
	// example:
	//		var variant = dojox.uuid.getVariant("3b12f1df-5232-4804-897e-917bf397618a");
	//		dojox.uuid.assert(variant == dojox.uuid.variant.DCE);
	// example:
	// "3b12f1df-5232-4804-897e-917bf397618a"
	//                     ^
	//                     |
	//         (variant "10__" == DCE)
	if(!dojox.uuid._ourVariantLookupTable){
		var variant = dojox.uuid.variant;
		var lookupTable = [];

		lookupTable[0x0] = variant.NCS;       // 0000
		lookupTable[0x1] = variant.NCS;       // 0001
		lookupTable[0x2] = variant.NCS;       // 0010
		lookupTable[0x3] = variant.NCS;       // 0011

		lookupTable[0x4] = variant.NCS;       // 0100
		lookupTable[0x5] = variant.NCS;       // 0101
		lookupTable[0x6] = variant.NCS;       // 0110
		lookupTable[0x7] = variant.NCS;       // 0111

		lookupTable[0x8] = variant.DCE;       // 1000
		lookupTable[0x9] = variant.DCE;       // 1001
		lookupTable[0xA] = variant.DCE;       // 1010
		lookupTable[0xB] = variant.DCE;       // 1011

		lookupTable[0xC] = variant.MICROSOFT; // 1100
		lookupTable[0xD] = variant.MICROSOFT; // 1101
		lookupTable[0xE] = variant.UNKNOWN;   // 1110
		lookupTable[0xF] = variant.UNKNOWN;   // 1111
		
		dojox.uuid._ourVariantLookupTable = lookupTable;
	}

	uuidString = uuidString.toString();
	var variantCharacter = uuidString.charAt(19);
	var HEX_RADIX = 16;
	var variantNumber = parseInt(variantCharacter, HEX_RADIX);
	dojox.uuid.assert((variantNumber >= 0) && (variantNumber <= 16));
	return dojox.uuid._ourVariantLookupTable[variantNumber]; // dojox.uuid.variant
};

dojox.uuid.getVersion = function(/*String*/ uuidString){
	// summary:
	//		Returns a version number that indicates what type of UUID this is.
	//		Returns one of the enumerated dojox.uuid.version values.
	// example:
	//		var version = dojox.uuid.getVersion("b4308fb0-86cd-11da-a72b-0800200c9a66");
	//		dojox.uuid.assert(version == dojox.uuid.version.TIME_BASED);
	// exceptions:
	//		Throws an Error if this is not a DCE Variant UUID.
	var errorMessage = "dojox.uuid.getVersion() was not passed a DCE Variant UUID.";
	dojox.uuid.assert(dojox.uuid.getVariant(uuidString) == dojox.uuid.variant.DCE, errorMessage);
	uuidString = uuidString.toString();
	
		// "b4308fb0-86cd-11da-a72b-0800200c9a66"
		//                ^
		//                |
		//       (version 1 == TIME_BASED)
	var versionCharacter = uuidString.charAt(14);
	var HEX_RADIX = 16;
	var versionNumber = parseInt(versionCharacter, HEX_RADIX);
	return versionNumber; // dojox.uuid.version
};

dojox.uuid.getNode = function(/*String*/ uuidString){
	// summary:
	//		If this is a version 1 UUID (a time-based UUID), getNode() returns a
	//		12-character string with the "node" or "pseudonode" portion of the UUID,
	//		which is the rightmost 12 characters.
	// exceptions:
	//		Throws an Error if this is not a version 1 UUID.
	var errorMessage = "dojox.uuid.getNode() was not passed a TIME_BASED UUID.";
	dojox.uuid.assert(dojox.uuid.getVersion(uuidString) == dojox.uuid.version.TIME_BASED, errorMessage);

	uuidString = uuidString.toString();
	var arrayOfStrings = uuidString.split('-');
	var nodeString = arrayOfStrings[4];
	return nodeString; // String (a 12-character string, which will look something like "917bf397618a")
};

dojox.uuid.getTimestamp = function(/*String*/ uuidString, /*String?*/ returnType){
	// summary:
	//		If this is a version 1 UUID (a time-based UUID), this method returns
	//		the timestamp value encoded in the UUID.  The caller can ask for the
	//		timestamp to be returned either as a JavaScript Date object or as a
	//		15-character string of hex digits.
	// returnType: Any of these five values: "string", String, "hex", "date", Date
	// returns:
	//		Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.
	// examples:
	//		var uuidString = "b4308fb0-86cd-11da-a72b-0800200c9a66";
	//		var date, string, hexString;
	//		date   = dojox.uuid.getTimestamp(uuidString);         // returns a JavaScript Date
	//		date   = dojox.uuid.getTimestamp(uuidString, Date);     //
	//		string = dojox.uuid.getTimestamp(uuidString, String);   // "Mon, 16 Jan 2006 20:21:41 GMT"
	//		hexString = dojox.uuid.getTimestamp(uuidString, "hex"); // "1da86cdb4308fb0"
	// exceptions:
	//		Throws an Error if this is not a version 1 UUID.
	var errorMessage = "dojox.uuid.getTimestamp() was not passed a TIME_BASED UUID.";
	dojox.uuid.assert(dojox.uuid.getVersion(uuidString) == dojox.uuid.version.TIME_BASED, errorMessage);
	
	uuidString = uuidString.toString();
	if(!returnType){returnType = null};
	switch(returnType){
		case "string":
		case String:
			return dojox.uuid.getTimestamp(uuidString, Date).toUTCString(); // String (e.g. "Mon, 16 Jan 2006 20:21:41 GMT")
			break;
		case "hex":
			// Return a 15-character string of hex digits containing the
			// timestamp for this UUID, with the high-order bits first.
			var arrayOfStrings = uuidString.split('-');
			var hexTimeLow = arrayOfStrings[0];
			var hexTimeMid = arrayOfStrings[1];
			var hexTimeHigh = arrayOfStrings[2];
		
			// Chop off the leading "1" character, which is the UUID
			// version number for time-based UUIDs.
			hexTimeHigh = hexTimeHigh.slice(1);
		
			var timestampAsHexString = hexTimeHigh + hexTimeMid + hexTimeLow;
			dojox.uuid.assert(timestampAsHexString.length == 15);
			return timestampAsHexString; // String (e.g. "1da86cdb4308fb0")
			break;
		case null: // no returnType was specified, so default to Date
		case "date":
		case Date:
			// Return a JavaScript Date object.
			var GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;
			var HEX_RADIX = 16;
		
			var arrayOfParts = uuidString.split('-');
			var timeLow = parseInt(arrayOfParts[0], HEX_RADIX);
			var timeMid = parseInt(arrayOfParts[1], HEX_RADIX);
			var timeHigh = parseInt(arrayOfParts[2], HEX_RADIX);
			var hundredNanosecondIntervalsSince1582 = timeHigh & 0x0FFF;
			hundredNanosecondIntervalsSince1582 <<= 16;
			hundredNanosecondIntervalsSince1582 += timeMid;
			// What we really want to do next is shift left 32 bits, but the
			// result will be too big to fit in an int, so we'll multiply by 2^32,
			// and the result will be a floating point approximation.
			hundredNanosecondIntervalsSince1582 *= 0x100000000;
			hundredNanosecondIntervalsSince1582 += timeLow;
			var millisecondsSince1582 = hundredNanosecondIntervalsSince1582 / 10000;
		
			// Again, this will be a floating point approximation.
			// We can make things exact later if we need to.
			var secondsPerHour = 60 * 60;
			var hoursBetween1582and1970 = GREGORIAN_CHANGE_OFFSET_IN_HOURS;
			var secondsBetween1582and1970 = hoursBetween1582and1970 * secondsPerHour;
			var millisecondsBetween1582and1970 = secondsBetween1582and1970 * 1000;
			var millisecondsSince1970 = millisecondsSince1582 - millisecondsBetween1582and1970;
		
			var timestampAsDate = new Date(millisecondsSince1970);
			return timestampAsDate; // Date
			break;
		default:
			// we got passed something other than a valid returnType
			dojox.uuid.assert(false, "dojox.uuid.getTimestamp was not passed a valid returnType: " + returnType);
			break;
	}
};

}

if(!dojo._hasResource["dojox.uuid"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.uuid"] = true;
dojo.provide("dojox.uuid");


}

if(!dojo._hasResource["dojox.data.QueryReadStore"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.data.QueryReadStore"] = true;
dojo.provide("dojox.data.QueryReadStore");




dojo.declare("dojox.data.QueryReadStore",
	null,
	{
		//	summary:
		//		This class provides a store that is mainly intended to be used
		//		for loading data dynamically from the server, used i.e. for
		//		retreiving chunks of data from huge data stores on the server (by server-side filtering!).
		//		Upon calling the fetch() method of this store the data are requested from
		//		the server if they are not yet loaded for paging (or cached).
		//
		//		For example used for a combobox which works on lots of data. It
		//		can be used to retreive the data partially upon entering the
		//		letters "ac" it returns only items like "action", "acting", etc.
		//
		// note:
		//		The field name "id" in a query is reserved for looking up data
		//		by id. This is necessary as before the first fetch, the store
		//		has no way of knowing which field the server will declare as
		//		identifier.
		//
		//	example:
		// |	// The parameter "query" contains the data that are sent to the server.
		// |	var store = new dojox.data.QueryReadStore({url:'/search.php'});
		// |	store.fetch({query:{name:'a'}, queryOptions:{ignoreCase:false}});
		//
		// |	// Since "serverQuery" is given, it overrules and those data are
		// |	// sent to the server.
		// |	var store = new dojox.data.QueryReadStore({url:'/search.php'});
		// |	store.fetch({serverQuery:{name:'a'}, queryOptions:{ignoreCase:false}});
		//
		// |	<div dojoType="dojox.data.QueryReadStore"
		// |		jsId="store2"
		// |		url="../tests/stores/QueryReadStore.php"
		// |		requestMethod="post"></div>
		// |	<div dojoType="dojox.grid.data.DojoData"
		// |		jsId="model2"
		// |		store="store2"
		// |		sortFields="[{attribute: 'name', descending: true}]"
		// |		rowsPerPage="30"></div>
		// |	<div dojoType="dojox.Grid" id="grid2"
		// |		model="model2"
		// |		structure="gridLayout"
		// |		style="height:300px; width:800px;"></div>
	
		//
		//	todo:
		//		- there is a bug in the paging, when i set start:2, count:5 after an initial fetch() and doClientPaging:true
		//		  it returns 6 elemetns, though count=5, try it in QueryReadStore.html
		//		- add optional caching
		//		- when the first query searched for "a" and the next for a subset of
		//		  the first, i.e. "ab" then we actually dont need a server request, if
		//		  we have client paging, we just need to filter the items we already have
		//		  that might also be tooo much logic
		
		url:"",
		requestMethod:"get",
		//useCache:false,
		
		// We use the name in the errors, once the name is fixed hardcode it, may be.
		_className:"dojox.data.QueryReadStore",
		
		// This will contain the items we have loaded from the server.
		// The contents of this array is optimized to satisfy all read-api requirements
		// and for using lesser storage, so the keys and their content need some explaination:
		// 		this._items[0].i - the item itself
		//		this._items[0].r - a reference to the store, so we can identify the item
		//			securly. We set this reference right after receiving the item from the
		//			server.
		_items:[],
		
		// Store the last query that triggered xhr request to the server.
		// So we can compare if the request changed and if we shall reload
		// (this also depends on other factors, such as is caching used, etc).
		_lastServerQuery:null,
		
		// Store how many rows we have so that we can pass it to a clientPaging handler
		_numRows:-1,
		
		// Store a hash of the last server request. Actually I introduced this
		// for testing, so I can check if no unnecessary requests were issued for
		// client-side-paging.
		lastRequestHash:null,
		
		// summary:
		//		By default every request for paging is sent to the server.
		doClientPaging:false,
	
		// summary:
		//		By default all the sorting is done serverside before the data is returned
		//		which is the proper place to be doing it for really large datasets.
		doClientSorting:false,
	
		// Items by identify for Identify API
		_itemsByIdentity:null,
		
		// Identifier used
		_identifier:null,
	
		_features: {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true},
	
		_labelAttr: "label",
		
		constructor: function(/* Object */ params){
			dojo.mixin(this,params);
		},
		
		getValue: function(/* item */ item, /* attribute-name-string */ attribute, /* value? */ defaultValue){
			//	According to the Read API comments in getValue() and exception is
			//	thrown when an item is not an item or the attribute not a string!
			this._assertIsItem(item);
			if(!dojo.isString(attribute)){
				throw new Error(this._className+".getValue(): Invalid attribute, string expected!");
			}
			if(!this.hasAttribute(item, attribute)){
				// read api says: return defaultValue "only if *item* does not have a value for *attribute*."
				// Is this the case here? The attribute doesn't exist, but a defaultValue, sounds reasonable.
				if(defaultValue){
					return defaultValue;
				}
			}
			return item.i[attribute];
		},
		
		getValues: function(/* item */ item, /* attribute-name-string */ attribute){
			this._assertIsItem(item);
			var ret = [];
			if(this.hasAttribute(item, attribute)){
				ret.push(item.i[attribute]);
			}
			return ret;
		},
		
		getAttributes: function(/* item */ item){
			this._assertIsItem(item);
			var ret = [];
			for(var i in item.i){
				ret.push(i);
			}
			return ret;
		},
	
		hasAttribute: function(/* item */ item,	/* attribute-name-string */ attribute){
			//	summary:
			//		See dojo.data.api.Read.hasAttribute()
			return this.isItem(item) && typeof item.i[attribute]!="undefined";
		},
		
		containsValue: function(/* item */ item, /* attribute-name-string */ attribute, /* anything */ value){
			var values = this.getValues(item, attribute);
			var len = values.length;
			for(var i=0; i<len; i++){
				if(values[i] == value){
					return true;
				}
			}
			return false;
		},
		
		isItem: function(/* anything */ something){
			// Some basic tests, that are quick and easy to do here.
			// >>> var store = new dojox.data.QueryReadStore({});
			// >>> store.isItem("");
			// false
			//
			// >>> var store = new dojox.data.QueryReadStore({});
			// >>> store.isItem({});
			// false
			//
			// >>> var store = new dojox.data.QueryReadStore({});
			// >>> store.isItem(0);
			// false
			//
			// >>> var store = new dojox.data.QueryReadStore({});
			// >>> store.isItem({name:"me", label:"me too"});
			// false
			//
			if(something){
				return typeof something.r != "undefined" && something.r == this;
			}
			return false;
		},
		
		isItemLoaded: function(/* anything */ something){
			// Currently we dont have any state that tells if an item is loaded or not
			// if the item exists its also loaded.
			// This might change when we start working with refs inside items ...
			return this.isItem(something);
		},
	
		loadItem: function(/* object */ args){
			if(this.isItemLoaded(args.item)){
				return;
			}
			// Actually we have nothing to do here, or at least I dont know what to do here ...
		},
	
		fetch:function(/* Object? */ request){
			//	summary:
			//		See dojo.data.util.simpleFetch.fetch() this is just a copy and I adjusted
			//		only the paging, since it happens on the server if doClientPaging is
			//		false, thx to http://trac.dojotoolkit.org/ticket/4761 reporting this.
			//		Would be nice to be able to use simpleFetch() to reduce copied code,
			//		but i dont know how yet. Ideas please!
			request = request || {};
			if(!request.store){
				request.store = this;
			}
			var self = this;
		
			var _errorHandler = function(errorData, requestObject){
				if(requestObject.onError){
					var scope = requestObject.scope || dojo.global;
					requestObject.onError.call(scope, errorData, requestObject);
				}
			};
		
			var _fetchHandler = function(items, requestObject, numRows){
				var oldAbortFunction = requestObject.abort || null;
				var aborted = false;
				
				var startIndex = requestObject.start?requestObject.start:0;
				if(self.doClientPaging == false){
					// For client paging we dont need no slicing of the result.
					startIndex = 0;
				}
				var endIndex = requestObject.count?(startIndex + requestObject.count):items.length;
		
				requestObject.abort = function(){
					aborted = true;
					if(oldAbortFunction){
						oldAbortFunction.call(requestObject);
					}
				};
		
				var scope = requestObject.scope || dojo.global;
				if(!requestObject.store){
					requestObject.store = self;
				}
				if(requestObject.onBegin){
					requestObject.onBegin.call(scope, numRows, requestObject);
				}
				if(requestObject.sort && self.doClientSorting){
					items.sort(dojo.data.util.sorter.createSortFunction(requestObject.sort, self));
				}
				if(requestObject.onItem){
					for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
						var item = items[i];
						if(!aborted){
							requestObject.onItem.call(scope, item, requestObject);
						}
					}
				}
				if(requestObject.onComplete && !aborted){
					var subset = null;
					if(!requestObject.onItem){
						subset = items.slice(startIndex, endIndex);
					}
					requestObject.onComplete.call(scope, subset, requestObject);
				}
			};
			this._fetchItems(request, _fetchHandler, _errorHandler);
			return request;	// Object
		},
	
		getFeatures: function(){
			return this._features;
		},
	
		close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
			// I have no idea if this is really needed ...
		},
	
		getLabel: function(/* item */ item){
			//	summary:
			//		See dojo.data.api.Read.getLabel()
			if(this._labelAttr && this.isItem(item)){
				return this.getValue(item, this._labelAttr); //String
			}
			return undefined; //undefined
		},
	
		getLabelAttributes: function(/* item */ item){
			//	summary:
			//		See dojo.data.api.Read.getLabelAttributes()
			if(this._labelAttr){
				return [this._labelAttr]; //array
			}
			return null; //null
		},
		
		_xhrFetchHandler: function(data, request, fetchHandler, errorHandler){
			data = this._filterResponse(data);
			if(data.label){
				this._labelAttr = data.label;
			}
			var numRows = data.numRows || -1;

			this._items = [];
			// Store a ref to "this" in each item, so we can simply check if an item
			// really origins form here (idea is from ItemFileReadStore, I just don't know
			// how efficient the real storage use, garbage collection effort, etc. is).
			dojo.forEach(data.items,function(e){
				this._items.push({i:e, r:this});
			},this);
			
			var identifier = data.identifier;
			this._itemsByIdentity = {};
			if(identifier){
				this._identifier = identifier;
				var i;
				for(i = 0; i < this._items.length; ++i){
					var item = this._items[i].i;
					var identity = item[identifier];
					if(!this._itemsByIdentity[identity]){
						this._itemsByIdentity[identity] = item;
					}else{
						throw new Error(this._className+":  The json data as specified by: [" + this.url + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}else{
				this._identifier = Number;
				for(i = 0; i < this._items.length; ++i){
					this._items[i].n = i;
				}
			}
			
			// TODO actually we should do the same as dojo.data.ItemFileReadStore._getItemsFromLoadedData() to sanitize
			// (does it really sanititze them) and store the data optimal. should we? for security reasons???
			numRows = this._numRows = (numRows === -1) ? this._items.length : numRows;
			fetchHandler(this._items, request, numRows);
			this._numRows = numRows;
		},
		
		_fetchItems: function(request, fetchHandler, errorHandler){
			//	summary:
			// 		The request contains the data as defined in the Read-API.
			// 		Additionally there is following keyword "serverQuery".
			//
			//	The *serverQuery* parameter, optional.
			//		This parameter contains the data that will be sent to the server.
			//		If this parameter is not given the parameter "query"'s
			//		data are sent to the server. This is done for some reasons:
			//		- to specify explicitly which data are sent to the server, they
			//		  might also be a mix of what is contained in "query", "queryOptions"
			//		  and the paging parameters "start" and "count" or may be even
			//		  completely different things.
			//		- don't modify the request.query data, so the interface using this
			//		  store can rely on unmodified data, as the combobox dijit currently
			//		  does it, it compares if the query has changed
			//		- request.query is required by the Read-API
			//
			// 		I.e. the following examples might be sent via GET:
			//		  fetch({query:{name:"abc"}, queryOptions:{ignoreCase:true}})
			//		  the URL will become:   /url.php?name=abc
			//
			//		  fetch({serverQuery:{q:"abc", c:true}, query:{name:"abc"}, queryOptions:{ignoreCase:true}})
			//		  the URL will become:   /url.php?q=abc&c=true
			//		  // The serverQuery-parameter has overruled the query-parameter
			//		  // but the query parameter stays untouched, but is not sent to the server!
			//		  // The serverQuery contains more data than the query, so they might differ!
			//
	
			var serverQuery = request.serverQuery || request.query || {};
			//Need to add start and count
			if(!this.doClientPaging){
				serverQuery.start = request.start || 0;
				// Count might not be sent if not given.
				if(request.count){
					serverQuery.count = request.count;
				}
			}
			if(!this.doClientSorting && request.sort){
				var sortInfo = [];
				dojo.forEach(request.sort, function(sort){
					if(sort && sort.attribute){
						sortInfo.push((sort.descending ? "-" : "") + sort.attribute);
					}
				});
				serverQuery.sort = sortInfo.join(',');
			}
			// Add token to request
			
			if (document.getElementById("_token"))
			{
				serverQuery.token = document.getElementById("_token").getAttribute('value');
			}

			// Compare the last query and the current query by simply json-encoding them,
			// so we dont have to do any deep object compare ... is there some dojo.areObjectsEqual()???
			if(this.doClientPaging && this._lastServerQuery !== null &&
				dojo.toJson(serverQuery) == dojo.toJson(this._lastServerQuery)
				){
				this._numRows = (this._numRows === -1) ? this._items.length : this._numRows;
				fetchHandler(this._items, request, this._numRows);
			}else{
				var xhrFunc = this.requestMethod.toLowerCase() == "post" ? dojo.xhrPost : dojo.xhrGet;
				var xhrHandler = xhrFunc({url:this.url, handleAs:"json-comment-optional", content:serverQuery, failOk: true});
				request.abort = function(){
					xhrHandler.cancel();
				};
				xhrHandler.addCallback(dojo.hitch(this, function(data){
					this._xhrFetchHandler(data, request, fetchHandler, errorHandler);
				}));
				xhrHandler.addErrback(function(error){
					errorHandler(error, request);
				});
				// Generate the hash using the time in milliseconds and a randon number.
				// Since Math.randon() returns something like: 0.23453463, we just remove the "0."
				// probably just for esthetic reasons :-).
				this.lastRequestHash = new Date().getTime()+"-"+String(Math.random()).substring(2);
				this._lastServerQuery = dojo.mixin({}, serverQuery);
			}
		},
		
		_filterResponse: function(data){
			//	summary:
			//		If the data from servers needs to be processed before it can be processed by this
			//		store, then this function should be re-implemented in subclass. This default
			//		implementation just return the data unchanged.
			//	data:
			//		The data received from server
			return data;
		},
	
		_assertIsItem: function(/* item */ item){
			//	summary:
			//		It throws an error if item is not valid, so you can call it in every method that needs to
			//		throw an error when item is invalid.
			//	item:
			//		The item to test for being contained by the store.
			if(!this.isItem(item)){
				throw new Error(this._className+": Invalid item argument.");
			}
		},
	
		_assertIsAttribute: function(/* attribute-name-string */ attribute){
			//	summary:
			//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
			//	attribute:
			//		The attribute to test for being contained by the store.
			if(typeof attribute !== "string"){
				throw new Error(this._className+": Invalid attribute argument ('"+attribute+"').");
			}
		},
	
		fetchItemByIdentity: function(/* Object */ keywordArgs){
			//	summary:
			//		See dojo.data.api.Identity.fetchItemByIdentity()
	
			// See if we have already loaded the item with that id
			// In case there hasn't been a fetch yet, _itemsByIdentity is null
			// and thus a fetch will be triggered below.
			if(this._itemsByIdentity){
				var item = this._itemsByIdentity[keywordArgs.identity];
				if(!(item === undefined)){
					if(keywordArgs.onItem){
						var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
						keywordArgs.onItem.call(scope, {i:item, r:this});
					}
					return;
				}
			}
	
			// Otherwise we need to go remote
			// Set up error handler
			var _errorHandler = function(errorData, requestObject){
				var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
				if(keywordArgs.onError){
					keywordArgs.onError.call(scope, errorData);
				}
			};
			
			// Set up fetch handler
			var _fetchHandler = function(items, requestObject){
				var scope = keywordArgs.scope ? keywordArgs.scope : dojo.global;
				try{
					// There is supposed to be only one result
					var item = null;
					if(items && items.length == 1){
						item = items[0];
					}
					
					// If no item was found, item is still null and we'll
					// fire the onItem event with the null here
					if(keywordArgs.onItem){
						keywordArgs.onItem.call(scope, item);
					}
				}catch(error){
					if(keywordArgs.onError){
						keywordArgs.onError.call(scope, error);
					}
				}
			};
			
			// Construct query
			var request = {serverQuery:{id:keywordArgs.identity}};
			
			// Dispatch query
			this._fetchItems(request, _fetchHandler, _errorHandler);
		},
		
		getIdentity: function(/* item */ item){
			//	summary:
			//		See dojo.data.api.Identity.getIdentity()
			var identifier = null;
			if(this._identifier === Number){
				identifier = item.n; // Number
			}else{
				identifier = item.i[this._identifier];
			}
			return identifier;
		},
		
		getIdentityAttributes: function(/* item */ item){
			//	summary:
			//		See dojo.data.api.Identity.getIdentityAttributes()
			return [this._identifier];
		}
	}
);

}

if(!dojo._hasResource["dijit._KeyNavContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._KeyNavContainer"] = true;
dojo.provide("dijit._KeyNavContainer");



dojo.declare("dijit._KeyNavContainer",
	dijit._Container,
	{

		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		To use this mixin, call connectKeyNavHandlers() in
		//		postCreate() and call startupKeyNavChildren() in startup().
		//		It provides normalized keyboard and focusing code for Container
		//		widgets.
/*=====
		// focusedChild: [protected] Widget
		//		The currently focused child widget, or null if there isn't one
		focusedChild: null,
=====*/

		// tabIndex: Integer
		//		Tab index of the container; same as HTML tabIndex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",

		_keyNavCodes: {},

		connectKeyNavHandlers: function(/*dojo.keys[]*/ prevKeyCodes, /*dojo.keys[]*/ nextKeyCodes){
			// summary:
			//		Call in postCreate() to attach the keyboard handlers
			//		to the container.
			// preKeyCodes: dojo.keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: dojo.keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			var keyCodes = (this._keyNavCodes = {});
			var prev = dojo.hitch(this, this.focusPrev);
			var next = dojo.hitch(this, this.focusNext);
			dojo.forEach(prevKeyCodes, function(code){ keyCodes[code] = prev; });
			dojo.forEach(nextKeyCodes, function(code){ keyCodes[code] = next; });
			keyCodes[dojo.keys.HOME] = dojo.hitch(this, "focusFirstChild");
			keyCodes[dojo.keys.END] = dojo.hitch(this, "focusLastChild");
			this.connect(this.domNode, "onkeypress", "_onContainerKeypress");
			this.connect(this.domNode, "onfocus", "_onContainerFocus");
		},

		startupKeyNavChildren: function(){
			// summary:
			//		Call in startup() to set child tabindexes to -1
			// tags:
			//		protected
			dojo.forEach(this.getChildren(), dojo.hitch(this, "_startupChild"));
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Add a child to our _Container
			dijit._KeyNavContainer.superclass.addChild.apply(this, arguments);
			this._startupChild(widget);
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected
			var child = this._getFirstFocusableChild();
			if(child){ // edge case: Menu could be empty or hidden
				this.focusChild(child);
			}
		},

		focusLastChild: function(){
			// summary:
			//		Focus the last focusable child in the container.
			// tags:
			//		protected
			var child = this._getLastFocusableChild();
			if(child){ // edge case: Menu could be empty or hidden
				this.focusChild(child);
			}
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget
			// tags:
			//		protected
			var child = this._getNextFocusableChild(this.focusedChild, 1);
			this.focusChild(child);
		},

		focusPrev: function(){
			// summary:
			//		Focus the last focusable node in the previous widget
			//		(ex: go to the ComboButton icon section rather than button section)
			// tags:
			//		protected
			var child = this._getNextFocusableChild(this.focusedChild, -1);
			this.focusChild(child, true);
		},

		focusChild: function(/*dijit._Widget*/ widget, /*Boolean*/ last){
			// summary:
			//		Focus widget.
			// widget:
			//		Reference to container's child widget
			// last:
			//		If true and if widget has multiple focusable nodes, focus the
			//		last one instead of the first one
			// tags:
			//		protected
			
			if(this.focusedChild && widget !== this.focusedChild){
				this._onChildBlur(this.focusedChild);
			}
			widget.set("tabIndex", this.tabIndex);	// for IE focus outline to appear, must set tabIndex before focs
			widget.focus(last ? "end" : "start");
			this._set("focusedChild", widget);
		},

		_startupChild: function(/*dijit._Widget*/ widget){
			// summary:
			//		Setup for each child widget
			// description:
			//		Sets tabIndex=-1 on each child, so that the tab key will
			//		leave the container rather than visiting each child.
			// tags:
			//		private
			
			widget.set("tabIndex", "-1");
			
			this.connect(widget, "_onFocus", function(){
				// Set valid tabIndex so tabbing away from widget goes to right place, see #10272
				widget.set("tabIndex", this.tabIndex);
			});
			this.connect(widget, "_onBlur", function(){
				widget.set("tabIndex", "-1");
			});
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container gets focus
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child...
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively)

			// focus bubbles on Firefox,
			// so just make sure that focus has really gone to the container
			if(evt.target !== this.domNode){ return; }

			this.focusFirstChild();

			// and then set the container's tabIndex to -1,
			// (don't remove as that breaks Safari 4)
			// so that tab or shift-tab will go to the fields after/before
			// the container, rather than the container itself
			dojo.attr(this.domNode, "tabIndex", "-1");
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and its descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)
			if(this.tabIndex){
				dojo.attr(this.domNode, "tabIndex", this.tabIndex);
			}
			this.inherited(arguments);
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then
			//		it's handled here.
			// tags:
			//		private
			if(evt.ctrlKey || evt.altKey){ return; }
			var func = this._keyNavCodes[evt.charOrCode];
			if(func){
				func();
				dojo.stopEvent(evt);
			}
		},

		_onChildBlur: function(/*dijit._Widget*/ widget){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			// tags:
			//		protected
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused
			return this._getNextFocusableChild(null, 1);	// dijit._Widget
		},

		_getLastFocusableChild: function(){
			// summary:
			//		Returns last child that can be focused
			return this._getNextFocusableChild(null, -1);	// dijit._Widget
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable child, compared
			//		to "child"
			// child: Widget
			//		The current widget
			// dir: Integer
			//		* 1 = after
			//		* -1 = before
			if(child){
				child = this._getSiblingOfChild(child, dir);
			}
			var children = this.getChildren();
			for(var i=0; i < children.length; i++){
				if(!child){
					child = children[(dir>0) ? 0 : (children.length-1)];
				}
				if(child.isFocusable()){
					return child;	// dijit._Widget
				}
				child = this._getSiblingOfChild(child, dir);
			}
			// no focusable child found
			return null;	// dijit._Widget
		}
	}
);

}

if(!dojo._hasResource["dijit.MenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuItem"] = true;
dojo.provide("dijit.MenuItem");






dojo.declare("dijit.MenuItem",
		[dijit._Widget, dijit._Templated, dijit._Contained, dijit._CssStateMixin],
		{
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString: dojo.cache("dijit", "templates/MenuItem.html", "<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitMenuItemIcon\" dojoAttachPoint=\"iconNode\"/>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">\n\t\t<div dojoAttachPoint=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\"/>\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</div>\n\t</td>\n</tr>\n"),

		attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
			label: { node: "containerNode", type: "innerHTML" },
			iconClass: { node: "iconNode", type: "class" }
		}),

		baseClass: "dijitMenuItem",

		// label: String
		//		Menu text
		label: '',

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "",

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination.
		//		Note that although Menu can display accelerator keys there
		//		is no infrastructure to actually catch and execute these
		//		accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this.set('label', source.innerHTML);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			var label = this.id+"_text";
			dojo.attr(this.containerNode, "id", label);
			if(this.accelKeyNode){
				if(!window.isAccessibilityEnabled || (window.isAccessibilityEnabled && this.accelKeyNode && this.accelKeyNode.innerHTML && this.accelKeyNode.innerHTML !== "")) { 
					dojo.attr(this.accelKeyNode, "id", this.id + "_accel");
					label += " " + this.id + "_accel";
				}
			}
			dijit.setWaiState(this.domNode, "labelledby", label);
			dojo.setSelectable(this.domNode, false);
		},

		_onHover: function(){
			// summary:
			//		Handler when mouse is moved onto menu item
			// tags:
			//		protected
			this.getParent().onItemHover(this);
		},

		_onUnhover: function(){
			// summary:
			//		Handler when mouse is moved off of menu item,
			//		possibly to a child menu, or maybe to a sibling
			//		menuitem or somewhere else entirely.
			// tags:
			//		protected

			// if we are unhovering the currently selected item
			// then unselect it
			this.getParent().onItemUnhover(this);

			// When menu is hidden (collapsed) due to clicking a MenuItem and having it execute,
			// FF and IE don't generate an onmouseout event for the MenuItem.
			// So, help out _CssStateMixin in this case.
			this._set("hovering", false);
		},

		_onClick: function(evt){
			// summary:
			//		Internal handler for click events on MenuItem.
			// tags:
			//		private
			this.getParent().onItemClick(this, evt);
			dojo.stopEvent(evt);
		},

		onClick: function(/*Event*/ evt){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				if(dojo.isIE == 8){
					// needed for IE8 which won't scroll TR tags into view on focus yet calling scrollIntoView creates flicker (#10275)
					this.containerNode.focus();
				}
				dijit.focus(this.focusNode);
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_onFocus: function(){
			// summary:
			//		This is called by the focus manager when focus
			//		goes to this MenuItem or a child menu.
			// tags:
			//		protected
			this._setSelected(false);
			this.getParent()._onItemFocus(this);

			this.inherited(arguments);
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			/***
			 * TODO: remove this method and calls to it, when _onBlur() is working for MenuItem.
			 * Currently _onBlur() gets called when focus is moved from the MenuItem to a child menu.
			 * That's not supposed to happen, but the problem is:
			 * In order to allow dijit.popup's getTopPopup() to work,a sub menu's popupParent
			 * points to the parent Menu, bypassing the parent MenuItem... thus the
			 * MenuItem is not in the chain of active widgets and gets a premature call to
			 * _onBlur()
			 */

			dojo.toggleClass(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use set('label', ...) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use set('disabled', bool) instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit.Menu.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
			this.set('disabled', disabled);
		},
		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.

			dijit.setWaiState(this.focusNode, 'disabled', value ? 'true' : 'false');
			this._set("disabled", value);
		},
		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.

			this.accelKeyNode.style.display=value?"":"none";
			this.accelKeyNode.innerHTML=value;
			//have to use colSpan to make it work in IE
			dojo.attr(this.containerNode,'colSpan',value?"1":"2");
			
			this._set("accelKey", value);
		}
	});

}

if(!dojo._hasResource["dijit.PopupMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.PopupMenuItem"] = true;
dojo.provide("dijit.PopupMenuItem");



dojo.declare("dijit.PopupMenuItem",
		dijit.MenuItem,
		{
		_fillContent: function(){
			// summary:
			//		When Menu is declared in markup, this code gets the menu label and
			//		the popup widget from the srcNodeRef.
			// description:
			//		srcNodeRefinnerHTML contains both the menu item text and a popup widget
			//		The first part holds the menu item text and the second part is the popup
			// example:
			// |	<div dojoType="dijit.PopupMenuItem">
			// |		<span>pick me</span>
			// |		<popup> ... </popup>
			// |	</div>
			// tags:
			//		protected

			if(this.srcNodeRef){
				var nodes = dojo.query("*", this.srcNodeRef);
				dijit.PopupMenuItem.superclass._fillContent.call(this, nodes[0]);

				// save pointer to srcNode so we can grab the drop down widget after it's instantiated
				this.dropDownContainer = this.srcNodeRef;
			}
		},

		startup: function(){
			if(this._started){ return; }
			this.inherited(arguments);

			// we didn't copy the dropdown widget from the this.srcNodeRef, so it's in no-man's
			// land now.  move it to dojo.doc.body.
			if(!this.popup){
				var node = dojo.query("[widgetId]", this.dropDownContainer)[0];
				this.popup = dijit.byNode(node);
			}
			dojo.body().appendChild(this.popup.domNode);
			this.popup.startup();

			this.popup.domNode.style.display="none";
			if(this.arrowWrapper){
				dojo.style(this.arrowWrapper, "visibility", "");
			}
			dijit.setWaiState(this.focusNode, "haspopup", "true");
		},

		destroyDescendants: function(){
			if(this.popup){
				// Destroy the popup, unless it's already been destroyed.  This can happen because
				// the popup is a direct child of <body> even though it's logically my child.
				if(!this.popup._destroyed){
					this.popup.destroyRecursive();
				}
				delete this.popup;
			}
			this.inherited(arguments);
		}
	});

}

if(!dojo._hasResource["dijit.CheckedMenuItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.CheckedMenuItem"] = true;
dojo.provide("dijit.CheckedMenuItem");



dojo.declare("dijit.CheckedMenuItem",
		dijit.MenuItem,
		{
		// summary:
		//		A checkbox-like menu item for toggling on and off

		templateString: dojo.cache("dijit", "templates/CheckedMenuItem.html", "<tr class=\"dijitReset dijitMenuItem\" dojoAttachPoint=\"focusNode\" role=\"menuitemcheckbox\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon dijitCheckedMenuItemIcon\" dojoAttachPoint=\"iconNode\"/>\n\t\t<span class=\"dijitCheckedMenuItemIconChar\">&#10003;</span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" dojoAttachPoint=\"containerNode,labelNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" dojoAttachPoint=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">&nbsp;</td>\n</tr>\n"),

		// checked: Boolean
		//		Our checked state
		checked: false,
		_setCheckedAttr: function(/*Boolean*/ checked){
			// summary:
			//		Hook so attr('checked', bool) works.
			//		Sets the class and state for the check box.
			dojo.toggleClass(this.domNode, "dijitCheckedMenuItemChecked", checked);
			dijit.setWaiState(this.domNode, "checked", checked);
			this._set("checked", checked);
		},

		onChange: function(/*Boolean*/ checked){
			// summary:
			//		User defined function to handle check/uncheck events
			// tags:
			//		callback
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Clicking this item just toggles its state
			// tags:
			//		private
			if(!this.disabled){
				this.set("checked", !this.checked);
				this.onChange(this.checked);
			}
			this.inherited(arguments);
		}
	});

}

if(!dojo._hasResource["dijit.MenuSeparator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuSeparator"] = true;
dojo.provide("dijit.MenuSeparator");





dojo.declare("dijit.MenuSeparator",
		[dijit._Widget, dijit._Templated, dijit._Contained],
		{
		// summary:
		//		A line between two menu items

		templateString: dojo.cache("dijit", "templates/MenuSeparator.html", "<tr class=\"dijitMenuSeparator\">\n\t<td class=\"dijitMenuSeparatorIconCell\">\n\t\t<div class=\"dijitMenuSeparatorTop\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n\t<td colspan=\"3\" class=\"dijitMenuSeparatorLabelCell\">\n\t\t<div class=\"dijitMenuSeparatorTop dijitMenuSeparatorLabel\"></div>\n\t\t<div class=\"dijitMenuSeparatorBottom\"></div>\n\t</td>\n</tr>\n"),

		buildRendering: function(){
			this.inherited(arguments);
			dojo.setSelectable(this.domNode, false);
		},

		isFocusable: function(){
			// summary:
			//		Override to always return false
			// tags:
			//		protected

			return false; // Boolean
		}
	});

}

if(!dojo._hasResource["dijit.Menu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Menu"] = true;
dojo.provide("dijit.Menu");










// "dijit/MenuItem", "dijit/PopupMenuItem", "dijit/CheckedMenuItem", "dijit/MenuSeparator" for Back-compat (TODO: remove in 2.0)

dojo.declare("dijit._MenuBase",
	[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
{
	// summary:
	//		Base class for Menu and MenuBar

	// parentMenu: [readonly] Widget
	//		pointer to menu that displayed me
	parentMenu: null,

	// popupDelay: Integer
	//		number of milliseconds before hovering (without clicking) causes the popup to automatically open.
	popupDelay: 500,

	startup: function(){
		if(this._started){ return; }

		dojo.forEach(this.getChildren(), function(child){ child.startup(); });
		this.startupKeyNavChildren();

		this.inherited(arguments);
	},

	onExecute: function(){
		// summary:
		//		Attach point for notification about when a menu item has been executed.
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them, because they are about to execute the onClick handler.   In
		//		general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	onCancel: function(/*Boolean*/ closeAll){
		// summary:
		//		Attach point for notification about when the user cancels the current menu
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them.  In general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	_moveToPopup: function(/*Event*/ evt){
		// summary:
		//		This handles the right arrow key (left arrow key on RTL systems),
		//		which will either open a submenu, or move to the next item in the
		//		ancestor MenuBar
		// tags:
		//		private

		if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
			this.focusedChild._onClick(evt);
		}else{
			var topMenu = this._getTopMenu();
			if(topMenu && topMenu._isMenuBar){
				topMenu.focusNext();
			}
		}
	},

	_onPopupHover: function(/*Event*/ evt){
		// summary:
		//		This handler is called when the mouse moves over the popup.
		// tags:
		//		private

		// if the mouse hovers over a menu popup that is in pending-close state,
		// then stop the close operation.
		// This can't be done in onItemHover since some popup targets don't have MenuItems (e.g. ColorPicker)
		if(this.currentPopup && this.currentPopup._pendingClose_timer){
			var parentMenu = this.currentPopup.parentMenu;
			// highlight the parent menu item pointing to this popup
			if(parentMenu.focusedChild){
				parentMenu.focusedChild._setSelected(false);
			}
			parentMenu.focusedChild = this.currentPopup.from_item;
			parentMenu.focusedChild._setSelected(true);
			// cancel the pending close
			this._stopPendingCloseTimer(this.currentPopup);
		}
	},

	onItemHover: function(/*MenuItem*/ item){
		// summary:
		//		Called when cursor is over a MenuItem.
		// tags:
		//		protected

		// Don't do anything unless user has "activated" the menu by:
		//		1) clicking it
		//		2) opening it from a parent menu (which automatically focuses it)
		if(this.isActive){
			this.focusChild(item);
			if(this.focusedChild.popup && !this.focusedChild.disabled && !this.hover_timer){
				this.hover_timer = setTimeout(dojo.hitch(this, "_openPopup"), this.popupDelay);
			}
		}
		// if the user is mixing mouse and keyboard navigation,
		// then the menu may not be active but a menu item has focus,
		// but it's not the item that the mouse just hovered over.
		// To avoid both keyboard and mouse selections, use the latest.
		if(this.focusedChild){
			this.focusChild(item);
		}
		this._hoveredChild = item;
	},

	_onChildBlur: function(item){
		// summary:
		//		Called when a child MenuItem becomes inactive because focus
		//		has been removed from the MenuItem *and* it's descendant menus.
		// tags:
		//		private
		this._stopPopupTimer();
		item._setSelected(false);
		// Close all popups that are open and descendants of this menu
		var itemPopup = item.popup;
		if(itemPopup){
			this._stopPendingCloseTimer(itemPopup);
			itemPopup._pendingClose_timer = setTimeout(function(){
				itemPopup._pendingClose_timer = null;
				if(itemPopup.parentMenu){
					itemPopup.parentMenu.currentPopup = null;
				}
				dijit.popup.close(itemPopup); // this calls onClose
			}, this.popupDelay);
		}
	},

	onItemUnhover: function(/*MenuItem*/ item){
		// summary:
		//		Callback fires when mouse exits a MenuItem
		// tags:
		//		protected

		if(this.isActive){
			this._stopPopupTimer();
			item._setSelected(false);
		}
		if(this._hoveredChild == item){ this._hoveredChild = null; }
	},

	_stopPopupTimer: function(){
		// summary:
		//		Cancels the popup timer because the user has stop hovering
		//		on the MenuItem, etc.
		// tags:
		//		private
		if(this.hover_timer){
			clearTimeout(this.hover_timer);
			this.hover_timer = null;
		}
	},

	_stopPendingCloseTimer: function(/*dijit._Widget*/ popup){
		// summary:
		//		Cancels the pending-close timer because the close has been preempted
		// tags:
		//		private
		if(popup._pendingClose_timer){
			clearTimeout(popup._pendingClose_timer);
			popup._pendingClose_timer = null;
		}
	},

	_stopFocusTimer: function(){
		// summary:
		//		Cancels the pending-focus timer because the menu was closed before focus occured
		// tags:
		//		private
		if(this._focus_timer){
			clearTimeout(this._focus_timer);
			this._focus_timer = null;
		}
	},

	_getTopMenu: function(){
		// summary:
		//		Returns the top menu in this chain of Menus
		// tags:
		//		private
		for(var top=this; top.parentMenu; top=top.parentMenu);
		return top;
	},

	onItemClick: function(/*dijit._Widget*/ item, /*Event*/ evt){
		// summary:
		//		Handle clicks on an item.
		// tags:
		//		private

		// this can't be done in _onFocus since the _onFocus events occurs asynchronously
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu
			this._markActive();
		}

		this.focusChild(item);

		if(item.disabled){ return false; }

		if(item.popup){
			this._openPopup();
		}else{
			// before calling user defined handler, close hierarchy of menus
			// and restore focus to place it was when menu was opened
			this.onExecute();

			// user defined handler for click
			item.onClick(evt);
		}
	},

	_openPopup: function(){
		// summary:
		//		Open the popup to the side of/underneath the current menu item
		// tags:
		//		protected

		this._stopPopupTimer();
		var from_item = this.focusedChild;
		if(!from_item){ return; } // the focused child lost focus since the timer was started
		var popup = from_item.popup;
		if(popup.isShowingNow){ return; }
		if(this.currentPopup){
			this._stopPendingCloseTimer(this.currentPopup);
			dijit.popup.close(this.currentPopup);
		}
		popup.parentMenu = this;
		popup.from_item = from_item; // helps finding the parent item that should be focused for this popup
		var self = this;
		dijit.popup.open({
			parent: this,
			popup: popup,
			around: from_item.domNode,
			orient: this._orient || (this.isLeftToRight() ?
									{'TR': 'TL', 'TL': 'TR', 'BR': 'BL', 'BL': 'BR'} :
									{'TL': 'TR', 'TR': 'TL', 'BL': 'BR', 'BR': 'BL'}),
			onCancel: function(){ // called when the child menu is canceled
				// set isActive=false (_closeChild vs _cleanUp) so that subsequent hovering will NOT open child menus
				// which seems aligned with the UX of most applications (e.g. notepad, wordpad, paint shop pro)
				self.focusChild(from_item);	// put focus back on my node
				self._cleanUp();			// close the submenu (be sure this is done _after_ focus is moved)
				from_item._setSelected(true); // oops, _cleanUp() deselected the item
				self.focusedChild = from_item;	// and unset focusedChild
			},
			onExecute: dojo.hitch(this, "_cleanUp")
		});

		this.currentPopup = popup;
		// detect mouseovers to handle lazy mouse movements that temporarily focus other menu items
		popup.connect(popup.domNode, "onmouseenter", dojo.hitch(self, "_onPopupHover")); // cleaned up when the popped-up widget is destroyed on close

		if(popup.focus){
			// If user is opening the popup via keyboard (right arrow, or down arrow for MenuBar),
			// if the cursor happens to collide with the popup, it will generate an onmouseover event
			// even though the mouse wasn't moved.   Use a setTimeout() to call popup.focus so that
			// our focus() call overrides the onmouseover event, rather than vice-versa.  (#8742)
			popup._focus_timer = setTimeout(dojo.hitch(popup, function(){
				this._focus_timer = null;
				this.focus();
			}), 0);
		}
	},

	_markActive: function(){
		// summary:
		//              Mark this menu's state as active.
		//		Called when this Menu gets focus from:
		//			1) clicking it (mouse or via space/arrow key)
		//			2) being opened by a parent menu.
		//		This is not called just from mouse hover.
		//		Focusing a menu via TAB does NOT automatically set isActive
		//		since TAB is a navigation operation and not a selection one.
		//		For Windows apps, pressing the ALT key focuses the menubar
		//		menus (similar to TAB navigation) but the menu is not active
		//		(ie no dropdown) until an item is clicked.
		this.isActive = true;
		dojo.replaceClass(this.domNode, "dijitMenuActive", "dijitMenuPassive");
	},

	onOpen: function(/*Event*/ e){
		// summary:
		//		Callback when this menu is opened.
		//		This is called by the popup manager as notification that the menu
		//		was opened.
		// tags:
		//		private

		this.isShowingNow = true;
		this._markActive();
	},

	_markInactive: function(){
		// summary:
		//		Mark this menu's state as inactive.
		this.isActive = false; // don't do this in _onBlur since the state is pending-close until we get here
		dojo.replaceClass(this.domNode, "dijitMenuPassive", "dijitMenuActive");
	},

	onClose: function(){
		// summary:
		//		Callback when this menu is closed.
		//		This is called by the popup manager as notification that the menu
		//		was closed.
		// tags:
		//		private

		this._stopFocusTimer();
		this._markInactive();
		this.isShowingNow = false;
		this.parentMenu = null;
	},

	_closeChild: function(){
		// summary:
		//		Called when submenu is clicked or focus is lost.  Close hierarchy of menus.
		// tags:
		//		private
		this._stopPopupTimer();

		var fromItem = this.focusedChild && this.focusedChild.from_item;

		if(this.currentPopup){
			// If focus is on my child menu then move focus to me,
			// because IE doesn't like it when you display:none a node with focus
			if(dijit._curFocus && dojo.isDescendant(dijit._curFocus, this.currentPopup.domNode)){
				this.focusedChild.focusNode.focus();
			}
			// Close all popups that are open and descendants of this menu
			dijit.popup.close(this.currentPopup);
			this.currentPopup = null;
		}

		if(this.focusedChild){ // unhighlight the focused item
			this.focusedChild._setSelected(false);
			this.focusedChild._onUnhover();
			this.focusedChild = null;
		}
	},

	_onItemFocus: function(/*MenuItem*/ item){
		// summary:
		//		Called when child of this Menu gets focus from:
		//			1) clicking it
		//			2) tabbing into it
		//			3) being opened by a parent menu.
		//		This is not called just from mouse hover.
		if(this._hoveredChild && this._hoveredChild != item){
			this._hoveredChild._onUnhover(); // any previous mouse movement is trumped by focus selection
		}
	},

	_onBlur: function(){
		// summary:
		//		Called when focus is moved away from this Menu and it's submenus.
		// tags:
		//		protected
		this._cleanUp();
		this.inherited(arguments);
	},

	_cleanUp: function(){
		// summary:
		//		Called when the user is done with this menu.  Closes hierarchy of menus.
		// tags:
		//		private

		this._closeChild(); // don't call this.onClose since that's incorrect for MenuBar's that never close
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu doesn't call onClose
			this._markInactive();
		}
	}
});

dojo.declare("dijit.Menu",
	dijit._MenuBase,
	{
	// summary
	//		A context menu you can assign to multiple elements

	// TODO: most of the code in here is just for context menu (right-click menu)
	// support.  In retrospect that should have been a separate class (dijit.ContextMenu).
	// Split them for 2.0

	constructor: function(){
		this._bindings = [];
	},

	templateString: dojo.cache("dijit", "templates/Menu.html", "<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\" dojoAttachEvent=\"onkeypress:_onKeyPress\" cellspacing=\"0\">\n\t<tbody class=\"dijitReset\" dojoAttachPoint=\"containerNode\"></tbody>\n</table>\n"),

	baseClass: "dijitMenu",

	// targetNodeIds: [const] String[]
	//		Array of dom node ids of nodes to attach to.
	//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
	targetNodeIds: [],

	// contextMenuForWindow: [const] Boolean
	//		If true, right clicking anywhere on the window will cause this context menu to open.
	//		If false, must specify targetNodeIds.
	contextMenuForWindow: false,

	// leftClickToOpen: [const] Boolean
	//		If true, menu will open on left click instead of right click, similiar to a file menu.
	leftClickToOpen: false,

	// refocus: Boolean
	// 		When this menu closes, re-focus the element which had focus before it was opened.
	refocus: true,

	postCreate: function(){
		if(this.contextMenuForWindow){
			this.bindDomNode(dojo.body());
		}else{
			// TODO: should have _setTargetNodeIds() method to handle initialization and a possible
			// later set('targetNodeIds', ...) call.   There's also a problem that targetNodeIds[]
			// gets stale after calls to bindDomNode()/unBindDomNode() as it still is just the original list (see #9610)
			dojo.forEach(this.targetNodeIds, this.bindDomNode, this);
		}
		var k = dojo.keys, l = this.isLeftToRight();
		this._openSubMenuKey = l ? k.RIGHT_ARROW : k.LEFT_ARROW;
		this._closeSubMenuKey = l ? k.LEFT_ARROW : k.RIGHT_ARROW;
		this.connectKeyNavHandlers([k.UP_ARROW], [k.DOWN_ARROW]);
	},

	_onKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handle keyboard based menu navigation.
		// tags:
		//		protected

		if(evt.ctrlKey || evt.altKey){ return; }

		switch(evt.charOrCode){
			case this._openSubMenuKey:
				this._moveToPopup(evt);
				dojo.stopEvent(evt);
				break;
			case this._closeSubMenuKey:
				if(this.parentMenu){
					if(this.parentMenu._isMenuBar){
						this.parentMenu.focusPrev();
					}else{
						this.onCancel(false);
					}
				}else{
					dojo.stopEvent(evt);
				}
				break;
		}
	},

	// thanks burstlib!
	_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns the window reference of the passed iframe
		// tags:
		//		private
		var win = dojo.window.get(this._iframeContentDocument(iframe_el)) ||
			// Moz. TODO: is this available when defaultView isn't?
			this._iframeContentDocument(iframe_el)['__parent__'] ||
			(iframe_el.name && dojo.doc.frames[iframe_el.name]) || null;
		return win;	//	Window
	},

	_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns a reference to the document object inside iframe_el
		// tags:
		//		protected
		var doc = iframe_el.contentDocument // W3
			|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
			|| (iframe_el.name && dojo.doc.frames[iframe_el.name] && dojo.doc.frames[iframe_el.name].document)
			|| null;
		return doc;	//	HTMLDocument
	},

	bindDomNode: function(/*String|DomNode*/ node){
		// summary:
		//		Attach menu to given node
		node = dojo.byId(node);

		var cn;	// Connect node

		// Support context menus on iframes.   Rather than binding to the iframe itself we need
		// to bind to the <body> node inside the iframe.
		if(node.tagName.toLowerCase() == "iframe"){
			var iframe = node,
				win = this._iframeContentWindow(iframe);
			cn = dojo.withGlobal(win, dojo.body);
		}else{
			
			// To capture these events at the top level, attach to <html>, not <body>.
			// Otherwise right-click context menu just doesn't work.
			cn = (node == dojo.body() ? dojo.doc.documentElement : node);
		}


		// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
		var binding = {
			node: node,
			iframe: iframe
		};

		// Save info about binding in _bindings[], and make node itself record index(+1) into
		// _bindings[] array.   Prefix w/_dijitMenu to avoid setting an attribute that may
		// start with a number, which fails on FF/safari.
		dojo.attr(node, "_dijitMenu" + this.id, this._bindings.push(binding));

		// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
		// loading yet, in which case we need to wait for the onload event first, and then connect
		// On linux Shift-F10 produces the oncontextmenu event, but on Windows it doesn't, so
		// we need to monitor keyboard events in addition to the oncontextmenu event.
		var doConnects = dojo.hitch(this, function(cn){
			return [
				// TODO: when leftClickToOpen is true then shouldn't space/enter key trigger the menu,
				// rather than shift-F10?
				dojo.connect(cn, this.leftClickToOpen ? "onclick" : "oncontextmenu", this, function(evt){
					// Schedule context menu to be opened unless it's already been scheduled from onkeydown handler
					dojo.stopEvent(evt);
					this._scheduleOpen(evt.target, iframe, {x: evt.pageX, y: evt.pageY});
				}),
				dojo.connect(cn, "onkeydown", this, function(evt){
					if(evt.shiftKey && evt.keyCode == dojo.keys.F10){
						dojo.stopEvent(evt);
						this._scheduleOpen(evt.target, iframe);	// no coords - open near target node
					}
				})
			];
		});
		binding.connects = cn ? doConnects(cn) : [];

		if(iframe){
			// Setup handler to [re]bind to the iframe when the contents are initially loaded,
			// and every time the contents change.
			// Need to do this b/c we are actually binding to the iframe's <body> node.
			// Note: can't use dojo.connect(), see #9609.

			binding.onloadHandler = dojo.hitch(this, function(){
				// want to remove old connections, but IE throws exceptions when trying to
				// access the <body> node because it's already gone, or at least in a state of limbo

				var win = this._iframeContentWindow(iframe);
					cn = dojo.withGlobal(win, dojo.body);
				binding.connects = doConnects(cn);
			});
			if(iframe.addEventListener){
				iframe.addEventListener("load", binding.onloadHandler, false);
			}else{
				iframe.attachEvent("onload", binding.onloadHandler);
			}
		}
	},

	unBindDomNode: function(/*String|DomNode*/ nodeName){
		// summary:
		//		Detach menu from given node

		var node;
		try{
			node = dojo.byId(nodeName);
		}catch(e){
			// On IE the dojo.byId() call will get an exception if the attach point was
			// the <body> node of an <iframe> that has since been reloaded (and thus the
			// <body> node is in a limbo state of destruction.
			return;
		}

		// node["_dijitMenu" + this.id] contains index(+1) into my _bindings[] array
		var attrName = "_dijitMenu" + this.id;
		if(node && dojo.hasAttr(node, attrName)){
			var bid = dojo.attr(node, attrName)-1, b = this._bindings[bid];
			dojo.forEach(b.connects, dojo.disconnect);

			// Remove listener for iframe onload events
			var iframe = b.iframe;
			if(iframe){
				if(iframe.removeEventListener){
					iframe.removeEventListener("load", b.onloadHandler, false);
				}else{
					iframe.detachEvent("onload", b.onloadHandler);
				}
			}

			dojo.removeAttr(node, attrName);
			delete this._bindings[bid];
		}
	},

	_scheduleOpen: function(/*DomNode?*/ target, /*DomNode?*/ iframe, /*Object?*/ coords){
		// summary:
		//		Set timer to display myself.  Using a timer rather than displaying immediately solves
		//		two problems:
		//
		//		1. IE: without the delay, focus work in "open" causes the system
		//		context menu to appear in spite of stopEvent.
		//
		//		2. Avoid double-shows on linux, where shift-F10 generates an oncontextmenu event
		//		even after a dojo.stopEvent(e).  (Shift-F10 on windows doesn't generate the
		//		oncontextmenu event.)

		if(!this._openTimer){
			this._openTimer = setTimeout(dojo.hitch(this, function(){
				delete this._openTimer;
				this._openMyself({
					target: target,
					iframe: iframe,
					coords: coords
				});
			}), 1);
		}
	},

	_openMyself: function(args){
		// summary:
		//		Internal function for opening myself when the user does a right-click or something similar.
		// args:
		//		This is an Object containing:
		//		* target:
		//			The node that is being clicked
		//		* iframe:
		//			If an <iframe> is being clicked, iframe points to that iframe
		//		* coords:
		//			Put menu at specified x/y position in viewport, or if iframe is
		//			specified, then relative to iframe.
		//
		//		_openMyself() formerly took the event object, and since various code references
		//		evt.target (after connecting to _openMyself()), using an Object for parameters
		//		(so that old code still works).

		var target = args.target,
			iframe = args.iframe,
			coords = args.coords;

		// Get coordinates to open menu, either at specified (mouse) position or (if triggered via keyboard)
		// then near the node the menu is assigned to.
		if(coords){
			if(iframe){
				// Specified coordinates are on <body> node of an <iframe>, convert to match main document
				var od = target.ownerDocument,
					ifc = dojo.position(iframe, true),
					win = this._iframeContentWindow(iframe),
					scroll = dojo.withGlobal(win, "_docScroll", dojo);
	
				var cs = dojo.getComputedStyle(iframe),
					tp = dojo._toPixelValue,
					left = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingLeft)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderLeftWidth) : 0),
					top = (dojo.isIE && dojo.isQuirks ? 0 : tp(iframe, cs.paddingTop)) + (dojo.isIE && dojo.isQuirks ? tp(iframe, cs.borderTopWidth) : 0);

				coords.x += ifc.x + left - scroll.x;
				coords.y += ifc.y + top - scroll.y;
			}
		}else{
			coords = dojo.position(target, true);
			coords.x += 10;
			coords.y += 10;
		}

		var self=this;
		var savedFocus = dijit.getFocus(this);
		function closeAndRestoreFocus(){
			// user has clicked on a menu or popup
			if(self.refocus){
				dijit.focus(savedFocus);
			}
			dijit.popup.close(self);
		}
		dijit.popup.open({
			popup: this,
			x: coords.x,
			y: coords.y,
			onExecute: closeAndRestoreFocus,
			onCancel: closeAndRestoreFocus,
			orient: this.isLeftToRight() ? 'L' : 'R'
		});
		this.focus();

		this._onBlur = function(){
			this.inherited('_onBlur', arguments);
			// Usually the parent closes the child widget but if this is a context
			// menu then there is no parent
			dijit.popup.close(this);
			// don't try to restore focus; user has clicked another part of the screen
			// and set focus there
		};
	},

	uninitialize: function(){
 		dojo.forEach(this._bindings, function(b){ if(b){ this.unBindDomNode(b.node); } }, this);
 		this.inherited(arguments);
	}
}
);

}

if(!dojo._hasResource["dojox.html.metrics"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.html.metrics"] = true;
dojo.provide("dojox.html.metrics");

(function(){
	var dhm = dojox.html.metrics;

	//	derived from Morris John's emResized measurer
	dhm.getFontMeasurements = function(){
		//	summary
		//	Returns an object that has pixel equivilents of standard font size values.
		var heights = {
			'1em':0, '1ex':0, '100%':0, '12pt':0, '16px':0, 'xx-small':0, 'x-small':0,
			'small':0, 'medium':0, 'large':0, 'x-large':0, 'xx-large':0
		};
	
		if(dojo.isIE){
			//	we do a font-size fix if and only if one isn't applied already.
			//	NOTE: If someone set the fontSize on the HTML Element, this will kill it.
			dojo.doc.documentElement.style.fontSize="100%";
		}
	
		//	set up the measuring node.
		var div=dojo.doc.createElement("div");
		var ds = div.style;
		ds.position="absolute";
		ds.left="-100px";
		ds.top="0";
		ds.width="30px";
		ds.height="1000em";
		ds.borderWidth="0";
		ds.margin="0";
		ds.padding="0";
		ds.outline="0";
		ds.lineHeight="1";
		ds.overflow="hidden";
		dojo.body().appendChild(div);
	
		//	do the measurements.
		for(var p in heights){
			ds.fontSize = p;
			heights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;
		}
		
		dojo.body().removeChild(div);
		div = null;
		return heights; 	//	object
	};

	var fontMeasurements = null;
	
	dhm.getCachedFontMeasurements = function(recalculate){
		if(recalculate || !fontMeasurements){
			fontMeasurements = dhm.getFontMeasurements();
		}
		return fontMeasurements;
	};

	var measuringNode = null, empty = {};
	dhm.getTextBox = function(/* String */ text, /* Object */ style, /* String? */ className){
		var m, s;
		if(!measuringNode){
			m = measuringNode = dojo.doc.createElement("div");
			// Container that we can set contraints on so that it doesn't
			// trigger a scrollbar.
			var c = dojo.doc.createElement("div");
			c.appendChild(m);
			s = c.style;
			s.overflow='scroll';
			s.position = "absolute";
			s.left = "0px";
			s.top = "-10000px";
			s.width = "1px";
			s.height = "1px";
			s.visibility = "hidden";
			s.borderWidth = "0";
			s.margin = "0";
			s.padding = "0";
			s.outline = "0";
			dojo.body().appendChild(c);
		}else{
			m = measuringNode;
		}
		// reset styles
		m.className = "";
		s = m.style;
		s.borderWidth = "0";
		s.margin = "0";
		s.padding = "0";
		s.outline = "0";
		// set new style
		if(arguments.length > 1 && style){
			for(var i in style){
				if(i in empty){ continue; }
				s[i] = style[i];
			}
		}
		// set classes
		if(arguments.length > 2 && className){
			m.className = className;
		}
		// take a measure
		m.innerHTML = text;
		var box = dojo.position(m);
		// position doesn't report right (reports 1, since parent is 1)
		// So we have to look at the scrollWidth to get the real width
		// Height is right.
		box.w = m.parentNode.scrollWidth;
		return box;
	};

	//	determine the scrollbar sizes on load.
	var scroll={ w:16, h:16 };
	dhm.getScrollbar=function(){ return { w:scroll.w, h:scroll.h }; };

	dhm._fontResizeNode = null;

	dhm.initOnFontResize = function(interval){
		var f = dhm._fontResizeNode = dojo.doc.createElement("iframe");
		var fs = f.style;
		fs.position = "absolute";
		fs.width = "5em";
		fs.height = "10em";
		fs.top = "-10000px";
		if(dojo.isIE){
			f.onreadystatechange = function(){
				if(f.contentWindow.document.readyState == "complete"){
					f.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
				}
			};
		}else{
			f.onload = function(){
				f.contentWindow.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
			};
		}
		//The script tag is to work around a known firebug race condition.  See comments in bug #9046
		f.setAttribute("src", "javascript:'<html><head><script>if(\"loadFirebugConsole\" in window){window.loadFirebugConsole();}</script></head><body></body></html>'");
		dojo.body().appendChild(f);
		dhm.initOnFontResize = function(){};
	};

	dhm.onFontResize = function(){};
	dhm._fontresize = function(){
		dhm.onFontResize();
	}

	dojo.addOnUnload(function(){
		// destroy our font resize iframe if we have one
		var f = dhm._fontResizeNode;
		if(f){
			if(dojo.isIE && f.onresize){
				f.onresize = null;
			}else if(f.contentWindow && f.contentWindow.onresize){
				f.contentWindow.onresize = null;
			}
			dhm._fontResizeNode = null;
		}
	});

	dojo.addOnLoad(function(){
		// getScrollbar metrics node
		try{
			var n=dojo.doc.createElement("div");
			n.style.cssText = "top:0;left:0;width:100px;height:100px;overflow:scroll;position:absolute;visibility:hidden;";
			dojo.body().appendChild(n);
			scroll.w = n.offsetWidth - n.clientWidth;
			scroll.h = n.offsetHeight - n.clientHeight;
			dojo.body().removeChild(n);
			//console.log("Scroll bar dimensions: ", scroll);
			delete n;
		}catch(e){}

		// text size poll setup
		if("fontSizeWatch" in dojo.config && !!dojo.config.fontSizeWatch){
			dhm.initOnFontResize();
		}
	});
})();

}

if(!dojo._hasResource["dojox.grid.util"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.util"] = true;
dojo.provide("dojox.grid.util");

// summary: grid utility library
(function(){
	var dgu = dojox.grid.util;

	dgu.na = '...';
	dgu.rowIndexTag = "gridRowIndex";
	dgu.gridViewTag = "gridView";


	dgu.fire = function(ob, ev, args){
		var fn = ob && ev && ob[ev];
		return fn && (args ? fn.apply(ob, args) : ob[ev]());
	};
	
	dgu.setStyleHeightPx = function(inElement, inHeight){
		if(inHeight >= 0){
			var s = inElement.style;
			var v = inHeight + 'px';
			if(inElement && s['height'] != v){
				s['height'] = v;
			}
		}
	};
	
	dgu.mouseEvents = [ 'mouseover', 'mouseout', /*'mousemove',*/ 'mousedown', 'mouseup', 'click', 'dblclick', 'contextmenu' ];

	dgu.keyEvents = [ 'keyup', 'keydown', 'keypress' ];

	dgu.funnelEvents = function(inNode, inObject, inMethod, inEvents){
		var evts = (inEvents ? inEvents : dgu.mouseEvents.concat(dgu.keyEvents));
		for (var i=0, l=evts.length; i<l; i++){
			inObject.connect(inNode, 'on' + evts[i], inMethod);
		}
	};

	dgu.removeNode = function(inNode){
		inNode = dojo.byId(inNode);
		inNode && inNode.parentNode && inNode.parentNode.removeChild(inNode);
		return inNode;
	};
	
	dgu.arrayCompare = function(inA, inB){
		for(var i=0,l=inA.length; i<l; i++){
			if(inA[i] != inB[i]){return false;}
		}
		return (inA.length == inB.length);
	};
	
	dgu.arrayInsert = function(inArray, inIndex, inValue){
		if(inArray.length <= inIndex){
			inArray[inIndex] = inValue;
		}else{
			inArray.splice(inIndex, 0, inValue);
		}
	};
	
	dgu.arrayRemove = function(inArray, inIndex){
		inArray.splice(inIndex, 1);
	};
	
	dgu.arraySwap = function(inArray, inI, inJ){
		var cache = inArray[inI];
		inArray[inI] = inArray[inJ];
		inArray[inJ] = cache;
	};
})();

}

if(!dojo._hasResource["dojox.grid._Scroller"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._Scroller"] = true;
dojo.provide("dojox.grid._Scroller");

(function(){
	var indexInParent = function(inNode){
		var i=0, n, p=inNode.parentNode;
		while((n = p.childNodes[i++])){
			if(n == inNode){
				return i - 1;
			}
		}
		return -1;
	};
	
	var cleanNode = function(inNode){
		if(!inNode){
			return;
		}
		var filter = function(inW){
			return inW.domNode && dojo.isDescendant(inW.domNode, inNode, true);
		};
		var ws = dijit.registry.filter(filter);
		for(var i=0, w; (w=ws[i]); i++){
			w.destroy();
		}
		delete ws;
	};

	var getTagName = function(inNodeOrId){
		var node = dojo.byId(inNodeOrId);
		return (node && node.tagName ? node.tagName.toLowerCase() : '');
	};
	
	var nodeKids = function(inNode, inTag){
		var result = [];
		var i=0, n;
		while((n = inNode.childNodes[i])){
			i++;
			if(getTagName(n) == inTag){
				result.push(n);
			}
		}
		return result;
	};
	
	var divkids = function(inNode){
		return nodeKids(inNode, 'div');
	};

	dojo.declare("dojox.grid._Scroller", null, {
		constructor: function(inContentNodes){
			this.setContentNodes(inContentNodes);
			this.pageHeights = [];
			this.pageNodes = [];
			this.stack = [];
		},
		// specified
		rowCount: 0, // total number of rows to manage
		defaultRowHeight: 32, // default height of a row
		keepRows: 100, // maximum number of rows that should exist at one time
		contentNode: null, // node to contain pages
		scrollboxNode: null, // node that controls scrolling
		// calculated
		defaultPageHeight: 0, // default height of a page
		keepPages: 10, // maximum number of pages that should exists at one time
		pageCount: 0,
		windowHeight: 0,
		firstVisibleRow: 0,
		lastVisibleRow: 0,
		averageRowHeight: 0, // the average height of a row
		// private
		page: 0,
		pageTop: 0,
		// init
		init: function(inRowCount, inKeepRows, inRowsPerPage){
			switch(arguments.length){
				case 3: this.rowsPerPage = inRowsPerPage;
				case 2: this.keepRows = inKeepRows;
				case 1: this.rowCount = inRowCount;
				default: break;
			}
			this.defaultPageHeight = this.defaultRowHeight * this.rowsPerPage;
			this.pageCount = this._getPageCount(this.rowCount, this.rowsPerPage);
			this.setKeepInfo(this.keepRows);
			this.invalidate();
			if(this.scrollboxNode){
				this.scrollboxNode.scrollTop = 0;
				this.scroll(0);
				this.scrollboxNode.onscroll = dojo.hitch(this, 'onscroll');
			}
		},
		_getPageCount: function(rowCount, rowsPerPage){
			return rowCount ? (Math.ceil(rowCount / rowsPerPage) || 1) : 0;
		},
		destroy: function(){
			this.invalidateNodes();
			delete this.contentNodes;
			delete this.contentNode;
			delete this.scrollboxNode;
		},
		setKeepInfo: function(inKeepRows){
			this.keepRows = inKeepRows;
			this.keepPages = !this.keepRows ? this.keepPages : Math.max(Math.ceil(this.keepRows / this.rowsPerPage), 2);
		},
		// nodes
		setContentNodes: function(inNodes){
			this.contentNodes = inNodes;
			this.colCount = (this.contentNodes ? this.contentNodes.length : 0);
			this.pageNodes = [];
			for(var i=0; i<this.colCount; i++){
				this.pageNodes[i] = [];
			}
		},
		getDefaultNodes: function(){
			return this.pageNodes[0] || [];
		},
		// updating
		invalidate: function(){
			this._invalidating = true;
			this.invalidateNodes();
			this.pageHeights = [];
			this.height = (this.pageCount ? (this.pageCount - 1)* this.defaultPageHeight + this.calcLastPageHeight() : 0);
			this.resize();
			this._invalidating = false;
		},
		updateRowCount: function(inRowCount){
			this.invalidateNodes();
			this.rowCount = inRowCount;
			// update page count, adjust document height
			var oldPageCount = this.pageCount;
			if(oldPageCount === 0){
				//We want to have at least 1px in height to keep scroller.  Otherwise with an
				//empty grid you can't scroll to see the header.
				this.height = 1;
			}
			this.pageCount = this._getPageCount(this.rowCount, this.rowsPerPage);
			if(this.pageCount < oldPageCount){
				for(var i=oldPageCount-1; i>=this.pageCount; i--){
					this.height -= this.getPageHeight(i);
					delete this.pageHeights[i];
				}
			}else if(this.pageCount > oldPageCount){
				this.height += this.defaultPageHeight * (this.pageCount - oldPageCount - 1) + this.calcLastPageHeight();
			}
			this.resize();
		},
		// implementation for page manager
		pageExists: function(inPageIndex){
			return Boolean(this.getDefaultPageNode(inPageIndex));
		},
		measurePage: function(inPageIndex){
			if(this.grid.rowHeight){
				var height = this.grid.rowHeight + 1;
				return ((inPageIndex + 1) * this.rowsPerPage > this.rowCount ?
					this.rowCount - inPageIndex * this.rowsPerPage :
					this.rowsPerPage) * height;
					 
			}
			var n = this.getDefaultPageNode(inPageIndex);
			return (n && n.innerHTML) ? n.offsetHeight : undefined;
		},
		positionPage: function(inPageIndex, inPos){
			for(var i=0; i<this.colCount; i++){
				this.pageNodes[i][inPageIndex].style.top = inPos + 'px';
			}
		},
		repositionPages: function(inPageIndex){
			var nodes = this.getDefaultNodes();
			var last = 0;

			for(var i=0; i<this.stack.length; i++){
				last = Math.max(this.stack[i], last);
			}
			//
			var n = nodes[inPageIndex];
			var y = (n ? this.getPageNodePosition(n) + this.getPageHeight(inPageIndex) : 0);
			for(var p=inPageIndex+1; p<=last; p++){
				n = nodes[p];
				if(n){
					if(this.getPageNodePosition(n) == y){
						return;
					}
					this.positionPage(p, y);
				}
				y += this.getPageHeight(p);
			}
		},
		installPage: function(inPageIndex){
			for(var i=0; i<this.colCount; i++){
				this.contentNodes[i].appendChild(this.pageNodes[i][inPageIndex]);
			}
		},
		preparePage: function(inPageIndex, inReuseNode){
			var p = (inReuseNode ? this.popPage() : null);
			for(var i=0; i<this.colCount; i++){
				var nodes = this.pageNodes[i];
				var new_p = (p === null ? this.createPageNode() : this.invalidatePageNode(p, nodes));
				new_p.pageIndex = inPageIndex;
				nodes[inPageIndex] = new_p;
			}
		},
		// rendering implementation
		renderPage: function(inPageIndex){
			var nodes = [];
			var i, j;
			for(i=0; i<this.colCount; i++){
				nodes[i] = this.pageNodes[i][inPageIndex];
			}
			for(i=0, j=inPageIndex*this.rowsPerPage; (i<this.rowsPerPage)&&(j<this.rowCount); i++, j++){
				this.renderRow(j, nodes);
			}
		},
		removePage: function(inPageIndex){
			for(var i=0, j=inPageIndex*this.rowsPerPage; i<this.rowsPerPage; i++, j++){
				this.removeRow(j);
			}
		},
		destroyPage: function(inPageIndex){
			for(var i=0; i<this.colCount; i++){
				var n = this.invalidatePageNode(inPageIndex, this.pageNodes[i]);
				if(n){
					dojo.destroy(n);
				}
			}
		},
		pacify: function(inShouldPacify){
		},
		// pacification
		pacifying: false,
		pacifyTicks: 200,
		setPacifying: function(inPacifying){
			if(this.pacifying != inPacifying){
				this.pacifying = inPacifying;
				this.pacify(this.pacifying);
			}
		},
		startPacify: function(){
			this.startPacifyTicks = new Date().getTime();
		},
		doPacify: function(){
			var result = (new Date().getTime() - this.startPacifyTicks) > this.pacifyTicks;
			this.setPacifying(true);
			this.startPacify();
			return result;
		},
		endPacify: function(){
			this.setPacifying(false);
		},
		// default sizing implementation
		resize: function(){
			if(this.scrollboxNode){
				this.windowHeight = this.scrollboxNode.clientHeight;
			}
			for(var i=0; i<this.colCount; i++){
				//We want to have 1px in height min to keep scroller.  Otherwise can't scroll
				//and see header in empty grid.
				dojox.grid.util.setStyleHeightPx(this.contentNodes[i], Math.max(1,this.height));
			}
			
			// Calculate the average row height and update the defaults (row and page).
			var needPage = (!this._invalidating);
			if(!needPage){
				var ah = this.grid.get("autoHeight");
				if(typeof ah == "number" && ah <= Math.min(this.rowsPerPage, this.rowCount)){
					needPage = true;
				}
			}
			if(needPage){
				this.needPage(this.page, this.pageTop);
			}
			var rowsOnPage = (this.page < this.pageCount - 1) ? this.rowsPerPage : ((this.rowCount % this.rowsPerPage) || this.rowsPerPage);
			var pageHeight = this.getPageHeight(this.page);
			this.averageRowHeight = (pageHeight > 0 && rowsOnPage > 0) ? (pageHeight / rowsOnPage) : 0;
		},
		calcLastPageHeight: function(){
			if(!this.pageCount){
				return 0;
			}
			var lastPage = this.pageCount - 1;
			var lastPageHeight = ((this.rowCount % this.rowsPerPage)||(this.rowsPerPage)) * this.defaultRowHeight;
			this.pageHeights[lastPage] = lastPageHeight;
			return lastPageHeight;
		},
		updateContentHeight: function(inDh){
			this.height += inDh;
			this.resize();
		},
		updatePageHeight: function(inPageIndex, fromBuild, fromAsynRendering){
			if(this.pageExists(inPageIndex)){
				var oh = this.getPageHeight(inPageIndex);
				var h = (this.measurePage(inPageIndex));
				if(h === undefined){
					h = oh;
				}
				this.pageHeights[inPageIndex] = h;
				if(oh != h){
					this.updateContentHeight(h - oh);
					var ah = this.grid.get("autoHeight");
					if((typeof ah == "number" && ah > this.rowCount)||(ah === true && !fromBuild)){
						if(!fromAsynRendering){
							this.grid.sizeChange();
						}else{//fix #11101 by using fromAsynRendering to avoid deadlock
							var ns = this.grid.viewsNode.style;
							ns.height = parseInt(ns.height) + h - oh + 'px';
							this.repositionPages(inPageIndex);
						}
					}else{
						this.repositionPages(inPageIndex);
					}
				}
				return h;
			}
			return 0;
		},
		rowHeightChanged: function(inRowIndex, fromAsynRendering){
			this.updatePageHeight(Math.floor(inRowIndex / this.rowsPerPage), false, fromAsynRendering);
		},
		// scroller core
		invalidateNodes: function(){
			while(this.stack.length){
				this.destroyPage(this.popPage());
			}
		},
		createPageNode: function(){
			var p = document.createElement('div');
			dojo.attr(p,"role","presentation");
			p.style.position = 'absolute';
			//p.style.width = '100%';
			p.style[dojo._isBodyLtr() ? "left" : "right"] = '0';
			return p;
		},
		getPageHeight: function(inPageIndex){
			var ph = this.pageHeights[inPageIndex];
			return (ph !== undefined ? ph : this.defaultPageHeight);
		},
		// FIXME: this is not a stack, it's a FIFO list
		pushPage: function(inPageIndex){
			return this.stack.push(inPageIndex);
		},
		popPage: function(){
			return this.stack.shift();
		},
		findPage: function(inTop){
			var i = 0, h = 0;
			for(var ph = 0; i<this.pageCount; i++, h += ph){
				ph = this.getPageHeight(i);
				if(h + ph >= inTop){
					break;
				}
			}
			this.page = i;
			this.pageTop = h;
		},
		buildPage: function(inPageIndex, inReuseNode, inPos){
			this.preparePage(inPageIndex, inReuseNode);
			this.positionPage(inPageIndex, inPos);
			// order of operations is key below
			this.installPage(inPageIndex);
			this.renderPage(inPageIndex);
			// order of operations is key above
			this.pushPage(inPageIndex);
		},
		needPage: function(inPageIndex, inPos){
			var h = this.getPageHeight(inPageIndex), oh = h;
			if(!this.pageExists(inPageIndex)){
				this.buildPage(inPageIndex, (!this.grid._autoHeight/*fix #10543*/ && this.keepPages&&(this.stack.length >= this.keepPages)), inPos);
				h = this.updatePageHeight(inPageIndex, true);
			}else{
				this.positionPage(inPageIndex, inPos);
			}
			return h;
		},
		onscroll: function(){
			this.scroll(this.scrollboxNode.scrollTop);
		},
		scroll: function(inTop){
			this.grid.scrollTop = inTop;
			if(this.colCount){
				this.startPacify();
				this.findPage(inTop);
				var h = this.height;
				var b = this.getScrollBottom(inTop);
				for(var p=this.page, y=this.pageTop; (p<this.pageCount)&&((b<0)||(y<b)); p++){
					y += this.needPage(p, y);
				}
				this.firstVisibleRow = this.getFirstVisibleRow(this.page, this.pageTop, inTop);
				this.lastVisibleRow = this.getLastVisibleRow(p - 1, y, b);
				// indicates some page size has been updated
				if(h != this.height){
					this.repositionPages(p-1);
				}
				this.endPacify();
			}
		},
		getScrollBottom: function(inTop){
			return (this.windowHeight >= 0 ? inTop + this.windowHeight : -1);
		},
		// events
		processNodeEvent: function(e, inNode){
			var t = e.target;
			while(t && (t != inNode) && t.parentNode && (t.parentNode.parentNode != inNode)){
				t = t.parentNode;
			}
			if(!t || !t.parentNode || (t.parentNode.parentNode != inNode)){
				return false;
			}
			var page = t.parentNode;
			e.topRowIndex = page.pageIndex * this.rowsPerPage;
			e.rowIndex = e.topRowIndex + indexInParent(t);
			e.rowTarget = t;
			return true;
		},
		processEvent: function(e){
			return this.processNodeEvent(e, this.contentNode);
		},
		// virtual rendering interface
		renderRow: function(inRowIndex, inPageNode){
		},
		removeRow: function(inRowIndex){
		},
		// page node operations
		getDefaultPageNode: function(inPageIndex){
			return this.getDefaultNodes()[inPageIndex];
		},
		positionPageNode: function(inNode, inPos){
		},
		getPageNodePosition: function(inNode){
			return inNode.offsetTop;
		},
		invalidatePageNode: function(inPageIndex, inNodes){
			var p = inNodes[inPageIndex];
			if(p){
				delete inNodes[inPageIndex];
				this.removePage(inPageIndex, p);
				cleanNode(p);
				p.innerHTML = '';
			}
			return p;
		},
		// scroll control
		getPageRow: function(inPage){
			return inPage * this.rowsPerPage;
		},
		getLastPageRow: function(inPage){
			return Math.min(this.rowCount, this.getPageRow(inPage + 1)) - 1;
		},
		getFirstVisibleRow: function(inPage, inPageTop, inScrollTop){
			if(!this.pageExists(inPage)){
				return 0;
			}
			var row = this.getPageRow(inPage);
			var nodes = this.getDefaultNodes();
			var rows = divkids(nodes[inPage]);
			for(var i=0,l=rows.length; i<l && inPageTop<inScrollTop; i++, row++){
				inPageTop += rows[i].offsetHeight;
			}
			return (row ? row - 1 : row);
		},
		getLastVisibleRow: function(inPage, inBottom, inScrollBottom){
			if(!this.pageExists(inPage)){
				return 0;
			}
			var nodes = this.getDefaultNodes();
			var row = this.getLastPageRow(inPage);
			var rows = divkids(nodes[inPage]);
			for(var i=rows.length-1; i>=0 && inBottom>inScrollBottom; i--, row--){
				inBottom -= rows[i].offsetHeight;
			}
			return row + 1;
		},
		findTopRow: function(inScrollTop){
			var nodes = this.getDefaultNodes();
			var rows = divkids(nodes[this.page]);
			for(var i=0,l=rows.length,t=this.pageTop,h; i<l; i++){
				h = rows[i].offsetHeight;
				t += h;
				if(t >= inScrollTop){
					this.offset = h - (t - inScrollTop);
					return i + this.page * this.rowsPerPage;
				}
			}
			return -1;
		},
		findScrollTop: function(inRow){
			var rowPage = Math.floor(inRow / this.rowsPerPage);
			var t = 0;
			var i, l;
			for(i=0; i<rowPage; i++){
				t += this.getPageHeight(i);
			}
			this.pageTop = t;
			this.page = rowPage;//fix #10543
			this.needPage(rowPage, this.pageTop);

			var nodes = this.getDefaultNodes();
			var rows = divkids(nodes[rowPage]);
			var r = inRow - this.rowsPerPage * rowPage;
			for(i=0,l=rows.length; i<l && i<r; i++){
				t += rows[i].offsetHeight;
			}
			return t;
		},
		dummy: 0
	});
})();

}

if(!dojo._hasResource["dojox.grid.cells._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.cells._base"] = true;
dojo.provide("dojox.grid.cells._base");




dojo.declare("dojox.grid._DeferredTextWidget", dijit._Widget, {
	deferred: null,
	_destroyOnRemove: true,
	postCreate: function(){
		if(this.deferred){
			this.deferred.addBoth(dojo.hitch(this, function(text){
				if(this.domNode){
					this.domNode.innerHTML = text;
				}
			}));
		}
	}
});

(function(){
	var focusSelectNode = function(inNode){
		try{
			dojox.grid.util.fire(inNode, "focus");
			dojox.grid.util.fire(inNode, "select");
		}catch(e){// IE sux bad
		}
	};
	
	var whenIdle = function(/*inContext, inMethod, args ...*/){
		setTimeout(dojo.hitch.apply(dojo, arguments), 0);
	};

	var dgc = dojox.grid.cells;

	dojo.declare("dojox.grid.cells._Base", null, {
		// summary:
		//	Respresents a grid cell and contains information about column options and methods
		//	for retrieving cell related information.
		//	Each column in a grid layout has a cell object and most events and many methods
		//	provide access to these objects.
		styles: '',
		classes: '',
		editable: false,
		alwaysEditing: false,
		formatter: null,
		defaultValue: '...',
		value: null,
		hidden: false,
		noresize: false,
		draggable: true,
		//private
		_valueProp: "value",
		_formatPending: false,

		constructor: function(inProps){
			this._props = inProps || {};
			dojo.mixin(this, inProps);
			if(this.draggable === undefined){
				this.draggable = true;
			}
		},

		_defaultFormat: function(inValue, callArgs){
			var s = this.grid.formatterScope || this;
			var f = this.formatter;
			if(f && s && typeof f == "string"){
				f = this.formatter = s[f];
			}
			var v = (inValue != this.defaultValue && f) ? f.apply(s, callArgs) : inValue;
			if(typeof v == "undefined"){
				return this.defaultValue;
			}
			if(v && v.addBoth){
				// Check if it's a deferred
				v = new dojox.grid._DeferredTextWidget({deferred: v},
									dojo.create("span", {innerHTML: this.defaultValue}));
			}
			if(v && v.declaredClass && v.startup){
				return "<div class='dojoxGridStubNode' linkWidget='" +
						v.id +
						"' cellIdx='" +
						this.index +
						"'>" +
						this.defaultValue +
						"</div>";
			}
			return v;
		},
		
		// data source
		format: function(inRowIndex, inItem){
			// summary:
			//	provides the html for a given grid cell.
			// inRowIndex: int
			// grid row index
			// returns: html for a given grid cell
			var f, i=this.grid.edit.info, d=this.get ? this.get(inRowIndex, inItem) : (this.value || this.defaultValue);
			//d = (d && d.replace && this.grid.escapeHTMLInData) ? d.replace(/&/g, '&amp;').replace(/</g, '&lt;') : d;
			if(this.editable && (this.alwaysEditing || (i.rowIndex==inRowIndex && i.cell==this))){
				return this.formatEditing(d, inRowIndex);
			}else{
				return this._defaultFormat(d, [d, inRowIndex, this]);
			}
		},
		formatEditing: function(inDatum, inRowIndex){
			// summary:
			//	formats the cell for editing
			// inDatum: anything
			//	cell data to edit
			// inRowIndex: int
			//	grid row index
			// returns: string of html to place in grid cell
		},
		// utility
		getNode: function(inRowIndex){
			// summary:
			//	gets the dom node for a given grid cell.
			// inRowIndex: int
			// grid row index
			// returns: dom node for a given grid cell
			return this.view.getCellNode(inRowIndex, this.index);
		},
		getHeaderNode: function(){
			return this.view.getHeaderCellNode(this.index);
		},
		getEditNode: function(inRowIndex){
			return (this.getNode(inRowIndex) || 0).firstChild || 0;
		},
		canResize: function(){
			var uw = this.unitWidth;
			return uw && (uw!=='auto');
		},
		isFlex: function(){
			var uw = this.unitWidth;
			return uw && dojo.isString(uw) && (uw=='auto' || uw.slice(-1)=='%');
		},
		// edit support
		applyEdit: function(inValue, inRowIndex){
			this.grid.edit.applyCellEdit(inValue, this, inRowIndex);
		},
		cancelEdit: function(inRowIndex){
			this.grid.doCancelEdit(inRowIndex);
		},
		_onEditBlur: function(inRowIndex){
			if(this.grid.edit.isEditCell(inRowIndex, this.index)){
				//console.log('editor onblur', e);
				this.grid.edit.apply();
			}
		},
		registerOnBlur: function(inNode, inRowIndex){
			if(this.commitOnBlur){
				dojo.connect(inNode, "onblur", function(e){
					// hack: if editor still thinks this editor is current some ms after it blurs, assume we've focused away from grid
					setTimeout(dojo.hitch(this, "_onEditBlur", inRowIndex), 250);
				});
			}
		},
		//protected
		needFormatNode: function(inDatum, inRowIndex){
			this._formatPending = true;
			whenIdle(this, "_formatNode", inDatum, inRowIndex);
		},
		cancelFormatNode: function(){
			this._formatPending = false;
		},
		//private
		_formatNode: function(inDatum, inRowIndex){
			if(this._formatPending){
				this._formatPending = false;
				// make cell selectable
				dojo.setSelectable(this.grid.domNode, true);
				this.formatNode(this.getEditNode(inRowIndex), inDatum, inRowIndex);
			}
		},
		//protected
		formatNode: function(inNode, inDatum, inRowIndex){
			// summary:
			//	format the editing dom node. Use when editor is a widget.
			// inNode: dom node
			// dom node for the editor
			// inDatum: anything
			//	cell data to edit
			// inRowIndex: int
			//	grid row index
			if(dojo.isIE){
				// IE sux bad
				whenIdle(this, "focus", inRowIndex, inNode);
			}else{
				this.focus(inRowIndex, inNode);
			}
		},
		dispatchEvent: function(m, e){
			if(m in this){
				return this[m](e);
			}
		},
		//public
		getValue: function(inRowIndex){
			// summary:
			//	returns value entered into editor
			// inRowIndex: int
			// grid row index
			// returns:
			//	value of editor
			return this.getEditNode(inRowIndex)[this._valueProp];
		},
		setValue: function(inRowIndex, inValue){
			// summary:
			//	set the value of the grid editor
			// inRowIndex: int
			// grid row index
			// inValue: anything
			//	value of editor
			var n = this.getEditNode(inRowIndex);
			if(n){
				n[this._valueProp] = inValue;
			}
		},
		focus: function(inRowIndex, inNode){
			// summary:
			//	focus the grid editor
			// inRowIndex: int
			// grid row index
			// inNode: dom node
			//	editor node
			focusSelectNode(inNode || this.getEditNode(inRowIndex));
		},
		save: function(inRowIndex){
			// summary:
			//	save editor state
			// inRowIndex: int
			// grid row index
			this.value = this.value || this.getValue(inRowIndex);
			//console.log("save", this.value, inCell.index, inRowIndex);
		},
		restore: function(inRowIndex){
			// summary:
			//	restore editor state
			// inRowIndex: int
			// grid row index
			this.setValue(inRowIndex, this.value);
			//console.log("restore", this.value, inCell.index, inRowIndex);
		},
		//protected
		_finish: function(inRowIndex){
			// summary:
			//	called when editing is completed to clean up editor
			// inRowIndex: int
			// grid row index
			dojo.setSelectable(this.grid.domNode, false);
			this.cancelFormatNode();
		},
		//public
		apply: function(inRowIndex){
			// summary:
			//	apply edit from cell editor
			// inRowIndex: int
			// grid row index
			this.applyEdit(this.getValue(inRowIndex), inRowIndex);
			this._finish(inRowIndex);
		},
		cancel: function(inRowIndex){
			// summary:
			//	cancel cell edit
			// inRowIndex: int
			// grid row index
			this.cancelEdit(inRowIndex);
			this._finish(inRowIndex);
		}
	});
	dgc._Base.markupFactory = function(node, cellDef){
		var d = dojo;
		var formatter = d.trim(d.attr(node, "formatter")||"");
		if(formatter){
			cellDef.formatter = dojo.getObject(formatter)||formatter;
		}
		var get = d.trim(d.attr(node, "get")||"");
		if(get){
			cellDef.get = dojo.getObject(get);
		}
		var getBoolAttr = function(attr, cell, cellAttr){
			var value = d.trim(d.attr(node, attr)||"");
			if(value){ cell[cellAttr||attr] = !(value.toLowerCase()=="false"); }
		};
		getBoolAttr("sortDesc", cellDef);
		getBoolAttr("editable", cellDef);
		getBoolAttr("alwaysEditing", cellDef);
		getBoolAttr("noresize", cellDef);
		getBoolAttr("draggable", cellDef);

		var value = d.trim(d.attr(node, "loadingText")||d.attr(node, "defaultValue")||"");
		if(value){
			cellDef.defaultValue = value;
		}

		var getStrAttr = function(attr, cell, cellAttr){
			var value = d.trim(d.attr(node, attr)||"")||undefined;
			if(value){ cell[cellAttr||attr] = value; }
		};
		getStrAttr("styles", cellDef);
		getStrAttr("headerStyles", cellDef);
		getStrAttr("cellStyles", cellDef);
		getStrAttr("classes", cellDef);
		getStrAttr("headerClasses", cellDef);
		getStrAttr("cellClasses", cellDef);
	};

	dojo.declare("dojox.grid.cells.Cell", dgc._Base, {
		// summary
		// grid cell that provides a standard text input box upon editing
		constructor: function(){
			this.keyFilter = this.keyFilter;
		},
		// keyFilter: RegExp
		//		optional regex for disallowing keypresses
		keyFilter: null,
		formatEditing: function(inDatum, inRowIndex){
			this.needFormatNode(inDatum, inRowIndex);
			return '<input class="dojoxGridInput" type="text" value="' + inDatum + '">';
		},
		formatNode: function(inNode, inDatum, inRowIndex){
			this.inherited(arguments);
			// FIXME: feels too specific for this interface
			this.registerOnBlur(inNode, inRowIndex);
		},
		doKey: function(e){
			if(this.keyFilter){
				var key = String.fromCharCode(e.charCode);
				if(key.search(this.keyFilter) == -1){
					dojo.stopEvent(e);
				}
			}
		},
		_finish: function(inRowIndex){
			this.inherited(arguments);
			var n = this.getEditNode(inRowIndex);
			try{
				dojox.grid.util.fire(n, "blur");
			}catch(e){}
		}
	});
	dgc.Cell.markupFactory = function(node, cellDef){
		dgc._Base.markupFactory(node, cellDef);
		var d = dojo;
		var keyFilter = d.trim(d.attr(node, "keyFilter")||"");
		if(keyFilter){
			cellDef.keyFilter = new RegExp(keyFilter);
		}
	};

	dojo.declare("dojox.grid.cells.RowIndex", dgc.Cell, {
		name: 'Row',

		postscript: function(){
			this.editable = false;
		},
		get: function(inRowIndex){
			return inRowIndex + 1;
		}
	});
	dgc.RowIndex.markupFactory = function(node, cellDef){
		dgc.Cell.markupFactory(node, cellDef);
	};

	dojo.declare("dojox.grid.cells.Select", dgc.Cell, {
		// summary:
		// grid cell that provides a standard select for editing

		// options: Array
		// 		text of each item
		options: null,

		// values: Array
		//		value for each item
		values: null,

		// returnIndex: Integer
		// 		editor returns only the index of the selected option and not the value
		returnIndex: -1,

		constructor: function(inCell){
			this.values = this.values || this.options;
		},
		formatEditing: function(inDatum, inRowIndex){
			this.needFormatNode(inDatum, inRowIndex);
			var h = [ '<select class="dojoxGridSelect">' ];
			for (var i=0, o, v; ((o=this.options[i]) !== undefined)&&((v=this.values[i]) !== undefined); i++){
				h.push("<option", (inDatum==v ? ' selected' : ''), ' value="' + v + '"', ">", o, "</option>");
			}
			h.push('</select>');
			return h.join('');
		},
		getValue: function(inRowIndex){
			var n = this.getEditNode(inRowIndex);
			if(n){
				var i = n.selectedIndex, o = n.options[i];
				return this.returnIndex > -1 ? i : o.value || o.innerHTML;
			}
		}
	});
	dgc.Select.markupFactory = function(node, cell){
		dgc.Cell.markupFactory(node, cell);
		var d=dojo;
		var options = d.trim(d.attr(node, "options")||"");
		if(options){
			var o = options.split(',');
			if(o[0] != options){
				cell.options = o;
			}
		}
		var values = d.trim(d.attr(node, "values")||"");
		if(values){
			var v = values.split(',');
			if(v[0] != values){
				cell.values = v;
			}
		}
	};

	dojo.declare("dojox.grid.cells.AlwaysEdit", dgc.Cell, {
		// summary:
		// grid cell that is always in an editable state, regardless of grid editing state
		alwaysEditing: true,
		_formatNode: function(inDatum, inRowIndex){
			this.formatNode(this.getEditNode(inRowIndex), inDatum, inRowIndex);
		},
		applyStaticValue: function(inRowIndex){
			var e = this.grid.edit;
			e.applyCellEdit(this.getValue(inRowIndex), this, inRowIndex);
			e.start(this, inRowIndex, true);
		}
	});
	dgc.AlwaysEdit.markupFactory = function(node, cell){
		dgc.Cell.markupFactory(node, cell);
	};

	dojo.declare("dojox.grid.cells.Bool", dgc.AlwaysEdit, {
		// summary:
		// grid cell that provides a standard checkbox that is always on for editing
		_valueProp: "checked",
		formatEditing: function(inDatum, inRowIndex){
			return '<input class="dojoxGridInput" type="checkbox"' + (inDatum ? ' checked="checked"' : '') + ' style="width: auto" />';
		},
		doclick: function(e){
			if(e.target.tagName == 'INPUT'){
				this.applyStaticValue(e.rowIndex);
			}
		}
	});
	dgc.Bool.markupFactory = function(node, cell){
		dgc.AlwaysEdit.markupFactory(node, cell);
	};
})();

}

if(!dojo._hasResource["dojox.grid.cells"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.cells"] = true;
dojo.provide("dojox.grid.cells");


}

if(!dojo._hasResource["dojox.grid._Builder"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._Builder"] = true;
dojo.provide("dojox.grid._Builder");




(function(){
	var dg = dojox.grid;

	var getTdIndex = function(td){
		return td.cellIndex >=0 ? td.cellIndex : dojo.indexOf(td.parentNode.cells, td);
	};
	
	var getTrIndex = function(tr){
		return tr.rowIndex >=0 ? tr.rowIndex : dojo.indexOf(tr.parentNode.childNodes, tr);
	};
	
	var getTr = function(rowOwner, index){
		return rowOwner && ((rowOwner.rows||0)[index] || rowOwner.childNodes[index]);
	};

	var findTable = function(node){
		for(var n=node; n && n.tagName!='TABLE'; n=n.parentNode){}
		return n;
	};
	
	var ascendDom = function(inNode, inWhile){
		for(var n=inNode; n && inWhile(n); n=n.parentNode){}
		return n;
	};
	
	var makeNotTagName = function(inTagName){
		var name = inTagName.toUpperCase();
		return function(node){ return node.tagName != name; };
	};

	var rowIndexTag = dojox.grid.util.rowIndexTag;
	var gridViewTag = dojox.grid.util.gridViewTag;

	// base class for generating markup for the views
	dg._Builder = dojo.extend(function(view){
		if(view){
			this.view = view;
			this.grid = view.grid;
		}
	},{
		view: null,
		// boilerplate HTML
		_table: '<table class="dojoxGridRowTable" border="0" cellspacing="0" cellpadding="0" role="presentation"',

		// Returns the table variable as an array - and with the view width, if specified
		getTableArray: function(){
			var html = [this._table];
			if(this.view.viewWidth){
				html.push([' style="width:', this.view.viewWidth, ';"'].join(''));
			}
			html.push('>');
			return html;
		},
		
		// generate starting tags for a cell
		generateCellMarkup: function(inCell, inMoreStyles, inMoreClasses, isHeader){
			var result = [], html;
			if(isHeader){
				var sortInfo = inCell.index != inCell.grid.getSortIndex() ? "" : inCell.grid.sortInfo > 0 ? 'aria-sort="ascending"' : 'aria-sort="descending"';
				if (!inCell.id){
					inCell.id = this.grid.id + "Hdr" + inCell.index;
				}
				// column headers are not editable, mark as aria-readonly=true
				html = ['<th tabIndex="-1" aria-readonly="true" role="columnheader"', sortInfo, 'id="', inCell.id, '"'];
			}else{
				// cells inherit grid aria-readonly property; default value for aria-readonly is false(grid is editable)
				// if grid is editable (had any editable cells), mark non editable cells as aria-readonly=true
				// if no editable cells, grid's aria-readonly value will have been set to true and cells will inherit
				var editInfo = this.grid.editable && !inCell.editable ? 'aria-readonly="true"' : "";
				html = ['<td tabIndex="-1" role="gridcell"', editInfo];
			}
			if(inCell.colSpan){
				html.push(' colspan="', inCell.colSpan, '"');
			}
			if(inCell.rowSpan){
				html.push(' rowspan="', inCell.rowSpan, '"');
			}
			html.push(' class="dojoxGridCell ');
			if(inCell.classes){
				html.push(inCell.classes, ' ');
			}
			if(inMoreClasses){
				html.push(inMoreClasses, ' ');
			}
			// result[0] => td opener, style
			result.push(html.join(''));
			// SLOT: result[1] => td classes
			result.push('');
			html = ['" idx="', inCell.index, '" style="'];
			if(inMoreStyles && inMoreStyles[inMoreStyles.length-1] != ';'){
				inMoreStyles += ';';
			}
			html.push(inCell.styles, inMoreStyles||'', inCell.hidden?'display:none;':'');
			if(inCell.unitWidth){
				html.push('width:', inCell.unitWidth, ';');
			}
			// result[2] => markup
			result.push(html.join(''));
			// SLOT: result[3] => td style
			result.push('');
			html = [ '"' ];
			if(inCell.attrs){
				html.push(" ", inCell.attrs);
			}
			html.push('>');
			// result[4] => td postfix
			result.push(html.join(''));
			// SLOT: result[5] => content
			result.push('');
			// result[6] => td closes
			result.push(isHeader?'</th>':'</td>');
			return result; // Array
		},

		// cell finding
		isCellNode: function(inNode){
			return Boolean(inNode && inNode!=dojo.doc && dojo.attr(inNode, "idx"));
		},
		
		getCellNodeIndex: function(inCellNode){
			return inCellNode ? Number(dojo.attr(inCellNode, "idx")) : -1;
		},
		
		getCellNode: function(inRowNode, inCellIndex){
			for(var i=0, row; ((row = getTr(inRowNode.firstChild, i)) && row.cells); i++){
				for(var j=0, cell; (cell = row.cells[j]); j++){
					if(this.getCellNodeIndex(cell) == inCellIndex){
						return cell;
					}
				}
			}
			return null;
		},
		
		findCellTarget: function(inSourceNode, inTopNode){
			var n = inSourceNode;
			while(n && (!this.isCellNode(n) || (n.offsetParent && gridViewTag in n.offsetParent.parentNode && n.offsetParent.parentNode[gridViewTag] != this.view.id)) && (n!=inTopNode)){
				n = n.parentNode;
			}
			return n!=inTopNode ? n : null;
		},
		
		// event decoration
		baseDecorateEvent: function(e){
			e.dispatch = 'do' + e.type;
			e.grid = this.grid;
			e.sourceView = this.view;
			e.cellNode = this.findCellTarget(e.target, e.rowNode);
			e.cellIndex = this.getCellNodeIndex(e.cellNode);
			e.cell = (e.cellIndex >= 0 ? this.grid.getCell(e.cellIndex) : null);
		},
		
		// event dispatch
		findTarget: function(inSource, inTag){
			var n = inSource;
			while(n && (n!=this.domNode) && (!(inTag in n) || (gridViewTag in n && n[gridViewTag] != this.view.id))){
				n = n.parentNode;
			}
			return (n != this.domNode) ? n : null;
		},

		findRowTarget: function(inSource){
			return this.findTarget(inSource, rowIndexTag);
		},

		isIntraNodeEvent: function(e){
			try{
				return (e.cellNode && e.relatedTarget && dojo.isDescendant(e.relatedTarget, e.cellNode));
			}catch(x){
				// e.relatedTarget has permission problem in FF if it's an input: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
				return false;
			}
		},

		isIntraRowEvent: function(e){
			try{
				var row = e.relatedTarget && this.findRowTarget(e.relatedTarget);
				return !row && (e.rowIndex==-1) || row && (e.rowIndex==row.gridRowIndex);
			}catch(x){
				// e.relatedTarget on INPUT has permission problem in FF: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
				return false;
			}
		},

		dispatchEvent: function(e){
			if(e.dispatch in this){
				return this[e.dispatch](e);
			}
			return false;
		},

		// dispatched event handlers
		domouseover: function(e){
			if(e.cellNode && (e.cellNode!=this.lastOverCellNode)){
				this.lastOverCellNode = e.cellNode;
				this.grid.onMouseOver(e);
			}
			this.grid.onMouseOverRow(e);
		},

		domouseout: function(e){
			if(e.cellNode && (e.cellNode==this.lastOverCellNode) && !this.isIntraNodeEvent(e, this.lastOverCellNode)){
				this.lastOverCellNode = null;
				this.grid.onMouseOut(e);
				if(!this.isIntraRowEvent(e)){
					this.grid.onMouseOutRow(e);
				}
			}
		},
		
		domousedown: function(e){
			if (e.cellNode)
				this.grid.onMouseDown(e);
			this.grid.onMouseDownRow(e);
		}
	});

	// Produces html for grid data content. Owned by grid and used internally
	// for rendering data. Override to implement custom rendering.
	dg._ContentBuilder = dojo.extend(function(view){
		dg._Builder.call(this, view);
	},dg._Builder.prototype,{
		update: function(){
			this.prepareHtml();
		},

		// cache html for rendering data rows
		prepareHtml: function(){
			var defaultGet=this.grid.get, cells=this.view.structure.cells;
			for(var j=0, row; (row=cells[j]); j++){
				for(var i=0, cell; (cell=row[i]); i++){
					cell.get = cell.get || (cell.value == undefined) && defaultGet;
					cell.markup = this.generateCellMarkup(cell, cell.cellStyles, cell.cellClasses, false);
					if (!this.grid.editable && cell.editable){
						this.grid.editable = true;
					}
				}
			}
		},

		// time critical: generate html using cache and data source
		generateHtml: function(inDataIndex, inRowIndex){
			var
				html = this.getTableArray(),
				v = this.view,
				cells = v.structure.cells,
				item = this.grid.getItem(inRowIndex);

			dojox.grid.util.fire(this.view, "onBeforeRow", [inRowIndex, cells]);
			for(var j=0, row; (row=cells[j]); j++){
				if(row.hidden || row.header){
					continue;
				}
				html.push(!row.invisible ? '<tr>' : '<tr class="dojoxGridInvisible">');
				for(var i=0, cell, m, cc, cs; (cell=row[i]); i++){
					m = cell.markup; cc = cell.customClasses = []; cs = cell.customStyles = [];
					// content (format can fill in cc and cs as side-effects)
					m[5] = cell.format(inRowIndex, item);
					// classes
					m[1] = cc.join(' ');
					// styles
					m[3] = cs.join(';');
					// in-place concat
					html.push.apply(html, m);
				}
				html.push('</tr>');
			}
			html.push('</table>');
			return html.join(''); // String
		},

		decorateEvent: function(e){
			e.rowNode = this.findRowTarget(e.target);
			if(!e.rowNode){return false;}
			e.rowIndex = e.rowNode[rowIndexTag];
			this.baseDecorateEvent(e);
			e.cell = this.grid.getCell(e.cellIndex);
			return true; // Boolean
		}
	});

	// Produces html for grid header content. Owned by grid and used internally
	// for rendering data. Override to implement custom rendering.
	dg._HeaderBuilder = dojo.extend(function(view){
		this.moveable = null;
		dg._Builder.call(this, view);
	},dg._Builder.prototype,{
		_skipBogusClicks: false,
		overResizeWidth: 4,
		minColWidth: 1,
		
		update: function(){
			if(this.tableMap){
				this.tableMap.mapRows(this.view.structure.cells);
			}else{
				this.tableMap = new dg._TableMap(this.view.structure.cells);
			}
		},

		generateHtml: function(inGetValue, inValue){
			var html = this.getTableArray(), cells = this.view.structure.cells;
			
			dojox.grid.util.fire(this.view, "onBeforeRow", [-1, cells]);
			for(var j=0, row; (row=cells[j]); j++){
				if(row.hidden){
					continue;
				}
				html.push(!row.invisible ? '<tr>' : '<tr class="dojoxGridInvisible">');
				for(var i=0, cell, markup; (cell=row[i]); i++){
					cell.customClasses = [];
					cell.customStyles = [];
					if(this.view.simpleStructure){
						if(cell.draggable){
							if(cell.headerClasses){
								if(cell.headerClasses.indexOf('dojoDndItem') == -1){
									cell.headerClasses += ' dojoDndItem';
								}
							}else{
								cell.headerClasses = 'dojoDndItem';
							}
						}
						if(cell.attrs){
							if(cell.attrs.indexOf("dndType='gridColumn_") == -1){
								cell.attrs += " dndType='gridColumn_" + this.grid.id + "'";
							}
						}else{
							cell.attrs = "dndType='gridColumn_" + this.grid.id + "'";
						}
					}
					markup = this.generateCellMarkup(cell, cell.headerStyles, cell.headerClasses, true);
					// content
					markup[5] = (inValue != undefined ? inValue : inGetValue(cell));
					// styles
					markup[3] = cell.customStyles.join(';');
					// classes
					markup[1] = cell.customClasses.join(' '); //(cell.customClasses ? ' ' + cell.customClasses : '');
					html.push(markup.join(''));
				}
				html.push('</tr>');
			}
			html.push('</table>');
			return html.join('');
		},

		// event helpers
		getCellX: function(e){
			var n, x = e.layerX;
			if(dojo.isMoz || dojo.isIE >= 9){
				n = ascendDom(e.target, makeNotTagName("th"));
				x -= (n && n.offsetLeft) || 0;
				var t = e.sourceView.getScrollbarWidth();
				if(!dojo._isBodyLtr()/*&& e.sourceView.headerNode.scrollLeft < t*/){
					//fix #11253
					table = ascendDom(n,makeNotTagName("table"));
					x -= (table && table.offsetLeft) || 0;
				}
				//x -= getProp(ascendDom(e.target, mkNotTagName("td")), "offsetLeft") || 0;
			}
			n = ascendDom(e.target, function(){
				if(!n || n == e.cellNode){
					return false;
				}
				// Mozilla 1.8 (FF 1.5) has a bug that makes offsetLeft = -parent border width
				// when parent has border, overflow: hidden, and is positioned
				// handle this problem here ... not a general solution!
				x += (n.offsetLeft < 0 ? 0 : n.offsetLeft);
				return true;
			});
			return x;
		},

		// event decoration
		decorateEvent: function(e){
			this.baseDecorateEvent(e);
			e.rowIndex = -1;
			e.cellX = this.getCellX(e);
			return true;
		},

		// event handlers
		// resizing
		prepareResize: function(e, mod){
			do{
				var i = getTdIndex(e.cellNode);
				e.cellNode = (i ? e.cellNode.parentNode.cells[i+mod] : null);
				e.cellIndex = (e.cellNode ? this.getCellNodeIndex(e.cellNode) : -1);
			}while(e.cellNode && e.cellNode.style.display == "none");
			return Boolean(e.cellNode);
		},

		canResize: function(e){
			if(!e.cellNode || e.cellNode.colSpan > 1){
				return false;
			}
			var cell = this.grid.getCell(e.cellIndex);
			return !cell.noresize && cell.canResize();
		},

		overLeftResizeArea: function(e){
			// We are never over a resize area if we are in the process of moving
			if(dojo.hasClass(dojo.body(), "dojoDndMove")){
				return false;
			}
			//Bugfix for crazy IE problem (#8807).  IE returns position information for the icon and text arrow divs
			//as if they were still on the left instead of returning the position they were 'float: right' to.
			//So, the resize check ends up checking the wrong adjacent cell.  This checks to see if the hover was over
			//the image or text nodes, then just ignored them/treat them not in scale range.
			if(dojo.isIE){
				var tN = e.target;
				if(dojo.hasClass(tN, "dojoxGridArrowButtonNode") ||
					dojo.hasClass(tN, "dojoxGridArrowButtonChar")){
					return false;
				}
			}

			if(dojo._isBodyLtr()){
				return (e.cellIndex>0) && (e.cellX > 0 && e.cellX < this.overResizeWidth) && this.prepareResize(e, -1);
			}
			var t = e.cellNode && (e.cellX > 0 && e.cellX < this.overResizeWidth);
			return t;
		},

		overRightResizeArea: function(e){
			// We are never over a resize area if we are in the process of moving
			if(dojo.hasClass(dojo.body(), "dojoDndMove")){
				return false;
			}
			//Bugfix for crazy IE problem (#8807).  IE returns position information for the icon and text arrow divs
			//as if they were still on the left instead of returning the position they were 'float: right' to.
			//So, the resize check ends up checking the wrong adjacent cell.  This checks to see if the hover was over
			//the image or text nodes, then just ignored them/treat them not in scale range.
			if(dojo.isIE){
				var tN = e.target;
				if(dojo.hasClass(tN, "dojoxGridArrowButtonNode") ||
					dojo.hasClass(tN, "dojoxGridArrowButtonChar")){
					return false;
				}
			}

			if(dojo._isBodyLtr()){
				return e.cellNode && (e.cellX >= e.cellNode.offsetWidth - this.overResizeWidth);
			}
			return (e.cellIndex>0) && (e.cellX >= e.cellNode.offsetWidth - this.overResizeWidth) && this.prepareResize(e, -1);
		},

		domousemove: function(e){
			//console.log(e.cellIndex, e.cellX, e.cellNode.offsetWidth);
			if(!this.moveable){
				var c = (this.overRightResizeArea(e) ? 'dojoxGridColResize' : (this.overLeftResizeArea(e) ? 'dojoxGridColResize' : ''));
				if(c && !this.canResize(e)){
					c = 'dojoxGridColNoResize';
				}
				dojo.toggleClass(e.sourceView.headerNode, "dojoxGridColNoResize", (c == "dojoxGridColNoResize"));
				dojo.toggleClass(e.sourceView.headerNode, "dojoxGridColResize", (c == "dojoxGridColResize"));
				if(dojo.isIE){
					var t = e.sourceView.headerNode.scrollLeft;
					e.sourceView.headerNode.scrollLeft = t;
				}
				if(c){
					dojo.stopEvent(e);
				}
			}
		},

		domousedown: function(e){
			if(!this.moveable){
				if((this.overRightResizeArea(e) || this.overLeftResizeArea(e)) && this.canResize(e)){
				//	this.beginColumnResize(e);
				}else{
					this.grid.onMouseDown(e);
					this.grid.onMouseOverRow(e);
				}
				//else{
				//	this.beginMoveColumn(e);
				//}
			}
		},

		doclick: function(e) {
			if(this._skipBogusClicks){
				dojo.stopEvent(e);
				return true;
			}
			return false;
		},

		// column resizing
		colResizeSetup: function(/*Event Object*/e, /*boolean*/ isMouse ){
			//Set up the drag object for column resizing
			// Called with mouse event in case of drag and drop,
			// Also called from keyboard shift-arrow event when focus is on a header
			var headContentBox = dojo.contentBox(e.sourceView.headerNode);
			
			if(isMouse){  //IE draws line even with no mouse down so separate from keyboard
				this.lineDiv = document.createElement('div');

				// NOTE: this is for backwards compatibility with Dojo 1.3
				var vw = (dojo.position||dojo._abs)(e.sourceView.headerNode, true);
				var bodyContentBox = dojo.contentBox(e.sourceView.domNode);
				//fix #11340
				var l = e.pageX;
				if(!dojo._isBodyLtr() && dojo.isIE < 8){
					l -= dojox.html.metrics.getScrollbar().w;
				}
				dojo.style(this.lineDiv, {
					top: vw.y + "px",
					left: l + "px",
					height: (bodyContentBox.h + headContentBox.h) + "px"
				});
				dojo.addClass(this.lineDiv, "dojoxGridResizeColLine");
				this.lineDiv._origLeft = l;
				dojo.body().appendChild(this.lineDiv);
			}
			var spanners = [], nodes = this.tableMap.findOverlappingNodes(e.cellNode);
			for(var i=0, cell; (cell=nodes[i]); i++){
				spanners.push({ node: cell, index: this.getCellNodeIndex(cell), width: cell.offsetWidth });
				//console.log("spanner: " + this.getCellNodeIndex(cell));
			}

			var view = e.sourceView;
			var adj = dojo._isBodyLtr() ? 1 : -1;
			var views = e.grid.views.views;
			var followers = [];
			for(var j=view.idx+adj, cView; (cView=views[j]); j=j+adj){
				followers.push({ node: cView.headerNode, left: window.parseInt(cView.headerNode.style.left) });
			}
			var table = view.headerContentNode.firstChild;
			var drag = {
				scrollLeft: e.sourceView.headerNode.scrollLeft,
				view: view,
				node: e.cellNode,
				index: e.cellIndex,
				w: dojo.contentBox(e.cellNode).w,
				vw: headContentBox.w,
				table: table,
				tw: dojo.contentBox(table).w,
				spanners: spanners,
				followers: followers
			};
			return drag;
		},
		beginColumnResize: function(e){
			this.moverDiv = document.createElement("div");
			dojo.style(this.moverDiv,{position: "absolute", left:0}); // to make DnD work with dir=rtl
			dojo.body().appendChild(this.moverDiv);
			dojo.addClass(this.grid.domNode, "dojoxGridColumnResizing");
			var m = (this.moveable = new dojo.dnd.Moveable(this.moverDiv));

			var drag = this.colResizeSetup(e,true);

			m.onMove = dojo.hitch(this, "doResizeColumn", drag);

			dojo.connect(m, "onMoveStop", dojo.hitch(this, function(){
				this.endResizeColumn(drag);
				if(drag.node.releaseCapture){
					drag.node.releaseCapture();
				}
				this.moveable.destroy();
				delete this.moveable;
				this.moveable = null;
				dojo.removeClass(this.grid.domNode, "dojoxGridColumnResizing");
			}));

			if(e.cellNode.setCapture){
				e.cellNode.setCapture();
			}
			m.onMouseDown(e);
		},

		doResizeColumn: function(inDrag, mover, leftTop){
			var changeX = leftTop.l;
			var data = {
				deltaX: changeX,
				w: inDrag.w + (dojo._isBodyLtr() ? changeX : -changeX),//fix #11341
				vw: inDrag.vw + changeX,
				tw: inDrag.tw + changeX
			};
			
			this.dragRecord = {inDrag: inDrag, mover: mover, leftTop:leftTop};
			
			if(data.w >= this.minColWidth){
				if (!mover) { // we are using keyboard do immediate resize
					this.doResizeNow(inDrag, data);
				}
				else{
					dojo.style(this.lineDiv, "left", (this.lineDiv._origLeft + data.deltaX) + "px");
				}
			}
		},

		endResizeColumn: function(inDrag){
			if(this.dragRecord){
				var leftTop = this.dragRecord.leftTop;
				var changeX = dojo._isBodyLtr() ? leftTop.l : -leftTop.l;
				// Make sure we are not under our minimum
				// http://bugs.dojotoolkit.org/ticket/9390
				changeX += Math.max(inDrag.w + changeX, this.minColWidth) - (inDrag.w + changeX);
				if(dojo.isWebKit && inDrag.spanners.length){
					// Webkit needs the pad border extents back in
					changeX += dojo._getPadBorderExtents(inDrag.spanners[0].node).w;
				}
				var data = {
					deltaX: changeX,
					w: inDrag.w + changeX,
					vw: inDrag.vw + changeX,
					tw: inDrag.tw + changeX
				};
				// Only resize the columns when the drag has finished
				this.doResizeNow(inDrag, data);
				delete this.dragRecord;
			}
			
			dojo.destroy(this.lineDiv);
 			dojo.destroy(this.moverDiv);
			dojo.destroy(this.moverDiv);
			delete this.moverDiv;
			this._skipBogusClicks = true;
			inDrag.view.update();
			this._skipBogusClicks = false;
			this.grid.onResizeColumn(inDrag.index);
		},
		doResizeNow: function(inDrag, data){
			inDrag.view.convertColPctToFixed();
			if(inDrag.view.flexCells && !inDrag.view.testFlexCells()){
				var t = findTable(inDrag.node);
				if(t){
					(t.style.width = '');
				}
			}
			var i, s, sw, f, fl;
			for(i=0; (s=inDrag.spanners[i]); i++){
				sw = s.width + data.deltaX;
				if(sw > 0){
					s.node.style.width = sw + 'px';
					inDrag.view.setColWidth(s.index, sw);
				}
			}
			if(dojo._isBodyLtr() || !dojo.isIE){//fix #11339
				for(i=0; (f=inDrag.followers[i]); i++){
					fl = f.left + data.deltaX;
					f.node.style.left = fl + 'px';
				}
			}
			inDrag.node.style.width = data.w + 'px';
			inDrag.view.setColWidth(inDrag.index, data.w);
			inDrag.view.headerNode.style.width = data.vw + 'px';
			inDrag.view.setColumnsWidth(data.tw);
			if(!dojo._isBodyLtr()){
				inDrag.view.headerNode.scrollLeft = inDrag.scrollLeft + data.deltaX;
			}
		}
	});

	// Maps an html table into a structure parsable for information about cell row and col spanning.
	// Used by HeaderBuilder.
	dg._TableMap = dojo.extend(function(rows){
		this.mapRows(rows);
	},{
		map: null,

		mapRows: function(inRows){
			// summary: Map table topography

			//console.log('mapRows');
			// # of rows
			var rowCount = inRows.length;
			if(!rowCount){
				return;
			}
			// map which columns and rows fill which cells
			this.map = [];
			var row;
			for(var k=0; (row=inRows[k]); k++){
				this.map[k] = [];
			}
			for(var j=0; (row=inRows[j]); j++){
				for(var i=0, x=0, cell, colSpan, rowSpan; (cell=row[i]); i++){
					while(this.map[j][x]){x++;}
					this.map[j][x] = { c: i, r: j };
					rowSpan = cell.rowSpan || 1;
					colSpan = cell.colSpan || 1;
					for(var y=0; y<rowSpan; y++){
						for(var s=0; s<colSpan; s++){
							this.map[j+y][x+s] = this.map[j][x];
						}
					}
					x += colSpan;
				}
			}
			//this.dumMap();
		},

		dumpMap: function(){
			for(var j=0, row, h=''; (row=this.map[j]); j++,h=''){
				for(var i=0, cell; (cell=row[i]); i++){
					h += cell.r + ',' + cell.c + '   ';
				}
			}
		},

		getMapCoords: function(inRow, inCol){
			// summary: Find node's map coords by it's structure coords
			for(var j=0, row; (row=this.map[j]); j++){
				for(var i=0, cell; (cell=row[i]); i++){
					if(cell.c==inCol && cell.r == inRow){
						return { j: j, i: i };
					}
					//else{console.log(inRow, inCol, ' : ', i, j, " : ", cell.r, cell.c); };
				}
			}
			return { j: -1, i: -1 };
		},
		
		getNode: function(inTable, inRow, inCol){
			// summary: Find a node in inNode's table with the given structure coords
			var row = inTable && inTable.rows[inRow];
			return row && row.cells[inCol];
		},
		
		_findOverlappingNodes: function(inTable, inRow, inCol){
			var nodes = [];
			var m = this.getMapCoords(inRow, inCol);
			//console.log("node j: %d, i: %d", m.j, m.i);
			for(var j=0, row; (row=this.map[j]); j++){
				if(j == m.j){ continue; }
				var rw = row[m.i];
				//console.log("overlaps: r: %d, c: %d", rw.r, rw.c);
				var n = (rw?this.getNode(inTable, rw.r, rw.c):null);
				if(n){ nodes.push(n); }
			}
			//console.log(nodes);
			return nodes;
		},
		
		findOverlappingNodes: function(inNode){
			return this._findOverlappingNodes(findTable(inNode), getTrIndex(inNode.parentNode), getTdIndex(inNode));
		}
	});
})();

}

if(!dojo._hasResource["dojo.dnd.Container"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Container"] = true;
dojo.provide("dojo.dnd.Container");




/*
	Container states:
		""		- normal state
		"Over"	- mouse over a container
	Container item states:
		""		- normal state
		"Over"	- mouse over a container item
*/

/*=====
dojo.declare("dojo.dnd.__ContainerArgs", [], {
	creator: function(){
		// summary:
		//		a creator function, which takes a data item, and returns an object like that:
		//		{node: newNode, data: usedData, type: arrayOfStrings}
	},

	// skipForm: Boolean
	//		don't start the drag operation, if clicked on form elements
	skipForm: false,

	// dropParent: Node||String
	//		node or node's id to use as the parent node for dropped items
	//		(must be underneath the 'node' parameter in the DOM)
	dropParent: null,

	// _skipStartup: Boolean
	//		skip startup(), which collects children, for deferred initialization
	//		(this is used in the markup mode)
	_skipStartup: false
});

dojo.dnd.Item = function(){
	// summary:
	//		Represents (one of) the source node(s) being dragged.
	//		Contains (at least) the "type" and "data" attributes.
	// type: String[]
	//		Type(s) of this item, by default this is ["text"]
	// data: Object
	//		Logical representation of the object being dragged.
	//		If the drag object's type is "text" then data is a String,
	//		if it's another type then data could be a different Object,
	//		perhaps a name/value hash.
	
	this.type = type;
	this.data = data;
}
=====*/

dojo.declare("dojo.dnd.Container", null, {
	// summary:
	//		a Container object, which knows when mouse hovers over it,
	//		and over which element it hovers
	
	// object attributes (for markup)
	skipForm: false,
	
	/*=====
	// current: DomNode
	//		The DOM node the mouse is currently hovered over
	current: null,
	
	// map: Hash<String, dojo.dnd.Item>
	//		Map from an item's id (which is also the DOMNode's id) to
	//		the dojo.dnd.Item itself.
	map: {},
	=====*/
	
	constructor: function(node, params){
		// summary:
		//		a constructor of the Container
		// node: Node
		//		node or node's id to build the container on
		// params: dojo.dnd.__ContainerArgs
		//		a dictionary of parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.creator = params.creator || null;
		this.skipForm = params.skipForm;
		this.parent = params.dropParent && dojo.byId(params.dropParent);
		
		// class-specific variables
		this.map = {};
		this.current = null;

		// states
		this.containerState = "";
		dojo.addClass(this.node, "dojoDndContainer");
		
		// mark up children
		if(!(params && params._skipStartup)){
			this.startup();
		}

		// set up events
		this.events = [
			dojo.connect(this.node, "onmouseover", this, "onMouseOver"),
			dojo.connect(this.node, "onmouseout",  this, "onMouseOut"),
			// cancel text selection and text dragging
			dojo.connect(this.node, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.node, "onselectstart", this, "onSelectStart")
		];
	},
	
	// object attributes (for markup)
	creator: function(){
		// summary:
		//		creator function, dummy at the moment
	},
	
	// abstract access to the map
	getItem: function(/*String*/ key){
		// summary:
		//		returns a data item by its key (id)
		return this.map[key];	// dojo.dnd.Item
	},
	setItem: function(/*String*/ key, /*dojo.dnd.Item*/ data){
		// summary:
		//		associates a data item with its key (id)
		this.map[key] = data;
	},
	delItem: function(/*String*/ key){
		// summary:
		//		removes a data item from the map by its key (id)
		delete this.map[key];
	},
	forInItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over a data map skipping members that
		//		are present in the empty object (IE and/or 3rd-party libraries).
		o = o || dojo.global;
		var m = this.map, e = dojo.dnd._empty;
		for(var i in m){
			if(i in e){ continue; }
			f.call(o, m[i], i, this);
		}
		return o;	// Object
	},
	clearItems: function(){
		// summary:
		//		removes all data items from the map
		this.map = {};
	},
	
	// methods
	getAllNodes: function(){
		// summary:
		//		returns a list (an array) of all valid child nodes
		return dojo.query("> .dojoDndItem", this.parent);	// NodeList
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map
		var map = {};
		this.getAllNodes().forEach(function(node){
			if(node.id){
				var item = this.getItem(node.id);
				if(item){
					map[node.id] = item;
					return;
				}
			}else{
				node.id = dojo.dnd.getUniqueId();
			}
			var type = node.getAttribute("dndType"),
				data = node.getAttribute("dndData");
			map[node.id] = {
				data: data || node.innerHTML,
				type: type ? type.split(/\s*,\s*/) : ["text"]
			};
		}, this);
		this.map = map;
		return this;	// self
	},
	insertNodes: function(data, before, anchor){
		// summary:
		//		inserts an array of new nodes before/after an anchor node
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		if(!this.parent.firstChild){
			anchor = null;
		}else if(before){
			if(!anchor){
				anchor = this.parent.firstChild;
			}
		}else{
			if(anchor){
				anchor = anchor.nextSibling;
			}
		}
		if(anchor){
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.insertBefore(t.node, anchor);
			}
		}else{
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.appendChild(t.node);
			}
		}
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares this object to be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.clearItems();
		this.node = this.parent = this.current = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Container(node, params);
	},
	startup: function(){
		// summary:
		//		collects valid child items and populate the map
		
		// set up the real parent node
		if(!this.parent){
			// use the standard algorithm, if not assigned
			this.parent = this.node;
			if(this.parent.tagName.toLowerCase() == "table"){
				var c = this.parent.getElementsByTagName("tbody");
				if(c && c.length){ this.parent = c[0]; }
			}
		}
		this.defaultCreator = dojo.dnd._defaultCreator(this.parent);

		// process specially marked children
		this.sync();
	},

	// mouse events
	onMouseOver: function(e){
		// summary:
		//		event processor for onmouseover
		// e: Event
		//		mouse event
		var n = e.relatedTarget;
		while(n){
			if(n == this.node){ break; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(!n){
			this._changeState("Container", "Over");
			this.onOverEvent();
		}
		n = this._getChildByEvent(e);
		if(this.current == n){ return; }
		if(this.current){ this._removeItemClass(this.current, "Over"); }
		if(n){ this._addItemClass(n, "Over"); }
		this.current = n;
	},
	onMouseOut: function(e){
		// summary:
		//		event processor for onmouseout
		// e: Event
		//		mouse event
		for(var n = e.relatedTarget; n;){
			if(n == this.node){ return; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(this.current){
			this._removeItemClass(this.current, "Over");
			this.current = null;
		}
		this._changeState("Container", "");
		this.onOutEvent();
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skipForm || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
	},
	_changeState: function(type, newState){
		// summary:
		//		changes a named state to new state value
		// type: String
		//		a name of the state to change
		// newState: String
		//		new state
		var prefix = "dojoDnd" + type;
		var state  = type.toLowerCase() + "State";
		//dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
		dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
		this[state] = newState;
	},
	_addItemClass: function(node, type){
		// summary:
		//		adds a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		dojo.addClass(node, "dojoDndItem" + type);
	},
	_removeItemClass: function(node, type){
		// summary:
		//		removes a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		dojo.removeClass(node, "dojoDndItem" + type);
	},
	_getChildByEvent: function(e){
		// summary:
		//		gets a child, which is under the mouse at the moment, or null
		// e: Event
		//		a mouse event
		var node = e.target;
		if(node){
			for(var parent = node.parentNode; parent; node = parent, parent = node.parentNode){
				if(parent == this.parent && dojo.hasClass(node, "dojoDndItem")){ return node; }
			}
		}
		return null;
	},
	_normalizedCreator: function(/*dojo.dnd.Item*/ item, /*String*/ hint){
		// summary:
		//		adds all necessary data to the output of the user-supplied creator function
		var t = (this.creator || this.defaultCreator).call(this, item, hint);
		if(!dojo.isArray(t.type)){ t.type = ["text"]; }
		if(!t.node.id){ t.node.id = dojo.dnd.getUniqueId(); }
		dojo.addClass(t.node, "dojoDndItem");
		return t;
	}
});

dojo.dnd._createNode = function(tag){
	// summary:
	//		returns a function, which creates an element of given tag
	//		(SPAN by default) and sets its innerHTML to given text
	// tag: String
	//		a tag name or empty for SPAN
	if(!tag){ return dojo.dnd._createSpan; }
	return function(text){	// Function
		return dojo.create(tag, {innerHTML: text});	// Node
	};
};

dojo.dnd._createTrTd = function(text){
	// summary:
	//		creates a TR/TD structure with given text as an innerHTML of TD
	// text: String
	//		a text for TD
	var tr = dojo.create("tr");
	dojo.create("td", {innerHTML: text}, tr);
	return tr;	// Node
};

dojo.dnd._createSpan = function(text){
	// summary:
	//		creates a SPAN element with given text as its innerHTML
	// text: String
	//		a text for SPAN
	return dojo.create("span", {innerHTML: text});	// Node
};

// dojo.dnd._defaultCreatorNodes: Object
//		a dictionary that maps container tag names to child tag names
dojo.dnd._defaultCreatorNodes = {ul: "li", ol: "li", div: "div", p: "div"};

dojo.dnd._defaultCreator = function(node){
	// summary:
	//		takes a parent node, and returns an appropriate creator function
	// node: Node
	//		a container node
	var tag = node.tagName.toLowerCase();
	var c = tag == "tbody" || tag == "thead" ? dojo.dnd._createTrTd :
			dojo.dnd._createNode(dojo.dnd._defaultCreatorNodes[tag]);
	return function(item, hint){	// Function
		var isObj = item && dojo.isObject(item), data, type, n;
		if(isObj && item.tagName && item.nodeType && item.getAttribute){
			// process a DOM node
			data = item.getAttribute("dndData") || item.innerHTML;
			type = item.getAttribute("dndType");
			type = type ? type.split(/\s*,\s*/) : ["text"];
			n = item;	// this node is going to be moved rather than copied
		}else{
			// process a DnD item object or a string
			data = (isObj && item.data) ? item.data : item;
			type = (isObj && item.type) ? item.type : ["text"];
			n = (hint == "avatar" ? dojo.dnd._createSpan : c)(String(data));
		}
		if(!n.id){
			n.id = dojo.dnd.getUniqueId();
		}
		return {node: n, data: data, type: type};
	};
};

}

if(!dojo._hasResource["dojo.dnd.Selector"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Selector"] = true;
dojo.provide("dojo.dnd.Selector");




/*
	Container item states:
		""			- an item is not selected
		"Selected"	- an item is selected
		"Anchor"	- an item is selected, and is an anchor for a "shift" selection
*/

/*=====
dojo.declare("dojo.dnd.__SelectorArgs", [dojo.dnd.__ContainerArgs], {
	//	singular: Boolean
	//		allows selection of only one element, if true
	singular: false,

	//	autoSync: Boolean
	//		autosynchronizes the source with its list of DnD nodes,
	autoSync: false
});
=====*/

dojo.declare("dojo.dnd.Selector", dojo.dnd.Container, {
	// summary:
	//		a Selector object, which knows how to select its children
	
	/*=====
	// selection: Set<String>
	//		The set of id's that are currently selected, such that this.selection[id] == 1
	//		if the node w/that id is selected.  Can iterate over selected node's id's like:
	//	|		for(var id in this.selection)
	selection: {},
	=====*/

	constructor: function(node, params){
		// summary:
		//		constructor of the Selector
		// node: Node||String
		//		node or node's id to build the selector on
		// params: dojo.dnd.__SelectorArgs?
		//		a dictionary of parameters
		if(!params){ params = {}; }
		this.singular = params.singular;
		this.autoSync = params.autoSync;
		// class-specific variables
		this.selection = {};
		this.anchor = null;
		this.simpleSelection = false;
		// set up events
		this.events.push(
			dojo.connect(this.node, "onmousedown", this, "onMouseDown"),
			dojo.connect(this.node, "onmouseup",   this, "onMouseUp"));
	},
	
	// object attributes (for markup)
	singular: false,	// is singular property
	
	// methods
	getSelectedNodes: function(){
		// summary:
		//		returns a list (an array) of selected nodes
		var t = new dojo.NodeList();
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			t.push(dojo.byId(i));
		}
		return t;	// NodeList
	},
	selectNone: function(){
		// summary:
		//		unselects all items
		return this._removeSelection()._removeAnchor();	// self
	},
	selectAll: function(){
		// summary:
		//		selects all items
		this.forInItems(function(data, id){
			this._addItemClass(dojo.byId(id), "Selected");
			this.selection[id] = 1;
		}, this);
		return this._removeAnchor();	// self
	},
	deleteSelectedNodes: function(){
		// summary:
		//		deletes all selected items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var n = dojo.byId(i);
			this.delItem(i);
			dojo.destroy(n);
		}
		this.anchor = null;
		this.selection = {};
		return this;	// self
	},
	forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over selected items;
		//		see `dojo.dnd.Container.forInItems()` for details
		o = o || dojo.global;
		var s = this.selection, e = dojo.dnd._empty;
		for(var i in s){
			if(i in e){ continue; }
			f.call(o, this.getItem(i), i, this);
		}
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map
		
		dojo.dnd.Selector.superclass.sync.call(this);
		
		// fix the anchor
		if(this.anchor){
			if(!this.getItem(this.anchor.id)){
				this.anchor = null;
			}
		}
		
		// fix the selection
		var t = [], e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			if(!this.getItem(i)){
				t.push(i);
			}
		}
		dojo.forEach(t, function(i){
			delete this.selection[i];
		}, this);
		
		return this;	// self
	},
	insertNodes: function(addSelected, data, before, anchor){
		// summary:
		//		inserts new data items (see `dojo.dnd.Container.insertNodes()` method for details)
		// addSelected: Boolean
		//		all new nodes will be added to selected items, if true, no selection change otherwise
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		var oldCreator = this._normalizedCreator;
		this._normalizedCreator = function(item, hint){
			var t = oldCreator.call(this, item, hint);
			if(addSelected){
				if(!this.anchor){
					this.anchor = t.node;
					this._removeItemClass(t.node, "Selected");
					this._addItemClass(this.anchor, "Anchor");
				}else if(this.anchor != t.node){
					this._removeItemClass(t.node, "Anchor");
					this._addItemClass(t.node, "Selected");
				}
				this.selection[t.node.id] = 1;
			}else{
				this._removeItemClass(t.node, "Selected");
				this._removeItemClass(t.node, "Anchor");
			}
			return t;
		};
		dojo.dnd.Selector.superclass.insertNodes.call(this, data, before, anchor);
		this._normalizedCreator = oldCreator;
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		dojo.dnd.Selector.superclass.destroy.call(this);
		this.selection = this.anchor = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Selector(node, params);
	},

	// mouse events
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(this.autoSync){ this.sync(); }
		if(!this.current){ return; }
		if(!this.singular && !dojo.isCopyKey(e) && !e.shiftKey && (this.current.id in this.selection)){
			this.simpleSelection = true;
			if(e.button === dojo.mouseButtons.LEFT){
				// accept the left button and stop the event
				// for IE we don't stop event when multiple buttons are pressed
				dojo.stopEvent(e);
			}
			return;
		}
		if(!this.singular && e.shiftKey){
			if(!dojo.isCopyKey(e)){
				this._removeSelection();
			}
			var c = this.getAllNodes();
			if(c.length){
				if(!this.anchor){
					this.anchor = c[0];
					this._addItemClass(this.anchor, "Anchor");
				}
				this.selection[this.anchor.id] = 1;
				if(this.anchor != this.current){
					var i = 0;
					for(; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
					}
					for(++i; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
						this._addItemClass(node, "Selected");
						this.selection[node.id] = 1;
					}
					this._addItemClass(this.current, "Selected");
					this.selection[this.current.id] = 1;
				}
			}
		}else{
			if(this.singular){
				if(this.anchor == this.current){
					if(dojo.isCopyKey(e)){
						this.selectNone();
					}
				}else{
					this.selectNone();
					this.anchor = this.current;
					this._addItemClass(this.anchor, "Anchor");
					this.selection[this.current.id] = 1;
				}
			}else{
				if(dojo.isCopyKey(e)){
					if(this.anchor == this.current){
						delete this.selection[this.anchor.id];
						this._removeAnchor();
					}else{
						if(this.current.id in this.selection){
							this._removeItemClass(this.current, "Selected");
							delete this.selection[this.current.id];
						}else{
							if(this.anchor){
								this._removeItemClass(this.anchor, "Anchor");
								this._addItemClass(this.anchor, "Selected");
							}
							this.anchor = this.current;
							this._addItemClass(this.current, "Anchor");
							this.selection[this.current.id] = 1;
						}
					}
				}else{
					if(!(this.current.id in this.selection)){
						this.selectNone();
						this.anchor = this.current;
						this._addItemClass(this.current, "Anchor");
						this.selection[this.current.id] = 1;
					}
				}
			}
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(!this.simpleSelection){ return; }
		this.simpleSelection = false;
		this.selectNone();
		if(this.current){
			this.anchor = this.current;
			this._addItemClass(this.anchor, "Anchor");
			this.selection[this.current.id] = 1;
		}
	},
	onMouseMove: function(e){
		// summary
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		this.simpleSelection = false;
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		this.onmousemoveEvent = dojo.connect(this.node, "onmousemove", this, "onMouseMove");
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		dojo.disconnect(this.onmousemoveEvent);
		delete this.onmousemoveEvent;
	},
	_removeSelection: function(){
		// summary:
		//		unselects all items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var node = dojo.byId(i);
			if(node){ this._removeItemClass(node, "Selected"); }
		}
		this.selection = {};
		return this;	// self
	},
	_removeAnchor: function(){
		if(this.anchor){
			this._removeItemClass(this.anchor, "Anchor");
			this.anchor = null;
		}
		return this;	// self
	}
});

}

if(!dojo._hasResource["dojo.dnd.Avatar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Avatar"] = true;
dojo.provide("dojo.dnd.Avatar");



dojo.declare("dojo.dnd.Avatar", null, {
	// summary:
	//		Object that represents transferred DnD items visually
	// manager: Object
	//		a DnD manager object

	constructor: function(manager){
		this.manager = manager;
		this.construct();
	},

	// methods
	construct: function(){
		// summary:
		//		constructor function;
		//		it is separate so it can be (dynamically) overwritten in case of need
		this.isA11y = dojo.hasClass(dojo.body(),"dijit_a11y");
		var a = dojo.create("table", {
				"class": "dojoDndAvatar",
				style: {
					position: "absolute",
					zIndex:   "1999",
					margin:   "0px"
				}
			}),
			source = this.manager.source, node,
			b = dojo.create("tbody", null, a),
			tr = dojo.create("tr", null, b),
			td = dojo.create("td", null, tr),
			icon = this.isA11y ? dojo.create("span", {
						id : "a11yIcon",
						innerHTML : this.manager.copy ? '+' : "<"
					}, td) : null,
			span = dojo.create("span", {
				innerHTML: source.generateText ? this._generateText() : ""
			}, td),
			k = Math.min(5, this.manager.nodes.length), i = 0;
		// we have to set the opacity on IE only after the node is live
		dojo.attr(tr, {
			"class": "dojoDndAvatarHeader",
			style: {opacity: 0.9}
		});
		for(; i < k; ++i){
			if(source.creator){
				// create an avatar representation of the node
				node = source._normalizedCreator(source.getItem(this.manager.nodes[i].id).data, "avatar").node;
			}else{
				// or just clone the node and hope it works
				node = this.manager.nodes[i].cloneNode(true);
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					var table = dojo.create("table"),
						tbody = dojo.create("tbody", null, table);
					tbody.appendChild(node);
					node = table;
				}
			}
			node.id = "";
			tr = dojo.create("tr", null, b);
			td = dojo.create("td", null, tr);
			td.appendChild(node);
			dojo.attr(tr, {
				"class": "dojoDndAvatarItem",
				style: {opacity: (9 - i) / 10}
			});
		}
		this.node = a;
	},
	destroy: function(){
		// summary:
		//		destructor for the avatar; called to remove all references so it can be garbage-collected
		dojo.destroy(this.node);
		this.node = false;
	},
	update: function(){
		// summary:
		//		updates the avatar to reflect the current DnD state
		dojo[(this.manager.canDropFlag ? "add" : "remove") + "Class"](this.node, "dojoDndAvatarCanDrop");
		if (this.isA11y){
			var icon = dojo.byId("a11yIcon");
			var text = '+';   // assume canDrop && copy
			if (this.manager.canDropFlag && !this.manager.copy) {
				text = '< '; // canDrop && move
			}else if (!this.manager.canDropFlag && !this.manager.copy) {
				text = "o"; //!canDrop && move
			}else if(!this.manager.canDropFlag){
				text = 'x';  // !canDrop && copy
			}
			icon.innerHTML=text;
		}
		// replace text
		dojo.query(("tr.dojoDndAvatarHeader td span" +(this.isA11y ? " span" : "")), this.node).forEach(
			function(node){
				node.innerHTML = this._generateText();
			}, this);
	},
	_generateText: function(){
		// summary: generates a proper text to reflect copying or moving of items
		return this.manager.nodes.length.toString();
	}
});

}

if(!dojo._hasResource["dojo.dnd.Manager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Manager"] = true;
dojo.provide("dojo.dnd.Manager");





dojo.declare("dojo.dnd.Manager", null, {
	// summary:
	//		the manager of DnD operations (usually a singleton)
	constructor: function(){
		this.avatar  = null;
		this.source = null;
		this.nodes = [];
		this.copy  = true;
		this.target = null;
		this.canDropFlag = false;
		this.events = [];
	},

	// avatar's offset from the mouse
	OFFSET_X: 16,
	OFFSET_Y: 16,
	
	// methods
	overSource: function(source){
		// summary:
		//		called when a source detected a mouse-over condition
		// source: Object
		//		the reporter
		if(this.avatar){
			this.target = (source && source.targetState != "Disabled") ? source : null;
			this.canDropFlag = Boolean(this.target);
			this.avatar.update();
		}
		dojo.publish("/dnd/source/over", [source]);
	},
	outSource: function(source){
		// summary:
		//		called when a source detected a mouse-out condition
		// source: Object
		//		the reporter
		if(this.avatar){
			if(this.target == source){
				this.target = null;
				this.canDropFlag = false;
				this.avatar.update();
				dojo.publish("/dnd/source/over", [null]);
			}
		}else{
			dojo.publish("/dnd/source/over", [null]);
		}
	},
	startDrag: function(source, nodes, copy){
		// summary:
		//		called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		this.source = source;
		this.nodes  = nodes;
		this.copy   = Boolean(copy); // normalizing to true boolean
		this.avatar = this.makeAvatar();
		dojo.body().appendChild(this.avatar.node);
		dojo.publish("/dnd/start", [source, nodes, this.copy]);
		this.events = [
			dojo.connect(dojo.doc, "onmousemove", this, "onMouseMove"),
			dojo.connect(dojo.doc, "onmouseup",   this, "onMouseUp"),
			dojo.connect(dojo.doc, "onkeydown",   this, "onKeyDown"),
			dojo.connect(dojo.doc, "onkeyup",     this, "onKeyUp"),
			// cancel text selection and text dragging
			dojo.connect(dojo.doc, "ondragstart",   dojo.stopEvent),
			dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent)
		];
		var c = "dojoDnd" + (copy ? "Copy" : "Move");
		dojo.addClass(dojo.body(), c);
	},
	canDrop: function(flag){
		// summary:
		//		called to notify if the current target can accept items
		var canDropFlag = Boolean(this.target && flag);
		if(this.canDropFlag != canDropFlag){
			this.canDropFlag = canDropFlag;
			this.avatar.update();
		}
	},
	stopDrag: function(){
		// summary:
		//		stop the DnD in progress
		dojo.removeClass(dojo.body(), ["dojoDndCopy", "dojoDndMove"]);
		dojo.forEach(this.events, dojo.disconnect);
		this.events = [];
		this.avatar.destroy();
		this.avatar = null;
		this.source = this.target = null;
		this.nodes = [];
	},
	makeAvatar: function(){
		// summary:
		//		makes the avatar; it is separate to be overwritten dynamically, if needed
		return new dojo.dnd.Avatar(this);
	},
	updateAvatar: function(){
		// summary:
		//		updates the avatar; it is separate to be overwritten dynamically, if needed
		this.avatar.update();
	},
	
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		var a = this.avatar;
		if(a){
			dojo.dnd.autoScrollNodes(e);
			//dojo.dnd.autoScroll(e);
			var s = a.node.style;
			s.left = (e.pageX + this.OFFSET_X) + "px";
			s.top  = (e.pageY + this.OFFSET_Y) + "px";
			var copy = Boolean(this.source.copyState(dojo.isCopyKey(e)));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.avatar){
			if(this.target && this.canDropFlag){
				var copy = Boolean(this.source.copyState(dojo.isCopyKey(e))),
				params = [this.source, this.nodes, copy, this.target, e];
				dojo.publish("/dnd/drop/before", params);
				dojo.publish("/dnd/drop", params);
			}else{
				dojo.publish("/dnd/cancel");
			}
			this.stopDrag();
		}
	},
	
	// keyboard event processors
	onKeyDown: function(e){
		// summary:
		//		event processor for onkeydown:
		//		watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag
		// e: Event
		//		keyboard event
		if(this.avatar){
			switch(e.keyCode){
				case dojo.keys.CTRL:
					var copy = Boolean(this.source.copyState(true));
					if(this.copy != copy){
						this._setCopyStatus(copy);
					}
					break;
				case dojo.keys.ESCAPE:
					dojo.publish("/dnd/cancel");
					this.stopDrag();
					break;
			}
		}
	},
	onKeyUp: function(e){
		// summary:
		//		event processor for onkeyup, watching for CTRL for copy/move status
		// e: Event
		//		keyboard event
		if(this.avatar && e.keyCode == dojo.keys.CTRL){
			var copy = Boolean(this.source.copyState(false));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},
	
	// utilities
	_setCopyStatus: function(copy){
		// summary:
		//		changes the copy status
		// copy: Boolean
		//		the copy status
		this.copy = copy;
		this.source._markDndStatus(this.copy);
		this.updateAvatar();
		dojo.replaceClass(dojo.body(),
			"dojoDnd" + (this.copy ? "Copy" : "Move"),
			"dojoDnd" + (this.copy ? "Move" : "Copy"));
	}
});

// dojo.dnd._manager:
//		The manager singleton variable. Can be overwritten if needed.
dojo.dnd._manager = null;

dojo.dnd.manager = function(){
	// summary:
	//		Returns the current DnD manager.  Creates one if it is not created yet.
	if(!dojo.dnd._manager){
		dojo.dnd._manager = new dojo.dnd.Manager();
	}
	return dojo.dnd._manager;	// Object
};

}

if(!dojo._hasResource["dojo.dnd.Source"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.dnd.Source"] = true;
dojo.provide("dojo.dnd.Source");




/*
	Container property:
		"Horizontal"- if this is the horizontal container
	Source states:
		""			- normal state
		"Moved"		- this source is being moved
		"Copied"	- this source is being copied
	Target states:
		""			- normal state
		"Disabled"	- the target cannot accept an avatar
	Target anchor state:
		""			- item is not selected
		"Before"	- insert point is before the anchor
		"After"		- insert point is after the anchor
*/

/*=====
dojo.dnd.__SourceArgs = function(){
	//	summary:
	//		a dict of parameters for DnD Source configuration. Note that any
	//		property on Source elements may be configured, but this is the
	//		short-list
	//	isSource: Boolean?
	//		can be used as a DnD source. Defaults to true.
	//	accept: Array?
	//		list of accepted types (text strings) for a target; defaults to
	//		["text"]
	//	autoSync: Boolean
	//		if true refreshes the node list on every operation; false by default
	//	copyOnly: Boolean?
	//		copy items, if true, use a state of Ctrl key otherwise,
	//		see selfCopy and selfAccept for more details
	//	delay: Number
	//		the move delay in pixels before detecting a drag; 0 by default
	//	horizontal: Boolean?
	//		a horizontal container, if true, vertical otherwise or when omitted
	//	selfCopy: Boolean?
	//		copy items by default when dropping on itself,
	//		false by default, works only if copyOnly is true
	//	selfAccept: Boolean?
	//		accept its own items when copyOnly is true,
	//		true by default, works only if copyOnly is true
	//	withHandles: Boolean?
	//		allows dragging only by handles, false by default
	//  generateText: Boolean?
	//		generate text node for drag and drop, true by default
	this.isSource = isSource;
	this.accept = accept;
	this.autoSync = autoSync;
	this.copyOnly = copyOnly;
	this.delay = delay;
	this.horizontal = horizontal;
	this.selfCopy = selfCopy;
	this.selfAccept = selfAccept;
	this.withHandles = withHandles;
	this.generateText = true;
}
=====*/

dojo.declare("dojo.dnd.Source", dojo.dnd.Selector, {
	// summary:
	//		a Source object, which can be used as a DnD source, or a DnD target
	
	// object attributes (for markup)
	isSource: true,
	horizontal: false,
	copyOnly: false,
	selfCopy: false,
	selfAccept: true,
	skipForm: false,
	withHandles: false,
	autoSync: false,
	delay: 0, // pixels
	accept: ["text"],
	generateText: true,
	
	constructor: function(/*DOMNode|String*/node, /*dojo.dnd.__SourceArgs?*/params){
		// summary:
		//		a constructor of the Source
		// node:
		//		node or node's id to build the source on
		// params:
		//		any property of this class may be configured via the params
		//		object which is mixed-in to the `dojo.dnd.Source` instance
		dojo.mixin(this, dojo.mixin({}, params));
		var type = this.accept;
		if(type.length){
			this.accept = {};
			for(var i = 0; i < type.length; ++i){
				this.accept[type[i]] = 1;
			}
		}
		// class-specific variables
		this.isDragging = false;
		this.mouseDown = false;
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
		this._lastX = 0;
		this._lastY = 0;
		// states
		this.sourceState  = "";
		if(this.isSource){
			dojo.addClass(this.node, "dojoDndSource");
		}
		this.targetState  = "";
		if(this.accept){
			dojo.addClass(this.node, "dojoDndTarget");
		}
		if(this.horizontal){
			dojo.addClass(this.node, "dojoDndHorizontal");
		}
		// set up events
		this.topics = [
			dojo.subscribe("/dnd/source/over", this, "onDndSourceOver"),
			dojo.subscribe("/dnd/start",  this, "onDndStart"),
			dojo.subscribe("/dnd/drop",   this, "onDndDrop"),
			dojo.subscribe("/dnd/cancel", this, "onDndCancel")
		];
	},
	
	// methods
	checkAcceptance: function(source, nodes){
		// summary:
		//		checks if the target can accept nodes from this source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		if(this == source){
			return !this.copyOnly || this.selfAccept;
		}
		for(var i = 0; i < nodes.length; ++i){
			var type = source.getItem(nodes[i].id).type;
			// type instanceof Array
			var flag = false;
			for(var j = 0; j < type.length; ++j){
				if(type[j] in this.accept){
					flag = true;
					break;
				}
			}
			if(!flag){
				return false;	// Boolean
			}
		}
		return true;	// Boolean
	},
	copyState: function(keyPressed, self){
		// summary:
		//		Returns true if we need to copy items, false to move.
		//		It is separated to be overwritten dynamically, if needed.
		// keyPressed: Boolean
		//		the "copy" key was pressed
		// self: Boolean?
		//		optional flag that means that we are about to drop on itself
		
		if(keyPressed){ return true; }
		if(arguments.length < 2){
			self = this == dojo.dnd.manager().target;
		}
		if(self){
			if(this.copyOnly){
				return this.selfCopy;
			}
		}else{
			return this.copyOnly;
		}
		return false;	// Boolean
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		dojo.dnd.Source.superclass.destroy.call(this);
		dojo.forEach(this.topics, dojo.unsubscribe);
		this.targetAnchor = null;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Source(node, params);
	},

	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		if(this.isDragging && this.targetState == "Disabled"){ return; }
		dojo.dnd.Source.superclass.onMouseMove.call(this, e);
		var m = dojo.dnd.manager();
		if(!this.isDragging){
			if(this.mouseDown && this.isSource &&
					(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay)){
				var nodes = this.getSelectedNodes();
				if(nodes.length){
					m.startDrag(this, nodes, this.copyState(dojo.isCopyKey(e), true));
				}
			}
		}
		if(this.isDragging){
			// calculate before/after
			var before = false;
			if(this.current){
				if(!this.targetBox || this.targetAnchor != this.current){
					this.targetBox = dojo.position(this.current, true);
				}
				if(this.horizontal){
					before = (e.pageX - this.targetBox.x) < (this.targetBox.w / 2);
				}else{
					before = (e.pageY - this.targetBox.y) < (this.targetBox.h / 2);
				}
			}
			if(this.current != this.targetAnchor || before != this.before){
				this._markTargetAnchor(before);
				m.canDrop(!this.current || m.source != this || !(this.current.id in this.selection));
			}
		}
	},
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(!this.mouseDown && this._legalMouseDown(e) && (!this.skipForm || !dojo.dnd.isFormElement(e))){
			this.mouseDown = true;
			this._lastX = e.pageX;
			this._lastY = e.pageY;
			dojo.dnd.Source.superclass.onMouseDown.call(this, e);
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.mouseDown){
			this.mouseDown = false;
			dojo.dnd.Source.superclass.onMouseUp.call(this, e);
		}
	},
	
	// topic event processors
	onDndSourceOver: function(source){
		// summary:
		//		topic event processor for /dnd/source/over, called when detected a current source
		// source: Object
		//		the source which has the mouse over it
		if(this != source){
			this.mouseDown = false;
			if(this.targetAnchor){
				this._unmarkTargetAnchor();
			}
		}else if(this.isDragging){
			var m = dojo.dnd.manager();
			m.canDrop(this.targetState != "Disabled" && (!this.current || m.source != this || !(this.current.id in this.selection)));
		}
	},
	onDndStart: function(source, nodes, copy){
		// summary:
		//		topic event processor for /dnd/start, called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		if(this.autoSync){ this.sync(); }
		if(this.isSource){
			this._changeState("Source", this == source ? (copy ? "Copied" : "Moved") : "");
		}
		var accepted = this.accept && this.checkAcceptance(source, nodes);
		this._changeState("Target", accepted ? "" : "Disabled");
		if(this == source){
			dojo.dnd.manager().overSource(this);
		}
		this.isDragging = true;
	},
	onDndDrop: function(source, nodes, copy, target){
		// summary:
		//		topic event processor for /dnd/drop, called to finish the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		// target: Object
		//		the target which accepts items
		if(this == target){
			// this one is for us => move nodes!
			this.onDrop(source, nodes, copy);
		}
		this.onDndCancel();
	},
	onDndCancel: function(){
		// summary:
		//		topic event processor for /dnd/cancel, called to cancel the DnD operation
		if(this.targetAnchor){
			this._unmarkTargetAnchor();
			this.targetAnchor = null;
		}
		this.before = true;
		this.isDragging = false;
		this.mouseDown = false;
		this._changeState("Source", "");
		this._changeState("Target", "");
	},
	
	// local events
	onDrop: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		if(this != source){
			this.onDropExternal(source, nodes, copy);
		}else{
			this.onDropInternal(nodes, copy);
		}
	},
	onDropExternal: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from an external source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		var oldCreator = this._normalizedCreator;
		// transferring nodes from the source to the target
		if(this.creator){
			// use defined creator
			this._normalizedCreator = function(node, hint){
				return oldCreator.call(this, source.getItem(node.id).data, hint);
			};
		}else{
			// we have no creator defined => move/clone nodes
			if(copy){
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}else{
				// move nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					source.delItem(node.id);
					return {node: node, data: t.data, type: t.type};
				};
			}
		}
		this.selectNone();
		if(!copy && !this.creator){
			source.selectNone();
		}
		this.insertNodes(true, nodes, this.before, this.current);
		if(!copy && this.creator){
			source.deleteSelectedNodes();
		}
		this._normalizedCreator = oldCreator;
	},
	onDropInternal: function(nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from the same target/source
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		
		var oldCreator = this._normalizedCreator;
		// transferring nodes within the single source
		if(this.current && this.current.id in this.selection){
			// do nothing
			return;
		}
		if(copy){
			if(this.creator){
				// create new copies of data items
				this._normalizedCreator = function(node, hint){
					return oldCreator.call(this, this.getItem(node.id).data, hint);
				};
			}else{
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = this.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}
		}else{
			// move nodes
			if(!this.current){
				// do nothing
				return;
			}
			this._normalizedCreator = function(node, hint){
				var t = this.getItem(node.id);
				return {node: node, data: t.data, type: t.type};
			};
		}
		this._removeSelection();
		this.insertNodes(true, nodes, this.before, this.current);
		this._normalizedCreator = oldCreator;
	},
	onDraggingOver: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged over this target, and it is not disabled
	},
	onDraggingOut: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged away from this target, and it is not disabled
	},
	
	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		dojo.dnd.Source.superclass.onOverEvent.call(this);
		dojo.dnd.manager().overSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOver();
		}
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		dojo.dnd.Source.superclass.onOutEvent.call(this);
		dojo.dnd.manager().outSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOut();
		}
	},
	_markTargetAnchor: function(before){
		// summary:
		//		assigns a class to the current target anchor based on "before" status
		// before: Boolean
		//		insert before, if true, after otherwise
		if(this.current == this.targetAnchor && this.before == before){ return; }
		if(this.targetAnchor){
			this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
		this.targetAnchor = this.current;
		this.targetBox = null;
		this.before = before;
		if(this.targetAnchor){
			this._addItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
	},
	_unmarkTargetAnchor: function(){
		// summary:
		//		removes a class of the current target anchor based on "before" status
		if(!this.targetAnchor){ return; }
		this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
	},
	_markDndStatus: function(copy){
		// summary:
		//		changes source's state based on "copy" status
		this._changeState("Source", copy ? "Copied" : "Moved");
	},
	_legalMouseDown: function(e){
		// summary:
		//		checks if user clicked on "approved" items
		// e: Event
		//		mouse event
		
		// accept only the left mouse button
		if(!dojo.mouseButtons.isLeft(e)){ return false; }
		
		if(!this.withHandles){ return true; }
		
		// check for handles
		for(var node = e.target; node && node !== this.node; node = node.parentNode){
			if(dojo.hasClass(node, "dojoDndHandle")){ return true; }
			if(dojo.hasClass(node, "dojoDndItem") || dojo.hasClass(node, "dojoDndIgnore")){ break; }
		}
		return false;	// Boolean
	}
});

dojo.declare("dojo.dnd.Target", dojo.dnd.Source, {
	// summary: a Target object, which can be used as a DnD target
	
	constructor: function(node, params){
		// summary:
		//		a constructor of the Target --- see the `dojo.dnd.Source.constructor` for details
		this.isSource = false;
		dojo.removeClass(this.node, "dojoDndSource");
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.Target(node, params);
	}
});

dojo.declare("dojo.dnd.AutoSource", dojo.dnd.Source, {
	// summary:
	//		a source that syncs its DnD nodes by default
	
	constructor: function(node, params){
		// summary:
		//		constructor of the AutoSource --- see the Source constructor for details
		this.autoSync = true;
	},

	// markup methods
	markupFactory: function(params, node){
		params._skipStartup = true;
		return new dojo.dnd.AutoSource(node, params);
	}
});

}

if(!dojo._hasResource["dojox.grid._View"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._View"] = true;
dojo.provide("dojox.grid._View");










(function(){
	// a private function
	var getStyleText = function(inNode, inStyleText){
		return inNode.style.cssText == undefined ? inNode.getAttribute("style") : inNode.style.cssText;
	};

	// some public functions
	dojo.declare('dojox.grid._View', [dijit._Widget, dijit._Templated], {
		// summary:
		//		A collection of grid columns. A grid is comprised of a set of views that stack horizontally.
		//		Grid creates views automatically based on grid's layout structure.
		//		Users should typically not need to access individual views directly.
		//
		// defaultWidth: String
		//		Default width of the view
		defaultWidth: "18em",

		// viewWidth: String
		// 		Width for the view, in valid css unit
		viewWidth: "",

		templateString:"<div class=\"dojoxGridView\" role=\"presentation\">\n\t<div class=\"dojoxGridHeader\" dojoAttachPoint=\"headerNode\" role=\"presentation\">\n\t\t<div dojoAttachPoint=\"headerNodeContainer\" style=\"width:100%\" role=\"presentation\">\n\t\t\t<div dojoAttachPoint=\"headerContentNode\" role=\"row\"></div>\n\t\t</div>\n\t</div>\n\t<input type=\"checkbox\" class=\"dojoxGridHiddenFocus\" dojoAttachPoint=\"hiddenFocusNode\" role=\"presentation\" aria-hidden=\"true\"/>\n\t<input type=\"checkbox\" class=\"dojoxGridHiddenFocus\" role=\"presentation\" aria-hidden=\"true\"/>\n\t<div class=\"dojoxGridScrollbox\" dojoAttachPoint=\"scrollboxNode\" role=\"presentation\">\n\t\t<div class=\"dojoxGridContent\" dojoAttachPoint=\"contentNode\" hidefocus=\"hidefocus\" role=\"presentation\"></div>\n\t</div>\n</div>\n",
		
		themeable: false,
		classTag: 'dojoxGrid',
		marginBottom: 0,
		rowPad: 2,

		// _togglingColumn: int
		//		Width of the column being toggled (-1 for none)
		_togglingColumn: -1,
		
		// _headerBuilderClass: Object
		//		The class to use for our header builder
		_headerBuilderClass: dojox.grid._HeaderBuilder,
		
		// _contentBuilderClass: Object
		//		The class to use for our content builder
		_contentBuilderClass: dojox.grid._ContentBuilder,
		
		postMixInProperties: function(){
			this.rowNodes = {};
		},

		postCreate: function(){
			this.connect(this.scrollboxNode,"onscroll","doscroll");
			dojox.grid.util.funnelEvents(this.contentNode, this, "doContentEvent", [ 'mouseover', 'mouseout', 'click', 'dblclick', 'contextmenu', 'mousedown' ]);
			dojox.grid.util.funnelEvents(this.headerNode, this, "doHeaderEvent", [ 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'click', 'contextmenu' ]);
			this.content = new this._contentBuilderClass(this);
			this.header = new this._headerBuilderClass(this);
			//BiDi: in RTL case, style width='9000em' causes scrolling problem in head node
			if(!dojo._isBodyLtr()){
				this.headerNodeContainer.style.width = "";
			}
		},

		destroy: function(){
			dojo.destroy(this.headerNode);
			delete this.headerNode;
			for(var i in this.rowNodes){
				dojo.destroy(this.rowNodes[i]);
			}
			this.rowNodes = {};
			if(this.source){
				this.source.destroy();
			}
			this.inherited(arguments);
		},

		// focus
		focus: function(){
			if(dojo.isIE || dojo.isWebKit || dojo.isOpera){
				this.hiddenFocusNode.focus();
			}else{
				this.scrollboxNode.focus();
			}
		},

		setStructure: function(inStructure){
			var vs = (this.structure = inStructure);
			// FIXME: similar logic is duplicated in layout
			if(vs.width && !isNaN(vs.width)){
				this.viewWidth = vs.width + 'em';
			}else{
				this.viewWidth = vs.width || (vs.noscroll ? 'auto' : this.viewWidth); //|| this.defaultWidth;
			}
			this._onBeforeRow = vs.onBeforeRow||function(){};
			this._onAfterRow = vs.onAfterRow||function(){};
			this.noscroll = vs.noscroll;
			if(this.noscroll){
				this.scrollboxNode.style.overflow = "hidden";
			}
			this.simpleStructure = Boolean(vs.cells.length == 1);
			// bookkeeping
			this.testFlexCells();
			// accomodate new structure
			this.updateStructure();
		},
		
		_cleanupRowWidgets: function(inRowNode){
			// Summary:
			//		Cleans up the widgets for the given row node so that
			//		we can reattach them if needed
			if(inRowNode){
				dojo.forEach(dojo.query("[widgetId]", inRowNode).map(dijit.byNode), function(w){
					if(w._destroyOnRemove){
						w.destroy();
						delete w;
					}else if(w.domNode && w.domNode.parentNode){
						w.domNode.parentNode.removeChild(w.domNode);
					}
				});
			}
		},
		
		onBeforeRow: function(inRowIndex, cells){
			this._onBeforeRow(inRowIndex, cells);
			if(inRowIndex >= 0){
				this._cleanupRowWidgets(this.getRowNode(inRowIndex));
			}
		},
		
		onAfterRow: function(inRowIndex, cells, inRowNode){
			this._onAfterRow(inRowIndex, cells, inRowNode);
			var g = this.grid;
			dojo.forEach(dojo.query(".dojoxGridStubNode", inRowNode), function(n){
				if(n && n.parentNode){
					var lw = n.getAttribute("linkWidget");
					var cellIdx = window.parseInt(dojo.attr(n, "cellIdx"), 10);
					var cellDef = g.getCell(cellIdx);
					var w = dijit.byId(lw);
					if(w){
						n.parentNode.replaceChild(w.domNode, n);
						if(!w._started){
							w.startup();
						}
					}else{
						n.innerHTML = "";
					}
				}
			}, this);
		},

		testFlexCells: function(){
			// FIXME: cheater, this function does double duty as initializer and tester
			this.flexCells = false;
			for(var j=0, row; (row=this.structure.cells[j]); j++){
				for(var i=0, cell; (cell=row[i]); i++){
					cell.view = this;
					this.flexCells = this.flexCells || cell.isFlex();
				}
			}
			return this.flexCells;
		},

		updateStructure: function(){
			// header builder needs to update table map
			this.header.update();
			// content builder needs to update markup cache
			this.content.update();
		},

		getScrollbarWidth: function(){
			var hasScrollSpace = this.hasVScrollbar();
			var overflow = dojo.style(this.scrollboxNode, "overflow");
			if(this.noscroll || !overflow || overflow == "hidden"){
				hasScrollSpace = false;
			}else if(overflow == "scroll"){
				hasScrollSpace = true;
			}
			return (hasScrollSpace ? dojox.html.metrics.getScrollbar().w : 0); // Integer
		},

		getColumnsWidth: function(){
			var h = this.headerContentNode;
			return h && h.firstChild ? h.firstChild.offsetWidth : 0; // Integer
		},

		setColumnsWidth: function(width){
			this.headerContentNode.firstChild.style.width = width + 'px';
			if(this.viewWidth){
				this.viewWidth = width + 'px';
			}
		},

		getWidth: function(){
			return this.viewWidth || (this.getColumnsWidth()+this.getScrollbarWidth()) +'px'; // String
		},

		getContentWidth: function(){
			return Math.max(0, dojo._getContentBox(this.domNode).w - this.getScrollbarWidth()) + 'px'; // String
		},

		render: function(){
			this.scrollboxNode.style.height = '';
			this.renderHeader();
			if(this._togglingColumn >= 0){
				this.setColumnsWidth(this.getColumnsWidth() - this._togglingColumn);
				this._togglingColumn = -1;
			}
			var cells = this.grid.layout.cells;
			var getSibling = dojo.hitch(this, function(node, before){
				!dojo._isBodyLtr() && (before = !before);
				var inc = before?-1:1;
				var idx = this.header.getCellNodeIndex(node) + inc;
				var cell = cells[idx];
				while(cell && cell.getHeaderNode() && cell.getHeaderNode().style.display == "none"){
					idx += inc;
					cell = cells[idx];
				}
				if(cell){
					return cell.getHeaderNode();
				}
				return null;
			});
			if(this.grid.columnReordering && this.simpleStructure){
				if(this.source){
					this.source.destroy();
				}
				
				// Create the top and bottom markers
				var bottomMarkerId = "dojoxGrid_bottomMarker";
				var topMarkerId = "dojoxGrid_topMarker";
				if(this.bottomMarker){
					dojo.destroy(this.bottomMarker);
				}
				this.bottomMarker = dojo.byId(bottomMarkerId);
				if(this.topMarker){
					dojo.destroy(this.topMarker);
				}
				this.topMarker = dojo.byId(topMarkerId);
				if (!this.bottomMarker) {
					this.bottomMarker = dojo.create("div", {
						"id": bottomMarkerId,
						"class": "dojoxGridColPlaceBottom"
					}, dojo.body());
					this._hide(this.bottomMarker);

					
					this.topMarker = dojo.create("div", {
						"id": topMarkerId,
						"class": "dojoxGridColPlaceTop"
					}, dojo.body());
					this._hide(this.topMarker);
				}
				this.arrowDim = dojo.contentBox(this.bottomMarker);

				var headerHeight = dojo.contentBox(this.headerContentNode.firstChild.rows[0]).h;
				
				this.source = new dojo.dnd.Source(this.headerContentNode.firstChild.rows[0], {
					horizontal: true,
					accept: [ "gridColumn_" + this.grid.id ],
					viewIndex: this.index,
					generateText: false,
					onMouseDown: dojo.hitch(this, function(e){
						this.header.decorateEvent(e);
						if((this.header.overRightResizeArea(e) || this.header.overLeftResizeArea(e)) &&
							this.header.canResize(e) && !this.header.moveable){
						// this.header.beginColumnResize(e);
						}else{
							if(this.grid.headerMenu){
								this.grid.headerMenu.onCancel(true);
							}
							// IE reports a left click as 1, where everything else reports 0
							if(e.button === (dojo.isIE ? 1 : 0)){
								dojo.dnd.Source.prototype.onMouseDown.call(this.source, e);
							}
						}
					}),
					onMouseOver: dojo.hitch(this, function(e){
						var src = this.source;
						if(src._getChildByEvent(e)){
							dojo.dnd.Source.prototype.onMouseOver.apply(src, arguments);
						}
					}),
					_markTargetAnchor: dojo.hitch(this, function(before){
						var src = this.source;
						if(src.current == src.targetAnchor && src.before == before){ return; }
						if(src.targetAnchor && getSibling(src.targetAnchor, src.before)){
							src._removeItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
						}
						dojo.dnd.Source.prototype._markTargetAnchor.call(src, before);
						
						var target = before ? src.targetAnchor : getSibling(src.targetAnchor, src.before);
						var endAdd = 0;

						if (!target) {
							target = src.targetAnchor;
							endAdd = dojo.contentBox(target).w + this.arrowDim.w/2 + 2;
						}

						// NOTE: this is for backwards compatibility with Dojo 1.3
						var pos = (dojo.position||dojo._abs)(target, true);
						var left = Math.floor(pos.x - this.arrowDim.w/2 + endAdd);

						dojo.style(this.bottomMarker, "visibility", "visible");
						dojo.style(this.topMarker, "visibility", "visible");
						dojo.style(this.bottomMarker, {
							"left": left + "px",
							"top" : (headerHeight + pos.y) + "px"
						});

						dojo.style(this.topMarker, {
							"left": left + "px",
							"top" : (pos.y - this.arrowDim.h) + "px"
						});

						if(src.targetAnchor && getSibling(src.targetAnchor, src.before)){
							src._addItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
						}
					}),
					_unmarkTargetAnchor: dojo.hitch(this, function(){
						var src = this.source;
						if(!src.targetAnchor){ return; }
						if(src.targetAnchor && getSibling(src.targetAnchor, src.before)){
							src._removeItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
						}
						this._hide(this.bottomMarker);
						this._hide(this.topMarker);
						dojo.dnd.Source.prototype._unmarkTargetAnchor.call(src);
					}),
					destroy: dojo.hitch(this, function(){
						dojo.disconnect(this._source_conn);
						dojo.unsubscribe(this._source_sub);
						dojo.dnd.Source.prototype.destroy.call(this.source);
						if(this.bottomMarker){
							dojo.destroy(this.bottomMarker);
							delete this.bottomMarker;
						}
						if(this.topMarker){
							dojo.destroy(this.topMarker);
							delete this.topMarker;
						}
					}),
					onDndCancel: dojo.hitch(this, function(){
						dojo.dnd.Source.prototype.onDndCancel.call(this.source);
						this._hide(this.bottomMarker);
						this._hide(this.topMarker);
					})
				});

				this._source_conn = dojo.connect(this.source, "onDndDrop", this, "_onDndDrop");
				this._source_sub = dojo.subscribe("/dnd/drop/before", this, "_onDndDropBefore");
				this.source.startup();
			}
		},
		
		_hide: function(node){
			dojo.style(node, {
				left: "-10000px",
				top: "-10000px",
				"visibility": "hidden"
			});
		},

		_onDndDropBefore: function(source, nodes, copy){
			if(dojo.dnd.manager().target !== this.source){
				return;
			}
			this.source._targetNode = this.source.targetAnchor;
			this.source._beforeTarget = this.source.before;
			var views = this.grid.views.views;
			var srcView = views[source.viewIndex];
			var tgtView = views[this.index];
			if(tgtView != srcView){
				srcView.convertColPctToFixed();
				tgtView.convertColPctToFixed();
			}
		},

		_onDndDrop: function(source, nodes, copy){
			if(dojo.dnd.manager().target !== this.source){
				if(dojo.dnd.manager().source === this.source){
					this._removingColumn = true;
				}
				return;
			}
			this._hide(this.bottomMarker);
			this._hide(this.topMarker);

			var getIdx = function(n){
				return n ? dojo.attr(n, "idx") : null;
			};
			var w = dojo.marginBox(nodes[0]).w;
			if(source.viewIndex !== this.index){
				var views = this.grid.views.views;
				var srcView = views[source.viewIndex];
				var tgtView = views[this.index];
				if(srcView.viewWidth && srcView.viewWidth != "auto"){
					srcView.setColumnsWidth(srcView.getColumnsWidth() - w);
				}
				if(tgtView.viewWidth && tgtView.viewWidth != "auto"){
					tgtView.setColumnsWidth(tgtView.getColumnsWidth());
				}
			}
			var stn = this.source._targetNode;
			var stb = this.source._beforeTarget;
			!dojo._isBodyLtr() && (stb = !stb);
			var layout = this.grid.layout;
			var idx = this.index;
			delete this.source._targetNode;
			delete this.source._beforeTarget;
			
			layout.moveColumn(
				source.viewIndex,
				idx,
				getIdx(nodes[0]),
				getIdx(stn),
				stb);
		},

		renderHeader: function(){
			this.headerContentNode.innerHTML = this.header.generateHtml(this._getHeaderContent);
			if(this.flexCells){
				this.contentWidth = this.getContentWidth();
				this.headerContentNode.firstChild.style.width = this.contentWidth;
			}
			dojox.grid.util.fire(this, "onAfterRow", [-1, this.structure.cells, this.headerContentNode]);
		},

		// note: not called in 'view' context
		_getHeaderContent: function(inCell){
			var n = inCell.name || inCell.grid.getCellName(inCell);
			var ret = [ '<div class="dojoxGridSortNode' ];
			
			if(inCell.index != inCell.grid.getSortIndex()){
				ret.push('">');
			}else{
				ret = ret.concat([ ' ',
							inCell.grid.sortInfo > 0 ? 'dojoxGridSortUp' : 'dojoxGridSortDown',
							'"><div class="dojoxGridArrowButtonChar">',
							inCell.grid.sortInfo > 0 ? '&#9650;' : '&#9660;',
							'</div><div class="dojoxGridArrowButtonNode" role="presentation"></div>',
							'<div class="dojoxGridColCaption">']);
			}
			ret = ret.concat([n, '</div></div>']);
			return ret.join('');
		},

		resize: function(){
			this.adaptHeight();
			this.adaptWidth();
		},

		hasHScrollbar: function(reset){
			var hadScroll = this._hasHScroll||false;
			if(this._hasHScroll == undefined || reset){
				if(this.noscroll){
					this._hasHScroll = false;
				}else{
					var style = dojo.style(this.scrollboxNode, "overflow");
					if(style == "hidden"){
						this._hasHScroll = false;
					}else if(style == "scroll"){
						this._hasHScroll = true;
					}else{
						this._hasHScroll = (this.scrollboxNode.offsetWidth - this.getScrollbarWidth() < this.contentNode.offsetWidth );
					}
				}
			}
			if(hadScroll !== this._hasHScroll){
				this.grid.update();
			}
			return this._hasHScroll; // Boolean
		},

		hasVScrollbar: function(reset){
			var hadScroll = this._hasVScroll||false;
			if(this._hasVScroll == undefined || reset){
				if(this.noscroll){
					this._hasVScroll = false;
				}else{
					var style = dojo.style(this.scrollboxNode, "overflow");
					if(style == "hidden"){
						this._hasVScroll = false;
					}else if(style == "scroll"){
						this._hasVScroll = true;
					}else{
						this._hasVScroll = (this.scrollboxNode.scrollHeight > this.scrollboxNode.clientHeight);
					}
				}
			}
			if(hadScroll !== this._hasVScroll){
				this.grid.update();
			}
			return this._hasVScroll; // Boolean
		},
		
		convertColPctToFixed: function(){
			// Fix any percentage widths to be pixel values
			var hasPct = false;
			this.grid.initialWidth = "";
			var cellNodes = dojo.query("th", this.headerContentNode);
			var fixedWidths = dojo.map(cellNodes, function(c, vIdx){
				var w = c.style.width;
				dojo.attr(c, "vIdx", vIdx);
				if(w && w.slice(-1) == "%"){
					hasPct = true;
				}else if(w && w.slice(-2) == "px"){
					return window.parseInt(w, 10);
				}
				return dojo.contentBox(c).w;
			});
			if(hasPct){
				dojo.forEach(this.grid.layout.cells, function(cell, idx){
					if(cell.view == this){
						var cellNode = cell.view.getHeaderCellNode(cell.index);
						if(cellNode && dojo.hasAttr(cellNode, "vIdx")){
							var vIdx = window.parseInt(dojo.attr(cellNode, "vIdx"));
							this.setColWidth(idx, fixedWidths[vIdx]);
							dojo.removeAttr(cellNode, "vIdx");
						}
					}
				}, this);
				return true;
			}
			return false;
		},

		adaptHeight: function(minusScroll){
			if(!this.grid._autoHeight){
				var h = (this.domNode.style.height && parseInt(this.domNode.style.height.replace(/px/,''), 10)) || this.domNode.clientHeight;
				var self = this;
				var checkOtherViewScrollers = function(){
					var v;
					for(var i in self.grid.views.views){
						v = self.grid.views.views[i];
						if(v !== self && v.hasHScrollbar()){
							return true;
						}
					}
					return false;
				};
				if(minusScroll || (this.noscroll && checkOtherViewScrollers())){
					h -= dojox.html.metrics.getScrollbar().h;
				}
				dojox.grid.util.setStyleHeightPx(this.scrollboxNode, h);
			}
			this.hasVScrollbar(true);
		},

		adaptWidth: function(){
			if(this.flexCells){
				// the view content width
				this.contentWidth = this.getContentWidth();
				this.headerContentNode.firstChild.style.width = this.contentWidth;
			}
			// FIXME: it should be easier to get w from this.scrollboxNode.clientWidth,
			// but clientWidth seemingly does not include scrollbar width in some cases
			var w = this.scrollboxNode.offsetWidth - this.getScrollbarWidth();
			if(!this._removingColumn){
				w = Math.max(w, this.getColumnsWidth()) + 'px';
			}else{
				w = Math.min(w, this.getColumnsWidth()) + 'px';
				this._removingColumn = false;
			}
			var cn = this.contentNode;
			cn.style.width = w;
			this.hasHScrollbar(true);
		},

		setSize: function(w, h){
			var ds = this.domNode.style;
			var hs = this.headerNode.style;

			if(w){
				ds.width = w;
				hs.width = w;
			}
			ds.height = (h >= 0 ? h + 'px' : '');
		},

		renderRow: function(inRowIndex){
			var rowNode = this.createRowNode(inRowIndex);
			this.buildRow(inRowIndex, rowNode);
			this.grid.edit.restore(this, inRowIndex);
			return rowNode;
		},

		createRowNode: function(inRowIndex){
			var node = document.createElement("div");
			node.className = this.classTag + 'Row';
			if (this instanceof dojox.grid._RowSelector){
				dojo.attr(node,"role","presentation");
			}else{
				dojo.attr(node,"role","row");
				if (this.grid.selectionMode != "none") {
					dojo.attr(node, "aria-selected", "false"); //rows can be selected so add aria-selected prop
				}
			}
			node[dojox.grid.util.gridViewTag] = this.id;
			node[dojox.grid.util.rowIndexTag] = inRowIndex;
			this.rowNodes[inRowIndex] = node;
			return node;
		},

		buildRow: function(inRowIndex, inRowNode){
			
			this.buildRowContent(inRowIndex, inRowNode);
		  	
			this.styleRow(inRowIndex, inRowNode);
		  
		 
		},

		buildRowContent: function(inRowIndex, inRowNode){
			inRowNode.innerHTML = this.content.generateHtml(inRowIndex, inRowIndex);
			if(this.flexCells && this.contentWidth){
				// FIXME: accessing firstChild here breaks encapsulation
				inRowNode.firstChild.style.width = this.contentWidth;
			}
			dojox.grid.util.fire(this, "onAfterRow", [inRowIndex, this.structure.cells, inRowNode]);
		},

		rowRemoved:function(inRowIndex){
			if(inRowIndex >= 0){
				this._cleanupRowWidgets(this.getRowNode(inRowIndex));
			}
			this.grid.edit.save(this, inRowIndex);
			delete this.rowNodes[inRowIndex];
		},

		getRowNode: function(inRowIndex){
			return this.rowNodes[inRowIndex];
		},

		getCellNode: function(inRowIndex, inCellIndex){
			var row = this.getRowNode(inRowIndex);
			if(row){
				return this.content.getCellNode(row, inCellIndex);
			}
		},

		getHeaderCellNode: function(inCellIndex){
			if(this.headerContentNode){
				return this.header.getCellNode(this.headerContentNode, inCellIndex);
			}
		},

		// styling
		styleRow: function(inRowIndex, inRowNode){
			inRowNode._style = getStyleText(inRowNode);
			this.styleRowNode(inRowIndex, inRowNode);
		},

		styleRowNode: function(inRowIndex, inRowNode){
			if(inRowNode){
				this.doStyleRowNode(inRowIndex, inRowNode);
			}
		},

		doStyleRowNode: function(inRowIndex, inRowNode){
			this.grid.styleRowNode(inRowIndex, inRowNode);
		},

		// updating
		updateRow: function(inRowIndex){
			var rowNode = this.getRowNode(inRowIndex);
			if(rowNode){
				rowNode.style.height = '';
				this.buildRow(inRowIndex, rowNode);
			}
			return rowNode;
		},

		updateRowStyles: function(inRowIndex){
			this.styleRowNode(inRowIndex, this.getRowNode(inRowIndex));
		},

		// scrolling
		lastTop: 0,
		firstScroll:0,

		doscroll: function(inEvent){
			//var s = dojo.marginBox(this.headerContentNode.firstChild);
			var isLtr = dojo._isBodyLtr();
			if(this.firstScroll < 2){
				if((!isLtr && this.firstScroll == 1) || (isLtr && this.firstScroll === 0)){
					var s = dojo.marginBox(this.headerNodeContainer);
					if(dojo.isIE){
						this.headerNodeContainer.style.width = s.w + this.getScrollbarWidth() + 'px';
					}else if(dojo.isMoz){
						//TODO currently only for FF, not sure for safari and opera
						this.headerNodeContainer.style.width = s.w - this.getScrollbarWidth() + 'px';
						//this.headerNodeContainer.style.width = s.w + 'px';
						//set scroll to right in FF
						this.scrollboxNode.scrollLeft = isLtr ?
							this.scrollboxNode.clientWidth - this.scrollboxNode.scrollWidth :
							this.scrollboxNode.scrollWidth - this.scrollboxNode.clientWidth;
					}
				}
				this.firstScroll++;
			}
			this.headerNode.scrollLeft = this.scrollboxNode.scrollLeft;
			// 'lastTop' is a semaphore to prevent feedback-loop with setScrollTop below
			var top = this.scrollboxNode.scrollTop;
			if(top !== this.lastTop){
				this.grid.scrollTo(top);
			}
		},

		setScrollTop: function(inTop){
			// 'lastTop' is a semaphore to prevent feedback-loop with doScroll above
			this.lastTop = inTop;
			this.scrollboxNode.scrollTop = inTop;
			return this.scrollboxNode.scrollTop;
		},

		// event handlers (direct from DOM)
		doContentEvent: function(e){
			if(this.content.decorateEvent(e)){
				this.grid.onContentEvent(e);
			}
		},

		doHeaderEvent: function(e){
			if(this.header.decorateEvent(e)){
				this.grid.onHeaderEvent(e);
			}
		},

		// event dispatch(from Grid)
		dispatchContentEvent: function(e){
			return this.content.dispatchEvent(e);
		},

		dispatchHeaderEvent: function(e){
			return this.header.dispatchEvent(e);
		},

		// column resizing
		setColWidth: function(inIndex, inWidth){
			this.grid.setCellWidth(inIndex, inWidth + 'px');
		},

		update: function(){
			if(!this.domNode){
				return;
			}
			this.content.update();
			this.grid.update();
			//get scroll after update or scroll left setting goes wrong on IE.
			//See trac: #8040
			var left = this.scrollboxNode.scrollLeft;
			this.scrollboxNode.scrollLeft = left;
			this.headerNode.scrollLeft = left;
		}
	});

	dojo.declare("dojox.grid._GridAvatar", dojo.dnd.Avatar, {
		construct: function(){
			var dd = dojo.doc;

			var a = dd.createElement("table");
			a.cellPadding = a.cellSpacing = "0";
			a.className = "dojoxGridDndAvatar";
			a.style.position = "absolute";
			a.style.zIndex = 1999;
			a.style.margin = "0px"; // to avoid dojo.marginBox() problems with table's margins
			var b = dd.createElement("tbody");
			var tr = dd.createElement("tr");
			var td = dd.createElement("td");
			var img = dd.createElement("td");
			tr.className = "dojoxGridDndAvatarItem";
			img.className = "dojoxGridDndAvatarItemImage";
			img.style.width = "16px";
			var source = this.manager.source, node;
			if(source.creator){
				// create an avatar representation of the node
				node = source._normalizedCreator(source.getItem(this.manager.nodes[0].id).data, "avatar").node;
			}else{
				// or just clone the node and hope it works
				node = this.manager.nodes[0].cloneNode(true);
				var table, tbody;
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					table = dd.createElement("table");
					tbody = dd.createElement("tbody");
					tbody.appendChild(node);
					table.appendChild(tbody);
					node = table;
				}else if(node.tagName.toLowerCase() == "th"){
					// insert extra table nodes
					table = dd.createElement("table");
					tbody = dd.createElement("tbody");
					var r = dd.createElement("tr");
					table.cellPadding = table.cellSpacing = "0";
					r.appendChild(node);
					tbody.appendChild(r);
					table.appendChild(tbody);
					node = table;
				}
			}
			node.id = "";
			td.appendChild(node);
			tr.appendChild(img);
			tr.appendChild(td);
			dojo.style(tr, "opacity", 0.9);
			b.appendChild(tr);

			a.appendChild(b);
			this.node = a;

			var m = dojo.dnd.manager();
			this.oldOffsetY = m.OFFSET_Y;
			m.OFFSET_Y = 1;
		},
		destroy: function(){
			dojo.dnd.manager().OFFSET_Y = this.oldOffsetY;
			this.inherited(arguments);
		}
	});

	var oldMakeAvatar = dojo.dnd.manager().makeAvatar;
	dojo.dnd.manager().makeAvatar = function(){
		var src = this.source;
		if(src.viewIndex !== undefined && !dojo.hasClass(dojo.body(),"dijit_a11y")){
			return new dojox.grid._GridAvatar(this);
		}
		return oldMakeAvatar.call(dojo.dnd.manager());
	};
})();

}

if(!dojo._hasResource["dojox.grid._RowSelector"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._RowSelector"] = true;
dojo.provide("dojox.grid._RowSelector");


dojo.declare('dojox.grid._RowSelector', dojox.grid._View, {
	// summary:
	//	Custom grid view. If used in a grid structure, provides a small selectable region for grid rows.
	defaultWidth: "2em",
	noscroll: true,
	padBorderWidth: 2,
	buildRendering: function(){
		this.inherited('buildRendering', arguments);
		this.scrollboxNode.style.overflow = "hidden";
		this.headerNode.style.visibility = "hidden";
	},
	getWidth: function(){
		return this.viewWidth || this.defaultWidth;
	},
	buildRowContent: function(inRowIndex, inRowNode){
		var w = this.contentWidth || 0;
		inRowNode.innerHTML = '<table class="dojoxGridRowbarTable" style="width:' + w + 'px;height:1px;" border="0" cellspacing="0" cellpadding="0" role="presentation"><tr><td class="dojoxGridRowbarInner">&nbsp;</td></tr></table>';
	},
	renderHeader: function(){
	},
	updateRow: function(){
	},
	resize: function(){
		this.adaptHeight();
	},
	adaptWidth: function(){
		// Only calculate this here - rather than every call to buildRowContent
		if(!("contentWidth" in this) && this.contentNode){
			this.contentWidth = this.contentNode.offsetWidth - this.padBorderWidth;
		}
	},
	// styling
	doStyleRowNode: function(inRowIndex, inRowNode){
		var n = [ "dojoxGridRowbar dojoxGridNonNormalizedCell" ];
		if(this.grid.rows.isOver(inRowIndex)){
			n.push("dojoxGridRowbarOver");
		}
		if(this.grid.selection.isSelected(inRowIndex)){
			n.push("dojoxGridRowbarSelected");
		}
		inRowNode.className = n.join(" ");
	},
	// event handlers
	domouseover: function(e){
		this.grid.onMouseOverRow(e);
	},
	domouseout: function(e){
		if(!this.isIntraRowEvent(e)){
			this.grid.onMouseOutRow(e);
		}
	}
});

}

if(!dojo._hasResource["dojox.grid._Layout"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._Layout"] = true;
dojo.provide("dojox.grid._Layout");



dojo.declare("dojox.grid._Layout", null, {
	// summary:
	//	Controls grid cell layout. Owned by grid and used internally.
	constructor: function(inGrid){
		this.grid = inGrid;
	},
	// flat array of grid cells
	cells: [],
	// structured array of grid cells
	structure: null,
	// default cell width
	defaultWidth: '6em',

	// methods
	moveColumn: function(sourceViewIndex, destViewIndex, cellIndex, targetIndex, before){
		var source_cells = this.structure[sourceViewIndex].cells[0];
		var dest_cells = this.structure[destViewIndex].cells[0];

		var cell = null;
		var cell_ri = 0;
		var target_ri = 0;

		for(var i=0, c; c=source_cells[i]; i++){
			if(c.index == cellIndex){
				cell_ri = i;
				break;
			}
		}
		cell = source_cells.splice(cell_ri, 1)[0];
		cell.view = this.grid.views.views[destViewIndex];

		for(i=0, c=null; c=dest_cells[i]; i++){
			if(c.index == targetIndex){
				target_ri = i;
				break;
			}
		}
		if(!before){
			target_ri += 1;
		}
		dest_cells.splice(target_ri, 0, cell);

		var sortedCell = this.grid.getCell(this.grid.getSortIndex());
		if(sortedCell){
			sortedCell._currentlySorted = this.grid.getSortAsc();
		}

		this.cells = [];
		cellIndex = 0;
		var v;
		for(i=0; v=this.structure[i]; i++){
			for(var j=0, cs; cs=v.cells[j]; j++){
				for(var k=0; c=cs[k]; k++){
					c.index = cellIndex;
					this.cells.push(c);
					if("_currentlySorted" in c){
						var si = cellIndex + 1;
						si *= c._currentlySorted ? 1 : -1;
						this.grid.sortInfo = si;
						delete c._currentlySorted;
					}
					cellIndex++;
				}
			}
		}
		
		//Fix #9481 - reset idx in cell markup
		dojo.forEach(this.cells, function(c){
			var marks = c.markup[2].split(" ");
			var oldIdx = parseInt(marks[1].substring(5));//get old "idx"
			if(oldIdx != c.index){
				marks[1] = "idx=\"" + c.index + "\"";
				c.markup[2] = marks.join(" ");
			}
		});
		
		this.grid.setupHeaderMenu();
		//this.grid.renderOnIdle();
	},

	setColumnVisibility: function(columnIndex, visible){
		var cell = this.cells[columnIndex];
		if(cell.hidden == visible){
			cell.hidden = !visible;
			var v = cell.view, w = v.viewWidth;
			if(w && w != "auto"){
				v._togglingColumn = dojo.marginBox(cell.getHeaderNode()).w || 0;
			}
			v.update();
			return true;
		}else{
			return false;
		}
	},
	
	addCellDef: function(inRowIndex, inCellIndex, inDef){
		var self = this;
		var getCellWidth = function(inDef){
			var w = 0;
			if(inDef.colSpan > 1){
				w = 0;
			}else{
				w = inDef.width || self._defaultCellProps.width || self.defaultWidth;

				if(!isNaN(w)){
					w = w + "em";
				}
			}
			return w;
		};

		var props = {
			grid: this.grid,
			subrow: inRowIndex,
			layoutIndex: inCellIndex,
			index: this.cells.length
		};

		if(inDef && inDef instanceof dojox.grid.cells._Base){
			var new_cell = dojo.clone(inDef);
			props.unitWidth = getCellWidth(new_cell._props);
			new_cell = dojo.mixin(new_cell, this._defaultCellProps, inDef._props, props);
			return new_cell;
		}

		var cell_type = inDef.type || inDef.cellType || this._defaultCellProps.type || this._defaultCellProps.cellType || dojox.grid.cells.Cell;

		props.unitWidth = getCellWidth(inDef);
		return new cell_type(dojo.mixin({}, this._defaultCellProps, inDef, props));
	},
	
	addRowDef: function(inRowIndex, inDef){
		var result = [];
		var relSum = 0, pctSum = 0, doRel = true;
		for(var i=0, def, cell; (def=inDef[i]); i++){
			cell = this.addCellDef(inRowIndex, i, def);
			result.push(cell);
			this.cells.push(cell);
			// Check and calculate the sum of all relative widths
			if(doRel && cell.relWidth){
				relSum += cell.relWidth;
			}else if(cell.width){
				var w = cell.width;
				if(typeof w == "string" && w.slice(-1) == "%"){
					pctSum += window.parseInt(w, 10);
				}else if(w == "auto"){
					// relative widths doesn't play nice with auto - since we
					// don't have a way of knowing how much space the auto is
					// supposed to take up.
					doRel = false;
				}
			}
		}
		if(relSum && doRel){
			// We have some kind of relWidths specified - so change them to %
			dojo.forEach(result, function(cell){
				if(cell.relWidth){
					cell.width = cell.unitWidth = ((cell.relWidth / relSum) * (100 - pctSum)) + "%";
				}
			});
		}
		return result;
	
	},

	addRowsDef: function(inDef){
		var result = [];
		if(dojo.isArray(inDef)){
			if(dojo.isArray(inDef[0])){
				for(var i=0, row; inDef && (row=inDef[i]); i++){
					result.push(this.addRowDef(i, row));
				}
			}else{
				result.push(this.addRowDef(0, inDef));
			}
		}
		return result;
	},
	
	addViewDef: function(inDef){
		this._defaultCellProps = inDef.defaultCell || {};
		if(inDef.width && inDef.width == "auto"){
			delete inDef.width;
		}
		return dojo.mixin({}, inDef, {cells: this.addRowsDef(inDef.rows || inDef.cells)});
	},
	
	setStructure: function(inStructure){
		this.fieldIndex = 0;
		this.cells = [];
		var s = this.structure = [];

		if(this.grid.rowSelector){
			var sel = { type: dojox._scopeName + ".grid._RowSelector" };

			if(dojo.isString(this.grid.rowSelector)){
				var width = this.grid.rowSelector;

				if(width == "false"){
					sel = null;
				}else if(width != "true"){
					sel['width'] = width;
				}
			}else{
				if(!this.grid.rowSelector){
					sel = null;
				}
			}

			if(sel){
				s.push(this.addViewDef(sel));
			}
		}

		var isCell = function(def){
			return ("name" in def || "field" in def || "get" in def);
		};

		var isRowDef = function(def){
			if(dojo.isArray(def)){
				if(dojo.isArray(def[0]) || isCell(def[0])){
					return true;
				}
			}
			return false;
		};

		var isView = function(def){
			return (def !== null && dojo.isObject(def) &&
					("cells" in def || "rows" in def || ("type" in def && !isCell(def))));
		};

		if(dojo.isArray(inStructure)){
			var hasViews = false;
			for(var i=0, st; (st=inStructure[i]); i++){
				if(isView(st)){
					hasViews = true;
					break;
				}
			}
			if(!hasViews){
				s.push(this.addViewDef({ cells: inStructure }));
			}else{
				for(i=0; (st=inStructure[i]); i++){
					if(isRowDef(st)){
						s.push(this.addViewDef({ cells: st }));
					}else if(isView(st)){
						s.push(this.addViewDef(st));
					}
				}
			}
		}else if(isView(inStructure)){
			// it's a view object
			s.push(this.addViewDef(inStructure));
		}

		this.cellCount = this.cells.length;
		this.grid.setupHeaderMenu();
	}
});

}

if(!dojo._hasResource["dojox.grid._ViewManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._ViewManager"] = true;
dojo.provide("dojox.grid._ViewManager");

dojo.declare('dojox.grid._ViewManager', null, {
	// summary:
	//		A collection of grid views. Owned by grid and used internally for managing grid views.
	// description:
	//		Grid creates views automatically based on grid's layout structure.
	//		Users should typically not need to access individual views or the views collection directly.
	constructor: function(inGrid){
		this.grid = inGrid;
	},

	defaultWidth: 200,

	views: [],

	// operations
	resize: function(){
		this.onEach("resize");
	},

	render: function(){
		this.onEach("render");
	},

	// views
	addView: function(inView){
		inView.idx = this.views.length;
		this.views.push(inView);
	},

	destroyViews: function(){
		for(var i=0, v; v=this.views[i]; i++){
			v.destroy();
		}
		this.views = [];
	},

	getContentNodes: function(){
		var nodes = [];
		for(var i=0, v; v=this.views[i]; i++){
			nodes.push(v.contentNode);
		}
		return nodes;
	},

	forEach: function(inCallback){
		for(var i=0, v; v=this.views[i]; i++){
			inCallback(v, i);
		}
	},

	onEach: function(inMethod, inArgs){
		inArgs = inArgs || [];
		for(var i=0, v; v=this.views[i]; i++){
			if(inMethod in v){
				v[inMethod].apply(v, inArgs);
			}
		}
	},

	// layout
	normalizeHeaderNodeHeight: function(){
		var rowNodes = [];
		for(var i=0, v; (v=this.views[i]); i++){
			if(v.headerContentNode.firstChild){
				rowNodes.push(v.headerContentNode);
			}
		}
		this.normalizeRowNodeHeights(rowNodes);
	},

	normalizeRowNodeHeights: function(inRowNodes){
		var h = 0;
		var currHeights = [];
		if(this.grid.rowHeight){
			h = this.grid.rowHeight;
		}else{
			if(inRowNodes.length <= 1){
				// no need to normalize if we are the only one...
				return;
			}
			for(var i=0, n; (n=inRowNodes[i]); i++){
				// We only care about the height - so don't use marginBox.  This
				// depends on the container not having any margin (which it shouldn't)
				// Also - we only look up the height if the cell doesn't have the
				// dojoxGridNonNormalizedCell class (like for row selectors)
				if(!dojo.hasClass(n, "dojoxGridNonNormalizedCell")){
					currHeights[i] = n.firstChild.offsetHeight;
					h =  Math.max(h, currHeights[i]);
				}
			}
			h = (h >= 0 ? h : 0);
	
			//Work around odd FF3 rendering bug: #8864.
			//A one px increase fixes FireFox 3's rounding bug for fractional font sizes.
			if(dojo.isMoz && h){h++;}
		}
		for(i=0; (n=inRowNodes[i]); i++){
			if(currHeights[i] != h){
				n.firstChild.style.height = h + "px";
			}
		}
	},
	
	resetHeaderNodeHeight: function(){
		for(var i=0, v, n; (v=this.views[i]); i++){
			n = v.headerContentNode.firstChild;
			if(n){
				n.style.height = "";
			}
		}
	},

	renormalizeRow: function(inRowIndex){
		var rowNodes = [];
		for(var i=0, v, n; (v=this.views[i])&&(n=v.getRowNode(inRowIndex)); i++){
			n.firstChild.style.height = '';
			rowNodes.push(n);
		}
		this.normalizeRowNodeHeights(rowNodes);
	},

	getViewWidth: function(inIndex){
		return this.views[inIndex].getWidth() || this.defaultWidth;
	},

	// must be called after view widths are properly set or height can be miscalculated
	// if there are flex columns
	measureHeader: function(){
		// need to reset view header heights so they are properly measured.
		this.resetHeaderNodeHeight();
		this.forEach(function(inView){
			inView.headerContentNode.style.height = '';
		});
		var h = 0;
		// calculate maximum view header height
		this.forEach(function(inView){
			h = Math.max(inView.headerNode.offsetHeight, h);
		});
		return h;
	},

	measureContent: function(){
		var h = 0;
		this.forEach(function(inView){
			h = Math.max(inView.domNode.offsetHeight, h);
		});
		return h;
	},

	findClient: function(inAutoWidth){
		// try to use user defined client
		var c = this.grid.elasticView || -1;
		// attempt to find implicit client
		if(c < 0){
			for(var i=1, v; (v=this.views[i]); i++){
				if(v.viewWidth){
					for(i=1; (v=this.views[i]); i++){
						if(!v.viewWidth){
							c = i;
							break;
						}
					}
					break;
				}
			}
		}
		// client is in the middle by default
		if(c < 0){
			c = Math.floor(this.views.length / 2);
		}
		return c;
	},

	arrange: function(l, w){
		var i, v, vw, len = this.views.length;
		// find the client
		var c = (w <= 0 ? len : this.findClient());
		// layout views
		var setPosition = function(v, l){
			var ds = v.domNode.style;
			var hs = v.headerNode.style;

			if(!dojo._isBodyLtr()){
				ds.right = l + 'px';
				// fixed rtl, the scrollbar is on the right side in FF
				if (dojo.isMoz) {
					hs.right = l + 'px';
					hs.width = parseInt(hs.width, 10) - v.getScrollbarWidth() + 'px';
				}else if(dojo.isChrome){
				if(v.hasHScrollbar() || v.hasVScrollbar())
				{
					hs.left = 0 + 'px';
					hs.width = parseInt(hs.width, 10) - v.getScrollbarWidth() + 'px';
				}
				else{
				hs.right = 0 + 'px';
				}
			
					
					
				}
				else{
					hs.right = l + 'px';
				}
			}else{
				ds.left = l + 'px';
				hs.left = l + 'px';
				
			}
			ds.top = 0 + 'px';
			hs.top = 0;
		};
		// for views left of the client
		//BiDi TODO: The left and right should not appear in BIDI environment. Should be replaced with
		//leading and tailing concept.
		for(i=0; (v=this.views[i])&&(i<c); i++){
			// get width
			vw = this.getViewWidth(i);
			// process boxes
			v.setSize(vw, 0);
			setPosition(v, l);
			if(v.headerContentNode && v.headerContentNode.firstChild){
				vw = v.getColumnsWidth()+v.getScrollbarWidth();
			}else{
				vw = v.domNode.offsetWidth;
			}
			// update position
			l += vw;
		}
		// next view (is the client, i++ == c)
		i++;
		// start from the right edge
		var r = w;
		// for views right of the client (iterated from the right)
		for(var j=len-1; (v=this.views[j])&&(i<=j); j--){
			// get width
			vw = this.getViewWidth(j);
			// set size
			v.setSize(vw, 0);
			// measure in pixels
			vw = v.domNode.offsetWidth;
			// update position
			r -= vw;
			// set position
			setPosition(v, r);
		}
		if(c<len){
			v = this.views[c];
			// position the client box between left and right boxes
			vw = Math.max(1, r-l);
			// set size
			v.setSize(vw + 'px', 0);
			setPosition(v, l);
		}
		return l;
	},

	// rendering
	renderRow: function(inRowIndex, inNodes, skipRenorm){
		var rowNodes = [];
		for(var i=0, v, n, rowNode; (v=this.views[i])&&(n=inNodes[i]); i++){
			rowNode = v.renderRow(inRowIndex);
			n.appendChild(rowNode);
			rowNodes.push(rowNode);
		}
		if(!skipRenorm){
			this.normalizeRowNodeHeights(rowNodes);
		}
	},
	
	rowRemoved: function(inRowIndex){
		this.onEach("rowRemoved", [ inRowIndex ]);
	},
	
	// updating
	updateRow: function(inRowIndex, skipRenorm){
		for(var i=0, v; v=this.views[i]; i++){
			v.updateRow(inRowIndex);
		}
		if(!skipRenorm){
			this.renormalizeRow(inRowIndex);
		}
	},
	
	updateRowStyles: function(inRowIndex){
		this.onEach("updateRowStyles", [ inRowIndex ]);
	},
	
	// scrolling
	setScrollTop: function(inTop){
		var top = inTop;
		for(var i=0, v; v=this.views[i]; i++){
			top = v.setScrollTop(inTop);
			// Work around IE not firing scroll events that cause header offset
			// issues to occur.
			if(dojo.isIE && v.headerNode && v.scrollboxNode){
				v.headerNode.scrollLeft = v.scrollboxNode.scrollLeft;
			}
		}
		return top;
		//this.onEach("setScrollTop", [ inTop ]);
	},
	
	getFirstScrollingView: function(){
		// summary: Returns the first grid view with a scroll bar
		for(var i=0, v; (v=this.views[i]); i++){
			if(v.hasHScrollbar() || v.hasVScrollbar()){
				return v;
			}
		}
		return null;
	}
	
});

}

if(!dojo._hasResource["dojox.grid._RowManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._RowManager"] = true;
dojo.provide("dojox.grid._RowManager");

(function(){
	var setStyleText = function(inNode, inStyleText){
		if(inNode.style.cssText == undefined){
			inNode.setAttribute("style", inStyleText);
		}else{
			inNode.style.cssText = inStyleText;
		}
	};

	dojo.declare("dojox.grid._RowManager", null, {
		//	Stores information about grid rows. Owned by grid and used internally.
		constructor: function(inGrid){
			this.grid = inGrid;
		},
		linesToEms: 2,
		overRow: -2,
		// styles
		prepareStylingRow: function(inRowIndex, inRowNode){
			return {
				index: inRowIndex,
				node: inRowNode,
				odd: Boolean(inRowIndex&1),
				selected: !!this.grid.selection.isSelected(inRowIndex),
				over: this.isOver(inRowIndex),
				customStyles: "",
				customClasses: "dojoxGridRow"
			};
		},
		styleRowNode: function(inRowIndex, inRowNode){
			var row = this.prepareStylingRow(inRowIndex, inRowNode);
			this.grid.onStyleRow(row);
			this.applyStyles(row);
		},
		applyStyles: function(inRow){
			var i = inRow;

			i.node.className = i.customClasses;
			var h = i.node.style.height;
			setStyleText(i.node, i.customStyles + ';' + (i.node._style||''));
			i.node.style.height = h;
		},
		updateStyles: function(inRowIndex){
			this.grid.updateRowStyles(inRowIndex);
		},
		// states and events
		setOverRow: function(inRowIndex){
			var last = this.overRow;
			this.overRow = inRowIndex;
			if((last!=this.overRow)&&(dojo.isString(last) || last >= 0)){
				this.updateStyles(last);
			}
			this.updateStyles(this.overRow);
		},
		isOver: function(inRowIndex){
			return (this.overRow == inRowIndex && !dojo.hasClass(this.grid.domNode, "dojoxGridColumnResizing"));
		}
	});
})();

}

if(!dojo._hasResource["dojox.grid._FocusManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._FocusManager"] = true;
dojo.provide("dojox.grid._FocusManager");



// focus management
dojo.declare("dojox.grid._FocusManager", null, {
	// summary:
	//	Controls grid cell focus. Owned by grid and used internally for focusing.
	//	Note: grid cell actually receives keyboard input only when cell is being edited.
	constructor: function(inGrid){
		this.grid = inGrid;
		this.cell = null;
		this.rowIndex = -1;
		this._connects = [];
		this._headerConnects = [];
		this.headerMenu = this.grid.headerMenu;
		this._connects.push(dojo.connect(this.grid.domNode, "onfocus", this, "doFocus"));
		this._connects.push(dojo.connect(this.grid.domNode, "onblur", this, "doBlur"));
		this._connects.push(dojo.connect(this.grid.domNode, "oncontextmenu", this, "doContextMenu"));
		this._connects.push(dojo.connect(this.grid.lastFocusNode, "onfocus", this, "doLastNodeFocus"));
		this._connects.push(dojo.connect(this.grid.lastFocusNode, "onblur", this, "doLastNodeBlur"));
		this._connects.push(dojo.connect(this.grid,"_onFetchComplete", this, "_delayedCellFocus"));
		this._connects.push(dojo.connect(this.grid,"postrender", this, "_delayedHeaderFocus"));
	},
	destroy: function(){
		dojo.forEach(this._connects, dojo.disconnect);
		dojo.forEach(this._headerConnects, dojo.disconnect);
		delete this.grid;
		delete this.cell;
	},
	_colHeadNode: null,
	_colHeadFocusIdx: null,
	_contextMenuBindNode: null,
	tabbingOut: false,
	focusClass: "dojoxGridCellFocus",
	focusView: null,
	initFocusView: function(){
		this.focusView = this.grid.views.getFirstScrollingView() || this.focusView || this.grid.views.views[0];
		this._initColumnHeaders();
	},
	isFocusCell: function(inCell, inRowIndex){
		// summary:
		//	states if the given cell is focused
		// inCell: object
		//	grid cell object
		// inRowIndex: int
		//	grid row index
		// returns:
		//	true of the given grid cell is focused
		return (this.cell == inCell) && (this.rowIndex == inRowIndex);
	},
	isLastFocusCell: function(){
		if(this.cell){
			return (this.rowIndex == this.grid.rowCount-1) && (this.cell.index == this.grid.layout.cellCount-1);
		}
		return false;
	},
	isFirstFocusCell: function(){
		if(this.cell){
			return (this.rowIndex === 0) && (this.cell.index === 0);
		}
		return false;
	},
	isNoFocusCell: function(){
		return (this.rowIndex < 0) || !this.cell;
	},
	isNavHeader: function(){
		// summary:
		//	states whether currently navigating among column headers.
		// returns:
		//	true if focus is on a column header; false otherwise.
		return (!!this._colHeadNode);
	},
	getHeaderIndex: function(){
		// summary:
		//	if one of the column headers currently has focus, return its index.
		// returns:
		//	index of the focused column header, or -1 if none have focus.
		if(this._colHeadNode){
			return dojo.indexOf(this._findHeaderCells(), this._colHeadNode);
		}else{
			return -1;
		}
	},
	_focusifyCellNode: function(inBork){
		var n = this.cell && this.cell.getNode(this.rowIndex);
		if(n){
			dojo.toggleClass(n, this.focusClass, inBork);
			if(inBork){
				var sl = this.scrollIntoView();
				try{
					if(!this.grid.edit.isEditing()){
						dojox.grid.util.fire(n, "focus");
						if(sl){ this.cell.view.scrollboxNode.scrollLeft = sl; }
					}
				}catch(e){}
			}
		}
	},
	_delayedCellFocus: function(){
		if(this.isNavHeader()||!this.grid._focused){
				return;
		}
		var n = this.cell && this.cell.getNode(this.rowIndex);
		if(n){
			try{
				var toFocus = true;
				if(window.preventTableHeaderFocus || window.isToPreventTableHeaderFocusAlways || window.isTopElementToBeFocussed) { 
					toFocus = ! (window.preventTableHeaderFocus || window.isToPreventTableHeaderFocusAlways || window.isTopElementToBeFocussed); 
				}
				if(toFocus) {
					if(!this.grid.edit.isEditing()){
						dojo.toggleClass(n, this.focusClass, true);
						this.blurHeader();
						dojox.grid.util.fire(n, "focus");
					}
				}
			}
			catch(e){}
		}
	},
	_delayedHeaderFocus: function(){
		var toFocus = true;
		if(window.preventTableHeaderFocus || window.isToPreventTableHeaderFocusAlways || window.isTopElementToBeFocussed) { 
			toFocus = ! (window.preventTableHeaderFocus || window.isToPreventTableHeaderFocusAlways || window.isTopElementToBeFocussed); 
		}
		if(toFocus) {
			if(this.isNavHeader()){
				this.focusHeader();
				this.grid.domNode.focus();
			}
		}
	},
	_initColumnHeaders: function(){
		dojo.forEach(this._headerConnects, dojo.disconnect);
		this._headerConnects = [];
		var headers = this._findHeaderCells();
		for(var i = 0; i < headers.length; i++){
			this._headerConnects.push(dojo.connect(headers[i], "onfocus", this, "doColHeaderFocus"));
			this._headerConnects.push(dojo.connect(headers[i], "onblur", this, "doColHeaderBlur"));
		}
	},
	_findHeaderCells: function(){
		// This should be a one liner:
		//	dojo.query("th[tabindex=-1]", this.grid.viewsHeaderNode);
		// But there is a bug in dojo.query() for IE -- see trac #7037.
		var allHeads = dojo.query("th", this.grid.viewsHeaderNode);
		var headers = [];
		for (var i = 0; i < allHeads.length; i++){
			var aHead = allHeads[i];
			var hasTabIdx = dojo.hasAttr(aHead, "tabIndex");
			var tabindex = dojo.attr(aHead, "tabIndex");
			if (hasTabIdx && tabindex < 0) {
				headers.push(aHead);
			}
		}
		return headers;
	},
	_setActiveColHeader: function(/*Node*/colHeaderNode, /*Integer*/colFocusIdx, /*Integer*/ prevColFocusIdx){
		//console.log("setActiveColHeader() - colHeaderNode:colFocusIdx:prevColFocusIdx = " + colHeaderNode + ":" + colFocusIdx + ":" + prevColFocusIdx);
		dojo.attr(this.grid.domNode, "aria-activedescendant",colHeaderNode.id);
		if (prevColFocusIdx != null && prevColFocusIdx >= 0 && prevColFocusIdx != colFocusIdx){
			dojo.toggleClass(this._findHeaderCells()[prevColFocusIdx],this.focusClass,false);
		}
		dojo.toggleClass(colHeaderNode,this.focusClass, true);
		this._colHeadNode = colHeaderNode;
		this._colHeadFocusIdx = colFocusIdx;
		this._scrollHeader(this._colHeadFocusIdx);
	},
	scrollIntoView: function(){
		var info = (this.cell ? this._scrollInfo(this.cell) : null);
		if(!info || !info.s){
			return null;
		}
		var rt = this.grid.scroller.findScrollTop(this.rowIndex);
		// place cell within horizontal view
		if(info.n && info.sr){
			if(info.n.offsetLeft + info.n.offsetWidth > info.sr.l + info.sr.w){
				info.s.scrollLeft = info.n.offsetLeft + info.n.offsetWidth - info.sr.w;
			}else if(info.n.offsetLeft < info.sr.l){
				info.s.scrollLeft = info.n.offsetLeft;
			}
		}
		// place cell within vertical view
		if(info.r && info.sr){
			if(rt + info.r.offsetHeight > info.sr.t + info.sr.h){
				this.grid.setScrollTop(rt + info.r.offsetHeight - info.sr.h);
			}else if(rt < info.sr.t){
				this.grid.setScrollTop(rt);
			}
		}

		return info.s.scrollLeft;
	},
	_scrollInfo: function(cell, domNode){
		if(cell){
			var cl = cell,
				sbn = cl.view.scrollboxNode,
				sbnr = {
					w: sbn.clientWidth,
					l: sbn.scrollLeft,
					t: sbn.scrollTop,
					h: sbn.clientHeight
				},
				rn = cl.view.getRowNode(this.rowIndex);
			return {
				c: cl,
				s: sbn,
				sr: sbnr,
				n: (domNode ? domNode : cell.getNode(this.rowIndex)),
				r: rn
			};
		}
		return null;
	},
	_scrollHeader: function(currentIdx){
		var info = null;
		if(this._colHeadNode){
			var cell = this.grid.getCell(currentIdx);
			info = this._scrollInfo(cell, cell.getNode(0));
		}
		if(info && info.s && info.sr && info.n){
			// scroll horizontally as needed.
			var scroll = info.sr.l + info.sr.w;
			if(info.n.offsetLeft + info.n.offsetWidth > scroll){
				info.s.scrollLeft = info.n.offsetLeft + info.n.offsetWidth - info.sr.w;
			}else if(info.n.offsetLeft < info.sr.l){
				info.s.scrollLeft = info.n.offsetLeft;
			}else if(dojo.isIE <= 7 && cell && cell.view.headerNode){
				// Trac 7158: scroll dojoxGridHeader for IE7 and lower
				cell.view.headerNode.scrollLeft = info.s.scrollLeft;
			}
		}
	},
	_isHeaderHidden: function(){
		// summary:
		//		determine if the grid headers are hidden
		//		relies on documented technique of setting .dojoxGridHeader { display:none; }
		// returns: Boolean
		//		true if headers are hidden
		//		false if headers are not hidden
		
		var curView = this.focusView;
		if (!curView){
			// find one so we can determine if headers are hidden
			// there is no focusView after adding items to empty grid (test_data_grid_empty.html)
			for (var i = 0, cView; (cView = this.grid.views.views[i]); i++) {
				if(cView.headerNode ){
					curView=cView;
					break;
				}
			}
		}
		return (curView && dojo.getComputedStyle(curView.headerNode).display == "none");
	},
	colSizeAdjust: function (e, colIdx, delta){ // adjust the column specified by colIdx by the specified delta px
		var headers = this._findHeaderCells();
		var view = this.focusView;
		if (!view) {
			for (var i = 0, cView; (cView = this.grid.views.views[i]); i++) {
				// find first view with a tableMap in order to work with empty grid
				if(cView.header.tableMap.map ){
					view=cView;
					break;
				}
			}
		}
		var curHeader = headers[colIdx];
		if (!view || (colIdx == headers.length-1 && colIdx === 0)){
			return; // can't adjust single col. grid
		}
		view.content.baseDecorateEvent(e);
		// need to adjust event with header cell info since focus is no longer on header cell
		e.cellNode = curHeader; //this.findCellTarget(e.target, e.rowNode);
		e.cellIndex = view.content.getCellNodeIndex(e.cellNode);
		e.cell = (e.cellIndex >= 0 ? this.grid.getCell(e.cellIndex) : null);
		if (view.header.canResize(e)){
			var deltaObj = {
				l: delta
			};
			var drag = view.header.colResizeSetup(e,false);
			view.header.doResizeColumn(drag, null, deltaObj);
			view.update();
		}
	},
	styleRow: function(inRow){
		return;
	},
	setFocusIndex: function(inRowIndex, inCellIndex){
		// summary:
		//	focuses the given grid cell
		// inRowIndex: int
		//	grid row index
		// inCellIndex: int
		//	grid cell index
		this.setFocusCell(this.grid.getCell(inCellIndex), inRowIndex);
	},
	setFocusCell: function(inCell, inRowIndex){
		// summary:
		//	focuses the given grid cell
		// inCell: object
		//	grid cell object
		// inRowIndex: int
		//	grid row index
		if(inCell && !this.isFocusCell(inCell, inRowIndex)){
			this.tabbingOut = false;
			if (this._colHeadNode){
				this.blurHeader();
			}
			this._colHeadNode = this._colHeadFocusIdx = null;
			this.focusGridView();
			this._focusifyCellNode(false);
			this.cell = inCell;
			this.rowIndex = inRowIndex;
			this._focusifyCellNode(true);
		}
		// even if this cell isFocusCell, the document focus may need to be rejiggered
		// call opera on delay to prevent keypress from altering focus
		if(dojo.isOpera){
			setTimeout(dojo.hitch(this.grid, 'onCellFocus', this.cell, this.rowIndex), 1);
		}else{
			this.grid.onCellFocus(this.cell, this.rowIndex);
		}
	},
	next: function(){
		// summary:
		//	focus next grid cell
		if(this.cell){
			var row=this.rowIndex, col=this.cell.index+1, cc=this.grid.layout.cellCount-1, rc=this.grid.rowCount-1;
			if(col > cc){
				col = 0;
				row++;
			}
			if(row > rc){
				col = cc;
				row = rc;
			}
			if(this.grid.edit.isEditing()){ //when editing, only navigate to editable cells
				var nextCell = this.grid.getCell(col);
				if (!this.isLastFocusCell() && (!nextCell.editable ||
					this.grid.canEdit && !this.grid.canEdit(nextCell, row))){
					this.cell=nextCell;
					this.rowIndex=row;
					this.next();
					return;
				}
			}
			this.setFocusIndex(row, col);
		}
	},
	previous: function(){
		// summary:
		//	focus previous grid cell
		if(this.cell){
			var row=(this.rowIndex || 0), col=(this.cell.index || 0) - 1;
			if(col < 0){
				col = this.grid.layout.cellCount-1;
				row--;
			}
			if(row < 0){
				row = 0;
				col = 0;
			}
			if(this.grid.edit.isEditing()){ //when editing, only navigate to editable cells
				var prevCell = this.grid.getCell(col);
				if (!this.isFirstFocusCell() && !prevCell.editable){
					this.cell=prevCell;
					this.rowIndex=row;
					this.previous();
					return;
				}
			}
			this.setFocusIndex(row, col);
		}
	},
	move: function(inRowDelta, inColDelta) {
		// summary:
		//	focus grid cell or  simulate focus to column header based on position relative to current focus
		// inRowDelta: int
		// vertical distance from current focus
		// inColDelta: int
		// horizontal distance from current focus

		var colDir = inColDelta < 0 ? -1 : 1;
		// Handle column headers.
		if(this.isNavHeader()){
			var headers = this._findHeaderCells();
			var savedIdx = currentIdx = dojo.indexOf(headers, this._colHeadNode);
			currentIdx += inColDelta;
			while(currentIdx >=0 && currentIdx < headers.length && headers[currentIdx].style.display == "none"){
				// skip over hidden column headers
				currentIdx += colDir;
			}
			if((currentIdx >= 0) && (currentIdx < headers.length)){
				this._setActiveColHeader(headers[currentIdx],currentIdx, savedIdx);
			}
		}else{
			if(this.cell){
				// Handle grid proper.
				var sc = this.grid.scroller,
					r = this.rowIndex,
					rc = this.grid.rowCount-1,
					row = Math.min(rc, Math.max(0, r+inRowDelta));
				if(inRowDelta){
					if(inRowDelta>0){
						if(row > sc.getLastPageRow(sc.page)){
							//need to load additional data, let scroller do that
							this.grid.setScrollTop(this.grid.scrollTop+sc.findScrollTop(row)-sc.findScrollTop(r));
						}
					}else if(inRowDelta<0){
						if(row <= sc.getPageRow(sc.page)){
							//need to load additional data, let scroller do that
							this.grid.setScrollTop(this.grid.scrollTop-sc.findScrollTop(r)-sc.findScrollTop(row));
						}
					}
				}
				var cc = this.grid.layout.cellCount-1,
				i = this.cell.index,
				col = Math.min(cc, Math.max(0, i+inColDelta));
				var cell = this.grid.getCell(col);
				while(col>=0 && col < cc && cell && cell.hidden === true){
					// skip hidden cells
					col += colDir;
					cell = this.grid.getCell(col);
				}
				if (!cell || cell.hidden === true){
					// don't change col if would move to hidden
					col = i;
				}
				//skip hidden row|cell
				var n = cell.getNode(row);
				if(!n && inRowDelta){
					if((row + inRowDelta) >= 0 && (row + inRowDelta) <= rc){
						this.move(inRowDelta > 0 ? ++inRowDelta : --inRowDelta, inColDelta);
					}
					return;
				}else if((!n || dojo.style(n, "display") === "none") && inColDelta){
					if((col + inRowDelta) >= 0 && (col + inRowDelta) <= cc){
						this.move(inRowDelta, inColDelta > 0 ? ++inColDelta : --inColDelta);
					}
					return;
				}
				this.setFocusIndex(row, col);
				if(inRowDelta){
					this.grid.updateRow(r);
				}
			}
		}
	},
	previousKey: function(e){
		if(this.grid.edit.isEditing()){
			dojo.stopEvent(e);
			this.previous();
		}else if(!this.isNavHeader() && !this._isHeaderHidden()) {
			this.grid.domNode.focus(); // will call doFocus and set focus into header.
			dojo.stopEvent(e);
		}else{
			this.tabOut(this.grid.domNode);
			if (this._colHeadFocusIdx != null) { // clear grid header focus
				dojo.toggleClass(this._findHeaderCells()[this._colHeadFocusIdx], this.focusClass, false);
				this._colHeadFocusIdx = null;
			}
			this._focusifyCellNode(false);
		}
	},
	nextKey: function(e) {
		var isEmpty = (this.grid.rowCount === 0);
		if(e.target === this.grid.domNode && this._colHeadFocusIdx == null){
			this.focusHeader();
			dojo.stopEvent(e);
		}else if(this.isNavHeader()){
			// if tabbing from col header, then go to grid proper.
			this.blurHeader();
			if(!this.findAndFocusGridCell()){
				this.tabOut(this.grid.lastFocusNode);
			}
			this._colHeadNode = this._colHeadFocusIdx= null;
		}else if(this.grid.edit.isEditing()){
			dojo.stopEvent(e);
			this.next();
		}else{
			this.tabOut(this.grid.lastFocusNode);
		}
	},
	tabOut: function(inFocusNode){
		this.tabbingOut = true;
		inFocusNode.focus();
	},
	focusGridView: function(){
		dojox.grid.util.fire(this.focusView, "focus");
	},
	focusGrid: function(inSkipFocusCell){
		this.focusGridView();
		this._focusifyCellNode(true);
	},
	findAndFocusGridCell: function(){
		// summary:
		//		find the first focusable grid cell
		// returns: Boolean
		//		true if focus was set to a cell
		//		false if no cell found to set focus onto
		
		var didFocus = true;
		var isEmpty = (this.grid.rowCount === 0); // If grid is empty this.grid.rowCount == 0
		if (this.isNoFocusCell() && !isEmpty){
			var cellIdx = 0;
			var cell = this.grid.getCell(cellIdx);
			if (cell.hidden) {
				// if first cell isn't visible, use _colHeadFocusIdx
				// could also use a while loop to find first visible cell - not sure that is worth it
				cellIdx = this.isNavHeader() ? this._colHeadFocusIdx : 0;
			}
			this.setFocusIndex(0, cellIdx);
		}
		else if (this.cell && !isEmpty){
			if (this.focusView && !this.focusView.rowNodes[this.rowIndex]){
				// if rowNode for current index is undefined (likely as a result of a sort and because of #7304)
				// scroll to that row
				this.grid.scrollToRow(this.rowIndex);
			}
			this.focusGrid();
		}else {
			didFocus = false;
		}
		this._colHeadNode = this._colHeadFocusIdx= null;
		return didFocus;
	},
	focusHeader: function(){
		var headerNodes = this._findHeaderCells();
		var saveColHeadFocusIdx = this._colHeadFocusIdx;
		if (this._isHeaderHidden()){
			// grid header is hidden, focus a cell
			this.findAndFocusGridCell();
		}
		else if (!this._colHeadFocusIdx) {
			if (this.isNoFocusCell()) {
				this._colHeadFocusIdx = 0;
			}
			else {
				this._colHeadFocusIdx = this.cell.index;
			}
		}
		this._colHeadNode = headerNodes[this._colHeadFocusIdx];
		while(this._colHeadNode && this._colHeadFocusIdx >=0 && this._colHeadFocusIdx < headerNodes.length &&
				this._colHeadNode.style.display == "none"){
			// skip over hidden column headers
			this._colHeadFocusIdx++;
			this._colHeadNode = headerNodes[this._colHeadFocusIdx];
		}
		if(this._colHeadNode && this._colHeadNode.style.display != "none"){
			// Column header cells know longer receive actual focus.  So, for keyboard invocation of
			// contextMenu to work, the contextMenu must be bound to the grid.domNode rather than the viewsHeaderNode.
			// unbind the contextmenu from the viewsHeaderNode and to the grid when header cells are active.  Reset
			// the binding back to the viewsHeaderNode when header cells are no longer acive (in blurHeader) #10483
			if (this.headerMenu && this._contextMenuBindNode != this.grid.domNode){
				this.headerMenu.unBindDomNode(this.grid.viewsHeaderNode);
				this.headerMenu.bindDomNode(this.grid.domNode);
				this._contextMenuBindNode = this.grid.domNode;
			}
			this._setActiveColHeader(this._colHeadNode, this._colHeadFocusIdx, saveColHeadFocusIdx);
			this._scrollHeader(this._colHeadFocusIdx);
			this._focusifyCellNode(false);
		}else {
			// all col head nodes are hidden - focus the grid
			this.findAndFocusGridCell();
		}
	},
	blurHeader: function(){
		dojo.removeClass(this._colHeadNode, this.focusClass);
		dojo.removeAttr(this.grid.domNode,"aria-activedescendant");
		// reset contextMenu onto viewsHeaderNode so right mouse on header will invoke (see focusHeader)
		if (this.headerMenu && this._contextMenuBindNode == this.grid.domNode) {
			var viewsHeader = this.grid.viewsHeaderNode;
			this.headerMenu.unBindDomNode(this.grid.domNode);
			this.headerMenu.bindDomNode(viewsHeader);
			this._contextMenuBindNode = viewsHeader;
		}
	},
	doFocus: function(e){
		// trap focus only for grid dom node
		if(e && e.target != e.currentTarget){
			dojo.stopEvent(e);
			return;
		}
		// do not focus for scrolling if grid is about to blur
		if(!this.tabbingOut){
			this.focusHeader();
		}
		this.tabbingOut = false;
		dojo.stopEvent(e);
	},
	doBlur: function(e){
		dojo.stopEvent(e);	// FF2
	},
	doContextMenu: function(e){
	//stop contextMenu event if no header Menu to prevent default/browser contextMenu
		if (!this.headerMenu){
			dojo.stopEvent(e);
		}
	},
	doLastNodeFocus: function(e){
		if (this.tabbingOut){
			this._focusifyCellNode(false);
		}else if(this.grid.rowCount >0){
			if (this.isNoFocusCell()){
				this.setFocusIndex(0,0);
			}
			this._focusifyCellNode(true);
		}else {
			this.focusHeader();
		}
		this.tabbingOut = false;
		dojo.stopEvent(e);	 // FF2
	},
	doLastNodeBlur: function(e){
		dojo.stopEvent(e);	 // FF2
	},
	doColHeaderFocus: function(e){
		this._setActiveColHeader(e.target,dojo.attr(e.target, "idx"),this._colHeadFocusIdx);
		this._scrollHeader(this.getHeaderIndex());
		dojo.stopEvent(e);
	},
	doColHeaderBlur: function(e){
		dojo.toggleClass(e.target, this.focusClass, false);
	}
});

}

if(!dojo._hasResource["dojox.grid._EditManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._EditManager"] = true;
dojo.provide("dojox.grid._EditManager");



dojo.declare("dojox.grid._EditManager", null, {
	// summary:
	//		Controls grid cell editing process. Owned by grid and used internally for editing.
	constructor: function(inGrid){
		// inGrid: dojox.Grid
		//		The dojox.Grid this editor should be attached to
		this.grid = inGrid;
		if(dojo.isIE){
			this.connections = [dojo.connect(document.body, "onfocus", dojo.hitch(this, "_boomerangFocus"))];
		}else{
			this.connections = [dojo.connect(this.grid, 'onBlur', this, 'apply')];
		}
	},
	
	info: {},

	destroy: function(){
		dojo.forEach(this.connections,dojo.disconnect);
	},

	cellFocus: function(inCell, inRowIndex){
		// summary:
		//		Invoke editing when cell is focused
		// inCell: cell object
		//		Grid cell object
		// inRowIndex: Integer
		//		Grid row index
		if(this.grid.singleClickEdit || this.isEditRow(inRowIndex)){
			// if same row or quick editing, edit
			this.setEditCell(inCell, inRowIndex);
		}else{
			// otherwise, apply any pending row edits
			this.apply();
		}
		// if dynamic or static editing...
		if(this.isEditing() || (inCell && inCell.editable && inCell.alwaysEditing)){
			// let the editor focus itself as needed
			this._focusEditor(inCell, inRowIndex);
		}
	},

	rowClick: function(e){
		if(this.isEditing() && !this.isEditRow(e.rowIndex)){
			this.apply();
		}
	},

	styleRow: function(inRow){
		if(inRow.index == this.info.rowIndex){
			inRow.customClasses += ' dojoxGridRowEditing';
		}
	},

	dispatchEvent: function(e){
		var c = e.cell, ed = (c && c["editable"]) ? c : 0;
		return ed && ed.dispatchEvent(e.dispatch, e);
	},

	// Editing
	isEditing: function(){
		// summary:
		//		Indicates editing state of the grid.
		// returns: Boolean
		//	 	True if grid is actively editing
		return this.info.rowIndex !== undefined;
	},

	isEditCell: function(inRowIndex, inCellIndex){
		// summary:
		//		Indicates if the given cell is being edited.
		// inRowIndex: Integer
		//		Grid row index
		// inCellIndex: Integer
		//		Grid cell index
		// returns: Boolean
		//	 	True if given cell is being edited
		return (this.info.rowIndex === inRowIndex) && (this.info.cell.index == inCellIndex);
	},

	isEditRow: function(inRowIndex){
		// summary:
		//		Indicates if the given row is being edited.
		// inRowIndex: Integer
		//		Grid row index
		// returns: Boolean
		//	 	True if given row is being edited
		return this.info.rowIndex === inRowIndex;
	},

	setEditCell: function(inCell, inRowIndex){
		// summary:
		//		Set the given cell to be edited
		// inRowIndex: Integer
		//		Grid row index
		// inCell: Object
		//		Grid cell object
		if(!this.isEditCell(inRowIndex, inCell.index) && this.grid.canEdit && this.grid.canEdit(inCell, inRowIndex)){
			this.start(inCell, inRowIndex, this.isEditRow(inRowIndex) || inCell.editable);
		}
	},

	_focusEditor: function(inCell, inRowIndex){
		dojox.grid.util.fire(inCell, "focus", [inRowIndex]);
	},

	focusEditor: function(){
		if(this.isEditing()){
			this._focusEditor(this.info.cell, this.info.rowIndex);
		}
	},

	// implement fix for focus boomerang effect on IE
	_boomerangWindow: 500,
	_shouldCatchBoomerang: function(){
		return this._catchBoomerang > new Date().getTime();
	},
	_boomerangFocus: function(){
		//console.log("_boomerangFocus");
		if(this._shouldCatchBoomerang()){
			// make sure we don't utterly lose focus
			this.grid.focus.focusGrid();
			// let the editor focus itself as needed
			this.focusEditor();
			// only catch once
			this._catchBoomerang = 0;
		}
	},
	_doCatchBoomerang: function(){
		// give ourselves a few ms to boomerang IE focus effects
		if(dojo.isIE){this._catchBoomerang = new Date().getTime() + this._boomerangWindow;}
	},
	// end boomerang fix API

	start: function(inCell, inRowIndex, inEditing){
		this.grid.beginUpdate();
		this.editorApply();
		if(this.isEditing() && !this.isEditRow(inRowIndex)){
			this.applyRowEdit();
			this.grid.updateRow(inRowIndex);
		}
		if(inEditing){
			this.info = { cell: inCell, rowIndex: inRowIndex };
			this.grid.doStartEdit(inCell, inRowIndex);
			this.grid.updateRow(inRowIndex);
		}else{
			this.info = {};
		}
		this.grid.endUpdate();
		// make sure we don't utterly lose focus
		this.grid.focus.focusGrid();
		// let the editor focus itself as needed
		this._focusEditor(inCell, inRowIndex);
		// give ourselves a few ms to boomerang IE focus effects
		this._doCatchBoomerang();
	},

	_editorDo: function(inMethod){
		var c = this.info.cell;
		//c && c.editor && c.editor[inMethod](c, this.info.rowIndex);
		if(c && c.editable){
			c[inMethod](this.info.rowIndex);
		}
	},

	editorApply: function(){
		this._editorDo("apply");
	},

	editorCancel: function(){
		this._editorDo("cancel");
	},

	applyCellEdit: function(inValue, inCell, inRowIndex){
		if(this.grid.canEdit(inCell, inRowIndex)){
			this.grid.doApplyCellEdit(inValue, inRowIndex, inCell.field);
		}
	},

	applyRowEdit: function(){
		this.grid.doApplyEdit(this.info.rowIndex, this.info.cell.field);
	},

	apply: function(){
		// summary:
		//		Apply a grid edit
		if(this.isEditing()){
			this.grid.beginUpdate();
			this.editorApply();
			this.applyRowEdit();
			this.info = {};
			this.grid.endUpdate();
			this.grid.focus.focusGrid();
			this._doCatchBoomerang();
		}
	},

	cancel: function(){
		// summary:
		//		Cancel a grid edit
		if(this.isEditing()){
			this.grid.beginUpdate();
			this.editorCancel();
			this.info = {};
			this.grid.endUpdate();
			this.grid.focus.focusGrid();
			this._doCatchBoomerang();
		}
	},

	save: function(inRowIndex, inView){
		// summary:
		//		Save the grid editing state
		// inRowIndex: Integer
		//		Grid row index
		// inView: Object
		//		Grid view
		var c = this.info.cell;
		if(this.isEditRow(inRowIndex) && (!inView || c.view==inView) && c.editable){
			c.save(c, this.info.rowIndex);
		}
	},

	restore: function(inView, inRowIndex){
		// summary:
		//		Restores the grid editing state
		// inRowIndex: Integer
		//		Grid row index
		// inView: Object
		//		Grid view
		var c = this.info.cell;
		if(this.isEditRow(inRowIndex) && c.view == inView && c.editable){
			c.restore(c, this.info.rowIndex);
		}
	}
});

}

if(!dojo._hasResource['dojox.grid.Selection']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['dojox.grid.Selection'] = true;
dojo.provide('dojox.grid.Selection');

dojo.declare("dojox.grid.Selection", null, {
	// summary:
	//		Manages row selection for grid. Owned by grid and used internally
	//		for selection. Override to implement custom selection.

	constructor: function(inGrid){
		this.grid = inGrid;
		this.selected = [];

		this.setMode(inGrid.selectionMode);
	},

	mode: 'extended',

	selected: null,
	updating: 0,
	selectedIndex: -1,

	setMode: function(mode){
		if(this.selected.length){
			this.deselectAll();
		}
		if(mode != 'extended' && mode != 'multiple' && mode != 'single' && mode != 'none'){
			this.mode = 'extended';
		}else{
			this.mode = mode;
		}
	},

	onCanSelect: function(inIndex){
		return this.grid.onCanSelect(inIndex);
	},

	onCanDeselect: function(inIndex){
		return this.grid.onCanDeselect(inIndex);
	},

	onSelected: function(inIndex){
	},

	onDeselected: function(inIndex){
	},

	//onSetSelected: function(inIndex, inSelect) { };
	onChanging: function(){
	},

	onChanged: function(){
	},

	isSelected: function(inIndex){
		if(this.mode == 'none'){
			return false;
		}
		return this.selected[inIndex];
	},

	getFirstSelected: function(){
		if(!this.selected.length||this.mode == 'none'){ return -1; }
		for(var i=0, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				return i;
			}
		}
		return -1;
	},

	getNextSelected: function(inPrev){
		if(this.mode == 'none'){ return -1; }
		for(var i=inPrev+1, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				return i;
			}
		}
		return -1;
	},

	getSelected: function(){
		var result = [];
		for(var i=0, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				result.push(i);
			}
		}
		return result;
	},

	getSelectedCount: function(){
		var c = 0;
		for(var i=0; i<this.selected.length; i++){
			if(this.selected[i]){
				c++;
			}
		}
		return c;
	},

	_beginUpdate: function(){
		if(this.updating === 0){
			this.onChanging();
		}
		this.updating++;
	},

	_endUpdate: function(){
		this.updating--;
		if(this.updating === 0){
			this.onChanged();
		}
	},

	select: function(inIndex){
		if(this.mode == 'none'){ return; }
		if(this.mode != 'multiple'){
			this.deselectAll(inIndex);
			this.addToSelection(inIndex);
		}else{
			this.toggleSelect(inIndex);
		}
	},

	addToSelection: function(inIndex){
		if(this.mode == 'none'){ return; }
		if(dojo.isArray(inIndex)){
			dojo.forEach(inIndex, this.addToSelection, this);
			return;
		}
		inIndex = Number(inIndex);
		if(this.selected[inIndex]){
			this.selectedIndex = inIndex;
		}else{
			if(this.onCanSelect(inIndex) !== false){
				this.selectedIndex = inIndex;
				var rowNode = this.grid.getRowNode(inIndex);
				if(rowNode){
					dojo.attr(rowNode,"aria-selected","true");
				}
				this._beginUpdate();
				this.selected[inIndex] = true;
				//this.grid.onSelected(inIndex);
				this.onSelected(inIndex);
				//this.onSetSelected(inIndex, true);
				this._endUpdate();
			}
		}
	},

	deselect: function(inIndex){
		if(this.mode == 'none'){ return; }
		if(dojo.isArray(inIndex)){
			dojo.forEach(inIndex, this.deselect, this);
			return;
		}
		inIndex = Number(inIndex);
		if(this.selectedIndex == inIndex){
			this.selectedIndex = -1;
		}
		if(this.selected[inIndex]){
			if(this.onCanDeselect(inIndex) === false){
				return;
			}
			var rowNode = this.grid.getRowNode(inIndex);
			if(rowNode){
				dojo.attr(rowNode,"aria-selected","false");
			}
			this._beginUpdate();
			delete this.selected[inIndex];
			//this.grid.onDeselected(inIndex);
			this.onDeselected(inIndex);
			//this.onSetSelected(inIndex, false);
			this._endUpdate();
		}
	},

	setSelected: function(inIndex, inSelect){
		this[(inSelect ? 'addToSelection' : 'deselect')](inIndex);
	},

	toggleSelect: function(inIndex){
		if(dojo.isArray(inIndex)){
			dojo.forEach(inIndex, this.toggleSelect, this);
			return;
		}
		this.setSelected(inIndex, !this.selected[inIndex]);
	},

	_range: function(inFrom, inTo, func){
		var s = (inFrom >= 0 ? inFrom : inTo), e = inTo;
		if(s > e){
			e = s;
			s = inTo;
		}
		for(var i=s; i<=e; i++){
			func(i);
		}
	},

	selectRange: function(inFrom, inTo){
		this._range(inFrom, inTo, dojo.hitch(this, "addToSelection"));
	},

	deselectRange: function(inFrom, inTo){
		this._range(inFrom, inTo, dojo.hitch(this, "deselect"));
	},

	insert: function(inIndex){
		this.selected.splice(inIndex, 0, false);
		if(this.selectedIndex >= inIndex){
			this.selectedIndex++;
		}
	},

	remove: function(inIndex){
		this.selected.splice(inIndex, 1);
		if(this.selectedIndex >= inIndex){
			this.selectedIndex--;
		}
	},

	deselectAll: function(inExcept){
		for(var i in this.selected){
			if((i!=inExcept)&&(this.selected[i]===true)){
				this.deselect(i);
			}
		}
	},

	clickSelect: function(inIndex, inCtrlKey, inShiftKey){
		if(this.mode == 'none'){ return; }
		this._beginUpdate();
		if(this.mode != 'extended'){
			this.select(inIndex);
		}else{
			var lastSelected = this.selectedIndex;
			if(!inCtrlKey){
				this.deselectAll(inIndex);
			}
			if(inShiftKey){
				this.selectRange(lastSelected, inIndex);
			}else if(inCtrlKey){
				this.toggleSelect(inIndex);
			}else{
				this.addToSelection(inIndex);
			}
		}
		this._endUpdate();
	},

	clickSelectEvent: function(e){
		this.clickSelect(e.rowIndex, dojo.isCopyKey(e), e.shiftKey);
	},

	clear: function(){
		this._beginUpdate();
		this.deselectAll();
		this._endUpdate();
	}
});

}

if(!dojo._hasResource["dojox.grid._Events"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._Events"] = true;
dojo.provide("dojox.grid._Events");

dojo.declare("dojox.grid._Events", null, {
	// summary:
	//		_Grid mixin that provides default implementations for grid events.
	// description:
	//		Default synthetic events dispatched for _Grid. dojo.connect to events to
	//		retain default implementation or override them for custom handling.
	
	// cellOverClass: String
	// 		css class to apply to grid cells over which the cursor is placed.
	cellOverClass: "dojoxGridCellOver",
	
	onKeyEvent: function(e){
		// summary: top level handler for Key Events
		this.dispatchKeyEvent(e);
	},

	onContentEvent: function(e){
		// summary: Top level handler for Content events
		this.dispatchContentEvent(e);
	},

	onHeaderEvent: function(e){
		// summary: Top level handler for header events
		this.dispatchHeaderEvent(e);
	},

	onStyleRow: function(inRow){
		// summary:
		//		Perform row styling on a given row. Called whenever row styling is updated.
		//
		// inRow: Object
		// 		Object containing row state information: selected, true if the row is selcted; over:
		// 		true of the mouse is over the row; odd: true if the row is odd. Use customClasses and
		// 		customStyles to control row css classes and styles; both properties are strings.
		//
		// example: onStyleRow({ selected: true, over:true, odd:false })
		var i = inRow;
		i.customClasses += (i.odd?" dojoxGridRowOdd":"") + (i.selected?" dojoxGridRowSelected":"") + (i.over?" dojoxGridRowOver":"");
		this.focus.styleRow(inRow);
		this.edit.styleRow(inRow);
	},
	
	onKeyDown: function(e){
		// summary:
		// 		Grid key event handler. By default enter begins editing and applies edits, escape cancels an edit,
		// 		tab, shift-tab, and arrow keys move grid cell focus.
		if(e.altKey || e.metaKey){
			return;
		}
		var dk = dojo.keys;
		var colIdx;
		switch(e.keyCode){
			case dk.ESCAPE:
				this.edit.cancel();
				break;
			case dk.ENTER:
				if(!this.edit.isEditing()){
					colIdx = this.focus.getHeaderIndex();
					if(colIdx >= 0) {
						this.setSortIndex(colIdx);
						break;
					}else {
						this.selection.clickSelect(this.focus.rowIndex, dojo.isCopyKey(e), e.shiftKey);
					}
					dojo.stopEvent(e);
				}
				if(!e.shiftKey){
					var isEditing = this.edit.isEditing();
					this.edit.apply();
					if(!isEditing){
						this.edit.setEditCell(this.focus.cell, this.focus.rowIndex);
					}
				}
				if (!this.edit.isEditing()){
					var curView = this.focus.focusView || this.views.views[0];  //if no focusView than only one view
					curView.content.decorateEvent(e);
					this.onRowClick(e);
					dojo.stopEvent(e);
				}
				break;
			case dk.SPACE:
				if(!this.edit.isEditing()){
					colIdx = this.focus.getHeaderIndex();
					if(colIdx >= 0) {
						this.setSortIndex(colIdx);
						break;
					}else {
						this.selection.clickSelect(this.focus.rowIndex, dojo.isCopyKey(e), e.shiftKey);
					}
					dojo.stopEvent(e);
				}
				break;
			case dk.TAB:
				this.focus[e.shiftKey ? 'previousKey' : 'nextKey'](e);
				break;
			case dk.LEFT_ARROW:
			case dk.RIGHT_ARROW:
				if(!this.edit.isEditing()){
					var keyCode = e.keyCode;  // IE seems to lose after stopEvent when modifier keys
					dojo.stopEvent(e);
					colIdx = this.focus.getHeaderIndex();
					if (colIdx >= 0 && (e.shiftKey && e.ctrlKey)){
						this.focus.colSizeAdjust(e, colIdx, (keyCode == dk.LEFT_ARROW ? -1 : 1)*5);
					}
					else{
						var offset = (keyCode == dk.LEFT_ARROW) ? 1 : -1;
						if(dojo._isBodyLtr()){ offset *= -1; }
						this.focus.move(0, offset);
					}
				}
				break;
			case dk.UP_ARROW:
				if(!this.edit.isEditing() && this.focus.rowIndex !== 0){
					dojo.stopEvent(e);
					this.focus.move(-1, 0);
				}
				break;
			case dk.DOWN_ARROW:
				if(!this.edit.isEditing() && this.focus.rowIndex+1 != this.rowCount){
					dojo.stopEvent(e);
					this.focus.move(1, 0);
				}
				break;
			case dk.PAGE_UP:
				if(!this.edit.isEditing() && this.focus.rowIndex !== 0){
					dojo.stopEvent(e);
					if(this.focus.rowIndex != this.scroller.firstVisibleRow+1){
						this.focus.move(this.scroller.firstVisibleRow-this.focus.rowIndex, 0);
					}else{
						this.setScrollTop(this.scroller.findScrollTop(this.focus.rowIndex-1));
						this.focus.move(this.scroller.firstVisibleRow-this.scroller.lastVisibleRow+1, 0);
					}
				}
				break;
			case dk.PAGE_DOWN:
				if(!this.edit.isEditing() && this.focus.rowIndex+1 != this.rowCount){
					dojo.stopEvent(e);
					if(this.focus.rowIndex != this.scroller.lastVisibleRow-1){
						this.focus.move(this.scroller.lastVisibleRow-this.focus.rowIndex-1, 0);
					}else{
						this.setScrollTop(this.scroller.findScrollTop(this.focus.rowIndex+1));
						this.focus.move(this.scroller.lastVisibleRow-this.scroller.firstVisibleRow-1, 0);
					}
				}
				break;
			default:
				break;
		}
	},
	
	onMouseOver: function(e){
		// summary:
		//		Event fired when mouse is over the grid.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		e.rowIndex == -1 ? this.onHeaderCellMouseOver(e) : this.onCellMouseOver(e);
	},
	
	onMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of the grid.
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		e.rowIndex == -1 ? this.onHeaderCellMouseOut(e) : this.onCellMouseOut(e);
	},
	
	onMouseDown: function(e){
		// summary:
		//		Event fired when mouse is down inside grid.
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		e.rowIndex == -1 ? this.onHeaderCellMouseDown(e) : this.onCellMouseDown(e);
	},
	
	onMouseOverRow: function(e){
		// summary:
		//		Event fired when mouse is over any row (data or header).
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(!this.rows.isOver(e.rowIndex)){
			this.rows.setOverRow(e.rowIndex);
			e.rowIndex == -1 ? this.onHeaderMouseOver(e) : this.onRowMouseOver(e);
		}
	},
	onMouseOutRow: function(e){
		// summary:
		//		Event fired when mouse moves out of any row (data or header).
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(this.rows.isOver(-1)){
			this.onHeaderMouseOut(e);
		}else if(!this.rows.isOver(-2)){
			this.rows.setOverRow(-2);
			this.onRowMouseOut(e);
		}
	},
	
	onMouseDownRow: function(e){
		// summary:
		//		Event fired when mouse is down inside grid row
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		if(e.rowIndex != -1)
			this.onRowMouseDown(e);
	},

	// cell events
	onCellMouseOver: function(e){
		// summary:
		//		Event fired when mouse is over a cell.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			dojo.addClass(e.cellNode, this.cellOverClass);
		}
	},
	
	onCellMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of a cell.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			dojo.removeClass(e.cellNode, this.cellOverClass);
		}
	},
	
	onCellMouseDown: function(e){
		// summary:
		//		Event fired when mouse is down in a header cell.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onCellClick: function(e){
		// summary:
		//		Event fired when a cell is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this._click[0] = this._click[1];
		this._click[1] = e;
		if(!this.edit.isEditCell(e.rowIndex, e.cellIndex)){
			this.focus.setFocusCell(e.cell, e.rowIndex);
		}
		this.onRowClick(e);
	},

	onCellDblClick: function(e){
		// summary:
		//		Event fired when a cell is double-clicked.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(this._click.length > 1 && dojo.isIE){
			this.edit.setEditCell(this._click[1].cell, this._click[1].rowIndex);
		}else if(this._click.length > 1 && this._click[0].rowIndex != this._click[1].rowIndex){
			this.edit.setEditCell(this._click[0].cell, this._click[0].rowIndex);
		}else{
			this.edit.setEditCell(e.cell, e.rowIndex);
		}
		this.onRowDblClick(e);
	},

	onCellContextMenu: function(e){
		// summary:
		//		Event fired when a cell context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.onRowContextMenu(e);
	},

	onCellFocus: function(inCell, inRowIndex){
		// summary:
		//		Event fired when a cell receives focus.
		// inCell: Object
		//		Cell object containing properties of the grid column.
		// inRowIndex: Integer
		//		Index of the grid row
		this.edit.cellFocus(inCell, inRowIndex);
	},

	// row events
	onRowClick: function(e){
		// summary:
		//		Event fired when a row is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.edit.rowClick(e);
		this.selection.clickSelectEvent(e);
	},

	onRowDblClick: function(e){
		// summary:
		//		Event fired when a row is double clicked.
		// e: Event
		//		decorated event object which contains reference to grid, cell, and rowIndex
	},

	onRowMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over a data row.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onRowMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of a data row.
		// e: Event
		// 		Decorated event object contains reference to grid, cell, and rowIndex
	},
	
	onRowMouseDown: function(e){
		// summary:
		//		Event fired when mouse is down in a row.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onRowContextMenu: function(e){
		// summary:
		//		Event fired when a row context menu is accessed via mouse right click.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
		dojo.stopEvent(e);
	},

	// header events
	onHeaderMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over the grid header.
		// e: Event
		// 		Decorated event object contains reference to grid, cell, and rowIndex
	},

	onHeaderMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of the grid header.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderCellMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over a header cell.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			dojo.addClass(e.cellNode, this.cellOverClass);
		}
	},

	onHeaderCellMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of a header cell.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			dojo.removeClass(e.cellNode, this.cellOverClass);
		}
	},
	
	onHeaderCellMouseDown: function(e) {
		// summary:
		//		Event fired when mouse is down in a header cell.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderClick: function(e){
		// summary:
		//		Event fired when the grid header is clicked.
		// e: Event
		// Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderCellClick: function(e){
		// summary:
		//		Event fired when a header cell is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.setSortIndex(e.cell.index);
		this.onHeaderClick(e);
	},

	onHeaderDblClick: function(e){
		// summary:
		//		Event fired when the grid header is double clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderCellDblClick: function(e){
		// summary:
		//		Event fired when a header cell is double clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.onHeaderDblClick(e);
	},

	onHeaderCellContextMenu: function(e){
		// summary:
		//		Event fired when a header cell context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.onHeaderContextMenu(e);
	},

	onHeaderContextMenu: function(e){
		// summary:
		//		Event fired when the grid header context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		if(!this.headerMenu){
			dojo.stopEvent(e);
		}
	},

	// editing
	onStartEdit: function(inCell, inRowIndex){
		// summary:
		//		Event fired when editing is started for a given grid cell
		// inCell: Object
		//		Cell object containing properties of the grid column.
		// inRowIndex: Integer
		//		Index of the grid row
	},

	onApplyCellEdit: function(inValue, inRowIndex, inFieldIndex){
		// summary:
		//		Event fired when editing is applied for a given grid cell
		// inValue: String
		//		Value from cell editor
		// inRowIndex: Integer
		//		Index of the grid row
		// inFieldIndex: Integer
		//		Index in the grid's data store
	},

	onCancelEdit: function(inRowIndex){
		// summary:
		//		Event fired when editing is cancelled for a given grid cell
		// inRowIndex: Integer
		//		Index of the grid row
	},

	onApplyEdit: function(inRowIndex){
		// summary:
		//		Event fired when editing is applied for a given grid row
		// inRowIndex: Integer
		//		Index of the grid row
	},

	onCanSelect: function(inRowIndex){
		// summary:
		//		Event to determine if a grid row may be selected
		// inRowIndex: Integer
		//		Index of the grid row
		// returns: Boolean
		//		true if the row can be selected
		return true;
	},

	onCanDeselect: function(inRowIndex){
		// summary:
		//		Event to determine if a grid row may be deselected
		// inRowIndex: Integer
		//		Index of the grid row
		// returns: Boolean
		//		true if the row can be deselected
		return true;
	},

	onSelected: function(inRowIndex){
		// summary:
		//		Event fired when a grid row is selected
		// inRowIndex: Integer
		//		Index of the grid row
		this.updateRowStyles(inRowIndex);
	},

	onDeselected: function(inRowIndex){
		// summary:
		//		Event fired when a grid row is deselected
		// inRowIndex: Integer
		//		Index of the grid row
		this.updateRowStyles(inRowIndex);
	},

	onSelectionChanged: function(){
	}
});

}

if(!dojo._hasResource["dojox.grid._Grid"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid._Grid"] = true;
dojo.provide("dojox.grid._Grid");




















(function(){
	// NOTE: this is for backwards compatibility with Dojo 1.3
	if(!dojo.isCopyKey){
		dojo.isCopyKey = dojo.dnd.getCopyKeyState;
	}
	/*=====
	dojox.grid.__CellDef = function(){
		//	name: String?
		//		The text to use in the header of the grid for this cell.
		//	get: Function?
		//		function(rowIndex){} rowIndex is of type Integer.  This
		//		function will be called when a cell	requests data.  Returns the
		//		unformatted data for the cell.
		//	value: String?
		//		If "get" is not specified, this is used as the data for the cell.
		//	defaultValue: String?
		//		If "get" and "value" aren't specified or if "get" returns an undefined
		//		value, this is used as the data for the cell.  "formatter" is not run
		//		on this if "get" returns an undefined value.
		//	formatter: Function?
		//		function(data, rowIndex){} data is of type anything, rowIndex
		//		is of type Integer.  This function will be called after the cell
		//		has its data but before it passes it back to the grid to render.
		//		Returns the formatted version of the cell's data.
		//	type: dojox.grid.cells._Base|Function?
		//		TODO
		//	editable: Boolean?
		//		Whether this cell should be editable or not.
		//	hidden: Boolean?
		//		If true, the cell will not be displayed.
		//	noresize: Boolean?
		//		If true, the cell will not be able to be resized.
		//	width: Integer|String?
		//		A CSS size.  If it's an Integer, the width will be in em's.
		//	colSpan: Integer?
		//		How many columns to span this cell.  Will not work in the first
		//		sub-row of cells.
		//	rowSpan: Integer?
		//		How many sub-rows to span this cell.
		//	styles: String?
		//		A string of styles to apply to both the header cell and main
		//		grid cells.  Must end in a ';'.
		//	headerStyles: String?
		//		A string of styles to apply to just the header cell.  Must end
		//		in a ';'
		//	cellStyles: String?
		//		A string of styles to apply to just the main grid cells.  Must
		//		end in a ';'
		//	classes: String?
		//		A space separated list of classes to apply to both the header
		//		cell and the main grid cells.
		//	headerClasses: String?
		//		A space separated list of classes to apply to just the header
		//		cell.
		//	cellClasses: String?
		//		A space separated list of classes to apply to just the main
		//		grid cells.
		//	attrs: String?
		//		A space separated string of attribute='value' pairs to add to
		//		the header cell element and main grid cell elements.
		this.name = name;
		this.value = value;
		this.get = get;
		this.formatter = formatter;
		this.type = type;
		this.editable = editable;
		this.hidden = hidden;
		this.width = width;
		this.colSpan = colSpan;
		this.rowSpan = rowSpan;
		this.styles = styles;
		this.headerStyles = headerStyles;
		this.cellStyles = cellStyles;
		this.classes = classes;
		this.headerClasses = headerClasses;
		this.cellClasses = cellClasses;
		this.attrs = attrs;
	}
	=====*/

	/*=====
	dojox.grid.__ViewDef = function(){
		//	noscroll: Boolean?
		//		If true, no scrollbars will be rendered without scrollbars.
		//	width: Integer|String?
		//		A CSS size.  If it's an Integer, the width will be in em's. If
		//		"noscroll" is true, this value is ignored.
		//	cells: dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]?
		//		The structure of the cells within this grid.
		//	type: String?
		//		A string containing the constructor of a subclass of
		//		dojox.grid._View.  If this is not specified, dojox.grid._View
		//		is used.
		//	defaultCell: dojox.grid.__CellDef?
		//		A cell definition with default values for all cells in this view.  If
		//		a property is defined in a cell definition in the "cells" array and
		//		this property, the cell definition's property will override this
		//		property's property.
		//	onBeforeRow: Function?
		//		function(rowIndex, cells){} rowIndex is of type Integer, cells
		//		is of type Array[dojox.grid.__CellDef[]].  This function is called
		//		before each row of data is rendered.  Before the header is
		//		rendered, rowIndex will be -1.  "cells" is a reference to the
		//		internal structure of this view's cells so any changes you make to
		//		it will persist between calls.
		//	onAfterRow: Function?
		//		function(rowIndex, cells, rowNode){} rowIndex is of type Integer, cells
		//		is of type Array[dojox.grid.__CellDef[]], rowNode is of type DOMNode.
		//		This function is called	after each row of data is rendered.  After the
		//		header is rendered, rowIndex will be -1.  "cells" is a reference to the
		//		internal structure of this view's cells so any changes you make to
		//		it will persist between calls.
		this.noscroll = noscroll;
		this.width = width;
		this.cells = cells;
		this.type = type;
		this.defaultCell = defaultCell;
		this.onBeforeRow = onBeforeRow;
		this.onAfterRow = onAfterRow;
	}
	=====*/

	dojo.declare('dojox.grid._Grid',
		[ dijit._Widget, dijit._Templated, dojox.grid._Events ],
		{
		// summary:
		// 		A grid widget with virtual scrolling, cell editing, complex rows,
		// 		sorting, fixed columns, sizeable columns, etc.
		//
		//	description:
		//		_Grid provides the full set of grid features without any
		//		direct connection to a data store.
		//
		//		The grid exposes a get function for the grid, or optionally
		//		individual columns, to populate cell contents.
		//
		//		The grid is rendered based on its structure, an object describing
		//		column and cell layout.
		//
		//	example:
		//		A quick sample:
		//
		//		define a get function
		//	|	function get(inRowIndex){ // called in cell context
		//	|		return [this.index, inRowIndex].join(', ');
		//	|	}
		//
		//		define the grid structure:
		//	|	var structure = [ // array of view objects
		//	|		{ cells: [// array of rows, a row is an array of cells
		//	|			[
		//	|				{ name: "Alpha", width: 6 },
		//	|				{ name: "Beta" },
		//	|				{ name: "Gamma", get: get }]
		//	|		]}
		//	|	];
		//
		//	|	<div id="grid"
		//	|		rowCount="100" get="get"
		//	|		structure="structure"
		//	|		dojoType="dojox.grid._Grid"></div>

		templateString:"<div hidefocus=\"hidefocus\" role=\"grid\" dojoAttachEvent=\"onmouseout:_mouseOut\">\n\t<div class=\"dojoxGridMasterHeader\" dojoAttachPoint=\"viewsHeaderNode\" role=\"presentation\"></div>\n\t<div class=\"dojoxGridMasterView\" dojoAttachPoint=\"viewsNode\" role=\"presentation\"></div>\n\t<div class=\"dojoxGridMasterMessages\" style=\"display: none;\" dojoAttachPoint=\"messagesNode\"></div>\n\t<span dojoAttachPoint=\"lastFocusNode\" tabindex=\"0\"></span>\n</div>\n",

		// classTag: String
		// 		CSS class applied to the grid's domNode
		classTag: 'dojoxGrid',

		// settings
		// rowCount: Integer
		//		Number of rows to display.
		rowCount: 5,

		// keepRows: Integer
		//		Number of rows to keep in the rendering cache.
		keepRows: 75,

		// rowsPerPage: Integer
		//		Number of rows to render at a time.
		rowsPerPage: 1000,

		// autoWidth: Boolean
		//		If autoWidth is true, grid width is automatically set to fit the data.
		autoWidth: false,
		
		// initialWidth: String
		//		A css string to use to set our initial width (only used if autoWidth
		//		is true).  The first rendering of the grid will be this width, any
		//		resizing of columns, etc will result in the grid switching to
		//		autoWidth mode.  Note, this width will override any styling in a
		//		stylesheet or directly on the node.
		initialWidth: "",

		// autoHeight: Boolean|Integer
		//		If autoHeight is true, grid height is automatically set to fit the data.
		//		If it is an integer, the height will be automatically set to fit the data
		//		if there are fewer than that many rows - and the height will be set to show
		//		that many rows if there are more
		autoHeight: '',

		// rowHeight: Integer
		//		If rowHeight is set to a positive number, it will define the height of the rows
		//		in pixels. This can provide a significant performance advantage, since it
		//		eliminates the need to measure row sizes during rendering, which is one
		// 		the primary bottlenecks in the DataGrid's performance.
		rowHeight: 0,
		
		// autoRender: Boolean
		//		If autoRender is true, grid will render itself after initialization.
		autoRender: true,

		// defaultHeight: String
		//		default height of the grid, measured in any valid css unit.
		defaultHeight: '15em',
		
		// height: String
		//		explicit height of the grid, measured in any valid css unit.  This will be populated (and overridden)
		//		if the height: css attribute exists on the source node.
		height: '',

		// structure: dojox.grid.__ViewDef|dojox.grid.__ViewDef[]|dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]
		//		View layout defintion.
		structure: null,

		// elasticView: Integer
		//	Override defaults and make the indexed grid view elastic, thus filling available horizontal space.
		elasticView: -1,

		// singleClickEdit: boolean
		//		Single-click starts editing. Default is double-click
		singleClickEdit: false,

		// selectionMode: String
		//		Set the selection mode of grid's Selection.  Value must be 'single', 'multiple',
		//		or 'extended'.  Default is 'extended'.
		selectionMode: 'extended',

		// rowSelector: Boolean|String
		// 		If set to true, will add a row selector view to this grid.  If set to a CSS width, will add
		// 		a row selector of that width to this grid.
		rowSelector: '',

		// columnReordering: Boolean
		// 		If set to true, will add drag and drop reordering to views with one row of columns.
		columnReordering: false,

		// headerMenu: dijit.Menu
		// 		If set to a dijit.Menu, will use this as a context menu for the grid headers.
		headerMenu: null,

		// placeholderLabel: String
		// 		Label of placeholders to search for in the header menu to replace with column toggling
		// 		menu items.
		placeholderLabel: "GridColumns",
		
		// selectable: Boolean
		//		Set to true if you want to be able to select the text within the grid.
		selectable: false,
		
		// Used to store the last two clicks, to ensure double-clicking occurs based on the intended row
		_click: null,
		
		// loadingMessage: String
		//  Message that shows while the grid is loading
		loadingMessage: "<span class='dojoxGridLoading'>${loadingState}</span>",

		// errorMessage: String
		//  Message that shows when the grid encounters an error loading
		errorMessage: "<span class='dojoxGridError'>${errorState}</span>",

		// noDataMessage: String
		//  Message that shows if the grid has no data - wrap it in a
		//  span with class 'dojoxGridNoData' if you want it to be
		//  styled similar to the loading and error messages
		noDataMessage: "",
		
		// escapeHTMLInData: Boolean
		//		This will escape HTML brackets from the data to prevent HTML from
		// 		user-inputted data being rendered with may contain JavaScript and result in
		// 		XSS attacks. This is true by default, and it is recommended that it remain
		// 		true. Setting this to false will allow data to be displayed in the grid without
		// 		filtering, and should be only used if it is known that the data won't contain
		// 		malicious scripts. If HTML is needed in grid cells, it is recommended that
		// 		you use the formatter function to generate the HTML (the output of
		// 		formatter functions is not filtered, even with escapeHTMLInData set to true).
		escapeHTMLInData: true,
		
		// formatterScope: Object
		//		An object to execute format functions within.  If not set, the
		//		format functions will execute within the scope of the cell that
		//		has a format function.
		formatterScope: null,
		
		// editable: boolean
		// indicates if the grid contains editable cells, default is false
		// set to true if editable cell encountered during rendering
		editable: false,
		
		// private
		sortInfo: 0,
		themeable: true,
		_placeholders: null,

		// _layoutClass: Object
		//	The class to use for our layout - can be overridden by grid subclasses
		_layoutClass: dojox.grid._Layout,

		// initialization
		buildRendering: function(){
			this.inherited(arguments);
			if(!this.domNode.getAttribute('tabIndex')){
				this.domNode.tabIndex = "0";
			}
			this.createScroller();
			this.createLayout();
			this.createViews();
			this.createManagers();

			this.createSelection();

			this.connect(this.selection, "onSelected", "onSelected");
			this.connect(this.selection, "onDeselected", "onDeselected");
			this.connect(this.selection, "onChanged", "onSelectionChanged");

			dojox.html.metrics.initOnFontResize();
			this.connect(dojox.html.metrics, "onFontResize", "textSizeChanged");
			dojox.grid.util.funnelEvents(this.domNode, this, 'doKeyEvent', dojox.grid.util.keyEvents);
			if (this.selectionMode != "none") {
				dojo.attr(this.domNode, "aria-multiselectable", this.selectionMode == "single" ? "false" : "true");
			}

			dojo.addClass(this.domNode, this.classTag);
			if(!this.isLeftToRight()){
				dojo.addClass(this.domNode, this.classTag+"Rtl");
			}
		},
		
		postMixInProperties: function(){
			this.inherited(arguments);
			var messages = dojo.i18n.getLocalization("dijit", "loading", this.lang);
			this.loadingMessage = dojo.string.substitute(this.loadingMessage, messages);
			this.errorMessage = dojo.string.substitute(this.errorMessage, messages);
			if(this.srcNodeRef && this.srcNodeRef.style.height){
				this.height = this.srcNodeRef.style.height;
			}
			// Call this to update our autoheight to start out
			this._setAutoHeightAttr(this.autoHeight, true);
			this.lastScrollTop = this.scrollTop = 0;
		},
		
		postCreate: function(){
			this._placeholders = [];
			this._setHeaderMenuAttr(this.headerMenu);
			this._setStructureAttr(this.structure);
			this._click = [];
			this.inherited(arguments);
			if(this.domNode && this.autoWidth && this.initialWidth){
				this.domNode.style.width = this.initialWidth;
			}
			if (this.domNode && !this.editable){
				// default value for aria-readonly is false, set to true if grid is not editable
				dojo.attr(this.domNode,"aria-readonly", "true");
			}
		},

		destroy: function(){
			this.domNode.onReveal = null;
			this.domNode.onSizeChange = null;

			// Fixes IE domNode leak
			delete this._click;

			this.edit.destroy();
			delete this.edit;

			this.views.destroyViews();
			if(this.scroller){
				this.scroller.destroy();
				delete this.scroller;
			}
			if(this.focus){
				this.focus.destroy();
				delete this.focus;
			}
			if(this.headerMenu&&this._placeholders.length){
				dojo.forEach(this._placeholders, function(p){ p.unReplace(true); });
				this.headerMenu.unBindDomNode(this.viewsHeaderNode);
			}
			this.inherited(arguments);
		},

		_setAutoHeightAttr: function(ah, skipRender){
			// Calculate our autoheight - turn it into a boolean or an integer
			if(typeof ah == "string"){
				if(!ah || ah == "false"){
					ah = false;
				}else if (ah == "true"){
					ah = true;
				}else{
					ah = window.parseInt(ah, 10);
				}
			}
			if(typeof ah == "number"){
				if(isNaN(ah)){
					ah = false;
				}
				// Autoheight must be at least 1, if it's a number.  If it's
				// less than 0, we'll take that to mean "all" rows (same as
				// autoHeight=true - if it is equal to zero, we'll take that
				// to mean autoHeight=false
				if(ah < 0){
					ah = true;
				}else if (ah === 0){
					ah = false;
				}
			}
			this.autoHeight = ah;
			if(typeof ah == "boolean"){
				this._autoHeight = ah;
			}else if(typeof ah == "number"){
				this._autoHeight = (ah >= this.get('rowCount'));
			}else{
				this._autoHeight = false;
			}
			if(this._started && !skipRender){
				this.render();
			}
		},

		_getRowCountAttr: function(){
			return this.updating && this.invalidated && this.invalidated.rowCount != undefined ?
				this.invalidated.rowCount : this.rowCount;
		},
		
		textSizeChanged: function(){
			this.render();
		},

		sizeChange: function(){
			this.update();
		},

		createManagers: function(){
			// summary:
			//		create grid managers for various tasks including rows, focus, selection, editing

			// row manager
			this.rows = new dojox.grid._RowManager(this);
			// focus manager
			this.focus = new dojox.grid._FocusManager(this);
			// edit manager
			this.edit = new dojox.grid._EditManager(this);
		},

		createSelection: function(){
			// summary:	Creates a new Grid selection manager.

			// selection manager
			this.selection = new dojox.grid.Selection(this);
		},

		createScroller: function(){
			// summary: Creates a new virtual scroller
			this.scroller = new dojox.grid._Scroller();
			this.scroller.grid = this;
			this.scroller.renderRow = dojo.hitch(this, "renderRow");
			this.scroller.removeRow = dojo.hitch(this, "rowRemoved");
		},

		createLayout: function(){
			// summary: Creates a new Grid layout
			this.layout = new this._layoutClass(this);
			this.connect(this.layout, "moveColumn", "onMoveColumn");
		},

		onMoveColumn: function(){
			this.render();
		},
		
		onResizeColumn: function(/*int*/ cellIdx){
			// Called when a column is resized.
		},

		// views
		createViews: function(){
			this.views = new dojox.grid._ViewManager(this);
			this.views.createView = dojo.hitch(this, "createView");
		},

		createView: function(inClass, idx){
			var c = dojo.getObject(inClass);
			var view = new c({ grid: this, index: idx });
			this.viewsNode.appendChild(view.domNode);
			this.viewsHeaderNode.appendChild(view.headerNode);
			this.views.addView(view);
			dojo.attr(this.domNode, "align", dojo._isBodyLtr() ? 'left' : 'right');
			return view;
		},

		buildViews: function(){
			for(var i=0, vs; (vs=this.layout.structure[i]); i++){
				this.createView(vs.type || dojox._scopeName + ".grid._View", i).setStructure(vs);
			}
			this.scroller.setContentNodes(this.views.getContentNodes());
		},

		_setStructureAttr: function(structure){
			var s = structure;
			if(s && dojo.isString(s)){
				dojo.deprecated("dojox.grid._Grid.set('structure', 'objVar')", "use dojox.grid._Grid.set('structure', objVar) instead", "2.0");
				s=dojo.getObject(s);
			}
			this.structure = s;
			if(!s){
				if(this.layout.structure){
					s = this.layout.structure;
				}else{
					return;
				}
			}
			this.views.destroyViews();
			this.focus.focusView = null;
			if(s !== this.layout.structure){
				this.layout.setStructure(s);
			}
			this._structureChanged();
		},

		setStructure: function(/* dojox.grid.__ViewDef|dojox.grid.__ViewDef[]|dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]] */ inStructure){
			// summary:
			//		Install a new structure and rebuild the grid.
			dojo.deprecated("dojox.grid._Grid.setStructure(obj)", "use dojox.grid._Grid.set('structure', obj) instead.", "2.0");
			this._setStructureAttr(inStructure);
		},
		
		getColumnTogglingItems: function(){
			// Summary: returns an array of dijit.CheckedMenuItem widgets that can be
			//		added to a menu for toggling columns on and off.
			return dojo.map(this.layout.cells, function(cell){
				if(!cell.menuItems){ cell.menuItems = []; }

				var self = this;
				var item = new dijit.CheckedMenuItem({
					label: cell.name,
					checked: !cell.hidden,
					_gridCell: cell,
					onChange: function(checked){
						if(self.layout.setColumnVisibility(this._gridCell.index, checked)){
							var items = this._gridCell.menuItems;
							if(items.length > 1){
								dojo.forEach(items, function(item){
									if(item !== this){
										item.setAttribute("checked", checked);
									}
								}, this);
							}
							checked = dojo.filter(self.layout.cells, function(c){
								if(c.menuItems.length > 1){
									dojo.forEach(c.menuItems, "item.set('disabled', false);");
								}else{
									c.menuItems[0].set('disabled', false);
								}
								return !c.hidden;
							});
							if(checked.length == 1){
								dojo.forEach(checked[0].menuItems, "item.set('disabled', true);");
							}
						}
					},
					destroy: function(){
						var index = dojo.indexOf(this._gridCell.menuItems, this);
						this._gridCell.menuItems.splice(index, 1);
						delete this._gridCell;
						dijit.CheckedMenuItem.prototype.destroy.apply(this, arguments);
					}
				});
				cell.menuItems.push(item);
				return item;
			}, this); // dijit.CheckedMenuItem[]
		},

		_setHeaderMenuAttr: function(menu){
			if(this._placeholders && this._placeholders.length){
				dojo.forEach(this._placeholders, function(p){
					p.unReplace(true);
				});
				this._placeholders = [];
			}
			if(this.headerMenu){
				this.headerMenu.unBindDomNode(this.viewsHeaderNode);
			}
			this.headerMenu = menu;
			if(!menu){ return; }

			this.headerMenu.bindDomNode(this.viewsHeaderNode);
			if(this.headerMenu.getPlaceholders){
				this._placeholders = this.headerMenu.getPlaceholders(this.placeholderLabel);
			}
		},

		setHeaderMenu: function(/* dijit.Menu */ menu){
			dojo.deprecated("dojox.grid._Grid.setHeaderMenu(obj)", "use dojox.grid._Grid.set('headerMenu', obj) instead.", "2.0");
			this._setHeaderMenuAttr(menu);
		},
		
		setupHeaderMenu: function(){
			if(this._placeholders && this._placeholders.length){
				dojo.forEach(this._placeholders, function(p){
					if(p._replaced){
						p.unReplace(true);
					}
					p.replace(this.getColumnTogglingItems());
				}, this);
			}
		},

		_fetch: function(start){
			this.setScrollTop(0);
		},

		getItem: function(inRowIndex){
			return null;
		},
		
		showMessage: function(message){
			if(message){
				this.messagesNode.innerHTML = message;
				this.messagesNode.style.display = "";
			}else{
				this.messagesNode.innerHTML = "";
				this.messagesNode.style.display = "none";
			}
		},

		_structureChanged: function() {
			this.buildViews();
			if(this.autoRender && this._started){
				this.render();
			}
		},

		hasLayout: function() {
			return this.layout.cells.length;
		},

		// sizing
		resize: function(changeSize, resultSize){
			// summary:
			//		Update the grid's rendering dimensions and resize it
			
			// Calling sizeChange calls update() which calls _resize...so let's
			// save our input values, if any, and use them there when it gets
			// called.  This saves us an extra call to _resize(), which can
			// get kind of heavy.
			this._pendingChangeSize = changeSize;
			this._pendingResultSize = resultSize;
			this.sizeChange();
		},

		_getPadBorder: function() {
			this._padBorder = this._padBorder || dojo._getPadBorderExtents(this.domNode);
			return this._padBorder;
		},

		_getHeaderHeight: function(){
			var vns = this.viewsHeaderNode.style, t = vns.display == "none" ? 0 : this.views.measureHeader();
			vns.height = t + 'px';
			// header heights are reset during measuring so must be normalized after measuring.
			this.views.normalizeHeaderNodeHeight();
			return t;
		},
		
		_resize: function(changeSize, resultSize){
			// Restore our pending values, if any
			changeSize = changeSize || this._pendingChangeSize;
			resultSize = resultSize || this._pendingResultSize;
			delete this._pendingChangeSize;
			delete this._pendingResultSize;
			// if we have set up everything except the DOM, we cannot resize
			if(!this.domNode){ return; }
			var pn = this.domNode.parentNode;
			if(!pn || pn.nodeType != 1 || !this.hasLayout() || pn.style.visibility == "hidden" || pn.style.display == "none"){
				return;
			}
			// useful measurement
			var padBorder = this._getPadBorder();
			var hh = undefined;
			var h;
			// grid height
			if(this._autoHeight){
				this.domNode.style.height = 'auto';
			}else if(typeof this.autoHeight == "number"){
				h = hh = this._getHeaderHeight();
				h += (this.scroller.averageRowHeight * this.autoHeight);
				this.domNode.style.height = h + "px";
			}else if(this.domNode.clientHeight <= padBorder.h){
				if(pn == document.body){
					this.domNode.style.height = this.defaultHeight;
				}else if(this.height){
					this.domNode.style.height = this.height;
				}else{
					this.fitTo = "parent";
				}
			}
			// if we are given dimensions, size the grid's domNode to those dimensions
			if(resultSize){
				changeSize = resultSize;
			}
			if(changeSize){
				dojo.marginBox(this.domNode, changeSize);
				this.height = this.domNode.style.height;
				delete this.fitTo;
			}else if(this.fitTo == "parent"){
				h = this._parentContentBoxHeight = this._parentContentBoxHeight || dojo._getContentBox(pn).h;
				this.domNode.style.height = Math.max(0, h) + "px";
			}
			
			var hasFlex = dojo.some(this.views.views, function(v){ return v.flexCells; });

			if(!this._autoHeight && (h || dojo._getContentBox(this.domNode).h) === 0){
				// We need to hide the header, since the Grid is essentially hidden.
				this.viewsHeaderNode.style.display = "none";
			}else{
				// Otherwise, show the header and give it an appropriate height.
				this.viewsHeaderNode.style.display = "block";
				if(!hasFlex && hh === undefined){
					hh = this._getHeaderHeight();
				}
			}
			if(hasFlex){
				hh = undefined;
			}

			// NOTE: it is essential that width be applied before height
			// Header height can only be calculated properly after view widths have been set.
			// This is because flex column width is naturally 0 in Firefox.
			// Therefore prior to width sizing flex columns with spaces are maximally wrapped
			// and calculated to be too tall.
			this.adaptWidth();
			this.adaptHeight(hh);

			this.postresize();
		},

		adaptWidth: function() {
			// private: sets width and position for views and update grid width if necessary
			var doAutoWidth = (!this.initialWidth && this.autoWidth);
			var w = doAutoWidth ? 0 : this.domNode.clientWidth || (this.domNode.offsetWidth - this._getPadBorder().w),
				vw = this.views.arrange(1, w);
			this.views.onEach("adaptWidth");
			if(doAutoWidth){
				this.domNode.style.width = vw + "px";
			}
		},

		adaptHeight: function(inHeaderHeight){
			// private: measures and normalizes header height, then sets view heights, and then updates scroller
			// content extent
			var t = inHeaderHeight === undefined ? this._getHeaderHeight() : inHeaderHeight;
			var h = (this._autoHeight ? -1 : Math.max(this.domNode.clientHeight - t, 0) || 0);
			this.views.onEach('setSize', [0, h]);
			this.views.onEach('adaptHeight');
			if(!this._autoHeight){
				var numScroll = 0, numNoScroll = 0;
				var noScrolls = dojo.filter(this.views.views, function(v){
					var has = v.hasHScrollbar();
					if(has){ numScroll++; }else{ numNoScroll++; }
					return (!has);
				});
				if(numScroll > 0 && numNoScroll > 0){
					dojo.forEach(noScrolls, function(v){
						v.adaptHeight(true);
					});
				}
			}
			if(this.autoHeight === true || h != -1 || (typeof this.autoHeight == "number" && this.autoHeight >= this.get('rowCount'))){
				this.scroller.windowHeight = h;
			}else{
				this.scroller.windowHeight = Math.max(this.domNode.clientHeight - t, 0);
			}
		},

		// startup
		startup: function(){
			if(this._started){return;}
			this.inherited(arguments);
			if(this.autoRender){
				this.render();
			}
		},

		// render
		render: function(){
			// summary:
			//	Render the grid, headers, and views. Edit and scrolling states are reset. To retain edit and
			// scrolling states, see Update.

			if(!this.domNode){return;}
			if(!this._started){return;}

			if(!this.hasLayout()) {
				this.scroller.init(0, this.keepRows, this.rowsPerPage);
				return;
			}
			//
			this.update = this.defaultUpdate;
			this._render();
		},

		_render: function(){
			this.scroller.init(this.get('rowCount'), this.keepRows, this.rowsPerPage);
			this.prerender();
			this.setScrollTop(0);
			this.postrender();
		},

		prerender: function(){
			// if autoHeight, make sure scroller knows not to virtualize; everything must be rendered.
			this.keepRows = this._autoHeight ? 0 : this.keepRows;
			this.scroller.setKeepInfo(this.keepRows);
			this.views.render();
			this._resize();
		},

		postrender: function(){
			this.postresize();
			this.focus.initFocusView();
			// make rows unselectable
			dojo.setSelectable(this.domNode, this.selectable);
		},

		postresize: function(){
			// views are position absolute, so they do not inflate the parent
			if(this._autoHeight){
				var size = Math.max(this.views.measureContent()) + 'px';
				
				this.viewsNode.style.height = size;
			}
		},

		renderRow: function(inRowIndex, inNodes){
			// summary: private, used internally to render rows
			this.views.renderRow(inRowIndex, inNodes, this._skipRowRenormalize);
		},

		rowRemoved: function(inRowIndex){
			// summary: private, used internally to remove rows
			this.views.rowRemoved(inRowIndex);
		},

		invalidated: null,

		updating: false,

		beginUpdate: function(){
			// summary:
			//		Use to make multiple changes to rows while queueing row updating.
			// NOTE: not currently supporting nested begin/endUpdate calls
			this.invalidated = [];
			this.updating = true;
		},

		endUpdate: function(){
			// summary:
			//		Use after calling beginUpdate to render any changes made to rows.
			this.updating = false;
			var i = this.invalidated, r;
			if(i.all){
				this.update();
			}else if(i.rowCount != undefined){
				this.updateRowCount(i.rowCount);
			}else{
				for(r in i){
					this.updateRow(Number(r));
				}
			}
			this.invalidated = [];
		},

		// update
		defaultUpdate: function(){
			// note: initial update calls render and subsequently this function.
			if(!this.domNode){return;}
			if(this.updating){
				this.invalidated.all = true;
				return;
			}
			//this.edit.saveState(inRowIndex);
			this.lastScrollTop = this.scrollTop;
			this.prerender();
			this.scroller.invalidateNodes();
			this.setScrollTop(this.lastScrollTop);
			this.postrender();
			//this.edit.restoreState(inRowIndex);
		},

		update: function(){
			// summary:
			//		Update the grid, retaining edit and scrolling states.
			this.render();
		},

		updateRow: function(inRowIndex){
			// summary:
			//		Render a single row.
			// inRowIndex: Integer
			//		Index of the row to render
			inRowIndex = Number(inRowIndex);
			if(this.updating){
				this.invalidated[inRowIndex]=true;
			}else{
				this.views.updateRow(inRowIndex);
				this.scroller.rowHeightChanged(inRowIndex);
			}
		},

		updateRows: function(startIndex, howMany){
			// summary:
			//		Render consecutive rows at once.
			// startIndex: Integer
			//		Index of the starting row to render
			// howMany: Integer
			//		How many rows to update.
			startIndex = Number(startIndex);
			howMany = Number(howMany);
			var i;
			if(this.updating){
				for(i=0; i<howMany; i++){
					this.invalidated[i+startIndex]=true;
				}
			}else{
				for(i=0; i<howMany; i++){
					this.views.updateRow(i+startIndex, this._skipRowRenormalize);
				}
				this.scroller.rowHeightChanged(startIndex);
			}
		},

		updateRowCount: function(inRowCount){
			//summary:
			//	Change the number of rows.
			// inRowCount: int
			//	Number of rows in the grid.
			if(this.updating){
				this.invalidated.rowCount = inRowCount;
			}else{
				this.rowCount = inRowCount;
				this._setAutoHeightAttr(this.autoHeight, true);
				if(this.layout.cells.length){
					this.scroller.updateRowCount(inRowCount);
				}
				this._resize();
				if(this.layout.cells.length){
					this.setScrollTop(this.scrollTop);
				}
			}
		},

		updateRowStyles: function(inRowIndex){
			// summary:
			//		Update the styles for a row after it's state has changed.
			this.views.updateRowStyles(inRowIndex);
		},
		getRowNode: function(inRowIndex){
			// summary:
			//		find the rowNode that is not a rowSelector
			if (this.focus.focusView && !(this.focus.focusView instanceof dojox.grid._RowSelector)){
					return this.focus.focusView.rowNodes[inRowIndex];
			}else{ // search through views
				for (var i = 0, cView; (cView = this.views.views[i]); i++) {
					if (!(cView instanceof dojox.grid._RowSelector)) {
						return cView.rowNodes[inRowIndex];
					}
				}
			}
			return null;
		},
		rowHeightChanged: function(inRowIndex){
			// summary:
			//		Update grid when the height of a row has changed. Row height is handled automatically as rows
			//		are rendered. Use this function only to update a row's height outside the normal rendering process.
			// inRowIndex: Integer
			// 		index of the row that has changed height

			this.views.renormalizeRow(inRowIndex);
			this.scroller.rowHeightChanged(inRowIndex);
		},

		// fastScroll: Boolean
		//		flag modifies vertical scrolling behavior. Defaults to true but set to false for slower
		//		scroll performance but more immediate scrolling feedback
		fastScroll: true,

		delayScroll: false,

		// scrollRedrawThreshold: int
		//	pixel distance a user must scroll vertically to trigger grid scrolling.
		scrollRedrawThreshold: (dojo.isIE ? 100 : 50),

		// scroll methods
		scrollTo: function(inTop){
			// summary:
			//		Vertically scroll the grid to a given pixel position
			// inTop: Integer
			//		vertical position of the grid in pixels
			if(!this.fastScroll){
				this.setScrollTop(inTop);
				return;
			}
			var delta = Math.abs(this.lastScrollTop - inTop);
			this.lastScrollTop = inTop;
			if(delta > this.scrollRedrawThreshold || this.delayScroll){
				this.delayScroll = true;
				this.scrollTop = inTop;
				this.views.setScrollTop(inTop);
				if(this._pendingScroll){
					window.clearTimeout(this._pendingScroll);
				}
				var _this = this;
				this._pendingScroll = window.setTimeout(function(){
					delete _this._pendingScroll;
					_this.finishScrollJob();
				}, 200);
			}else{
				this.setScrollTop(inTop);
			}
		},

		finishScrollJob: function(){
			this.delayScroll = false;
			this.setScrollTop(this.scrollTop);
		},

		setScrollTop: function(inTop){
			this.scroller.scroll(this.views.setScrollTop(inTop));
		},

		scrollToRow: function(inRowIndex){
			// summary:
			//		Scroll the grid to a specific row.
			// inRowIndex: Integer
			// 		grid row index
			this.setScrollTop(this.scroller.findScrollTop(inRowIndex) + 1);
		},

		// styling (private, used internally to style individual parts of a row)
		styleRowNode: function(inRowIndex, inRowNode){
			if(inRowNode){
				this.rows.styleRowNode(inRowIndex, inRowNode);
			}
		},
		
		// called when the mouse leaves the grid so we can deselect all hover rows
		_mouseOut: function(e){
			this.rows.setOverRow(-2);
		},
	
		// cells
		getCell: function(inIndex){
			// summary:
			//		Retrieves the cell object for a given grid column.
			// inIndex: Integer
			// 		Grid column index of cell to retrieve
			// returns:
			//		a grid cell
			return this.layout.cells[inIndex];
		},

		setCellWidth: function(inIndex, inUnitWidth){
			this.getCell(inIndex).unitWidth = inUnitWidth;
		},

		getCellName: function(inCell){
			// summary: Returns the cell name of a passed cell
			return "Cell " + inCell.index; // String
		},

		// sorting
		canSort: function(inSortInfo){
			// summary:
			//		Determines if the grid can be sorted
			// inSortInfo: Integer
			//		Sort information, 1-based index of column on which to sort, positive for an ascending sort
			// 		and negative for a descending sort
			// returns: Boolean
			//		True if grid can be sorted on the given column in the given direction
		},

		sort: function(){
		},

		getSortAsc: function(inSortInfo){
			// summary:
			//		Returns true if grid is sorted in an ascending direction.
			inSortInfo = inSortInfo == undefined ? this.sortInfo : inSortInfo;
			return Boolean(inSortInfo > 0); // Boolean
		},

		getSortIndex: function(inSortInfo){
			// summary:
			//		Returns the index of the column on which the grid is sorted
			inSortInfo = inSortInfo == undefined ? this.sortInfo : inSortInfo;
			return Math.abs(inSortInfo) - 1; // Integer
		},

		setSortIndex: function(inIndex, inAsc){
			// summary:
			// 		Sort the grid on a column in a specified direction
			// inIndex: Integer
			// 		Column index on which to sort.
			// inAsc: Boolean
			// 		If true, sort the grid in ascending order, otherwise in descending order
			var si = inIndex +1;
			if(inAsc != undefined){
				si *= (inAsc ? 1 : -1);
			} else if(this.getSortIndex() == inIndex){
				si = -this.sortInfo;
			}
			this.setSortInfo(si);
		},

		setSortInfo: function(inSortInfo){
			if(this.canSort(inSortInfo)){
				window.callFromSortHeaderClick=true; 
				
				this.sortInfo = inSortInfo;
				this.sort();
				this.update();
				
				setTimeout(function() {
					window.callFromSortHeaderClick=false;
				}, 5000);
			}
		},

		// DOM event handler
		doKeyEvent: function(e){
			e.dispatch = 'do' + e.type;
			this.onKeyEvent(e);
		},

		// event dispatch
		//: protected
		_dispatch: function(m, e){
			if(m in this){
				return this[m](e);
			}
			return false;
		},

		dispatchKeyEvent: function(e){
			this._dispatch(e.dispatch, e);
		},

		dispatchContentEvent: function(e){
			this.edit.dispatchEvent(e) || e.sourceView.dispatchContentEvent(e) || this._dispatch(e.dispatch, e);
		},

		dispatchHeaderEvent: function(e){
			e.sourceView.dispatchHeaderEvent(e) || this._dispatch('doheader' + e.type, e);
		},

		dokeydown: function(e){
			this.onKeyDown(e);
		},

		doclick: function(e){
			if(e.cellNode){
				this.onCellClick(e);
			}else{
				this.onRowClick(e);
			}
		},

		dodblclick: function(e){
			if(e.cellNode){
				this.onCellDblClick(e);
			}else{
				this.onRowDblClick(e);
			}
		},

		docontextmenu: function(e){
			if(e.cellNode){
				this.onCellContextMenu(e);
			}else{
				this.onRowContextMenu(e);
			}
		},

		doheaderclick: function(e){
			if(e.cellNode){
				this.onHeaderCellClick(e);
			}else{
				this.onHeaderClick(e);
			}
		},

		doheaderdblclick: function(e){
			if(e.cellNode){
				this.onHeaderCellDblClick(e);
			}else{
				this.onHeaderDblClick(e);
			}
		},

		doheadercontextmenu: function(e){
			if(e.cellNode){
				this.onHeaderCellContextMenu(e);
			}else{
				this.onHeaderContextMenu(e);
			}
		},

		// override to modify editing process
		doStartEdit: function(inCell, inRowIndex){
			this.onStartEdit(inCell, inRowIndex);
		},

		doApplyCellEdit: function(inValue, inRowIndex, inFieldIndex){
			this.onApplyCellEdit(inValue, inRowIndex, inFieldIndex);
		},

		doCancelEdit: function(inRowIndex){
			this.onCancelEdit(inRowIndex);
		},

		doApplyEdit: function(inRowIndex){
			this.onApplyEdit(inRowIndex);
		},

		// row editing
		addRow: function(){
			// summary:
			//		Add a row to the grid.
			this.updateRowCount(this.get('rowCount')+1);
		},

		removeSelectedRows: function(){
			// summary:
			//		Remove the selected rows from the grid.
			if(this.allItemsSelected){
				this.updateRowCount(0);
			}else{
				this.updateRowCount(Math.max(0, this.get('rowCount') - this.selection.getSelected().length));
			}
			this.selection.clear();
		}

	});

	dojox.grid._Grid.markupFactory = function(props, node, ctor, cellFunc){
		var d = dojo;
		var widthFromAttr = function(n){
			var w = d.attr(n, "width")||"auto";
			if((w != "auto")&&(w.slice(-2) != "em")&&(w.slice(-1) != "%")){
				w = parseInt(w, 10)+"px";
			}
			return w;
		};
		// if(!props.store){ console.debug("no store!"); }
		// if a structure isn't referenced, do we have enough
		// data to try to build one automatically?
		if(	!props.structure &&
			node.nodeName.toLowerCase() == "table"){

			// try to discover a structure
			props.structure = d.query("> colgroup", node).map(function(cg){
				var sv = d.attr(cg, "span");
				var v = {
					noscroll: (d.attr(cg, "noscroll") == "true") ? true : false,
					__span: (!!sv ? parseInt(sv, 10) : 1),
					cells: []
				};
				if(d.hasAttr(cg, "width")){
					v.width = widthFromAttr(cg);
				}
				return v; // for vendetta
			});
			if(!props.structure.length){
				props.structure.push({
					__span: Infinity,
					cells: [] // catch-all view
				});
			}
			// check to see if we're gonna have more than one view

			// for each tr in our th, create a row of cells
			d.query("thead > tr", node).forEach(function(tr, tr_idx){
				var cellCount = 0;
				var viewIdx = 0;
				var lastViewIdx;
				var cView = null;
				d.query("> th", tr).map(function(th){
					// what view will this cell go into?

					// NOTE:
					//		to prevent extraneous iteration, we start counters over
					//		for each row, incrementing over the surface area of the
					//		structure that colgroup processing generates and
					//		creating cell objects for each <th> to place into those
					//		cell groups.  There's a lot of state-keepking logic
					//		here, but it is what it has to be.
					if(!cView){ // current view book keeping
						lastViewIdx = 0;
						cView = props.structure[0];
					}else if(cellCount >= (lastViewIdx+cView.__span)){
						viewIdx++;
						// move to allocating things into the next view
						lastViewIdx += cView.__span;
						var lastView = cView;
						cView = props.structure[viewIdx];
					}

					// actually define the cell from what markup hands us
					var cell = {
						name: d.trim(d.attr(th, "name")||th.innerHTML),
						colSpan: parseInt(d.attr(th, "colspan")||1, 10),
						type: d.trim(d.attr(th, "cellType")||""),
						id: d.trim(d.attr(th,"id")||"")
					};
					cellCount += cell.colSpan;
					var rowSpan = d.attr(th, "rowspan");
					if(rowSpan){
						cell.rowSpan = rowSpan;
					}
					if(d.hasAttr(th, "width")){
						cell.width = widthFromAttr(th);
					}
					if(d.hasAttr(th, "relWidth")){
						cell.relWidth = window.parseInt(dojo.attr(th, "relWidth"), 10);
					}
					if(d.hasAttr(th, "hidden")){
						cell.hidden = (d.attr(th, "hidden") == "true" || d.attr(th, "hidden") === true/*always boolean true in Chrome*/);
					}

					if(cellFunc){
						cellFunc(th, cell);
					}

					cell.type = cell.type ? dojo.getObject(cell.type) : dojox.grid.cells.Cell;

					if(cell.type && cell.type.markupFactory){
						cell.type.markupFactory(th, cell);
					}

					if(!cView.cells[tr_idx]){
						cView.cells[tr_idx] = [];
					}
					cView.cells[tr_idx].push(cell);
				});
			});
		}

		return new ctor(props, node);
	};
})();

}

if(!dojo._hasResource["dojox.grid.DataSelection"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.DataSelection"] = true;
dojo.provide("dojox.grid.DataSelection");


dojo.declare("dojox.grid.DataSelection", dojox.grid.Selection, {
	getFirstSelected: function(){
		var idx = dojox.grid.Selection.prototype.getFirstSelected.call(this);

		if(idx == -1){ return null; }
		return this.grid.getItem(idx);
	},

	getNextSelected: function(inPrev){
		var old_idx = this.grid.getItemIndex(inPrev);
		var idx = dojox.grid.Selection.prototype.getNextSelected.call(this, old_idx);

		if(idx == -1){ return null; }
		return this.grid.getItem(idx);
	},

    getSelected: function(){
        var result = [];
     // Object.keys is undefined for IE<9 
        if (!Object.keys) {
        	  Object.keys = (function() {
        	    'use strict';
        	    var hasOwnProperty = Object.prototype.hasOwnProperty,
        	        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),
        	        dontEnums = [
        	          'toString',
        	          'toLocaleString',
        	          'valueOf',
        	          'hasOwnProperty',
        	          'isPrototypeOf',
        	          'propertyIsEnumerable',
        	          'constructor'
        	        ],
        	        dontEnumsLength = dontEnums.length;

        	    return function(obj) {
        	      if (typeof obj !== 'function' && (typeof obj !== 'object' || obj === null)) {
        	        throw new TypeError('Object.keys called on non-object');
        	      }

        	      var result = [], prop, i;

        	      for (prop in obj) {
        	        if (hasOwnProperty.call(obj, prop)) {
        	          result.push(prop);
        	        }
        	      }

        	      if (hasDontEnumBug) {
        	        for (i = 0; i < dontEnumsLength; i++) {
        	          if (hasOwnProperty.call(obj, dontEnums[i])) {
        	            result.push(dontEnums[i]);
        	          }
        	        }
        	      }
        	      return result;
        	    };
        	  }());
        	}
        // Object.entries is undefined for IE (all versions) 
        if (!Object.entries){
        	  Object.entries = function( obj ){
        	    var ownProps = Object.keys( obj ),
        	        i = ownProps.length,
        	        resArray = new Array(i); // preallocate the Array
        	    while (i--){
        	      resArray[i] = [ownProps[i], obj[ownProps[i]]];
        	    }
        	    return resArray;
        	  };
        }
        // for rest of the Browsers including Edge
        if(this.grid.multipleSelectItems && 
        		Object.entries(this.grid.multipleSelectItems).length != 0)
        {
               for(var mapKey in this.grid.multipleSelectItems)
               {
                     result.push(this.grid.multipleSelectItems[mapKey]);
               }
        }
        else
        {
               for(var i=0, l=this.selected.length; i<l; i++){
                     if(this.selected[i]){
                            result.push(this.grid.getItem(i));
                     }
               }
        }
        return result;
 },


 addToSelection: function(inItemOrIndex){
		if(this.mode == 'none'){ return; }
		var idx = null, 
		mapKey = "";
		if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
			idx = inItemOrIndex;
		}else{
			idx = this.grid.getItemIndex(inItemOrIndex);
		}
		dojox.grid.Selection.prototype.addToSelection.call(this, idx);
		if(this.grid.getItem(idx) &&  this.grid.getItem(idx).i)
		{
			if(this.grid.getItem(idx).i.ref_id)
			{
				mapKey = this.grid.getItem(idx).i.ref_id;
			}
			if(this.grid.getItem(idx).i.tnx_id)
			{
				mapKey += "_" + this.grid.getItem(idx).i.tnx_id;
			}
			if(this.grid.getItem(idx).loan_alias)
			{
				mapKey = this.grid.getItem(idx).loan_alias;
			}
		}
		if(this.grid.multipleSelectItems && 
				!this.grid.multipleSelectItems.hasOwnProperty(mapKey) && this.grid.getItem(idx).i)
		{
			this.grid.multipleSelectItems[mapKey] = this.grid.getItem(idx);
		}
	},

	deselect: function(inItemOrIndex){
		if(this.mode == 'none'){ return; }
		var idx = null;
		var idx = null, 
		mapKey = "";
		if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
			idx = inItemOrIndex;
		}else{
			idx = this.grid.getItemIndex(inItemOrIndex);
		}
		dojox.grid.Selection.prototype.deselect.call(this, idx);
		if(this.grid.getItem(idx) &&  this.grid.getItem(idx).i)
		{
			if(this.grid.getItem(idx).i.ref_id)
			{
				mapKey = this.grid.getItem(idx).i.ref_id;
			}
			if(this.grid.getItem(idx).i.tnx_id)
			{
				mapKey += "_" + this.grid.getItem(idx).i.tnx_id;
			}
			if(this.grid.getItem(idx).loan_alias)
			{
				mapKey = this.grid.getItem(idx).loan_alias;
			}
		}
		if(!this.selected[idx] && this.grid.multipleSelectItems &&
				this.grid.multipleSelectItems.hasOwnProperty(mapKey))
		{
			delete this.grid.multipleSelectItems[mapKey];
		}
	},

	deselectAll: function(inItemOrIndex){
		var idx = null;
		if(inItemOrIndex || typeof inItemOrIndex == "number"){
			if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
				idx = inItemOrIndex;
			}else{
				idx = this.grid.getItemIndex(inItemOrIndex);
			}
			dojox.grid.Selection.prototype.deselectAll.call(this, idx);
		}else{
			this.inherited(arguments);
		}
	}
});

}

if(!dojo._hasResource["dojox.grid.DataGrid"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.DataGrid"] = true;
dojo.provide("dojox.grid.DataGrid");




/*=====
dojo.declare("dojox.grid.__DataCellDef", dojox.grid.__CellDef, {
	constructor: function(){
		//	field: String?
		//		The attribute to read from the dojo.data item for the row.
		//  fields: String[]?
		//		An array of fields to grab the values of and pass as an array to the grid
		//	get: Function?
		//		function(rowIndex, item?){} rowIndex is of type Integer, item is of type
		//		Object.  This function will be called when a cell requests data.  Returns
		//		the unformatted data for the cell.
	}
});
=====*/

/*=====
dojo.declare("dojox.grid.__DataViewDef", dojox.grid.__ViewDef, {
	constructor: function(){
		//	cells: dojox.grid.__DataCellDef[]|Array[dojox.grid.__DataCellDef[]]?
		//		The structure of the cells within this grid.
		//	defaultCell: dojox.grid.__DataCellDef?
		//		A cell definition with default values for all cells in this view.  If
		//		a property is defined in a cell definition in the "cells" array and
		//		this property, the cell definition's property will override this
		//		property's property.
	}
});
=====*/

dojo.declare("dojox.grid.DataGrid", dojox.grid._Grid, {
	store: null,
	query: null,
	queryOptions: null,
	fetchText: '...',
	sortFields: null,
	
	// updateDelay: int
	//		Time, in milliseconds, to delay updates automatically so that multiple
	//		calls to onSet/onNew/onDelete don't keep rerendering the grid.  Set
	//		to 0 to immediately cause updates.  A higher value will result in
	//		better performance at the expense of responsiveness of the grid.
	updateDelay: 1,

/*=====
	// structure: dojox.grid.__DataViewDef|dojox.grid.__DataViewDef[]|dojox.grid.__DataCellDef[]|Array[dojox.grid.__DataCellDef[]]
	//		View layout defintion.
	structure: '',
=====*/

	// You can specify items instead of a query, if you like.  They do not need
	// to be loaded - but the must be items in the store
	items: null,
	
	_store_connects: null,
	_by_idty: null,
	_by_idx: null,
	_cache: null,
	_pages: null,
	_pending_requests: null,
	_bop: -1,
	_eop: -1,
	_requests: 0,
	rowCount: 0,

	_isLoaded: false,
	_isLoading: false,
	
	postCreate: function(){
		this._pages = [];
		this._store_connects = [];
		this._by_idty = {};
		this._by_idx = [];
		this._cache = [];
		this._pending_requests = {};

		this._setStore(this.store);
		this.inherited(arguments);
	},

	createSelection: function(){
		this.selection = new dojox.grid.DataSelection(this);
	},

	get: function(inRowIndex, inItem){
		// summary: Default data getter.
		// description:
		//		Provides data to display in a grid cell. Called in grid cell context.
		//		So this.cell.index is the column index.
		// inRowIndex: Integer
		//		Row for which to provide data
		// returns:
		//		Data to display for a given grid cell.
		
		if(inItem && this.field == "_item" && !this.fields){
			return inItem;
		}else if(inItem && this.fields){
			var ret = [];
			var s = this.grid.store;
			dojo.forEach(this.fields, function(f){
				ret = ret.concat(s.getValues(inItem, f));
			});
			return ret;
		}else if(!inItem && typeof inRowIndex === "string"){
			return this.inherited(arguments);
		}
		return (!inItem ? this.defaultValue : (!this.field ? this.value : (this.field == "_item" ? inItem : this.grid.store.getValue(inItem, this.field))));
	},

	_checkUpdateStatus: function(){
		if(this.updateDelay > 0){
			var iStarted = false;
			if(this._endUpdateDelay){
				clearTimeout(this._endUpdateDelay);
				delete this._endUpdateDelay;
				iStarted = true;
			}
			if(!this.updating){
				this.beginUpdate();
				iStarted = true;
			}
			if(iStarted){
				var _this = this;
				this._endUpdateDelay = setTimeout(function(){
					delete _this._endUpdateDelay;
					_this.endUpdate();
				}, this.updateDelay);
			}
		}
	},
	
	_onSet: function(item, attribute, oldValue, newValue){
		this._checkUpdateStatus();
		var idx = this.getItemIndex(item);
		if(idx>-1){
			this.updateRow(idx);
		}
	},
	
	_createItem: function(item, index){
		var idty = this._hasIdentity ? this.store.getIdentity(item) : dojo.toJson(this.query) + ":idx:" + index + ":sort:" + dojo.toJson(this.getSortProps());
		var o = this._by_idty[idty] = { idty: idty, item: item };
		return o;
	},

	_addItem: function(item, index, noUpdate){
		this._by_idx[index] = this._createItem(item, index);
		if(!noUpdate){
			this.updateRow(index);
		}
	},

	_onNew: function(item, parentInfo){
		this._checkUpdateStatus();
		var rowCount = this.get('rowCount');
		this._addingItem = true;
		this.updateRowCount(rowCount+1);
		this._addingItem = false;
		this._addItem(item, rowCount);
		this.showMessage();
	},

	_onDelete: function(item){
		this._checkUpdateStatus();
		var idx = this._getItemIndex(item, true);
		
		if(item.attachment_id)
		{
			var isDeleted = false;
			misys.xhrPost( {
				url : misys.getServletURL("/screen/AjaxScreen/action/DeleteAttachmentById"),
				handleAs : "json",
				sync : true,
				content : {
					attachmentId : item.attachment_id
				},
				load : function(response, args){
					isDeleted = response.isDeleted;
					_isError = false;
				},
				error : function(response, args){
					console.error('Technical error while deleting attachment');
					console.error(response);
					_isError = true;
					misys._config = misys._config || {};
				}
			});
		}

		if(idx >= 0){
			// When a row is deleted, all rest rows are shifted down,
			// and migrate from page to page. If some page is not
			// loaded yet empty rows can migrate to initialized pages
			// without refreshing. It causes empty rows in some pages, see:
			// http://bugs.dojotoolkit.org/ticket/6818
			// this code fix this problem by reseting loaded page info
			this._pages = [];
			this._bop = -1;
			this._eop = -1;

			var o = this._by_idx[idx];
			this._by_idx.splice(idx, 1);
			delete this._by_idty[o.idty];
			this.updateRowCount(this.get('rowCount')-1);
			if(this.get('rowCount') === 0){
				this.showMessage(this.noDataMessage);
			}
		}
	},

	_onRevert: function(){
		this._refresh();
	},

	setStore: function(store, query, queryOptions){
		this._setQuery(query, queryOptions);
		this._setStore(store);
		this._refresh(true);
	},
	
	setQuery: function(query, queryOptions){
		this._setQuery(query, queryOptions);
		this._refresh(true);
	},
	
	setItems: function(items){
		this.items = items;
		this._setStore(this.store);
		this._refresh(true);
	},
	
	_setQuery: function(query, queryOptions){
		this.query = query;
		this.queryOptions = queryOptions || this.queryOptions;
	},

	_setStore: function(store){
		if(this.store && this._store_connects){
			dojo.forEach(this._store_connects, this.disconnect, this);
		}
		this.store = store;

		if(this.store){
			var f = this.store.getFeatures();
			var h = [];

			this._canEdit = !!f["dojo.data.api.Write"] && !!f["dojo.data.api.Identity"];
			this._hasIdentity = !!f["dojo.data.api.Identity"];

			if(!!f["dojo.data.api.Notification"] && !this.items){
				h.push(this.connect(this.store, "onSet", "_onSet"));
				h.push(this.connect(this.store, "onNew", "_onNew"));
				h.push(this.connect(this.store, "onDelete", "_onDelete"));
			}
			if(this._canEdit){
				h.push(this.connect(this.store, "revert", "_onRevert"));
			}

			this._store_connects = h;
		}
	},

	_onFetchBegin: function(size, req){
		if(!this.scroller){ return; }
		if(this.rowCount != size){
			if(req.isRender){
				this.scroller.init(size, this.keepRows, this.rowsPerPage);
				this.rowCount = size;
				this._setAutoHeightAttr(this.autoHeight, true);
				this._skipRowRenormalize = true;
				this.prerender();
				this._skipRowRenormalize = false;
			}else{
				this.updateRowCount(size);
			}
		}
		if(size < 1){
			this.views.render();
			this._resize();
			this.showMessage(this.noDataMessage);
			this.focus.initFocusView();
		}else{
			this.showMessage();
		}
	},

	_onFetchComplete: function(items, req){
		if(!this.scroller){ return; }
		if(items && items.length > 0){
			//console.log(items);
			dojo.forEach(items, function(item, idx){
				this._addItem(item, req.start+idx, true);
			}, this);
			this.updateRows(req.start, items.length);
			if(req.isRender){
				this.setScrollTop(0);
				this.postrender();
			}else if(this._lastScrollTop){
				this.setScrollTop(this._lastScrollTop);
			}
		}
		delete this._lastScrollTop;
		if(!this._isLoaded){
			this._isLoading = false;
			this._isLoaded = true;
		}
		this._pending_requests[req.start] = false;
	},

	_onFetchError: function(err, req){
		console.log(err);
		delete this._lastScrollTop;
		if(!this._isLoaded){
			this._isLoading = false;
			this._isLoaded = true;
			this.showMessage(this.errorMessage);
		}
		this._pending_requests[req.start] = false;
		this.onFetchError(err, req);
	},

	onFetchError: function(err, req){
	},

	_fetch: function(start, isRender){
		start = start || 0;
		if(this.store && !this._pending_requests[start]){
			if(!this._isLoaded && !this._isLoading){
				this._isLoading = true;
				this.showMessage(this.loadingMessage);
			}
			this._pending_requests[start] = true;
			//console.log("fetch: ", start);
			try{
				if(this.items){
					var items = this.items;
					var store = this.store;
					this.rowsPerPage = items.length;
					var req = {
						start: start,
						count: this.rowsPerPage,
						isRender: isRender
					};
					this._onFetchBegin(items.length, req);
					
					// Load them if we need to
					var waitCount = 0;
					dojo.forEach(items, function(i){
						if(!store.isItemLoaded(i)){ waitCount++; }
					});
					if(waitCount === 0){
						this._onFetchComplete(items, req);
					}else{
						var onItem = function(item){
							waitCount--;
							if(waitCount === 0){
								this._onFetchComplete(items, req);
							}
						};
						dojo.forEach(items, function(i){
							if(!store.isItemLoaded(i)){
								store.loadItem({item: i, onItem: onItem, scope: this});
							}
						}, this);
					}
				}else{
					this.store.fetch({
						start: start,
						count: this.rowsPerPage,
						query: this.query,
						sort: this.getSortProps(),
						queryOptions: this.queryOptions,
						isRender: isRender,
						onBegin: dojo.hitch(this, "_onFetchBegin"),
						onComplete: dojo.hitch(this, "_onFetchComplete"),
						onError: dojo.hitch(this, "_onFetchError")
					});
				}
			}catch(e){
				this._onFetchError(e, {start: start, count: this.rowsPerPage});
			}
		}
	},

	_clearData: function(){
		this.updateRowCount(0);
		this._by_idty = {};
		this._by_idx = [];
		this._pages = [];
		this._bop = this._eop = -1;
		this._isLoaded = false;
		this._isLoading = false;
	},

	getItem: function(idx){
		var data = this._by_idx[idx];
		if(!data||(data&&!data.item)){
			this._preparePage(idx);
			return null;
		}
		return data.item;
	},

	getItemIndex: function(item){
		return this._getItemIndex(item, false);
	},
	
	_getItemIndex: function(item, isDeleted){
		if(!isDeleted && !this.store.isItem(item)){
			return -1;
		}

		var idty = this._hasIdentity ? this.store.getIdentity(item) : null;

		for(var i=0, l=this._by_idx.length; i<l; i++){
			var d = this._by_idx[i];
			if(d && ((idty && d.idty == idty) || (d.item === item))){
				return i;
			}
		}
		return -1;
	},

	filter: function(query, reRender){
		this.query = query;
		if(reRender){
			this._clearData();
		}
		this._fetch();
	},

	_getItemAttr: function(idx, attr){
		var item = this.getItem(idx);
		return (!item ? this.fetchText : this.store.getValue(item, attr));
	},

	// rendering
	_render: function(){
		if(this.domNode.parentNode){
			this.scroller.init(this.get('rowCount'), this.keepRows, this.rowsPerPage);
			this.prerender();
			this._fetch(0, true);
		}
	},

	// paging
	_requestsPending: function(inRowIndex){
		return this._pending_requests[inRowIndex];
	},

	_rowToPage: function(inRowIndex){
		return (this.rowsPerPage ? Math.floor(inRowIndex / this.rowsPerPage) : inRowIndex);
	},

	_pageToRow: function(inPageIndex){
		return (this.rowsPerPage ? this.rowsPerPage * inPageIndex : inPageIndex);
	},

	_preparePage: function(inRowIndex){
		if((inRowIndex < this._bop || inRowIndex >= this._eop) && !this._addingItem){
			var pageIndex = this._rowToPage(inRowIndex);
			this._needPage(pageIndex);
			this._bop = pageIndex * this.rowsPerPage;
			this._eop = this._bop + (this.rowsPerPage || this.get('rowCount'));
		}
	},

	_needPage: function(inPageIndex){
		if(!this._pages[inPageIndex]){
			this._pages[inPageIndex] = true;
			this._requestPage(inPageIndex);
		}
	},

	_requestPage: function(inPageIndex){
		var row = this._pageToRow(inPageIndex);
		var count = Math.min(this.rowsPerPage, this.get('rowCount') - row);
		if(count > 0){
			this._requests++;
			if(!this._requestsPending(row)){
				setTimeout(dojo.hitch(this, "_fetch", row, false), 1);
				//this.requestRows(row, count);
			}
		}
	},

	getCellName: function(inCell){
		return inCell.field;
		//console.log(inCell);
	},

	_refresh: function(isRender){
		this._clearData();
		this._fetch(0, isRender);
	},

	sort: function(){
		this.edit.apply();
		this._lastScrollTop = this.scrollTop;
		this._refresh();
	},

	canSort: function(){
		return (!this._isLoading);
	},

	getSortProps: function(){
		var c = this.getCell(this.getSortIndex());
		if(!c){
			if(this.sortFields){
				return this.sortFields;
			}
			return null;
		}else{
			var desc = c["sortDesc"];
			var si = !(this.sortInfo>0);
			if(typeof desc == "undefined"){
				desc = si;
			}else{
				desc = si ? !desc : desc;
			}
			return [{ attribute: c.field, descending: desc }];
		}
	},

	styleRowState: function(inRow){
		// summary: Perform row styling
		if(this.store && this.store.getState){
			var states=this.store.getState(inRow.index), c='';
			for(var i=0, ss=["inflight", "error", "inserting"], s; s=ss[i]; i++){
				if(states[s]){
					c = ' dojoxGridRow-' + s;
					break;
				}
			}
			inRow.customClasses += c;
		}
	},

	onStyleRow: function(inRow){
		this.styleRowState(inRow);
		this.inherited(arguments);
	},

	// editing
	canEdit: function(inCell, inRowIndex){
		return this._canEdit;
	},

	_copyAttr: function(idx, attr){
		var row = {};
		var backstop = {};
		var src = this.getItem(idx);
		return this.store.getValue(src, attr);
	},

	doStartEdit: function(inCell, inRowIndex){
		if(!this._cache[inRowIndex]){
			this._cache[inRowIndex] = this._copyAttr(inRowIndex, inCell.field);
		}
		this.onStartEdit(inCell, inRowIndex);
	},

	doApplyCellEdit: function(inValue, inRowIndex, inAttrName){
		this.store.fetchItemByIdentity({
			identity: this._by_idx[inRowIndex].idty,
			onItem: dojo.hitch(this, function(item){
				var oldValue = this.store.getValue(item, inAttrName);
				if(typeof oldValue == 'number'){
					inValue = isNaN(inValue) ? inValue : parseFloat(inValue);
				}else if(typeof oldValue == 'boolean'){
					inValue = inValue == 'true' ? true : inValue == 'false' ? false : inValue;
				}else if(oldValue instanceof Date){
					var asDate = new Date(inValue);
					inValue = isNaN(asDate.getTime()) ? inValue : asDate;
				}
				this.store.setValue(item, inAttrName, inValue);
				this.onApplyCellEdit(inValue, inRowIndex, inAttrName);
			})
		});
	},

	doCancelEdit: function(inRowIndex){
		var cache = this._cache[inRowIndex];
		if(cache){
			this.updateRow(inRowIndex);
			delete this._cache[inRowIndex];
		}
		this.onCancelEdit.apply(this, arguments);
	},

	doApplyEdit: function(inRowIndex, inDataAttr){
		var cache = this._cache[inRowIndex];
		/*if(cache){
			var data = this.getItem(inRowIndex);
			if(this.store.getValue(data, inDataAttr) != cache){
				this.update(cache, data, inRowIndex);
			}
			delete this._cache[inRowIndex];
		}*/
		this.onApplyEdit(inRowIndex);
	},

	removeSelectedRows: function(){
		// summary:
		//		Remove the selected rows from the grid.
		if(this._canEdit){
			this.edit.apply();
			var fx = dojo.hitch(this, function(items){
				if(items.length){
					dojo.forEach(items, this.store.deleteItem, this.store);
					this.selection.clear();
				}
			});
			if(this.allItemsSelected){
				this.store.fetch({
							query: this.query,
							queryOptions: this.queryOptions,
							onComplete: fx});
			}else{
				fx(this.selection.getSelected());
			}
		}
	}
});

dojox.grid.DataGrid.cell_markupFactory = function(cellFunc, node, cellDef){
	var field = dojo.trim(dojo.attr(node, "field")||"");
	if(field){
		cellDef.field = field;
	}
	cellDef.field = cellDef.field||cellDef.name;
	var fields = dojo.trim(dojo.attr(node, "fields")||"");
	if(fields){
		cellDef.fields = fields.split(",");
	}
	if(cellFunc){
		cellFunc(node, cellDef);
	}
};

dojox.grid.DataGrid.markupFactory = function(props, node, ctor, cellFunc){
	return dojox.grid._Grid.markupFactory(props, node, ctor,
					dojo.partial(dojox.grid.DataGrid.cell_markupFactory, cellFunc));
};

}

if(!dojo._hasResource["dojox.grid.enhanced._Events"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.enhanced._Events"] = true;
dojo.provide("dojox.grid.enhanced._Events");

dojo.declare("dojox.grid.enhanced._Events", null, {
	// summary:
	//		Overwrite some default events of DataGrid
	//
	// description:
	//		Methods are copied or replaced for overwriting, this might be refined once
	//		an overall plugin architecture is set up for DataGrid.

	//_events: Object
	//		Method map cached from dojox.grid._Events().
	_events: null,

	// headerCellActiveClass: String
	//		css class to apply to grid header cells when activated(mouse down)
	headerCellActiveClass: 'dojoxGridHeaderActive',
	
	// cellActiveClass: String
	//		css class to apply to grid content cells when activated(mouse down)
	cellActiveClass: 'dojoxGridCellActive',
	
	// rowActiveClass: String
	//		css class to apply to grid rows when activated(mouse down)
	rowActiveClass: 'dojoxGridRowActive',

	constructor: function(inGrid){
		//get the default Grid events
		this._events = new dojox.grid._Events();
		//for methods that won't be overwritten, copy them to "this" scope
		for(var p in this._events){
			if(!this[p]){
				this.p = this._events.p;
			}
		}
		//mixin "this" to Grid
		inGrid.mixin(inGrid, this);
	},
	dokeyup: function(e){
		// summary:
		//		Grid key up event handler.
		// e: Event
		//		Un-decorated event object
		this.focus.currentArea().keyup(e);
	},
	onKeyDown: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onKeyDown();
		if(e.altKey || e.metaKey){ return; }
		var dk = dojo.keys;
		var focus = this.focus;
		switch(e.keyCode){
			case dk.TAB:
				if(e.ctrlKey){ return; }
				focus.tab(e.shiftKey ? -1:1,e);
				break;
			case dk.UP_ARROW:
			case dk.DOWN_ARROW:
				focus.currentArea().move(e.keyCode == dk.UP_ARROW ? -1 : 1, 0, e);
				break;
			case dk.LEFT_ARROW:
			case dk.RIGHT_ARROW:
				var offset = (e.keyCode == dk.LEFT_ARROW) ? 1 : -1;
				if(dojo._isBodyLtr()){ offset *= -1; }
				focus.currentArea().move(0, offset, e);
				break;
			case dk.F10:
				if(this.menus && e.shiftKey){
					this.onRowContextMenu(e);
				}
				break;
			case dk.ENTER:
				if(window.isAccessibilityEnabled && e.grid && dojo.attr(e.grid.domNode,'data-row-click-set') && dojo.attr(e.grid.domNode,'data-row-click-set') === 'true') {
					if(!this.edit.isEditing()){
						colIdx = this.focus.getHeaderIndex();
						if(colIdx >= 0) {
							this.setSortIndex(colIdx);
							break;
						}else {
							this.selection.clickSelect(this.focus.rowIndex, dojo.isCopyKey(e), e.shiftKey);
						}
						dojo.stopEvent(e);
					}
					if(!e.shiftKey){
						var isEditing = this.edit.isEditing();
						this.edit.apply();
						if(!isEditing){
							this.edit.setEditCell(this.focus.cell, this.focus.rowIndex);
						}
					}
					if (!this.edit.isEditing()){
						var curView = this.focus.focusView || this.views.views[0];  //if no focusView than only one view
						curView.content.decorateEvent(e);
						this.onRowClick(e);
						dojo.stopEvent(e);
					}
					break;
				} else {
					focus.currentArea().keydown(e);
					break;
				}
			default:
				focus.currentArea().keydown(e);
				break;
		}
	},
	//TODO - make the following events more reasonalble - e.g. more accurate conditions
	//events for row selectors
	domouseup: function(e){
		if(e.cellNode){
			this.onMouseUp(e);
		}else{
			this.onRowSelectorMouseUp(e);
		}
	},
	domousedown: function(e){
		if(!e.cellNode){
			this.onRowSelectorMouseDown(e);
		}
	},
	onMouseUp: function(e){
		// summary:
		//		New - Event fired when mouse is up inside grid.
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		this[e.rowIndex == -1 ? "onHeaderCellMouseUp" : "onCellMouseUp"](e);
	},
	onCellMouseDown: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onCellMouseDown()
		dojo.addClass(e.cellNode, this.cellActiveClass);
		dojo.addClass(e.rowNode, this.rowActiveClass);
	},
	onCellMouseUp: function(e){
		// summary:
		//		New - Event fired when mouse is up inside content cell.
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		dojo.removeClass(e.cellNode, this.cellActiveClass);
		dojo.removeClass(e.rowNode, this.rowActiveClass);
	},
	onCellClick: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onCellClick()

		//invoke dojox.grid._Events.onCellClick()
		this._events.onCellClick.call(this, e);
		//move mouse events to the focus manager.
		this.focus.contentMouseEvent(e);//TODO
	},
	onCellDblClick: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onCellDblClick()
		if(this.pluginMgr.isFixedCell(e.cell)){ return; }
		if(this._click.length > 1 && (!this._click[0] || !this._click[1])){
			this._click[0] = this._click[1] = e;
		}
		//invoke dojox.grid._Events.onCellDblClick()
		this._events.onCellDblClick.call(this, e);
		//now focus.setFocusCell need isEditing info, so call it after that is set.
		//this.focus.setFocusCell(e.cell, e.rowIndex);
	},
	onRowClick: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onRowClick()
		this.edit.rowClick(e);
		if(!e.cell || (!e.cell.isRowSelector && (!this.rowSelectCell || !this.rowSelectCell.disabled(e.rowIndex)))){
			this.selection.clickSelectEvent(e);
		}
	},
	onRowContextMenu: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onRowContextMenu()
		if(!this.edit.isEditing() && this.menus){
			this.showMenu(e);
		}
	},
	onSelectedRegionContextMenu: function(e){
		// summary:
		//		New - Event fired when a selected region context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid and info of selected
		//		regions(selection type - row|column, selected index - [...])
		if(this.selectedRegionMenu){
			this.selectedRegionMenu._openMyself({
				target: e.target,
				coords: e.keyCode !== dojo.keys.F10 && "pageX" in e ? {
					x: e.pageX,
					y: e.pageY
				} : null
			});
			dojo.stopEvent(e);
		}
	},
	onHeaderCellMouseOut: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onHeaderCellMouseOut()
		if(e.cellNode){
			dojo.removeClass(e.cellNode, this.cellOverClass);
			dojo.removeClass(e.cellNode, this.headerCellActiveClass);
		}
	},
	onHeaderCellMouseDown: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onHeaderCellMouseDown()
		if(e.cellNode){//TBD - apply to selection region for nested sorting?
			dojo.addClass(e.cellNode, this.headerCellActiveClass);
		}
	},
	onHeaderCellMouseUp: function(e){
		// summary:
		//		New event
		if(e.cellNode){
			dojo.removeClass(e.cellNode, this.headerCellActiveClass);
		}
	},
	onHeaderCellClick: function(e){
		// summary:
		//		Overwritten, see dojox.grid._Events.onHeaderCellClick()
		//move focus to header.
		this.focus.currentArea("header");
		//invoke dojox.grid._Events.onHeaderCellClick()
		if(!e.cell.isRowSelector){
			this._events.onHeaderCellClick.call(this, e);
		}
		//move mouse events to the focus manager.
		this.focus.headerMouseEvent(e);
	},
	onRowSelectorMouseDown: function(e){
		this.focus.focusArea("rowHeader", e);
	},
	
	onRowSelectorMouseUp: function(e){},
	
	//triggered in _View, see Selector plugin
	onMouseUpRow: function(e){
		if(e.rowIndex != -1){
			this.onRowMouseUp(e);
		}
	},
	onRowMouseUp: function(e){}
});

}

if(!dojo._hasResource["dojox.grid.enhanced._FocusManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.enhanced._FocusManager"] = true;
dojo.provide("dojox.grid.enhanced._FocusManager");

dojo.declare("dojox.grid.enhanced._FocusArea",null,{
	// summary:
	//		This is a friend class of _FocusManager
/*=====
		// name: string
		//		Name of this area.
		name: "",
		
		// onFocus: function(event, step)
		//		Called when this area logically gets focus.
		//		event: Event object
		//				May be unavailable, should check before use.
		//		step: Integer
		//				The distance in the tab sequence from last focused area to this area.
		//		returns:
		//				whether this area is successfully focused. If not, the next area will get focus.
		onFocus: function(event, step){return true;},
		
		// onBlur: function(event, step)
		//		Called when this area logically loses focus.
		//		event: Event object
		//				May be unavailable, should check before use.
		//		step: Integer
		//				The distance in the tab sequence from this area to the area to focus.
		//		returns:
		//				If Boolean, means whether this area has successfully blurred. If not, the next area to focus is still this one.
		//				If String, means the next area to focus is given by this returned name.
		onBlur: function(event, step){return true;},
		
		// onMove: function(rowStep, colStep, event)
		//		Called when focus is moving around within this area.
		//		rowStep: Integer
		//		colStep: Integer
		//		event: Event object
		//				May be unavailable, should check before use.
		onMove: function(rowStep, colStep, event){},
		
		// onKey: function(event, isBubble)
		//		Called when some key is pressed when focus is logically in this area.
		//		event: Event object
		//		isBubble: Boolean
		//				Whether is in bubble stage (true) or catch stage (false).
		//		returns:
		//				If you do NOT want the event to propagate any further along the area stack, return exactly false.
		//				So if you return nothing (undefined), this event is still propagating.
		onKey: function(event, isBubble){return true},
		
		// getRegions: function()
		//		Define the small regions (dom nodes) in this area.
		//		returns: Array of dom nodes.
		getRegions: function(){},
		
		// onRegionFocus: function(event)
		//		Connected to the onfocus event of the defined regions (if any)
		onRegionFocus: function(event){},
		
		// onRegionBlur: function(event)
		//		Connected to the onblur event of the defined regions (if any)
		onRegionBlur: function(event){},
=====*/
	constructor: function(area, focusManager){
		this._fm = focusManager;
		this._evtStack = [area.name];
		var dummy = function(){return true;};
		area.onFocus = area.onFocus || dummy;
		area.onBlur = area.onBlur || dummy;
		area.onMove = area.onMove || dummy;
		area.onKeyUp = area.onKeyUp || dummy;
		area.onKeyDown = area.onKeyDown || dummy;
		dojo.mixin(this, area);
	},
	move: function(rowStep, colStep, evt){
		if(this.name){
			var i, len = this._evtStack.length;
			for(i = len - 1; i >= 0; --i){
				if(this._fm._areas[this._evtStack[i]].onMove(rowStep, colStep, evt) === false){
					return false;
				}
			}
		}
		return true;
	},
	_onKeyEvent: function(evt, funcName){
		if(this.name){
			var i, len = this._evtStack.length;
			for(i = len - 1; i >= 0; --i){
				if(this._fm._areas[this._evtStack[i]][funcName](evt, false) === false){
					return false;
				}
			}
			for(i = 0; i < len; ++i){
				if(this._fm._areas[this._evtStack[i]][funcName](evt, true) === false){
					return false;
				}
			}
		}
		return true;
	},
	keydown: function(evt){
		return this._onKeyEvent(evt, "onKeyDown");
	},
	keyup: function(evt){
		return this._onKeyEvent(evt, "onKeyUp");
	},
	contentMouseEventPlanner: function(){
		return 0;
	},
	headerMouseEventPlanner: function(){
		return 0;
	}
});
dojo.declare("dojox.grid.enhanced._FocusManager", dojox.grid._FocusManager, {
	_stopEvent: function(evt){
		try{
			if(evt && evt.preventDefault){
				dojo.stopEvent(evt);
			}
		}catch(e){}
	},
	
	constructor: function(grid){
		this.grid = grid;
		this._areas = {};
		this._areaQueue = [];
		this._contentMouseEventHandlers = [];
		this._headerMouseEventHandlers = [];
		this._currentAreaIdx = -1;
		this._gridBlured = true;
		this._connects.push(dojo.connect(grid, "onBlur", this, "_doBlur"));
		this._connects.push(dojo.connect(grid.scroller, "renderPage", this, "_delayedCellFocus"));
		
		this.addArea({
			name: "header",
			onFocus: dojo.hitch(this, this.focusHeader),
			onBlur: dojo.hitch(this, this._blurHeader),
			onMove: dojo.hitch(this, this._navHeader),
			getRegions: dojo.hitch(this, this._findHeaderCells),
			onRegionFocus: dojo.hitch(this, this.doColHeaderFocus),
			onRegionBlur: dojo.hitch(this, this.doColHeaderBlur),
			onKeyDown: dojo.hitch(this, this._onHeaderKeyDown)
		});
		this.addArea({
			name: "content",
			onFocus: dojo.hitch(this, this._focusContent),
			onBlur: dojo.hitch(this, this._blurContent),
			onMove: dojo.hitch(this, this._navContent),
			onKeyDown: dojo.hitch(this, this._onContentKeyDown)
		});
		this.addArea({
			name: "editableCell",
			onFocus: dojo.hitch(this, this._focusEditableCell),
			onBlur: dojo.hitch(this, this._blurEditableCell),
			onKeyDown: dojo.hitch(this, this._onEditableCellKeyDown),
			onContentMouseEvent: dojo.hitch(this, this._onEditableCellMouseEvent),
			contentMouseEventPlanner: function(evt, areas){ return -1; }
		});
		this.placeArea("header");
		this.placeArea("content");
		this.placeArea("editableCell");
		this.placeArea("editableCell","above","content");
	},
	destroy: function(){
		for(var name in this._areas){
			var area = this._areas[name];
			dojo.forEach(area._connects, dojo.disconnect);
			area._connects = null;
			if(area.uninitialize){
				area.uninitialize();
			}
		}
		this.inherited(arguments);
	},
	addArea: function(area){
		if(area.name && dojo.isString(area.name)){
			if(this._areas[area.name]){
				//Just replace the original area, instead of remove it, so the position does not change.
				dojo.forEach(area._connects, dojo.disconnect);
			}
			this._areas[area.name] = new dojox.grid.enhanced._FocusArea(area, this);
			if(area.onHeaderMouseEvent){
				this._headerMouseEventHandlers.push(area.name);
			}
			if(area.onContentMouseEvent){
				this._contentMouseEventHandlers.push(area.name);
			}
		}
	},
	getArea: function(areaName){
		return this._areas[areaName];
	},
	_bindAreaEvents: function(){
		var area, hdl, areas = this._areas;
		dojo.forEach(this._areaQueue, function(name){
			area = areas[name];
			if(!area._initialized && dojo.isFunction(area.initialize)){
				area.initialize();
				area._initialized = true;
			}
			if(area.getRegions){
				area._regions = area.getRegions() || [];
				dojo.forEach(area._connects || [], dojo.disconnect);
				area._connects = [];
				dojo.forEach(area._regions, function(r){
					if(area.onRegionFocus){
						hdl = dojo.connect(r, "onfocus", area.onRegionFocus);
						area._connects.push(hdl);
					}
					if(area.onRegionBlur){
						hdl = dojo.connect(r, "onblur", area.onRegionBlur);
						area._connects.push(hdl);
					}
				});
			}
		});
	},
	removeArea: function(areaName){
		var area = this._areas[areaName];
		if(area){
			this.ignoreArea(areaName);
			var i = dojo.indexOf(this._contentMouseEventHandlers, areaName);
			if(i >= 0){
				this._contentMouseEventHandlers.splice(i, 1);
			}
			i = dojo.indexOf(this._headerMouseEventHandlers, areaName);
			if(i >= 0){
				this._headerMouseEventHandlers.splice(i, 1);
			}
			dojo.forEach(area._connects, dojo.disconnect);
			if(area.uninitialize){
				area.uninitialize();
			}
			delete this._areas[areaName];
		}
	},
	currentArea: function(areaName, toBlurOld){
		// summary:
		//		Set current area to the one areaName refers.
		// areaName: String
		var idx, cai = this._currentAreaIdx;
		if(dojo.isString(areaName) && (idx = dojo.indexOf(this._areaQueue, areaName)) >= 0){
			if(cai != idx){
				this.tabbingOut = false;
				if(toBlurOld && cai >= 0 && cai < this._areaQueue.length){
					this._areas[this._areaQueue[cai]].onBlur();
				}
				this._currentAreaIdx = idx;
			}
		}else{
			return (cai < 0 || cai >= this._areaQueue.length) ?
				new dojox.grid.enhanced._FocusArea({}, this) :
				this._areas[this._areaQueue[this._currentAreaIdx]];
		}
		return null;
	},
	placeArea: function(name, pos, otherAreaName){
		// summary:
		//		Place the area refered by *name* at some logical position relative to an existing area.
		// example:
		//		placeArea("myarea","before"|"after",...)
		//		placeArea("myarea","below"|"above",...)
		if(!this._areas[name]){ return; }
		var idx = dojo.indexOf(this._areaQueue,otherAreaName);
		switch(pos){
			case "after":
				if(idx >= 0){ ++idx; }
				//intentional drop through
			case "before":
				if(idx >= 0){
					this._areaQueue.splice(idx,0,name);
					break;
				}
				//intentional drop through
			default:
				this._areaQueue.push(name);
				break;
			case "above":
				var isAbove = true;
				//intentional drop through
			case "below":
				var otherArea = this._areas[otherAreaName];
				if(otherArea){
					if(isAbove){
						otherArea._evtStack.push(name);
					}else{
						otherArea._evtStack.splice(0,0,name);
					}
				}
		}
	},
	ignoreArea: function(name){
		this._areaQueue = dojo.filter(this._areaQueue,function(areaName){
			return areaName != name;
		});
	},
	focusArea: function(/* int|string|areaObj */areaId,evt){
		var idx;
		if(typeof areaId == "number"){
			idx = areaId < 0 ? this._areaQueue.length + areaId : areaId;
		}else{
			idx = dojo.indexOf(this._areaQueue,
				dojo.isString(areaId) ? areaId : (areaId && areaId.name));
		}
		if(idx < 0){ idx = 0; }
		var step = idx - this._currentAreaIdx;
		this._gridBlured = false;
		if(step){
			this.tab(step, evt);
		}else{
			this.currentArea().onFocus(evt, step);
		}
	},
	tab: function(step,evt){
		//console.log("===========tab",step,"curArea",this._currentAreaIdx,"areaCnt",this._areaQueue.length);
		var tempCurAreaIdx = this._currentAreaIdx;
		
		this._gridBlured = false;
		this.tabbingOut = false;
		if(step === 0){
			return;
		}
		var cai = this._currentAreaIdx;
		var dir = step > 0 ? 1:-1;
		if(cai < 0 || cai >= this._areaQueue.length){
			cai = (this._currentAreaIdx += step);
		}else{
			var nextArea = this._areas[this._areaQueue[cai]].onBlur(evt,step);
			if(nextArea === true){
				cai = (this._currentAreaIdx += step);
			}else if(dojo.isString(nextArea) && this._areas[nextArea]){
				cai = this._currentAreaIdx = dojo.indexOf(this._areaQueue,nextArea);
			}
		}
		//console.log("target area:",cai);
		for(; cai >= 0 && cai < this._areaQueue.length; cai += dir){
			this._currentAreaIdx = cai;
			//console.log("this._currentAreaIdx:"+this._currentAreaIdx);
			//console.log("this._areaQueue[cai] " + this._areaQueue[cai] );
			//console.log("this._areas[this._areaQueue[cai]] " + this._areas[this._areaQueue[cai]] );
			if(this._areaQueue[cai] && this._areas[this._areaQueue[cai]].onFocus(evt,step)){
				//console.log("final target area:"+ this._currentAreaIdx);
				if( tempCurAreaIdx === this._currentAreaIdx && window.preventTabToPages ) { 
					//console.log('Resetting the focus to next element');
					var tmpNewcurrentAreaIdx = cai + dir; 
					if(tmpNewcurrentAreaIdx < this._areaQueue.length) {
						this._currentAreaIdx = tmpNewcurrentAreaIdx;
						cai = tmpNewcurrentAreaIdx;
						var tmpNewArea = this._areas[this._areaQueue[cai]];
						if(tmpNewArea) { 
							//tmpNewArea.onFocus(evt,step);
						}
						//console.log('this should have returned');
						//console.log('tmpNewArea:'+tmpNewArea);
						//return; 
					}
				}
				return;
			}
		}
		//console.log("tab out");
		this.tabbingOut = true;
		if(step < 0){
			this._currentAreaIdx = -1;
			dijit.focus(this.grid.domNode);
		}else{
			this._currentAreaIdx = this._areaQueue.length;
			dijit.focus(this.grid.lastFocusNode);
		}
	},
	_onMouseEvent: function(type, evt){
		var lowercase = type.toLowerCase(),
			handlers = this["_" + lowercase + "MouseEventHandlers"],
			res = dojo.map(handlers, function(areaName){
				return {
					"area": areaName,
					"idx": this._areas[areaName][lowercase + "MouseEventPlanner"](evt, handlers)
				};
			}, this).sort(function(a, b){
				return b.idx - a.idx;
			}),
			resHandlers = dojo.map(res, function(handler){
				return res.area;
			}),
			i = res.length;
		while(--i >= 0){
			if(this._areas[res[i].area]["on" + type + "MouseEvent"](evt, resHandlers) === false){
				return;
			}
		}
	},
	contentMouseEvent: function(evt){
		this._onMouseEvent("Content", evt);
	},
	headerMouseEvent: function(evt){
		this._onMouseEvent("Header", evt);
	},
	initFocusView: function(){
		// summary:
		//		Overwritten
		this.focusView = this.grid.views.getFirstScrollingView() || this.focusView || this.grid.views.views[0];
		this._bindAreaEvents();
	},
	isNavHeader: function(){
		// summary:
		//		Overwritten
		//		Check whether currently navigating among column headers.
		// return:
		//		true - focus is on a certain column header | false otherwise
		return this._areaQueue[this._currentAreaIdx] == "header";
	},
	previousKey: function(e){
		// summary:
		//		Overwritten
		this.tab(-1,e);
	},
	nextKey: function(e){
		// summary:
		//		Overwritten
		this.tab(1,e);
	},
	setFocusCell: function(/* Object */inCell, /* Integer */inRowIndex){
		// summary:
		//		Overwritten - focuses the given grid cell
		if(inCell){
			this.currentArea(this.grid.edit.isEditing() ? "editableCell" : "content", true);
			//This is very slow when selecting cells!
			//this.focusGridView();
			this._focusifyCellNode(false);
			this.cell = inCell;
			this.rowIndex = inRowIndex;
			this._focusifyCellNode(true);
		}
		this.grid.onCellFocus(this.cell, this.rowIndex);
	},
	doFocus: function(e){
		// summary:
		//		Overwritten
		//		trap focus only for grid dom node
		//		do not focus for scrolling if grid is about to blur
		if(e && e.target == e.currentTarget && !this.tabbingOut){
			if(this._gridBlured){
				this._gridBlured = false;
				if(this._currentAreaIdx < 0 || this._currentAreaIdx >= this._areaQueue.length){
					this.focusArea(0, e);
				}else{
					this.focusArea(this._currentAreaIdx, e);
				}
			}
		}else{
			this.tabbingOut = false;
		}
		dojo.stopEvent(e);
	},
	_doBlur: function(){
		this._gridBlured = true;
	},
	doLastNodeFocus: function(e){
		// summary:
		//		Overwritten
		if(this.tabbingOut){
			this.tabbingOut = false;
		}else{
			this.focusArea(-1, e);
		}
	},
	_delayedHeaderFocus: function(){
		// summary:
		//		Overwritten
		var toFocus = true;
		if(window.preventTableHeaderFocus || window.isToPreventTableHeaderFocusAlways || window.isTopElementToBeFocussed) { 
			toFocus = ! (window.preventTableHeaderFocus || window.isToPreventTableHeaderFocusAlways || window.isTopElementToBeFocussed); 
		}
		if(toFocus || window.callFromSortHeaderClick) {		
			if(this.isNavHeader()){
				this.focusHeader();
			}
		}
	},
	_delayedCellFocus: function(){
		// summary:
		//		Overwritten
		var toFocus = true;
		if(window.preventTableHeaderFocus || window.isToPreventTableHeaderFocusAlways || window.isTopElementToBeFocussed) { 
			toFocus = ! (window.preventTableHeaderFocus || window.isToPreventTableHeaderFocusAlways || window.isTopElementToBeFocussed); 
		}
		if(toFocus) {
			this.currentArea("header", true);
			this.focusArea(this._currentAreaIdx);
		}
		if(window.isAccessibilityEnabled) { 
			//All table images 
			dojo.query('div>div.dojoxGridRow>table>tbody>tr>td>a>img').forEach(function(imageTag){
			try {
				if(dojo.hasAttr(imageTag, 'title') && !dojo.hasAttr(imageTag, 'alt')) {
					dojo.attr(imageTag, 'alt', dojo.attr(imageTag, 'title'));
					if(!window.isTitleToDisplayInTableImageIcons) {	
						dojo.removeAttr(imageTag, 'title');
					}
				} 
			} catch (exc) {
				// ignore the exception
				// console.debug(exc);
			}
			});
		}
	},
	_changeMenuBindNode: function(oldBindNode, newBindNode){
		var hm = this.grid.headerMenu;
		if(hm && this._contextMenuBindNode == oldBindNode){
			hm.unBindDomNode(oldBindNode);
			hm.bindDomNode(newBindNode);
			this._contextMenuBindNode = newBindNode;
		}
	},
	//---------------Header Area------------------------------------------
	focusHeader: function(evt, step){ //need a further look why these changes to parent's
		// summary:
		//		Overwritten
		var didFocus = false;
		this.inherited(arguments);
		if(this._colHeadNode && dojo.style(this._colHeadNode, 'display') != "none"){
			dijit.focus(this._colHeadNode);
			this._stopEvent(evt);
			didFocus = true;
		}
		return didFocus;
	},
	_blurHeader: function(evt,step){
		// summary:
		//		Overwritten
		if(this._colHeadNode){
			dojo.removeClass(this._colHeadNode, this.focusClass);
		}
		dojo.removeAttr(this.grid.domNode,"aria-activedescendant");
		// reset contextMenu onto viewsHeaderNode so right mouse on header will invoke (see focusHeader)
		this._changeMenuBindNode(this.grid.domNode,this.grid.viewsHeaderNode);
		//moved here from nextKey
		this._colHeadNode = this._colHeadFocusIdx = null;
		return true;
	},
	_navHeader: function(rowStep, colStep, evt){
		var colDir = colStep < 0 ? -1 : 1,
			savedIdx = dojo.indexOf(this._findHeaderCells(), this._colHeadNode);
		if(savedIdx >= 0 && (evt.shiftKey && evt.ctrlKey)){
			this.colSizeAdjust(evt, savedIdx, colDir * 5);
			return;
		}
		this.move(rowStep, colStep);
	},
	_onHeaderKeyDown: function(e, isBubble){
		if(isBubble){
			var dk = dojo.keys;
			switch(e.keyCode){
				case dk.ENTER:
				case dk.SPACE:
					var colIdx = this.getHeaderIndex();
					if(colIdx >= 0 && !this.grid.pluginMgr.isFixedCell(e.cell)/*TODO*/){
						this.grid.setSortIndex(colIdx, null, e);
						dojo.stopEvent(e);
					}
					break;
			}
		}
		return true;
	},
	_setActiveColHeader: function(){
		// summary:
		//		Overwritten
		this.inherited(arguments);
		//EDG now will decorate event on header key events, if no focus, the cell will be wrong
		dijit.focus(this._colHeadNode);
	},
	//---------------Content Area------------------------------------------
	findAndFocusGridCell: function(){
		// summary:
		//		Overwritten
		this._focusContent();
	},
	_focusContent: function(evt,step){
		var didFocus = true;
		var isEmpty = (this.grid.rowCount === 0); // If grid is empty this.grid.rowCount == 0
		if(this.isNoFocusCell() && !isEmpty){
			//skip all the hidden cells
			for(var i = 0, cell = this.grid.getCell(0); cell && cell.hidden; cell = this.grid.getCell(++i)){}
			this.setFocusIndex(0, cell ? i : 0);
		}else if(this.cell && !isEmpty){
			if(this.focusView && !this.focusView.rowNodes[this.rowIndex]){
				// if rowNode for current index is undefined (likely as a result of a sort and because of #7304)
				// scroll to that row
				this.grid.scrollToRow(this.rowIndex);
				this.focusGrid();
			}else{
				this.setFocusIndex(this.rowIndex, this.cell.index);
			}
		}else{
			didFocus = false;
		}
		if(didFocus){ this._stopEvent(evt); }
		return didFocus;
	},
	_blurContent: function(evt,step){
		this._focusifyCellNode(false);
		return true;
	},
	_navContent: function(rowStep, colStep, evt){
		if((this.rowIndex === 0 && rowStep < 0) || (this.rowIndex === this.grid.rowCount - 1 && rowStep > 0)){
			return;
		}
		this._colHeadNode = null;
		this.move(rowStep, colStep, evt);
		if(evt){
			dojo.stopEvent(evt);
		}
	},
	_onContentKeyDown: function(e, isBubble){
		if(isBubble){
			var dk = dojo.keys, s = this.grid.scroller;
			switch(e.keyCode){
				case dk.ENTER:
				case dk.SPACE:
					var g = this.grid;
					if(g.indirectSelection || g.misysIndirectSelection){ break; }
					g.selection.clickSelect(this.rowIndex, dojo.isCopyKey(e), e.shiftKey);
					g.onRowClick(e);
					dojo.stopEvent(e);
					break;
				case dk.PAGE_UP:
					if(this.rowIndex !== 0){
						if(this.rowIndex != s.firstVisibleRow + 1){
							this._navContent(s.firstVisibleRow - this.rowIndex, 0);
						}else{
							this.grid.setScrollTop(s.findScrollTop(this.rowIndex - 1));
							this._navContent(s.firstVisibleRow - s.lastVisibleRow + 1, 0);
						}
						dojo.stopEvent(e);
					}
					break;
				case dk.PAGE_DOWN:
					if(this.rowIndex + 1 != this.grid.rowCount){
						dojo.stopEvent(e);
						if(this.rowIndex != s.lastVisibleRow - 1){
							this._navContent(s.lastVisibleRow - this.rowIndex - 1, 0);
						}else{
							this.grid.setScrollTop(s.findScrollTop(this.rowIndex + 1));
							this._navContent(s.lastVisibleRow - s.firstVisibleRow - 1, 0);
						}
						dojo.stopEvent(e);
					}
					break;
			}
		}
		return true;
	},
	//------------------editable content area-------------------------
	_blurFromEditableCell: false,
	_isNavigating: false,
	_navElems: null,
	_focusEditableCell: function(evt,step){
		var didFocus = false;
		if(this._isNavigating){
			didFocus = true;
		}else if(this.grid.edit.isEditing() && this.cell){
			if(this._blurFromEditableCell || !this._blurEditableCell(evt, step)){
				this.setFocusIndex(this.rowIndex,this.cell.index);
				didFocus = true;
			}
			this._stopEvent(evt);
		}
		return didFocus;
	},
	_applyEditableCell: function(){
		try{
			this.grid.edit.apply();
		}catch(e){
			console.warn("_FocusManager._applyEditableCell() error:", e);
		}
	},
	_blurEditableCell: function(evt,step){
		this._blurFromEditableCell = false;
		if(this._isNavigating){
			var toBlur = true;
			if(evt){
				var elems = this._navElems;
				var firstElem = elems.lowest || elems.first;
				var lastElem = elems.last || elems.highest || firstElem;
				var target = dojo.isIE ? evt.srcElement : evt.target;
				toBlur = target == (step > 0 ? lastElem : firstElem);
			}
			if(toBlur){
				this._isNavigating = false;
				return "content";
			}
			return false;
		}else if(this.grid.edit.isEditing() && this.cell){
			if(!step || typeof step != "number"){ return false; }
			var dir = step > 0 ? 1 : -1;
			var cc = this.grid.layout.cellCount;
			for(var cell, col = this.cell.index + dir; col >= 0 && col < cc; col += dir){
				cell = this.grid.getCell(col);
				if(cell.editable){
					this.cell = cell;
					this._blurFromEditableCell = true;
					return false;
				}
			}
			if((this.rowIndex > 0 || dir == 1) && (this.rowIndex < this.grid.rowCount || dir == -1)){
				this.rowIndex += dir;
				//this.cell = this.grid.getCell(0); //There must be an editable cell, so this is not necessary.
				for(col = dir > 0 ? 0 : cc - 1; col >= 0 && col < cc; col += dir){
					cell = this.grid.getCell(col);
					if(cell.editable){
						this.cell = cell;
						break;
					}
				}
				this._applyEditableCell();
				return "content";
			}
		}
		return true;
	},
	_initNavigatableElems: function(){
		this._navElems = dijit._getTabNavigable(this.cell.getNode(this.rowIndex));
	},
	_onEditableCellKeyDown: function(e, isBubble){
		var dk = dojo.keys,
			g = this.grid,
			edit = g.edit,
			editApplied = false,
			toPropagate = true;
		switch(e.keyCode){
			case dk.ENTER:
				if(isBubble && edit.isEditing()){
					this._applyEditableCell();
					editApplied = true;
					dojo.stopEvent(e);
				}
				//intentional drop through
			case dk.SPACE:
				if(!isBubble && this._isNavigating){
					toPropagate = false;
					break;
				}
				if(isBubble){
					if(!this.cell.editable && this.cell.navigatable){
						this._initNavigatableElems();
						var toFocus = this._navElems.lowest || this._navElems.first;
						if(toFocus){
							this._isNavigating = true;
							dijit.focus(toFocus);
							dojo.stopEvent(e);
							this.currentArea("editableCell", true);
							break;
						}
					}
					if(!editApplied && !edit.isEditing() && !g.pluginMgr.isFixedCell(this.cell)){
						edit.setEditCell(this.cell, this.rowIndex);
					}
					if(editApplied){
						this.currentArea("content", true);
					}else if(this.cell.editable && g.canEdit()){
						this.currentArea("editableCell", true);
					}
				}
				break;
			case dk.PAGE_UP:
			case dk.PAGE_DOWN:
				if(!isBubble && edit.isEditing()){
					//prevent propagating to content area
					toPropagate = false;
				}
				break;
			case dk.ESCAPE:
				if(!isBubble){
					edit.cancel();
					this.currentArea("content", true);
				}
		}
		return toPropagate;
	},
	_onEditableCellMouseEvent: function(evt){
		if(evt.type == "click"){
			var cell = this.cell || evt.cell;
			if(cell && !cell.editable && cell.navigatable){
				this._initNavigatableElems();
				if(this._navElems.lowest || this._navElems.first){
					var target = dojo.isIE ? evt.srcElement : evt.target;
					if(target != cell.getNode(evt.rowIndex)){
						this._isNavigating = true;
						this.focusArea("editableCell", evt);
						dijit.focus(target);
						return false;
					}
				}
			}else if(this.grid.singleClickEdit){
				this.currentArea("editableCell");
				return false;
			}
		}
		return true;
	}
});

}

if(!dojo._hasResource["dojox.grid.enhanced._PluginManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.enhanced._PluginManager"] = true;
dojo.provide("dojox.grid.enhanced._PluginManager");




dojo.declare("dojox.grid.enhanced._PluginManager", null, {
	// summary:
	//		Singleton plugin manager
	//
	// description:
	//		Plugin manager is responsible for
	//		1. Loading required plugins
	//		2. Handling collaboration and dependencies among plugins
	//
	//      Some plugin dependencies:
	//		- "columnReordering" attribute won't work when either DnD or Indirect Selections plugin is on.
		
	//_options: Object
	//		Normalized plugin options
	_options: null,

	//_plugins: Array
	//		Plugin list
	_plugins: null,

	//_connects: Array
	//		Connection list
	_connects: null,

	constructor: function(inGrid){
		this.grid = inGrid;
		this._store = inGrid.store;
		this._options = {};
		this._plugins = [];
		this._connects = [];
		this._parseProps(this.grid.plugins);
		
		inGrid.connect(inGrid, "_setStore", dojo.hitch(this, function(store){
			if(this._store !== store){
				this.forEach('onSetStore', [store, this._store]);
				this._store = store;
			}
		}));
	},
	startup: function(){
		this.forEach('onStartUp');
	},
	preInit: function(){
		// summary:
		//		Load appropriate plugins before DataGrid.postCreate().
		//		See EnhancedGrid.postCreate()
		this.grid.focus.destroy();
		this.grid.focus = new dojox.grid.enhanced._FocusManager(this.grid);
		new dojox.grid.enhanced._Events(this.grid);//overwrite some default events of DataGrid
		this._init(true);
		this.forEach('onPreInit');
	},
	postInit: function(){
		// summary:
		//		Load plugins after DataGrid.postCreate() - the default phase when plugins are created
		//		See EnhancedGrid.postCreate()
		this._init(false);
		
		dojo.forEach(this.grid.views.views, this._initView, this);
		this._connects.push(dojo.connect(this.grid.views, 'addView', dojo.hitch(this, this._initView)));
			
		if(this._plugins.length > 0){
			var edit = this.grid.edit;
			if(edit){ edit.styleRow = function(inRow){}; }
		}
		this.forEach('onPostInit');
	},
	forEach: function(func, args){
		dojo.forEach(this._plugins, function(p){
			if(!p || !p[func]){ return; }
			p[func].apply(p, args ? args : []);
		});
	},
	_parseProps: function(plugins){
		// summary:
		//		Parse plugins properties
		// plugins: Object
		//		Plugin properties defined by user
		if(!plugins){ return; }
		
		var p, loading = {}, options = this._options, grid = this.grid;
		var registry = dojox.grid.enhanced._PluginManager.registry;//global plugin registry
		for(p in plugins){
			if(plugins[p]){//filter out boolean false e.g. {p:false}
				this._normalize(p, plugins, registry, loading);
			}
		}
		//"columnReordering" attribute won't work when either DnD or Indirect Selections plugin is used.
		if(options.dnd || options.indirectSelection){
			options.columnReordering = false;
		}
		
		//mixin all plugin properties into Grid
		dojo.mixin(grid, options);
	},
	_normalize: function(p, plugins, registry, loading){
		// summary:
		//		Normalize plugin properties especially the dependency chain
		// p: String
		//		Plugin name
		// plugins: Object
		//		Plugin properties set by user
		// registry: Object
		//		The global plugin registry
		// loading: Object
		//		Map for checking process state
		if(!registry[p]){ throw new Error('Plugin ' + p + ' is required.');}
		
		if(loading[p]){ throw new Error('Recursive cycle dependency is not supported.'); }
		
		var options = this._options;
		if(options[p]){ return options[p]; }
		
		loading[p] = true;
		//TBD - more strict conditions?
		options[p] = dojo.mixin({}, registry[p], dojo.isObject(plugins[p]) ? plugins[p] : {});
		
		var dependencies = options[p]['dependency'];
		if(dependencies){
			if(!dojo.isArray(dependencies)){
				dependencies = options[p]['dependency'] = [dependencies];
			}
			dojo.forEach(dependencies, function(dependency){
				if(!this._normalize(dependency, plugins, registry, loading)){
					throw new Error('Plugin ' + dependency + ' is required.');
				}
			}, this);
		}
		delete loading[p];
		return options[p];
	},
	_init: function(pre){
		// summary:
		//		Find appropriate plugins and load them
		// pre: Boolean
		//		True - preInit | False - postInit(by default)
		var p, preInit, options = this._options;
		for(p in options){
			preInit = options[p]['preInit'];
			if((pre ? preInit : !preInit) && options[p]['class'] && !this.pluginExisted(p)){
				this.loadPlugin(p);
			}
		}
	},
	loadPlugin: function(name){
		// summary:
		//		Load required plugin("name")
		// name: String
		//		Plugin name
		// return: Object
		//		The newly loaded plugin
		var option = this._options[name];
		if(!option){ return null; } //return if no plugin option
		
		var plugin = this.getPlugin(name);
		if(plugin){ return plugin; } //return if plugin("name") already existed
		
		var dependencies = option['dependency'];
		dojo.forEach(dependencies, function(dependency){
			if(!this.loadPlugin(dependency)){
				throw new Error('Plugin ' + dependency + ' is required.');
			}
		}, this);
		var cls = option['class'];
		delete option['class'];//remove it for safety
		plugin = new this.getPluginClazz(cls)(this.grid, option);
		this._plugins.push(plugin);
		return plugin;
	},
	_initView: function(view){
		// summary:
		//		Overwrite several default behavior for each views(including _RowSelector view)
		if(!view){ return; }
		//add more events handler - _View
		dojox.grid.util.funnelEvents(view.contentNode, view, "doContentEvent", ['mouseup', 'mousemove']);
		dojox.grid.util.funnelEvents(view.headerNode, view, "doHeaderEvent", ['mouseup']);
	},
	pluginExisted: function(name){
		// summary:
		//		Check if plugin("name") existed
		// name: String
		//		Plugin name
		// return: Boolean
		//		True - existed | False - not existed
		return !!this.getPlugin(name);
	},
	getPlugin: function(name){
		// summary:
		//		Get plugin("name")
		// name: String
		//		Plugin name
		// return: Object
		//		Plugin instance
		var plugins = this._plugins;
		name = name.toLowerCase();
		for(var i = 0, len = plugins.length; i < len; i++){
			if(name == plugins[i]['name'].toLowerCase()){
				return plugins[i];
			}
		}
		return null;
	},
	getPluginClazz: function(clazz){
		// summary:
		//		Load target plugin which must be already required (dojo.require(..))
		// clazz: class | String
		//		Plugin class
		if(dojo.isFunction(clazz)){
			return clazz;//return if it's already a clazz
		}
		var errorMsg = 'Please make sure Plugin "' + clazz + '" is existed.';
		try{
			var cls = dojo.getObject(clazz);
			if(!cls){ throw new Error(errorMsg); }
			return cls;
		}catch(e){
			throw new Error(errorMsg);
		}
	},
	isFixedCell: function(cell){
		// summary:
		//		See if target cell(column) is fixed or not.
		// cell: Object
		//		Target cell(column)
		// return: Boolean
		//		True - fixed| False - not fixed

		//target cell can use Boolean attributes named "isRowSelector" or "fixedPos" to mark it's a fixed cell(column)
		return cell && (cell.isRowSelector || cell.fixedPos);
	},
	destroy: function(){
		// summary:
		//		Destroy all resources
		dojo.forEach(this._connects, dojo.disconnect);
		this.forEach('destroy');
		if(this.grid.unwrap){
			this.grid.unwrap();
		}
		delete this._connects;
		delete this._plugins;
		delete this._options;
	}
});

dojox.grid.enhanced._PluginManager.registerPlugin = function(clazz, props){
		// summary:
		//		Register plugins - TODO, a better way rather than global registry?
		// clazz: String
		//		Full class name, e.g. "dojox.grid.enhanced.plugins.DnD"
		// props: Object - Optional
		//		Plugin properties e.g. {"dependency": ["nestedSorting"], ...}
	if(!clazz){
		console.warn("Failed to register plugin, class missed!");
		return;
	}
	var cls = dojox.grid.enhanced._PluginManager;
	cls.registry = cls.registry || {};
	cls.registry[clazz.prototype.name]/*plugin name*/ = dojo.mixin({"class": clazz}, (props ? props : {}));
};

}

if(!dojo._hasResource["dojox.grid.enhanced.plugins._SelectionPreserver"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.enhanced.plugins._SelectionPreserver"] = true;
dojo.provide("dojox.grid.enhanced.plugins._SelectionPreserver");

dojo.declare("dojox.grid.enhanced.plugins._SelectionPreserver", null, {
	// summary:
	//		Preserve selections across various user actions.
	//
	// description:
	//		When this feature turned on, Grid will try to preserve selections across various user actions, e.g. sorting, filtering etc.
	//		Precondition - Identifier(id) is required for store, as id is used for differentiating row items.
	//		Known issue - The preserved selections might be inaccurate if some unloaded rows are selected by range previously(e.g.SHIFT + click)
	//
	// example:
	// |	//To turn on this - set 'keepSelection' attribute to true
	// |	<div dojoType="dojox.grid.EnhancedGrid" keepSelection = true .../>
	
	//_connects: Array
	//		List of all connections.
	_connects: [],
	
	constructor: function(selection){
		this.selection = selection;
		var grid = this.grid = selection.grid;
		grid.onSelectedById = this.onSelectedById;
		this.reset();

		var oldClearData = grid._clearData;
		var _this = this;
		grid._clearData = function(){
			_this._updateMapping(!grid._noInternalMapping);
			_this._trustSelection = [];
			oldClearData.apply(grid, arguments);
		};
		this.connect(grid, '_setStore', 'reset');
		this.connect(grid, '_addItem', '_reSelectById');
		this.connect(selection, 'addToSelection', dojo.hitch(this, '_selectById', true));
		this.connect(selection, 'deselect', dojo.hitch(this, '_selectById', false));
		this.connect(selection, 'selectRange', dojo.hitch(this, '_updateMapping', true, true, false));
		this.connect(selection, 'deselectRange', dojo.hitch(this, '_updateMapping', true, false, false));
		this.connect(selection, 'deselectAll', dojo.hitch(this, '_updateMapping', true, false, true));
	},
	destroy: function(){
		this.reset();
		dojo.forEach(this._connects, dojo.disconnect);
		delete this._connects;
	},
	connect: function(obj, event, method){
		// summary:
		//		Connects specified obj/event to specified method of this object.
		var conn = dojo.connect(obj, event, this, method);
		this._connects.push(conn);
		return conn;
	},
	reset: function(){
		this._idMap = [];
		this._selectedById = {};
		this._trustSelection = [];
		this._defaultSelected = false;
	},
	_reSelectById: function(item, index){
		// summary:
		//		When some rows is fetched, determine whether it should be selected.
		//		When this function is called, grid.selection.selected[] is not trustable.
		var s = this.selection, g = this.grid;
		if(item && g._hasIdentity){
			var id = g.store.getIdentity(item);
			if(this._selectedById[id] === undefined){
				if(!this._trustSelection[index]){
					s.selected[index] = this._defaultSelected;
				}
			}else{
				s.selected[index] = this._selectedById[id];
			}
			this._idMap.push(id);
			g.onSelectedById(id, index, s.selected[index]);
		}
	},
	_selectById: function(toSelect, inItemOrIndex){
		// summary:
		//		Record selected rows by ID.
		if(this.selection.mode == 'none' || !this.grid._hasIdentity){ return; }
		var item = inItemOrIndex;
		if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
			var entry = this.grid._by_idx[inItemOrIndex];
			item = entry && entry.item;
		}
		if(item){
			var id = this.grid.store.getIdentity(item);
			this._selectedById[id] = !!toSelect;
		}else{
			this._trustSelection[inItemOrIndex] = true;
		}
	},
	onSelectedById: function(id, rowIndex, value){},
	
	_updateMapping: function(trustSelection, isSelect, isForAll, from, to){
		// summary:
		//		This function trys to keep the selection info updated when range selection is performed.
		//		1. Calculate how many unloaded rows are there;
		//		2. update _selectedById data if grid.selection._selected can be trusted, so loaded but unselected rows can
		//			be properly recorded.
		var s = this.selection, g = this.grid, flag = 0, unloaded = 0, i, id;
		for(i = g.rowCount - 1; i >= 0; --i){
			if(!g._by_idx[i]){
				++unloaded;
				flag += s.selected[i] ? 1 : -1;
			}else{
				id = g._by_idx[i].idty;
				if(id && (trustSelection || this._selectedById[id] === undefined)){
					this._selectedById[id] = !!s.selected[i];
				}
			}
		}
		if(unloaded){
			this._defaultSelected = flag > 0;
		}
		if(!isForAll && from !== undefined && to !== undefined){
			isForAll = !g.usingPagination && Math.abs(to - from + 1) === g.rowCount;
		}
		// When deselectAll, make sure every thing is deselected, even if it was selected but not loaded now.
		// This occurs only when pagination's "All" is used.
		if(isForAll && !g.usingPagination){
			for(i = this._idMap.length; i >= 0; --i){
				this._selectedById[this._idMap[i]] = isSelect;
			}
		}
	}
});

}

if(!dojo._hasResource["dojox.grid.EnhancedGrid"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.EnhancedGrid"] = true;
dojo.provide("dojox.grid.EnhancedGrid");





dojo.experimental("dojox.grid.EnhancedGrid");

dojo.declare("dojox.grid.EnhancedGrid", dojox.grid.DataGrid, {
	// summary:
	//		Provides enhanced features based on DataGrid
	//
	// description:
	//		EnhancedGrid features are implemented as plugins that could be loaded on demand.
	//		Explicit dojo.require() is needed to use these feature plugins.
	//
	// example:
	//		A quick sample to use EnhancedGrid features:
	//
	//	   Step 1. Load EnhancedGrid and required features
	// |   <script type="text/javascript">
	// |		
	// |		dojo.require("dojox.grid.enhanced.plugins.DnD");
	// |		dojo.require("dojox.grid.enhanced.plugins.Menu");
	// |		dojo.require("dojox.grid.enhanced.plugins.NestedSorting");
	// |		
	// |	</script>
	//
	//		Step 2. Use EnhancedGrid
	//		- Via HTML markup
	// |	<div dojoType="dojox.grid.EnhancedGrid" ...
	// |		plugins="{nestedSorting: true, dnd: true, indirectSelection: true,
	// |		menus:{headerMenu:"headerMenuId", rowMenu:"rowMenuId", cellMenu:"cellMenuId",
	// |		selectedRegionMenu:"selectedRegionMenuId"}}">
	// |			...
	// |	</div>
	//
	//		- Or via JavaScript
	// |	<script type="text/javascript">
	// |		var grid = new dojox.grid.EnhancedGrid({plugins : {nestedSorting: true, dnd: true, indirectSelection: true,
	// |	               menus:{headerMenu:"headerMenuId", rowMenu:"rowMenuId", cellMenu:"cellMenuId",selectedRegionMenu:"selectedRegionMenuId"}},
	// |			       ... }, dojo.byId('gridDiv'));
	// |		grid.startup();
	// |	</script>
	//
	//
	//		Plugin Support
	//		[Note: Plugin support is still experimental]
	//
	//		You can either customize the default plugins or add new ones, more details please see
	//		- dojox.grid.enhanced._PluginManager
	//		- dojox.grid.enhanced._Plugin
	//		- dojox.grid.enhanced.plugins.*

	//plugins: Object
	//		Plugin properties, e.g. {nestedSorting: true, dnd: true, ...}
	plugins: null,
	noSortColumnIndex : null,
	multipleSelectItems: new Object(),
	//pluginMgr: Object
	//		Singleton plugin manager
	pluginMgr: null,

	//keepSelection: Boolean
	//		Whether keep selection after sort, filter, pagination etc.
	keepSelection: false,
	domIdArray : null,
	jsonArray : null,
	//_pluginMgrClass: Object
	//		Default plugin manager class
	_pluginMgrClass: dojox.grid.enhanced._PluginManager,

	postMixInProperties: function(){
		//load nls bundle
		this._nls = dojo.i18n.getLocalization("dojox.grid.enhanced", "EnhancedGrid", this.lang);
		this.inherited(arguments);
	},
	postCreate: function(){
		//create plugin manager
		this.pluginMgr = new this._pluginMgrClass(this);
		this.pluginMgr.preInit();
		this.inherited(arguments);
		this.pluginMgr.postInit();
		if(window.isAccessibilityEnabled) { 
			dojo.connect(this,'onCellFocus',function(cell, rowIndex){
					if(cell.headerSelector) { 
						var cellNode = cell.view.getCellNode(rowIndex,cell.index);
						if(cellNode) {
							dojo.attr(cellNode,'aria-describedby', cell.grid.id + "_rowSelector_" + rowIndex + "_a11y_text");
						}
					}
					cell.navigatable='true';
				});
		}
	},
	plugin: function(/*String*/name){
		// summary:
		//		An easier way for getting a plugin, e.g. grid.plugin('dnd')
		return this.pluginMgr.getPlugin(name);
	},
	startup: function(){
		this.inherited(arguments);
		this.pluginMgr.startup();
	},
	createSelection: function(){
		this.selection = new dojox.grid.enhanced.DataSelection(this);
	},
	canSort: function(colIndex, field){
		// summary:
		//		Overwritten
		return true;
	},
	doKeyEvent: function(e){
		// summary:
		//		Overwritten, see _Grid.doKeyEvent()
		try{
			var view = this.focus.focusView;
			view.content.decorateEvent(e);
			if(!e.cell){ view.header.decorateEvent(e); }
		}catch(e){}
		this.inherited(arguments);
	},
	doApplyCellEdit: function(inValue, inRowIndex, inAttrName){
		// summary:
		//		Overwritten, see DataGrid.doApplyCellEdit()
		if(!inAttrName){
			this.invalidated[inRowIndex] = true;
			return;
		}
		this.inherited(arguments);
	},
	mixin: function(target, source){
		var props = {};
		for(var p in source){
			if(p == '_inherited' || p == 'declaredClass' || p == 'constructor' ||
				source['privates'] && source['privates'][p]){
				continue;
			}
			props[p] = source[p];
		}
		dojo.mixin(target, props);
	},
	_copyAttr: function(idx, attr){
		// summary:
		//		Overwritten, see DataGrid._copyAttr()
		//		Fix cell TAB navigation for single click editing
		if(!attr){ return; }
		return this.inherited(arguments);
	},
	_getHeaderHeight: function(){
		// summary:
		//		Overwritten, see _Grid._getHeaderHeight()
		//		Should include borders/margins of this.viewsHeaderNode
		this.inherited(arguments);
		return dojo.marginBox(this.viewsHeaderNode).h;
	},
	_fetch: function(start, isRender){
		// summary:
		//		Overwritten, see DataGrid._fetch()
		if(this.items){
			return this.inherited(arguments);
		}
		start = start || 0;
		if(this.store && !this._pending_requests[start]){
			if(!this._isLoaded && !this._isLoading){
				this._isLoading = true;
				this.showMessage(this.loadingMessage);
			}
			this._pending_requests[start] = true;
			try{
				var req = {
					start: start,
					count: this.rowsPerPage,
					query: this.query,
					sort: this.getSortProps(),
					queryOptions: this.queryOptions,
					isRender: isRender,
					onBegin: dojo.hitch(this, "_onFetchBegin"),
					onComplete: dojo.hitch(this, "_onFetchComplete"),
					onError: dojo.hitch(this, "_onFetchError")
				};
				this._storeLayerFetch(req);
			}catch(e){
				this._onFetchError(e, {start: start, count: this.rowsPerPage});
			}
		}
		return 0;
	},
	_storeLayerFetch: function(req){
		// summary:
		//		Extracted fetch specifically for store layer use
		this.store.fetch(req);
	},
	getCellByField: function(field){
		return dojo.filter(this.layout.cells, function(cell){
			return cell.field == field;
		})[0];
	},
	onMouseUp: function(e){	},
	createView: function(){
		// summary
		//		Overwrite: rewrite getCellX of view.header
		var view = this.inherited(arguments);
		if(dojo.isMoz){
			var ascendDom = function(inNode, inWhile){
				for(var n = inNode; n && inWhile(n); n = n.parentNode){}
				return n;
			};//copied from dojox.grid._Builder
			var makeNotTagName = function(inTagName){
				var name = inTagName.toUpperCase();
				return function(node){ return node.tagName != name; };
			};//copied from dojox.grid._Builder

			var func = view.header.getCellX;
			view.header.getCellX = function(e){
				var x = func.call(view.header, e);
				var n = ascendDom(e.target, makeNotTagName("th"));
				if(n && n !== e.target && dojo.isDescendant(e.target, n)){ x += n.firstChild.offsetLeft; }
				return x;
			};
		}
		return view;
	},
	destroy: function(){
		// summary:
		//		Destroy all resources
		delete this._nls;
		this.selection.destroy();
		this.pluginMgr.destroy();
		this.inherited(arguments);
	}
});

dojo.provide("dojox.grid.enhanced.DataSelection");
//default loaded plugin

dojo.declare("dojox.grid.enhanced.DataSelection", dojox.grid.DataSelection, {
	constructor: function(grid){
		if(grid.keepSelection){
			this.preserver = new dojox.grid.enhanced.plugins._SelectionPreserver(this);
		}
	},
	_range: function(inFrom, inTo){
		this.grid._selectingRange = true;
		this.inherited(arguments);
		this.grid._selectingRange = false;
		this.onChanged();
	},
	deselectAll: function(inItemOrIndex){
		this.grid._selectingRange = true;
		this.inherited(arguments);
		this.grid._selectingRange = false;
		this.onChanged();
	},
	destroy: function(){
		if(this.preserver){
			this.preserver.destroy();
		}
	}
});

dojox.grid.EnhancedGrid.markupFactory = function(props, node, ctor, cellFunc){
	return dojox.grid._Grid.markupFactory(props, node, ctor,
					dojo.partial(dojox.grid.DataGrid.cell_markupFactory, cellFunc));
};

dojox.grid.EnhancedGrid.registerPlugin = function(clazz, props){
	dojox.grid.enhanced._PluginManager.registerPlugin(clazz, props);
};

}

if(!dojo._hasResource["dijit._TimePicker"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._TimePicker"] = true;
dojo.provide("dijit._TimePicker");




/*=====
dojo.declare(
	"dijit._TimePicker.__Constraints",
	dojo.date.locale.__FormatOptions,
	{
		// clickableIncrement: String
		//		See `dijit._TimePicker.clickableIncrement`
		clickableIncrement: "T00:15:00",

		// visibleIncrement: String
		//		See `dijit._TimePicker.visibleIncrement`
		visibleIncrement: "T01:00:00",

		// visibleRange: String
		//		See `dijit._TimePicker.visibleRange`
		visibleRange: "T05:00:00"
	}
);
=====*/

dojo.declare("dijit._TimePicker",
	[dijit._Widget, dijit._Templated],
	{
		// summary:
		//		A graphical time picker.
		//		This widget is used internally by other widgets and is not available
		//		as a standalone widget due to lack of accessibility support.

		templateString: dojo.cache("dijit", "templates/TimePicker.html", "<div id=\"widget_${id}\" class=\"dijitMenu\"\n    ><div dojoAttachPoint=\"upArrow\" class=\"dijitButtonNode dijitUpArrowButton\" dojoAttachEvent=\"onmouseenter:_buttonMouse,onmouseleave:_buttonMouse\"\n\t\t><div class=\"dijitReset dijitInline dijitArrowButtonInner\" role=\"presentation\">&nbsp;</div\n\t\t><div class=\"dijitArrowButtonChar\">&#9650;</div></div\n    ><div dojoAttachPoint=\"timeMenu,focusNode\" dojoAttachEvent=\"onclick:_onOptionSelected,onmouseover,onmouseout\"></div\n    ><div dojoAttachPoint=\"downArrow\" class=\"dijitButtonNode dijitDownArrowButton\" dojoAttachEvent=\"onmouseenter:_buttonMouse,onmouseleave:_buttonMouse\"\n\t\t><div class=\"dijitReset dijitInline dijitArrowButtonInner\" role=\"presentation\">&nbsp;</div\n\t\t><div class=\"dijitArrowButtonChar\">&#9660;</div></div\n></div>\n"),

		// baseClass: [protected] String
		//		The root className to use for the various states of this widget
		baseClass: "dijitTimePicker",

		// clickableIncrement: String
		//		ISO-8601 string representing the amount by which
		//		every clickable element in the time picker increases.
		//		Set in local time, without a time zone.
		//		Example: `T00:15:00` creates 15 minute increments
		//		Must divide dijit._TimePicker.visibleIncrement evenly
		clickableIncrement: "T00:15:00",

		// visibleIncrement: String
		//		ISO-8601 string representing the amount by which
		//		every element with a visible time in the time picker increases.
		//		Set in local time, without a time zone.
		//		Example: `T01:00:00` creates text in every 1 hour increment
		visibleIncrement: "T01:00:00",

		// visibleRange: String
		//		ISO-8601 string representing the range of this TimePicker.
		//		The TimePicker will only display times in this range.
		//		Example: `T05:00:00` displays 5 hours of options
		visibleRange: "T05:00:00",

		// value: String
		//		Date to display.
		//		Defaults to current time and date.
		//		Can be a Date object or an ISO-8601 string.
		//		If you specify the GMT time zone (`-01:00`),
		//		the time will be converted to the local time in the local time zone.
		//		Otherwise, the time is considered to be in the local time zone.
		//		If you specify the date and isDate is true, the date is used.
		//		Example: if your local time zone is `GMT -05:00`,
		//		`T10:00:00` becomes `T10:00:00-05:00` (considered to be local time),
		//		`T10:00:00-01:00` becomes `T06:00:00-05:00` (4 hour difference),
		//		`T10:00:00Z` becomes `T05:00:00-05:00` (5 hour difference between Zulu and local time)
		//		`yyyy-mm-ddThh:mm:ss` is the format to set the date and time
		//		Example: `2007-06-01T09:00:00`
		value: new Date(),

		_visibleIncrement:2,
		_clickableIncrement:1,
		_totalIncrements:10,

		// constraints: dijit._TimePicker.__Constraints
		//		Specifies valid range of times (start time, end time)
		constraints:{},

/*=====
		serialize: function(val, options){
			// summary:
			//		User overridable function used to convert the attr('value') result to a String
			// val: Date
			//		The current value
			// options: Object?
			// tags:
			//		protected
		},
=====*/
		serialize: dojo.date.stamp.toISOString,

/*=====
		// filterString: string
		//		The string to filter by
		filterString: "",
=====*/

		setValue: function(/*Date*/ value){
			// summary:
			//		Deprecated.  Used set('value') instead.
			// tags:
			//		deprecated
			dojo.deprecated("dijit._TimePicker:setValue() is deprecated.  Use set('value', ...) instead.", "", "2.0");
			this.set('value', value);
		},

		_setValueAttr: function(/*Date*/ date){
			// summary:
			//		Hook so set('value', ...) works.
			// description:
			//		Set the value of the TimePicker.
			//		Redraws the TimePicker around the new date.
			// tags:
			//		protected
			this._set("value", date);
			this._showText();
		},

		_setFilterStringAttr: function(val){
			// summary:
			//		Called by TimeTextBox to filter the values shown in my list
			this._set("filterString", val);
			this._showText();
		},

		isDisabledDate: function(/*Date*/ dateObject, /*String?*/ locale){
			// summary:
			//		May be overridden to disable certain dates in the TimePicker e.g. `isDisabledDate=dojo.date.locale.isWeekend`
			// type:
			//		extension
			return false; // Boolean
		},

		_getFilteredNodes: function(/*number*/ start, /*number*/ maxNum, /*Boolean*/ before, /*DOMnode*/ lastNode){
			// summary:
			//		Returns an array of nodes with the filter applied.  At most maxNum nodes
			//		will be returned - but fewer may be returned as well.  If the
			//		before parameter is set to true, then it will return the elements
			//		before the given index
			// tags:
			//		private
			var
				nodes = [],
				lastValue = lastNode ? lastNode.date : this._refDate,
				n,
				i = start,
				max = this._maxIncrement + Math.abs(i),
				chk = before ? -1 : 1,
				dec = before ? 1 : 0,
				inc = 1 - dec;
			do{
				i = i - dec;
				n = this._createOption(i);
				if(n){
					if((before && n.date > lastValue) || (!before && n.date < lastValue)){
						break; // don't wrap
					}
					nodes[before ? "unshift" : "push"](n);
					lastValue = n.date;
				}
				i = i + inc;
			}while(nodes.length < maxNum && (i*chk) < max);
			return nodes;
		},

		_showText: function(){
			// summary:
			//		Displays the relevant choices in the drop down list
			// tags:
			//		private
			var fromIso = dojo.date.stamp.fromISOString;
			this.timeMenu.innerHTML = "";
			this._clickableIncrementDate=fromIso(this.clickableIncrement);
			this._visibleIncrementDate=fromIso(this.visibleIncrement);
			this._visibleRangeDate=fromIso(this.visibleRange);
			// get the value of the increments and the range in seconds (since 00:00:00) to find out how many divs to create
			var
				sinceMidnight = function(/*Date*/ date){
				return date.getHours() * 60 * 60 + date.getMinutes() * 60 + date.getSeconds();
				},
				clickableIncrementSeconds = sinceMidnight(this._clickableIncrementDate),
				visibleIncrementSeconds = sinceMidnight(this._visibleIncrementDate),
				visibleRangeSeconds = sinceMidnight(this._visibleRangeDate),

			// round reference date to previous visible increment
				time = (this.value || this.currentFocus).getTime();

			this._refDate = new Date(time - time % (visibleIncrementSeconds*1000));
			this._refDate.setFullYear(1970,0,1); // match parse defaults

			// assume clickable increment is the smallest unit
			this._clickableIncrement = 1;
			// divide the visible range by the clickable increment to get the number of divs to create
			// example: 10:00:00/00:15:00 -> display 40 divs
			this._totalIncrements = visibleRangeSeconds / clickableIncrementSeconds;
			// divide the visible increments by the clickable increments to get how often to display the time inline
			// example: 01:00:00/00:15:00 -> display the time every 4 divs
			this._visibleIncrement = visibleIncrementSeconds / clickableIncrementSeconds;
			// divide the number of seconds in a day by the clickable increment in seconds to get the
			// absolute max number of increments.
			this._maxIncrement = (60 * 60 * 24) / clickableIncrementSeconds;

			var
				// Find the nodes we should display based on our filter.
				// Limit to 10 nodes displayed as a half-hearted attempt to stop drop down from overlapping <input>.
				after = this._getFilteredNodes(0, Math.min(this._totalIncrements >> 1, 10) - 1),
				before = this._getFilteredNodes(0, Math.min(this._totalIncrements, 10) - after.length, true, after[0]);
			dojo.forEach(before.concat(after), function(n){this.timeMenu.appendChild(n);}, this);
		},

		constructor: function(){
			this.constraints = {}; // create instance object
		},

		postMixInProperties: function(){
		        this.inherited(arguments);
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls
		},

		_setConstraintsAttr: function(/* Object */ constraints){
			// brings in visibleRange, increments, etc.
			dojo.mixin(this, constraints);

			// dojo.date.locale needs the lang in the constraints as locale
			if(!constraints.locale){
				constraints.locale = this.lang;
			}
		},

		postCreate: function(){
			// assign typematic mouse listeners to the arrow buttons
			this.connect(this.timeMenu, dojo.isIE ? "onmousewheel" : 'DOMMouseScroll', "_mouseWheeled");
			this._connects.push(dijit.typematic.addMouseListener(this.upArrow, this, "_onArrowUp", 33, 250));
			this._connects.push(dijit.typematic.addMouseListener(this.downArrow, this, "_onArrowDown", 33, 250));

			this.inherited(arguments);
		},

		_buttonMouse: function(/*Event*/ e){
			// summary:
			//		Handler for hover (and unhover) on up/down arrows
			// tags:
			//		private

			// in non-IE browser the "mouseenter" event will become "mouseover",
			// but in IE it's still "mouseenter"
			dojo.toggleClass(e.currentTarget, e.currentTarget == this.upArrow ? "dijitUpArrowHover" : "dijitDownArrowHover",
				e.type == "mouseenter" || e.type == "mouseover");
		},

		_createOption: function(/*Number*/ index){
			// summary:
			//		Creates a clickable time option
			// tags:
			//		private
			var date = new Date(this._refDate);
			var incrementDate = this._clickableIncrementDate;
			date.setHours(date.getHours() + incrementDate.getHours() * index,
				date.getMinutes() + incrementDate.getMinutes() * index,
				date.getSeconds() + incrementDate.getSeconds() * index);
			if(this.constraints.selector == "time"){
				date.setFullYear(1970,0,1); // make sure each time is for the same date
			}
			var dateString = dojo.date.locale.format(date, this.constraints);
			if(this.filterString && dateString.toLowerCase().indexOf(this.filterString) !== 0){
				// Doesn't match the filter - return null
				return null;
			}

			var div = dojo.create("div", {"class": this.baseClass+"Item"});
			div.date = date;
			div.index = index;
			dojo.create('div',{
				"class": this.baseClass + "ItemInner",
				innerHTML: dateString
			}, div);

			if(index%this._visibleIncrement<1 && index%this._visibleIncrement>-1){
				dojo.addClass(div, this.baseClass+"Marker");
			}else if(!(index%this._clickableIncrement)){
				dojo.addClass(div, this.baseClass+"Tick");
			}

			if(this.isDisabledDate(date)){
				// set disabled
				dojo.addClass(div, this.baseClass+"ItemDisabled");
			}
			if(this.value && !dojo.date.compare(this.value, date, this.constraints.selector)){
				div.selected = true;
				dojo.addClass(div, this.baseClass+"ItemSelected");
				if(dojo.hasClass(div, this.baseClass+"Marker")){
					dojo.addClass(div, this.baseClass+"MarkerSelected");
				}else{
					dojo.addClass(div, this.baseClass+"TickSelected");
				}

				// Initially highlight the current value.   User can change highlight by up/down arrow keys
				// or mouse movement.
				this._highlightOption(div, true);
			}
			return div;
		},

		_onOptionSelected: function(/*Object*/ tgt){
			// summary:
			//		Called when user clicks an option in the drop down list
			// tags:
			//		private
			var tdate = tgt.target.date || tgt.target.parentNode.date;
			if(!tdate || this.isDisabledDate(tdate)){ return; }
			this._highlighted_option = null;
			this.set('value', tdate);
			this.onChange(tdate);
		},

		onChange: function(/*Date*/ time){
			// summary:
			//		Notification that a time was selected.  It may be the same as the previous value.
			// tags:
			//      public
		},

		_highlightOption: function(/*node*/ node, /*Boolean*/ highlight){
			// summary:
			//		Turns on/off highlight effect on a node based on mouse out/over event
			// tags:
			//		private
			if(!node){return;}
			if(highlight){
				if(this._highlighted_option){
					this._highlightOption(this._highlighted_option, false);
				}
				this._highlighted_option = node;
			}else if(this._highlighted_option !== node){
				return;
			}else{
				this._highlighted_option = null;
			}
			dojo.toggleClass(node, this.baseClass+"ItemHover", highlight);
			if(dojo.hasClass(node, this.baseClass+"Marker")){
				dojo.toggleClass(node, this.baseClass+"MarkerHover", highlight);
			}else{
				dojo.toggleClass(node, this.baseClass+"TickHover", highlight);
			}
		},

		onmouseover: function(/*Event*/ e){
			// summary:
			//		Handler for onmouseover event
			// tags:
			//		private
			this._keyboardSelected = null;
			var tgr = (e.target.parentNode === this.timeMenu) ? e.target : e.target.parentNode;
			// if we aren't targeting an item, then we return
			if(!dojo.hasClass(tgr, this.baseClass+"Item")){return;}
			this._highlightOption(tgr, true);
		},

		onmouseout: function(/*Event*/ e){
			// summary:
			//		Handler for onmouseout event
			// tags:
			//		private
			this._keyboardSelected = null;
			var tgr = (e.target.parentNode === this.timeMenu) ? e.target : e.target.parentNode;
			this._highlightOption(tgr, false);
		},

		_mouseWheeled: function(/*Event*/ e){
			// summary:
			//		Handle the mouse wheel events
			// tags:
			//		private
			this._keyboardSelected = null;
			dojo.stopEvent(e);
			// we're not _measuring_ the scroll amount, just direction
			var scrollAmount = (dojo.isIE ? e.wheelDelta : -e.detail);
			this[(scrollAmount>0 ? "_onArrowUp" : "_onArrowDown")](); // yes, we're making a new dom node every time you mousewheel, or click
		},

		_onArrowUp: function(count){
			// summary:
			//		Handler for up arrow key.
			// description:
			//		Removes the bottom time and add one to the top
			// tags:
			//		private
			if(typeof count == "number" && count == -1){ return; } // typematic end
			if(!this.timeMenu.childNodes.length){ return; }
			var index = this.timeMenu.childNodes[0].index;
			var divs = this._getFilteredNodes(index, 1, true, this.timeMenu.childNodes[0]);
			if(divs.length){
				this.timeMenu.removeChild(this.timeMenu.childNodes[this.timeMenu.childNodes.length - 1]);
				this.timeMenu.insertBefore(divs[0], this.timeMenu.childNodes[0]);
			}
		},

		_onArrowDown: function(count){
			// summary:
			//		Handler for up arrow key.
			// description:
			//		Remove the top time and add one to the bottom
			// tags:
			//		private
			if(typeof count == "number" && count == -1){ return; } // typematic end
			if(!this.timeMenu.childNodes.length){ return; }
			var index = this.timeMenu.childNodes[this.timeMenu.childNodes.length - 1].index + 1;
			var divs = this._getFilteredNodes(index, 1, false, this.timeMenu.childNodes[this.timeMenu.childNodes.length - 1]);
			if(divs.length){
				this.timeMenu.removeChild(this.timeMenu.childNodes[0]);
				this.timeMenu.appendChild(divs[0]);
			}
		},

		handleKey: function(/*Event*/ e){
			// summary:
			//		Called from `dijit.form._DateTimeTextBox` to pass a keypress event
			//		from the `dijit.form.TimeTextBox` to be handled in this widget
			// tags:
			//		protected
			var dk = dojo.keys;
			if(e.charOrCode == dk.DOWN_ARROW || e.charOrCode == dk.UP_ARROW){
				dojo.stopEvent(e);
				// Figure out which option to highlight now and then highlight it
				if(this._highlighted_option && !this._highlighted_option.parentNode){
					this._highlighted_option = null;
				}
				var timeMenu = this.timeMenu,
					tgt = this._highlighted_option || dojo.query("." + this.baseClass + "ItemSelected", timeMenu)[0];
				if(!tgt){
					tgt = timeMenu.childNodes[0];
				}else if(timeMenu.childNodes.length){
					if(e.charOrCode == dk.DOWN_ARROW && !tgt.nextSibling){
						this._onArrowDown();
					}else if(e.charOrCode == dk.UP_ARROW && !tgt.previousSibling){
						this._onArrowUp();
					}
					if(e.charOrCode == dk.DOWN_ARROW){
						tgt = tgt.nextSibling;
					}else{
						tgt = tgt.previousSibling;
					}
				}
				this._highlightOption(tgt, true);
				this._keyboardSelected = tgt;
				return false;
			}else if(e.charOrCode == dk.ENTER || e.charOrCode === dk.TAB){
				// mouse hover followed by TAB is NO selection
				if(!this._keyboardSelected && e.charOrCode === dk.TAB){
					return true;	// true means don't call stopEvent()
				}

				// Accept the currently-highlighted option as the value
				if(this._highlighted_option){
				this._onOptionSelected({target: this._highlighted_option});
			}

				// Call stopEvent() for ENTER key so that form doesn't submit,
				// but not for TAB, so that TAB does switch focus
				return e.charOrCode === dk.TAB;
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form.TimeTextBox"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.TimeTextBox"] = true;
dojo.provide("dijit.form.TimeTextBox");




/*=====
dojo.declare(
	"dijit.form.TimeTextBox.__Constraints",
	[dijit.form._DateTimeTextBox.__Constraints, dijit._TimePicker.__Constraints]
);
=====*/

dojo.declare(
	"dijit.form.TimeTextBox",
	dijit.form._DateTimeTextBox,
	{
		// summary:
		//		A validating, serializable, range-bound time text box with a drop down time picker

		baseClass: "dijitTextBox dijitComboBox dijitTimeTextBox",
		popupClass: "dijit._TimePicker",
		_selector: "time",

/*=====
		// constraints: dijit.form.TimeTextBox.__Constraints
		constraints:{},
=====*/

		// value: Date
		//		The value of this widget as a JavaScript Date object.  Note that the date portion implies time zone and daylight savings rules.
		//
		//		Example:
		// |	new dijit.form.TimeTextBox({value: dojo.date.stamp.fromISOString("T12:59:59", new Date())})
		//
		//		When passed to the parser in markup, must be specified according to locale-independent
		//		`dojo.date.stamp.fromISOString` format.
		//
		//		Example:
		// |	<input dojotype='dijit.form.TimeTextBox' value='T12:34:00'>
		value: new Date(""),		// value.toString()="NaN"
		//FIXME: in markup, you have no control over daylight savings

		_onKey: function(evt){
			this.inherited(arguments);

			// If the user has backspaced or typed some numbers, then filter the result list
			// by what they typed.  Maybe there's a better way to detect this, like _handleOnChange()?
			switch(evt.keyCode){
				case dojo.keys.ENTER:
				case dojo.keys.TAB:
				case dojo.keys.ESCAPE:
				case dojo.keys.DOWN_ARROW:
				case dojo.keys.UP_ARROW:
					// these keys have special meaning
					break;
				default:
					// setTimeout() because the keystroke hasn't yet appeared in the <input>,
					// so the get('displayedValue') call below won't give the result we want.
					setTimeout(dojo.hitch(this, function(){
						// set this.filterString to the filter to apply to the drop down list;
						// it will be used in openDropDown()
						var val = this.get('displayedValue');
						this.filterString = (val && !this.parse(val, this.constraints)) ? val.toLowerCase() : "";
	
						// close the drop down and reopen it, in order to filter the items shown in the list
						// and also since the drop down may need to be repositioned if the number of list items has changed
						// and it's being displayed above the <input>
						if(this._opened){
							this.closeDropDown();
						}
						this.openDropDown();
					}), 0);
			}
		}
	}
);

}

if(!dojo._hasResource["dijit.form._Spinner"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form._Spinner"] = true;
dojo.provide("dijit.form._Spinner");



dojo.declare(
	"dijit.form._Spinner",
	dijit.form.RangeBoundTextBox,
	{
		// summary:
		//		Mixin for validation widgets with a spinner.
		// description:
		//		This class basically (conceptually) extends `dijit.form.ValidationTextBox`.
		//		It modifies the template to have up/down arrows, and provides related handling code.

		// defaultTimeout: Number
		//		Number of milliseconds before a held arrow key or up/down button becomes typematic
		defaultTimeout: 500,

		// minimumTimeout: Number
		//		minimum number of milliseconds that typematic event fires when held key or button is held
		minimumTimeout: 10,

		// timeoutChangeRate: Number
		//		Fraction of time used to change the typematic timer between events.
		//		1.0 means that each typematic event fires at defaultTimeout intervals.
		//		< 1.0 means that each typematic event fires at an increasing faster rate.
		timeoutChangeRate: 0.90,

		// smallDelta: Number
		//		Adjust the value by this much when spinning using the arrow keys/buttons
		smallDelta: 1,

		// largeDelta: Number
		//		Adjust the value by this much when spinning using the PgUp/Dn keys
		largeDelta: 10,

		templateString: dojo.cache("dijit.form", "templates/Spinner.html", "<div class=\"dijit dijitReset dijitInlineTable dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitButtonNode dijitSpinnerButtonContainer\"\n\t\t><input class=\"dijitReset dijitInputField dijitSpinnerButtonInner\" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t/><div class=\"dijitReset dijitLeft dijitButtonNode dijitArrowButton dijitUpArrowButton\"\n\t\t\tdojoAttachPoint=\"upArrowNode\"\n\t\t\t><div class=\"dijitArrowButtonInner\"\n\t\t\t\t><input class=\"dijitReset dijitInputField\" value=\"&#9650;\" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t\t\t${_buttonInputDisabled}\n\t\t\t/></div\n\t\t></div\n\t\t><div class=\"dijitReset dijitLeft dijitButtonNode dijitArrowButton dijitDownArrowButton\"\n\t\t\tdojoAttachPoint=\"downArrowNode\"\n\t\t\t><div class=\"dijitArrowButtonInner\"\n\t\t\t\t><input class=\"dijitReset dijitInputField\" value=\"&#9660;\" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t\t\t${_buttonInputDisabled}\n\t\t\t/></div\n\t\t></div\n\t></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input aria-label=\"Form field error\" class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935;\" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' dojoAttachPoint=\"textbox,focusNode\" type=\"${type}\" dojoAttachEvent=\"onkeypress:_onKeyPress\"\n\t\t\trole=\"spinbutton\" autocomplete=\"off\" ${!nameAttrSetting}\n\t/></div\n></div>\n"),

		baseClass: "dijitTextBox dijitSpinner",

		// Set classes like dijitUpArrowButtonHover or dijitDownArrowButtonActive depending on
		// mouse action over specified node
		cssStateNodes: {
			"upArrowNode": "dijitUpArrowButton",
			"downArrowNode": "dijitDownArrowButton"
		},

		adjust: function(/*Object*/ val, /*Number*/ delta){
			// summary:
			//		Overridable function used to adjust a primitive value(Number/Date/...) by the delta amount specified.
			// 		The val is adjusted in a way that makes sense to the object type.
			// tags:
			//		protected extension
			return val;
		},

		_arrowPressed: function(/*Node*/ nodePressed, /*Number*/ direction, /*Number*/ increment){
			// summary:
			//		Handler for arrow button or arrow key being pressed
			if(this.disabled || this.readOnly){ return; }
			this._setValueAttr(this.adjust(this.get('value'), direction*increment), false);
			dijit.selectInputText(this.textbox, this.textbox.value.length);
		},

		_arrowReleased: function(/*Node*/ node){
			// summary:
			//		Handler for arrow button or arrow key being released
			this._wheelTimer = null;
			if(this.disabled || this.readOnly){ return; }
		},

		_typematicCallback: function(/*Number*/ count, /*DOMNode*/ node, /*Event*/ evt){
			var inc=this.smallDelta;
			if(node == this.textbox){
				var k=dojo.keys;
				var key = evt.charOrCode;
				inc = (key == k.PAGE_UP || key == k.PAGE_DOWN) ? this.largeDelta : this.smallDelta;
				node = (key == k.UP_ARROW || key == k.PAGE_UP) ? this.upArrowNode : this.downArrowNode;
			}
			if(count == -1){ this._arrowReleased(node); }
			else{ this._arrowPressed(node, (node == this.upArrowNode) ? 1 : -1, inc); }
		},

		_wheelTimer: null,
		_mouseWheeled: function(/*Event*/ evt){
			// summary:
			//		Mouse wheel listener where supported

			dojo.stopEvent(evt);
			// FIXME: Safari bubbles

			// be nice to DOH and scroll as much as the event says to
			var scrollAmount = evt.detail ? (evt.detail * -1) : (evt.wheelDelta / 120);
			if(scrollAmount !== 0){
				var node = this[(scrollAmount > 0 ? "upArrowNode" : "downArrowNode" )];

				this._arrowPressed(node, scrollAmount, this.smallDelta);

				if(!this._wheelTimer){
					clearTimeout(this._wheelTimer);
				}
				this._wheelTimer = setTimeout(dojo.hitch(this,"_arrowReleased",node), 50);
			}

		},

		postCreate: function(){
			this.inherited(arguments);

			// extra listeners
			this.connect(this.domNode, !dojo.isMozilla ? "onmousewheel" : 'DOMMouseScroll', "_mouseWheeled");
			this._connects.push(dijit.typematic.addListener(this.upArrowNode, this.textbox, {charOrCode:dojo.keys.UP_ARROW,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout, this.minimumTimeout));
			this._connects.push(dijit.typematic.addListener(this.downArrowNode, this.textbox, {charOrCode:dojo.keys.DOWN_ARROW,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout, this.minimumTimeout));
			this._connects.push(dijit.typematic.addListener(this.upArrowNode, this.textbox, {charOrCode:dojo.keys.PAGE_UP,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout, this.minimumTimeout));
			this._connects.push(dijit.typematic.addListener(this.downArrowNode, this.textbox, {charOrCode:dojo.keys.PAGE_DOWN,ctrlKey:false,altKey:false,shiftKey:false,metaKey:false}, this, "_typematicCallback", this.timeoutChangeRate, this.defaultTimeout, this.minimumTimeout));
		}
});

}

if(!dojo._hasResource["dijit.form.NumberSpinner"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.NumberSpinner"] = true;
dojo.provide("dijit.form.NumberSpinner");




dojo.declare("dijit.form.NumberSpinner",
	[dijit.form._Spinner, dijit.form.NumberTextBoxMixin],
	{
	// summary:
	//		Extends NumberTextBox to add up/down arrows and pageup/pagedown for incremental change to the value
	//
	// description:
	//		A `dijit.form.NumberTextBox` extension to provide keyboard accessible value selection
	//		as well as icons for spinning direction. When using the keyboard, the typematic rules
	//		apply, meaning holding the key will gradually increase or decrease the value and
	// 		accelerate.
	//
	// example:
	//	| new dijit.form.NumberSpinner({ constraints:{ max:300, min:100 }}, "someInput");

	adjust: function(/*Object*/ val, /*Number*/ delta){
		// summary:
		//		Change Number val by the given amount
		// tags:
		//		protected

		var tc = this.constraints,
			v = isNaN(val),
			gotMax = !isNaN(tc.max),
			gotMin = !isNaN(tc.min)
		;
		if(v && delta != 0){ // blank or invalid value and they want to spin, so create defaults
			val = (delta > 0) ?
				gotMin ? tc.min : gotMax ? tc.max : 0 :
				gotMax ? this.constraints.max : gotMin ? tc.min : 0
			;
		}
		var newval = val + delta;
		if(v || isNaN(newval)){ return val; }
		if(gotMax && (newval > tc.max)){
			newval = tc.max;
		}
		if(gotMin && (newval < tc.min)){
			newval = tc.min;
		}
		return newval;
	},

	_onKeyPress: function(e){
		if((e.charOrCode == dojo.keys.HOME || e.charOrCode == dojo.keys.END) && !(e.ctrlKey || e.altKey || e.metaKey)
		&& typeof this.get('value') != 'undefined' /* gibberish, so HOME and END are default editing keys*/){
			var value = this.constraints[(e.charOrCode == dojo.keys.HOME ? "min" : "max")];
			if(typeof value == "number"){
				this._setValueAttr(value, false);
			}
			// eat home or end key whether we change the value or not
			dojo.stopEvent(e);
		}
	}
});

}

if(!dojo._hasResource["dijit.form.HorizontalSlider"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.HorizontalSlider"] = true;
dojo.provide("dijit.form.HorizontalSlider");







dojo.declare(
	"dijit.form.HorizontalSlider",
	[dijit.form._FormValueWidget, dijit._Container],
{
	// summary:
	//		A form widget that allows one to select a value with a horizontally draggable handle

	templateString: dojo.cache("dijit.form", "templates/HorizontalSlider.html", "<table class=\"dijit dijitReset dijitSlider dijitSliderH\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\" rules=\"none\" dojoAttachEvent=\"onkeypress:_onKeyPress,onkeyup:_onKeyUp\"\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t\t><td dojoAttachPoint=\"topDecoration\" class=\"dijitReset dijitSliderDecoration dijitSliderDecorationT dijitSliderDecorationH\"></td\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset dijitSliderButtonContainer dijitSliderButtonContainerH\"\n\t\t\t><div class=\"dijitSliderDecrementIconH\" style=\"display:none\" dojoAttachPoint=\"decrementButton\"><span class=\"dijitSliderButtonInner\">-</span></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><div class=\"dijitSliderBar dijitSliderBumper dijitSliderBumperH dijitSliderLeftBumper\" dojoAttachEvent=\"onmousedown:_onClkDecBumper\"></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><input dojoAttachPoint=\"valueNode\" type=\"hidden\" ${!nameAttrSetting}\n\t\t\t/><div class=\"dijitReset dijitSliderBarContainerH\" role=\"presentation\" dojoAttachPoint=\"sliderBarContainer\"\n\t\t\t\t><div role=\"presentation\" dojoAttachPoint=\"progressBar\" class=\"dijitSliderBar dijitSliderBarH dijitSliderProgressBar dijitSliderProgressBarH\" dojoAttachEvent=\"onmousedown:_onBarClick\"\n\t\t\t\t\t><div class=\"dijitSliderMoveable dijitSliderMoveableH\"\n\t\t\t\t\t\t><div dojoAttachPoint=\"sliderHandle,focusNode\" class=\"dijitSliderImageHandle dijitSliderImageHandleH\" dojoAttachEvent=\"onmousedown:_onHandleClick\" role=\"slider\" valuemin=\"${minimum}\" valuemax=\"${maximum}\"></div\n\t\t\t\t\t></div\n\t\t\t\t></div\n\t\t\t\t><div role=\"presentation\" dojoAttachPoint=\"remainingBar\" class=\"dijitSliderBar dijitSliderBarH dijitSliderRemainingBar dijitSliderRemainingBarH\" dojoAttachEvent=\"onmousedown:_onBarClick\"></div\n\t\t\t></div\n\t\t></td\n\t\t><td class=\"dijitReset\"\n\t\t\t><div class=\"dijitSliderBar dijitSliderBumper dijitSliderBumperH dijitSliderRightBumper\" dojoAttachEvent=\"onmousedown:_onClkIncBumper\"></div\n\t\t></td\n\t\t><td class=\"dijitReset dijitSliderButtonContainer dijitSliderButtonContainerH\"\n\t\t\t><div class=\"dijitSliderIncrementIconH\" style=\"display:none\" dojoAttachPoint=\"incrementButton\"><span class=\"dijitSliderButtonInner\">+</span></div\n\t\t></td\n\t></tr\n\t><tr class=\"dijitReset\"\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t\t><td dojoAttachPoint=\"containerNode,bottomDecoration\" class=\"dijitReset dijitSliderDecoration dijitSliderDecorationB dijitSliderDecorationH\"></td\n\t\t><td class=\"dijitReset\" colspan=\"2\"></td\n\t></tr\n></table>\n"),

	// Overrides FormValueWidget.value to indicate numeric value
	value: 0,

	// showButtons: [const] Boolean
	//		Show increment/decrement buttons at the ends of the slider?
	showButtons: true,

	// minimum:: [const] Integer
	//		The minimum value the slider can be set to.
	minimum: 0,

	// maximum: [const] Integer
	//		The maximum value the slider can be set to.
	maximum: 100,

	// discreteValues: Integer
	//		If specified, indicates that the slider handle has only 'discreteValues' possible positions,
	//		and that after dragging the handle, it will snap to the nearest possible position.
	//		Thus, the slider has only 'discreteValues' possible values.
	//
	//		For example, if minimum=10, maxiumum=30, and discreteValues=3, then the slider handle has
	//		three possible positions, representing values 10, 20, or 30.
	//
	//		If discreteValues is not specified or if it's value is higher than the number of pixels
	//		in the slider bar, then the slider handle can be moved freely, and the slider's value will be
	//		computed/reported based on pixel position (in this case it will likely be fractional,
	//		such as 123.456789).
	discreteValues: Infinity,

	// pageIncrement: Integer
	//		If discreteValues is also specified, this indicates the amount of clicks (ie, snap positions)
	//		that the slider handle is moved via pageup/pagedown keys.
	//		If discreteValues is not specified, it indicates the number of pixels.
	pageIncrement: 2,

	// clickSelect: Boolean
	//		If clicking the slider bar changes the value or not
	clickSelect: true,

	// slideDuration: Number
	//		The time in ms to take to animate the slider handle from 0% to 100%,
	//		when clicking the slider bar to make the handle move.
	slideDuration: dijit.defaultDuration,

	// Flag to _Templated  (TODO: why is this here?  I see no widgets in the template.)
	widgetsInTemplate: true,

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		id: ""
	}),

	baseClass: "dijitSlider",

	// Apply CSS classes to up/down arrows and handle per mouse state
	cssStateNodes: {
		incrementButton: "dijitSliderIncrementButton",
		decrementButton: "dijitSliderDecrementButton",
		focusNode: "dijitSliderThumb"
	},

	_mousePixelCoord: "pageX",
	_pixelCount: "w",
	_startingPixelCoord: "x",
	_startingPixelCount: "l",
	_handleOffsetCoord: "left",
	_progressPixelSize: "width",

	_onKeyUp: function(/*Event*/ e){
		if(this.disabled || this.readOnly || e.altKey || e.ctrlKey || e.metaKey){ return; }
		this._setValueAttr(this.value, true);
	},

	_onKeyPress: function(/*Event*/ e){
		if(this.disabled || this.readOnly || e.altKey || e.ctrlKey || e.metaKey){ return; }
		switch(e.charOrCode){
			case dojo.keys.HOME:
				this._setValueAttr(this.minimum, false);
				break;
			case dojo.keys.END:
				this._setValueAttr(this.maximum, false);
				break;
			// this._descending === false: if ascending vertical (min on top)
			// (this._descending || this.isLeftToRight()): if left-to-right horizontal or descending vertical
			case ((this._descending || this.isLeftToRight()) ? dojo.keys.RIGHT_ARROW : dojo.keys.LEFT_ARROW):
			case (this._descending === false ? dojo.keys.DOWN_ARROW : dojo.keys.UP_ARROW):
			case (this._descending === false ? dojo.keys.PAGE_DOWN : dojo.keys.PAGE_UP):
				this.increment(e);
				break;
			case ((this._descending || this.isLeftToRight()) ? dojo.keys.LEFT_ARROW : dojo.keys.RIGHT_ARROW):
			case (this._descending === false ? dojo.keys.UP_ARROW : dojo.keys.DOWN_ARROW):
			case (this._descending === false ? dojo.keys.PAGE_UP : dojo.keys.PAGE_DOWN):
				this.decrement(e);
				break;
			default:
				return;
		}
		dojo.stopEvent(e);
	},

	_onHandleClick: function(e){
		if(this.disabled || this.readOnly){ return; }
		if(!dojo.isIE){
			// make sure you get focus when dragging the handle
			// (but don't do on IE because it causes a flicker on mouse up (due to blur then focus)
			dijit.focus(this.sliderHandle);
		}
		dojo.stopEvent(e);
	},

	_isReversed: function(){
		// summary:
		//		Returns true if direction is from right to left
		// tags:
		//		protected extension
		return !this.isLeftToRight();
	},

	_onBarClick: function(e){
		if(this.disabled || this.readOnly || !this.clickSelect){ return; }
		dijit.focus(this.sliderHandle);
		dojo.stopEvent(e);
		var abspos = dojo.position(this.sliderBarContainer, true);
		var pixelValue = e[this._mousePixelCoord] - abspos[this._startingPixelCoord];
		this._setPixelValue(this._isReversed() ? (abspos[this._pixelCount] - pixelValue) : pixelValue, abspos[this._pixelCount], true);
		this._movable.onMouseDown(e);
	},

	_setPixelValue: function(/*Number*/ pixelValue, /*Number*/ maxPixels, /*Boolean?*/ priorityChange){
		if(this.disabled || this.readOnly){ return; }
		pixelValue = pixelValue < 0 ? 0 : maxPixels < pixelValue ? maxPixels : pixelValue;
		var count = this.discreteValues;
		if(count <= 1 || count == Infinity){ count = maxPixels; }
		count--;
		var pixelsPerValue = maxPixels / count;
		var wholeIncrements = Math.round(pixelValue / pixelsPerValue);
		this._setValueAttr((this.maximum-this.minimum)*wholeIncrements/count + this.minimum, priorityChange);
	},

	_setValueAttr: function(/*Number*/ value, /*Boolean?*/ priorityChange){
		// summary:
		//		Hook so set('value', value) works.
		this._set("value", value);
		this.valueNode.value = value;
		dijit.setWaiState(this.focusNode, "valuenow", value);
		this.inherited(arguments);
		var percent = (value - this.minimum) / (this.maximum - this.minimum);
		var progressBar = (this._descending === false) ? this.remainingBar : this.progressBar;
		var remainingBar = (this._descending === false) ? this.progressBar : this.remainingBar;
		if(this._inProgressAnim && this._inProgressAnim.status != "stopped"){
			this._inProgressAnim.stop(true);
		}
		if(priorityChange && this.slideDuration > 0 && progressBar.style[this._progressPixelSize]){
			// animate the slider
			var _this = this;
			var props = {};
			var start = parseFloat(progressBar.style[this._progressPixelSize]);
			var duration = this.slideDuration * (percent-start/100);
			if(duration == 0){ return; }
			if(duration < 0){ duration = 0 - duration; }
			props[this._progressPixelSize] = { start: start, end: percent*100, units:"%" };
			this._inProgressAnim = dojo.animateProperty({ node: progressBar, duration: duration,
				onAnimate: function(v){ remainingBar.style[_this._progressPixelSize] = (100-parseFloat(v[_this._progressPixelSize])) + "%"; },
				onEnd: function(){ delete _this._inProgressAnim; },
				properties: props
			})
			this._inProgressAnim.play();
		}else{
			progressBar.style[this._progressPixelSize] = (percent*100) + "%";
			remainingBar.style[this._progressPixelSize] = ((1-percent)*100) + "%";
		}
	},

	_bumpValue: function(signedChange, /*Boolean?*/ priorityChange){
		if(this.disabled || this.readOnly){ return; }
		var s = dojo.getComputedStyle(this.sliderBarContainer);
		var c = dojo._getContentBox(this.sliderBarContainer, s);
		var count = this.discreteValues;
		if(count <= 1 || count == Infinity){ count = c[this._pixelCount]; }
		count--;
		var value = (this.value - this.minimum) * count / (this.maximum - this.minimum) + signedChange;
		if(value < 0){ value = 0; }
		if(value > count){ value = count; }
		value = value * (this.maximum - this.minimum) / count + this.minimum;
		this._setValueAttr(value, priorityChange);
	},

	_onClkBumper: function(val){
		if(this.disabled || this.readOnly || !this.clickSelect){ return; }
		this._setValueAttr(val, true);
	},

	_onClkIncBumper: function(){
		this._onClkBumper(this._descending === false ? this.minimum : this.maximum);
	},

	_onClkDecBumper: function(){
		this._onClkBumper(this._descending === false ? this.maximum : this.minimum);
	},

	decrement: function(/*Event*/ e){
		// summary:
		//		Decrement slider
		// tags:
		//		private
		this._bumpValue(e.charOrCode == dojo.keys.PAGE_DOWN ? -this.pageIncrement : -1);
	},

	increment: function(/*Event*/ e){
		// summary:
		//		Increment slider
		// tags:
		//		private
		this._bumpValue(e.charOrCode == dojo.keys.PAGE_UP ? this.pageIncrement : 1);
	},

	_mouseWheeled: function(/*Event*/ evt){
		// summary:
		//		Event handler for mousewheel where supported
		dojo.stopEvent(evt);
		var janky = !dojo.isMozilla;
		var scroll = evt[(janky ? "wheelDelta" : "detail")] * (janky ? 1 : -1);
		this._bumpValue(scroll < 0 ? -1 : 1, true); // negative scroll acts like a decrement
	},

	startup: function(){
		if(this._started){ return; }

		dojo.forEach(this.getChildren(), function(child){
			if(this[child.container] != this.containerNode){
				this[child.container].appendChild(child.domNode);
			}
		}, this);

		this.inherited(arguments);
	},

	_typematicCallback: function(/*Number*/ count, /*Object*/ button, /*Event*/ e){
		if(count == -1){
			this._setValueAttr(this.value, true);
		}else{
			this[(button == (this._descending? this.incrementButton : this.decrementButton)) ? "decrement" : "increment"](e);
		}
	},

	buildRendering: function(){
		this.inherited(arguments);
		if(this.showButtons){
			this.incrementButton.style.display="";
			this.decrementButton.style.display="";
		}

		// find any associated label element and add to slider focusnode.
		var label = dojo.query('label[for="'+this.id+'"]');
		if(label.length){
			label[0].id = (this.id+"_label");
			dijit.setWaiState(this.focusNode, "labelledby", label[0].id);
		}

		dijit.setWaiState(this.focusNode, "valuemin", this.minimum);
		dijit.setWaiState(this.focusNode, "valuemax", this.maximum);
	},

	postCreate: function(){
		this.inherited(arguments);

		if(this.showButtons){
			this._connects.push(dijit.typematic.addMouseListener(
				this.decrementButton, this, "_typematicCallback", 25, 500));
			this._connects.push(dijit.typematic.addMouseListener(
				this.incrementButton, this, "_typematicCallback", 25, 500));
		}
		this.connect(this.domNode, !dojo.isMozilla ? "onmousewheel" : "DOMMouseScroll", "_mouseWheeled");

		// define a custom constructor for a SliderMover that points back to me
		var mover = dojo.declare(dijit.form._SliderMover, {
			widget: this
		});
		this._movable = new dojo.dnd.Moveable(this.sliderHandle, {mover: mover});

		this._layoutHackIE7();
	},

	destroy: function(){
		this._movable.destroy();
		if(this._inProgressAnim && this._inProgressAnim.status != "stopped"){
			this._inProgressAnim.stop(true);
		}
		this._supportingWidgets = dijit.findWidgets(this.domNode); // tells destroy about pseudo-child widgets (ruler/labels)
		this.inherited(arguments);
	}
});

dojo.declare("dijit.form._SliderMover",
	dojo.dnd.Mover,
{
	onMouseMove: function(e){
		var widget = this.widget;
		var abspos = widget._abspos;
		if(!abspos){
			abspos = widget._abspos = dojo.position(widget.sliderBarContainer, true);
			widget._setPixelValue_ = dojo.hitch(widget, "_setPixelValue");
			widget._isReversed_ = widget._isReversed();
		}
		var coordEvent = e.touches ? e.touches[0] : e, // if multitouch take first touch for coords
			pixelValue = coordEvent[widget._mousePixelCoord] - abspos[widget._startingPixelCoord];
		widget._setPixelValue_(widget._isReversed_ ? (abspos[widget._pixelCount]-pixelValue) : pixelValue, abspos[widget._pixelCount], false);
	},

	destroy: function(e){
		dojo.dnd.Mover.prototype.destroy.apply(this, arguments);
		var widget = this.widget;
		widget._abspos = null;
		widget._setValueAttr(widget.value, true);
	}
});

}

if(!dojo._hasResource["dijit._editor.selection"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor.selection"] = true;
dojo.provide("dijit._editor.selection");


dojo.getObject("_editor.selection", true, dijit);

// FIXME:
//		all of these methods branch internally for IE. This is probably
//		sub-optimal in terms of runtime performance. We should investigate the
//		size difference for differentiating at definition time.

dojo.mixin(dijit._editor.selection, {
	getType: function(){
		// summary:
		//		Get the selection type (like dojo.doc.select.type in IE).
		if(dojo.isIE < 9){
			return dojo.doc.selection.type.toLowerCase();
		}else{
			var stype = "text";

			// Check if the actual selection is a CONTROL (IMG, TABLE, HR, etc...).
			var oSel;
			try{
				oSel = dojo.global.getSelection();
			}catch(e){ /*squelch*/ }

			if(oSel && oSel.rangeCount == 1){
				var oRange = oSel.getRangeAt(0);
				if(	(oRange.startContainer == oRange.endContainer) &&
					((oRange.endOffset - oRange.startOffset) == 1) &&
					(oRange.startContainer.nodeType != 3 /* text node*/)
				){
					stype = "control";
				}
			}
			return stype; //String
		}
	},

	getSelectedText: function(){
		// summary:
		//		Return the text (no html tags) included in the current selection or null if no text is selected
		if(dojo.isIE < 9){
			if(dijit._editor.selection.getType() == 'control'){
				return null;
			}
			return dojo.doc.selection.createRange().text;
		}else{
			var selection = dojo.global.getSelection();
			if(selection){
				return selection.toString(); //String
			}
		}
		return '';
	},

	getSelectedHtml: function(){
		// summary:
		//		Return the html text of the current selection or null if unavailable
		if(dojo.isIE < 9){
			if(dijit._editor.selection.getType() == 'control'){
				return null;
			}
			return dojo.doc.selection.createRange().htmlText;
		}else{
			var selection = dojo.global.getSelection();
			if(selection && selection.rangeCount){
				var i;
				var html = "";
				for(i = 0; i < selection.rangeCount; i++){
					//Handle selections spanning ranges, such as Opera
					var frag = selection.getRangeAt(i).cloneContents();
					var div = dojo.doc.createElement("div");
					div.appendChild(frag);
					html += div.innerHTML;
				}
				return html; //String
			}
			return null;
		}
	},

	getSelectedElement: function(){
		// summary:
		//		Retrieves the selected element (if any), just in the case that
		//		a single element (object like and image or a table) is
		//		selected.
		if(dijit._editor.selection.getType() == "control"){
			if(dojo.isIE < 9){
				var range = dojo.doc.selection.createRange();
				if(range && range.item){
					return dojo.doc.selection.createRange().item(0);
				}
			}else{
				var selection = dojo.global.getSelection();
				return selection.anchorNode.childNodes[ selection.anchorOffset ];
			}
		}
		return null;
	},

	getParentElement: function(){
		// summary:
		//		Get the parent element of the current selection
		if(dijit._editor.selection.getType() == "control"){
			var p = this.getSelectedElement();
			if(p){ return p.parentNode; }
		}else{
			if(dojo.isIE < 9){
				var r = dojo.doc.selection.createRange();
				r.collapse(true);
				return r.parentElement();
			}else{
				var selection = dojo.global.getSelection();
				if(selection){
					var node = selection.anchorNode;
					while(node && (node.nodeType != 1)){ // not an element
						node = node.parentNode;
					}
					return node;
				}
			}
		}
		return null;
	},

	hasAncestorElement: function(/*String*/tagName /* ... */){
		// summary:
		// 		Check whether current selection has a  parent element which is
		// 		of type tagName (or one of the other specified tagName)
		// tagName: String
		//		The tag name to determine if it has an ancestor of.
		return this.getAncestorElement.apply(this, arguments) != null; //Boolean
	},

	getAncestorElement: function(/*String*/tagName /* ... */){
		// summary:
		//		Return the parent element of the current selection which is of
		//		type tagName (or one of the other specified tagName)
		// tagName: String
		//		The tag name to determine if it has an ancestor of.
		var node = this.getSelectedElement() || this.getParentElement();
		return this.getParentOfType(node, arguments); //DOMNode
	},

	isTag: function(/*DomNode*/ node, /*String[]*/ tags){
		// summary:
		//		Function to determine if a node is one of an array of tags.
		// node:
		//		The node to inspect.
		// tags:
		//		An array of tag name strings to check to see if the node matches.
		if(node && node.tagName){
			var _nlc = node.tagName.toLowerCase();
			for(var i=0; i<tags.length; i++){
				var _tlc = String(tags[i]).toLowerCase();
				if(_nlc == _tlc){
					return _tlc; // String
				}
			}
		}
		return "";
	},

	getParentOfType: function(/*DomNode*/ node, /*String[]*/ tags){
		// summary:
		//		Function to locate a parent node that matches one of a set of tags
		// node:
		//		The node to inspect.
		// tags:
		//		An array of tag name strings to check to see if the node matches.
		while(node){
			if(this.isTag(node, tags).length){
				return node; // DOMNode
			}
			node = node.parentNode;
		}
		return null;
	},

	collapse: function(/*Boolean*/beginning){
		// summary:
		//		Function to collapse (clear), the current selection
		// beginning: Boolean
		//		Boolean to indicate whether to collapse the cursor to the beginning of the selection or end.
		if(window.getSelection){
			var selection = dojo.global.getSelection();
			if(selection.removeAllRanges){ // Mozilla
				if(beginning){
					selection.collapseToStart();
				}else{
					selection.collapseToEnd();
				}
			}else{ // Safari
				// pulled from WebCore/ecma/kjs_window.cpp, line 2536
				selection.collapse(beginning);
			}
		}else if(dojo.isIE){ // IE
			var range = dojo.doc.selection.createRange();
			range.collapse(beginning);
			range.select();
		}
	},

	remove: function(){
		// summary:
		//		Function to delete the currently selected content from the document.
		var sel = dojo.doc.selection;
		if(dojo.isIE < 9){
			if(sel.type.toLowerCase() != "none"){
				sel.clear();
			}
			return sel; //Selection
		}else{
			sel = dojo.global.getSelection();
			sel.deleteFromDocument();
			return sel; //Selection
		}
	},

	selectElementChildren: function(/*DomNode*/element,/*Boolean?*/nochangefocus){
		// summary:
		//		clear previous selection and select the content of the node
		//		(excluding the node itself)
		// element: DOMNode
		//		The element you wish to select the children content of.
		// nochangefocus: Boolean
		//		Boolean to indicate if the foxus should change or not.
		var win = dojo.global;
		var doc = dojo.doc;
		var range;
		element = dojo.byId(element);
		if(doc.selection && dojo.isIE < 9 && dojo.body().createTextRange){ // IE
			range = element.ownerDocument.body.createTextRange();
			range.moveToElementText(element);
			if(!nochangefocus){
				try{
					range.select(); // IE throws an exception here if the widget is hidden.  See #5439
				}catch(e){ /* squelch */}
			}
		}else if(win.getSelection){
			var selection = dojo.global.getSelection();
			if(dojo.isOpera){
				//Opera's selectAllChildren doesn't seem to work right
				//against <body> nodes and possibly others ... so
				//we use the W3C range API
				if(selection.rangeCount){
					range = selection.getRangeAt(0);
				}else{
					range = doc.createRange();
				}
				range.setStart(element, 0);
				range.setEnd(element,(element.nodeType == 3)?element.length:element.childNodes.length);
				selection.addRange(range);
			}
			else
			{
				if(element.innerText && element.innerText !== "") {
					selection.selectAllChildren(element);
				}
			}
		}
	},

	selectElement: function(/*DomNode*/element,/*Boolean?*/nochangefocus){
		// summary:
		//		clear previous selection and select element (including all its children)
		// element:  DOMNode
		//		The element to select.
		// nochangefocus: Boolean
		//		Boolean indicating if the focus should be changed.  IE only.
		var range;
		var doc = dojo.doc;
		var win = dojo.global;
		element = dojo.byId(element);
		if(dojo.isIE < 9 && dojo.body().createTextRange){
			try{
				var tg = element.tagName ? element.tagName.toLowerCase() : "";
				if(tg === "img" || tg === "table"){
					range = dojo.body().createControlRange();
				}else{
					range = dojo.body().createRange();
				}
				range.addElement(element);
				if(!nochangefocus){
					range.select();
				}
			}catch(e){
				this.selectElementChildren(element,nochangefocus);
			}
		}else if(dojo.global.getSelection){
			var selection = win.getSelection();
			range = doc.createRange();
			if(selection.removeAllRanges){ // Mozilla
				// FIXME: does this work on Safari?
				if(dojo.isOpera){
					//Opera works if you use the current range on
					//the selection if present.
					if(selection.getRangeAt(0)){
						range = selection.getRangeAt(0);
					}
				}
				range.selectNode(element);
				selection.removeAllRanges();
				selection.addRange(range);
			}
		}
	},

	inSelection: function(node){
		// summary:
		//		This function determines if 'node' is
		//		in the current selection.
		// tags:
		//		public
		if(node){
			var newRange;
			var doc = dojo.doc;
			var range;

			if(dojo.global.getSelection){
				//WC3
				var sel = dojo.global.getSelection();
				if(sel && sel.rangeCount > 0){
					range = sel.getRangeAt(0);
				}
				if(range && range.compareBoundaryPoints && doc.createRange){
					try{
						newRange = doc.createRange();
						newRange.setStart(node, 0);
						if(range.compareBoundaryPoints(range.START_TO_END, newRange) === 1){
							return true;
						}
					}catch(e){ /* squelch */}
				}
			}else if(doc.selection){
				// Probably IE, so we can't use the range object as the pseudo
				// range doesn't implement the boundry checking, we have to
				// use IE specific crud.
				range = doc.selection.createRange();
				try{
					newRange = node.ownerDocument.body.createControlRange();
					if(newRange){
						newRange.addElement(node);
					}
				}catch(e1){
					try{
						newRange = node.ownerDocument.body.createTextRange();
						newRange.moveToElementText(node);
					}catch(e2){/* squelch */}
				}
				if(range && newRange){
					// We can finally compare similar to W3C
					if(range.compareEndPoints("EndToStart", newRange) === 1){
						return true;
					}
				}
			}
		}
		return false; // boolean
	}

});

}

if(!dojo._hasResource["dijit._editor.range"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor.range"] = true;
dojo.provide("dijit._editor.range");


dijit.range={};

dijit.range.getIndex=function(/*DomNode*/node, /*DomNode*/parent){
//	dojo.profile.start("dijit.range.getIndex");
	var ret=[], retR=[];
	var stop = parent;
	var onode = node;

	var pnode, n;
	while(node != stop){
		var i = 0;
		pnode = node.parentNode;
		while((n=pnode.childNodes[i++])){
			if(n === node){
				--i;
				break;
			}
		}
		//if(i>=pnode.childNodes.length){
			//dojo.debug("Error finding index of a node in dijit.range.getIndex");
		//}
		ret.unshift(i);
		retR.unshift(i-pnode.childNodes.length);
		node = pnode;
	}

	//normalized() can not be called so often to prevent
	//invalidating selection/range, so we have to detect
	//here that any text nodes in a row
	if(ret.length > 0 && onode.nodeType == 3){
		n = onode.previousSibling;
		while(n && n.nodeType == 3){
			ret[ret.length-1]--;
			n = n.previousSibling;
		}
		n = onode.nextSibling;
		while(n && n.nodeType == 3){
			retR[retR.length-1]++;
			n = n.nextSibling;
		}
	}
//	dojo.profile.end("dijit.range.getIndex");
	return {o: ret, r:retR};
}

dijit.range.getNode = function(/*Array*/index, /*DomNode*/parent){
	if(!dojo.isArray(index) || index.length == 0){
		return parent;
	}
	var node = parent;
//	if(!node)debugger
	dojo.every(index, function(i){
		if(i >= 0 && i < node.childNodes.length){
			node = node.childNodes[i];
		}else{
			node = null;
			//console.debug('Error: can not find node with index',index,'under parent node',parent );
			return false; //terminate dojo.every
		}
		return true; //carry on the every loop
	});

	return node;
}

dijit.range.getCommonAncestor = function(n1,n2,root){
	root = root||n1.ownerDocument.body;
	var getAncestors = function(n){
		var as=[];
		while(n){
			as.unshift(n);
			if(n !== root){
				n = n.parentNode;
			}else{
				break;
			}
		}
		return as;
	};
	var n1as = getAncestors(n1);
	var n2as = getAncestors(n2);

	var m = Math.min(n1as.length,n2as.length);
	var com = n1as[0]; //at least, one element should be in the array: the root (BODY by default)
	for(var i=1;i<m;i++){
		if(n1as[i] === n2as[i]){
			com = n1as[i]
		}else{
			break;
		}
	}
	return com;
}

dijit.range.getAncestor = function(/*DomNode*/node, /*RegEx?*/regex, /*DomNode?*/root){
	root = root || node.ownerDocument.body;
	while(node && node !== root){
		var name = node.nodeName.toUpperCase() ;
		if(regex.test(name)){
			return node;
		}

		node = node.parentNode;
	}
	return null;
}

dijit.range.BlockTagNames = /^(?:P|DIV|H1|H2|H3|H4|H5|H6|ADDRESS|PRE|OL|UL|LI|DT|DE)$/;
dijit.range.getBlockAncestor = function(/*DomNode*/node, /*RegEx?*/regex, /*DomNode?*/root){
	root = root || node.ownerDocument.body;
	regex = regex || dijit.range.BlockTagNames;
	var block=null, blockContainer;
	while(node && node !== root){
		var name = node.nodeName.toUpperCase() ;
		if(!block && regex.test(name)){
			block = node;
		}
		if(!blockContainer && (/^(?:BODY|TD|TH|CAPTION)$/).test(name)){
			blockContainer = node;
		}

		node = node.parentNode;
	}
	return {blockNode:block, blockContainer:blockContainer || node.ownerDocument.body};
}

dijit.range.atBeginningOfContainer = function(/*DomNode*/container, /*DomNode*/node, /*Int*/offset){
	var atBeginning = false;
	var offsetAtBeginning = (offset == 0);
	if(!offsetAtBeginning && node.nodeType == 3){ //if this is a text node, check whether the left part is all space
		if(/^[\s\xA0]+$/.test(node.nodeValue.substr(0,offset))){
			offsetAtBeginning = true;
		}
	}
	if(offsetAtBeginning){
		var cnode = node;
		atBeginning = true;
		while(cnode && cnode !== container){
			if(cnode.previousSibling){
				atBeginning = false;
				break;
			}
			cnode = cnode.parentNode;
		}
	}
	return atBeginning;
}

dijit.range.atEndOfContainer = function(/*DomNode*/container, /*DomNode*/node, /*Int*/offset){
	var atEnd = false;
	var offsetAtEnd = (offset == (node.length || node.childNodes.length));
	if(!offsetAtEnd && node.nodeType == 3){ //if this is a text node, check whether the right part is all space
		if(/^[\s\xA0]+$/.test(node.nodeValue.substr(offset))){
			offsetAtEnd = true;
		}
	}
	if(offsetAtEnd){
		var cnode = node;
		atEnd = true;
		while(cnode && cnode !== container){
			if(cnode.nextSibling){
				atEnd = false;
				break;
			}
			cnode = cnode.parentNode;
		}
	}
	return atEnd;
}

dijit.range.adjacentNoneTextNode=function(startnode, next){
	var node = startnode;
	var len = (0-startnode.length) || 0;
	var prop = next?'nextSibling':'previousSibling';
	while(node){
		if(node.nodeType!=3){
			break;
		}
		len += node.length
		node = node[prop];
	}
	return [node,len];
}

dijit.range._w3c = Boolean(window['getSelection']);
dijit.range.create = function(/*Window?*/win){
	if(dijit.range._w3c){
		return (win || dojo.global).document.createRange();
	}else{//IE
		return new dijit.range.W3CRange;
	}
}

dijit.range.getSelection = function(/*Window*/win, /*Boolean?*/ignoreUpdate){
	if(dijit.range._w3c){
		return win.getSelection();
	}else{//IE
		var s = new dijit.range.ie.selection(win);
		if(!ignoreUpdate){
			s._getCurrentSelection();
		}
		return s;
	}
}

if(!dijit.range._w3c){
	dijit.range.ie={
		cachedSelection: {},
		selection: function(win){
			this._ranges = [];
			this.addRange = function(r, /*boolean*/internal){
				this._ranges.push(r);
				if(!internal){
					r._select();
				}
				this.rangeCount = this._ranges.length;
			};
			this.removeAllRanges = function(){
				//don't detach, the range may be used later
//				for(var i=0;i<this._ranges.length;i++){
//					this._ranges[i].detach();
//				}
				this._ranges = [];
				this.rangeCount = 0;
			};
			var _initCurrentRange = function(){
				var r = win.document.selection.createRange();
				var type=win.document.selection.type.toUpperCase();
				if(type == "CONTROL"){
					//TODO: multiple range selection(?)
					return new dijit.range.W3CRange(dijit.range.ie.decomposeControlRange(r));
				}else{
					return new dijit.range.W3CRange(dijit.range.ie.decomposeTextRange(r));
				}
			};
			this.getRangeAt = function(i){
				return this._ranges[i];
			};
			this._getCurrentSelection = function(){
				this.removeAllRanges();
				var r=_initCurrentRange();
				if(r){
					this.addRange(r, true);
				}
			};
		},
		decomposeControlRange: function(range){
			var firstnode = range.item(0), lastnode = range.item(range.length-1);
			var startContainer = firstnode.parentNode, endContainer = lastnode.parentNode;
			var startOffset = dijit.range.getIndex(firstnode, startContainer).o;
			var endOffset = dijit.range.getIndex(lastnode, endContainer).o+1;
			return [startContainer, startOffset,endContainer, endOffset];
		},
		getEndPoint: function(range, end){
			var atmrange = range.duplicate();
			atmrange.collapse(!end);
			var cmpstr = 'EndTo' + (end?'End':'Start');
			var parentNode = atmrange.parentElement();

			var startnode, startOffset, lastNode;
			if(parentNode.childNodes.length>0){
				dojo.every(parentNode.childNodes, function(node,i){
					var calOffset;
					if(node.nodeType != 3){
						atmrange.moveToElementText(node);

						if(atmrange.compareEndPoints(cmpstr,range) > 0){
							//startnode = node.previousSibling;
							if(lastNode && lastNode.nodeType == 3){
								//where shall we put the start? in the text node or after?
								startnode = lastNode;
								calOffset = true;
							}else{
								startnode = parentNode;
								startOffset = i;
								return false;
							}
						}else{
							if(i == parentNode.childNodes.length-1){
								startnode = parentNode;
								startOffset = parentNode.childNodes.length;
								return false;
							}
						}
					}else{
						if(i == parentNode.childNodes.length-1){//at the end of this node
							startnode = node;
							calOffset = true;
						}
					}
		//			try{
						if(calOffset && startnode){
							var prevnode = dijit.range.adjacentNoneTextNode(startnode)[0];
							if(prevnode){
								startnode = prevnode.nextSibling;
							}else{
								startnode = parentNode.firstChild; //firstChild must be a text node
							}
							var prevnodeobj = dijit.range.adjacentNoneTextNode(startnode);
							prevnode = prevnodeobj[0];
							var lenoffset = prevnodeobj[1];
							if(prevnode){
								atmrange.moveToElementText(prevnode);
								atmrange.collapse(false);
							}else{
								atmrange.moveToElementText(parentNode);
							}
							atmrange.setEndPoint(cmpstr, range);
							startOffset = atmrange.text.length-lenoffset;

							return false;
						}
		//			}catch(e){ debugger }
					lastNode = node;
					return true;
				});
			}else{
				startnode = parentNode;
				startOffset = 0;
			}

			//if at the end of startnode and we are dealing with start container, then
			//move the startnode to nextSibling if it is a text node
			//TODO: do this for end container?
			if(!end && startnode.nodeType == 1 && startOffset == startnode.childNodes.length){
				var nextnode=startnode.nextSibling;
				if(nextnode && nextnode.nodeType == 3){
					startnode = nextnode;
					startOffset = 0;
				}
			}
			return [startnode, startOffset];
		},
		setEndPoint: function(range, container, offset){
			//text node
			var atmrange = range.duplicate(), node, len;
			if(container.nodeType!=3){ //normal node
				if(offset > 0){
					node = container.childNodes[offset-1];
					if(node){
						if(node.nodeType == 3){
							container = node;
							offset = node.length;
							//pass through
						}else{
							if(node.nextSibling && node.nextSibling.nodeType == 3){
								container=node.nextSibling;
								offset=0;
								//pass through
							}else{
								atmrange.moveToElementText(node.nextSibling?node:container);
								var parent = node.parentNode;
								var tempNode = parent.insertBefore(node.ownerDocument.createTextNode(' '), node.nextSibling);
								atmrange.collapse(false);
								parent.removeChild(tempNode);
							}
						}
					}
				}else{
					atmrange.moveToElementText(container);
					atmrange.collapse(true);
				}
			}
			if(container.nodeType == 3){
				var prevnodeobj = dijit.range.adjacentNoneTextNode(container);
				var prevnode = prevnodeobj[0];
				len = prevnodeobj[1];
				if(prevnode){
					atmrange.moveToElementText(prevnode);
					atmrange.collapse(false);
					//if contentEditable is not inherit, the above collapse won't make the end point
					//in the correctly position: it always has a -1 offset, so compensate it
					if(prevnode.contentEditable!='inherit'){
						len++;
					}
				}else{
					atmrange.moveToElementText(container.parentNode);
					atmrange.collapse(true);
				}

				offset += len;
				if(offset>0){
					if(atmrange.move('character',offset) != offset){
						console.error('Error when moving!');
					}
				}
			}

			return atmrange;
		},
		decomposeTextRange: function(range){
			var tmpary = dijit.range.ie.getEndPoint(range);
			var startContainer = tmpary[0], startOffset = tmpary[1];
			var endContainer = tmpary[0], endOffset = tmpary[1];

			if(range.htmlText.length){
				if(range.htmlText == range.text){ //in the same text node
					endOffset = startOffset+range.text.length;
				}else{
					tmpary = dijit.range.ie.getEndPoint(range,true);
					endContainer = tmpary[0], endOffset = tmpary[1];
//					if(startContainer.tagName == "BODY"){
//						startContainer = startContainer.firstChild;
//					}
				}
			}
			return [startContainer, startOffset, endContainer, endOffset];
		},
		setRange: function(range, startContainer,
			startOffset, endContainer, endOffset, collapsed){
			var start=dijit.range.ie.setEndPoint(range, startContainer, startOffset);

			range.setEndPoint('StartToStart',start);
			if(!collapsed){
				var end=dijit.range.ie.setEndPoint(range, endContainer, endOffset);
			}
			range.setEndPoint('EndToEnd',end || start);

			return range;
		}
	}

dojo.declare("dijit.range.W3CRange",null, {
	constructor: function(){
		if(arguments.length>0){
			this.setStart(arguments[0][0],arguments[0][1]);
			this.setEnd(arguments[0][2],arguments[0][3]);
		}else{
			this.commonAncestorContainer = null;
			this.startContainer = null;
			this.startOffset = 0;
			this.endContainer = null;
			this.endOffset = 0;
			this.collapsed = true;
		}
	},
	_updateInternal: function(){
		if(this.startContainer !== this.endContainer){
			this.commonAncestorContainer = dijit.range.getCommonAncestor(this.startContainer, this.endContainer);
		}else{
			this.commonAncestorContainer = this.startContainer;
		}
		this.collapsed = (this.startContainer === this.endContainer) && (this.startOffset == this.endOffset);
	},
	setStart: function(node, offset){
		offset=parseInt(offset);
		if(this.startContainer === node && this.startOffset == offset){
			return;
		}
		delete this._cachedBookmark;

		this.startContainer = node;
		this.startOffset = offset;
		if(!this.endContainer){
			this.setEnd(node, offset);
		}else{
			this._updateInternal();
		}
	},
	setEnd: function(node, offset){
		offset=parseInt(offset);
		if(this.endContainer === node && this.endOffset == offset){
			return;
		}
		delete this._cachedBookmark;

		this.endContainer = node;
		this.endOffset = offset;
		if(!this.startContainer){
			this.setStart(node, offset);
		}else{
			this._updateInternal();
		}
	},
	setStartAfter: function(node, offset){
		this._setPoint('setStart', node, offset, 1);
	},
	setStartBefore: function(node, offset){
		this._setPoint('setStart', node, offset, 0);
	},
	setEndAfter: function(node, offset){
		this._setPoint('setEnd', node, offset, 1);
	},
	setEndBefore: function(node, offset){
		this._setPoint('setEnd', node, offset, 0);
	},
	_setPoint: function(what, node, offset, ext){
		var index = dijit.range.getIndex(node, node.parentNode).o;
		this[what](node.parentNode, index.pop()+ext);
	},
	_getIERange: function(){
		var r = (this._body || this.endContainer.ownerDocument.body).createTextRange();
		dijit.range.ie.setRange(r, this.startContainer, this.startOffset, this.endContainer, this.endOffset, this.collapsed);
		return r;
	},
	getBookmark: function(body){
		this._getIERange();
		return this._cachedBookmark;
	},
	_select: function(){
		var r = this._getIERange();
		r.select();
	},
	deleteContents: function(){
		var r = this._getIERange();
		r.pasteHTML('');
		this.endContainer = this.startContainer;
		this.endOffset = this.startOffset;
		this.collapsed = true;
	},
	cloneRange: function(){
		var r = new dijit.range.W3CRange([this.startContainer,this.startOffset,
			this.endContainer,this.endOffset]);
		r._body = this._body;
		return r;
	},
	detach: function(){
		this._body = null;
		this.commonAncestorContainer = null;
		this.startContainer = null;
		this.startOffset = 0;
		this.endContainer = null;
		this.endOffset = 0;
		this.collapsed = true;
}
});
} //if(!dijit.range._w3c)

}

if(!dojo._hasResource["dijit._editor.html"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor.html"] = true;
dojo.provide("dijit._editor.html");

dojo.getObject("_editor", true, dijit);

dijit._editor.escapeXml=function(/*String*/str, /*Boolean?*/noSingleQuotes){
	// summary:
	//		Adds escape sequences for special characters in XML: &<>"'
	//		Optionally skips escapes for single quotes
	str = str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
	if(!noSingleQuotes){
		str = str.replace(/'/gm, "&#39;");
	}
	return str; // string
};

dijit._editor.getNodeHtml=function(/* DomNode */node){
	var output;
	switch(node.nodeType){
		case 1: //element node
			var lName = node.nodeName.toLowerCase();
			if(!lName || lName.charAt(0) == "/"){
				// IE does some strange things with malformed HTML input, like
				// treating a close tag </span> without an open tag <span>, as
				// a new tag with tagName of /span.  Corrupts output HTML, remove
				// them.  Other browsers don't prefix tags that way, so will
				// never show up.
				return "";
			}
			output = '<' + lName;

			//store the list of attributes and sort it to have the
			//attributes appear in the dictionary order
			var attrarray = [];
			var attr;
			if(dojo.isIE && node.outerHTML){
				var s = node.outerHTML;
				s = s.substr(0, s.indexOf('>'))
					.replace(/(['"])[^"']*\1/g, ''); //to make the following regexp safe
				var reg = /(\b\w+)\s?=/g;
				var m, key;
				while((m = reg.exec(s))){
					key = m[1];
					if(key.substr(0,3) != '_dj'){
						if(key == 'src' || key == 'href'){
							if(node.getAttribute('_djrealurl')){
								attrarray.push([key,node.getAttribute('_djrealurl')]);
								continue;
							}
						}
						var val, match;
						switch(key){
							case 'style':
								val = node.style.cssText.toLowerCase();
								break;
							case 'class':
								val = node.className;
								break;
							case 'width':
								if(lName === "img"){
									// This somehow gets lost on IE for IMG tags and the like
									// and we have to find it in outerHTML, known IE oddity.
									match=/width=(\S+)/i.exec(s);
									if(match){
										val = match[1];
									}
									break;
								}
							case 'height':
								if(lName === "img"){
									// This somehow gets lost on IE for IMG tags and the like
									// and we have to find it in outerHTML, known IE oddity.
									match=/height=(\S+)/i.exec(s);
									if(match){
										val = match[1];
									}
									break;
								}
							default:
								val = node.getAttribute(key);
						}
						if(val != null){
							attrarray.push([key, val.toString()]);
						}
					}
				}
			}else{
				var i = 0;
				while((attr = node.attributes[i++])){
					//ignore all attributes starting with _dj which are
					//internal temporary attributes used by the editor
					var n = attr.name;
					if(n.substr(0,3) != '_dj' /*&&
						(attr.specified == undefined || attr.specified)*/){
						var v = attr.value;
						if(n == 'src' || n == 'href'){
							if(node.getAttribute('_djrealurl')){
								v = node.getAttribute('_djrealurl');
							}
						}
						attrarray.push([n,v]);
					}
				}
			}
			attrarray.sort(function(a,b){
				return a[0] < b[0] ? -1 : (a[0] == b[0] ? 0 : 1);
			});
			var j = 0;
			while((attr = attrarray[j++])){
				output += ' ' + attr[0] + '="' +
					(dojo.isString(attr[1]) ? dijit._editor.escapeXml(attr[1], true) : attr[1]) + '"';
			}
			if(lName === "script"){
				// Browsers handle script tags differently in how you get content,
				// but innerHTML always seems to work, so insert its content that way
				// Yes, it's bad to allow script tags in the editor code, but some people
				// seem to want to do it, so we need to at least return them right.
				// other plugins/filters can strip them.
				output += '>' + node.innerHTML +'</' + lName + '>';
			}else{
				if(node.childNodes.length){
					output += '>' + dijit._editor.getChildrenHtml(node)+'</' + lName +'>';
				}else{
					switch(lName){
						case 'br':
						case 'hr':
						case 'img':
						case 'input':
						case 'base':
						case 'meta':
						case 'area':
						case 'basefont':
							// These should all be singly closed
							output += ' />';
							break;
						default:
							// Assume XML style separate closure for everything else.
							output += '></' + lName + '>';
					}
				}
			}
			break;
		case 4: // cdata
		case 3: // text
			// FIXME:
			output = dijit._editor.escapeXml(node.nodeValue, true);
			break;
		case 8: //comment
			// FIXME:
			output = '<!--' + dijit._editor.escapeXml(node.nodeValue, true) + '-->';
			break;
		default:
			output = "<!-- Element not recognized - Type: " + node.nodeType + " Name: " + node.nodeName + "-->";
	}
	return output;
};

dijit._editor.getChildrenHtml = function(/* DomNode */dom){
	// summary:
	//		Returns the html content of a DomNode and children
	var out = "";
	if(!dom){ return out; }
	var nodes = dom["childNodes"] || dom;

	//IE issue.
	//If we have an actual node we can check parent relationships on for IE,
	//We should check, as IE sometimes builds invalid DOMS.  If no parent, we can't check
	//And should just process it and hope for the best.
	var checkParent = !dojo.isIE || nodes !== dom;

	var node, i = 0;
	while((node = nodes[i++])){
		//IE is broken.  DOMs are supposed to be a tree.  But in the case of malformed HTML, IE generates a graph
		//meaning one node ends up with multiple references (multiple parents).  This is totally wrong and invalid, but
		//such is what it is.  We have to keep track and check for this because otherise the source output HTML will have dups.
		//No other browser generates a graph.  Leave it to IE to break a fundamental DOM rule.  So, we check the parent if we can
		//If we can't, nothing more we can do other than walk it.
		if(!checkParent || node.parentNode == dom){
			out += dijit._editor.getNodeHtml(node);
		}
	}
	return out; // String
};

}

if(!dojo._hasResource["dijit._editor.RichText"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor.RichText"] = true;
dojo.provide("dijit._editor.RichText");







// used to restore content when user leaves this page then comes back
// but do not try doing dojo.doc.write if we are using xd loading.
// dojo.doc.write will only work if RichText.js is included in the dojo.js
// file. If it is included in dojo.js and you want to allow rich text saving
// for back/forward actions, then set dojo.config.allowXdRichTextSave = true.
if(!dojo.config["useXDomain"] || dojo.config["allowXdRichTextSave"]){
	if(dojo._postLoad){
		(function(){
			var savetextarea = dojo.doc.createElement('textarea');
			savetextarea.id = dijit._scopeName + "._editor.RichText.value";
			dojo.style(savetextarea, {
				display:'none',
				position:'absolute',
				top:"-100px",
				height:"3px",
				width:"3px"
			});
			dojo.body().appendChild(savetextarea);
		})();
	}else{
		//dojo.body() is not available before onLoad is fired
		try{
			dojo.doc.write('<textarea id="' + dijit._scopeName + '._editor.RichText.value" ' +
				'style="display:none;position:absolute;top:-100px;left:-100px;height:3px;width:3px;overflow:hidden;"></textarea>');
		}catch(e){ }
	}
}

dojo.declare("dijit._editor.RichText", [dijit._Widget, dijit._CssStateMixin], {
	constructor: function(params){
		// summary:
		//		dijit._editor.RichText is the core of dijit.Editor, which provides basic
		//		WYSIWYG editing features.
		//
		// description:
		//		dijit._editor.RichText is the core of dijit.Editor, which provides basic
		//		WYSIWYG editing features. It also encapsulates the differences
		//		of different js engines for various browsers.  Do not use this widget
		//		with an HTML &lt;TEXTAREA&gt; tag, since the browser unescapes XML escape characters,
		//		like &lt;.  This can have unexpected behavior and lead to security issues
		//		such as scripting attacks.
		//
		// tags:
		//		private

		// contentPreFilters: Function(String)[]
		//		Pre content filter function register array.
		//		these filters will be executed before the actual
		//		editing area gets the html content.
		this.contentPreFilters = [];

		// contentPostFilters: Function(String)[]
		//		post content filter function register array.
		//		These will be used on the resulting html
		//		from contentDomPostFilters. The resulting
		//		content is the final html (returned by getValue()).
		this.contentPostFilters = [];

		// contentDomPreFilters: Function(DomNode)[]
		//		Pre content dom filter function register array.
		//		These filters are applied after the result from
		//		contentPreFilters are set to the editing area.
		this.contentDomPreFilters = [];

		// contentDomPostFilters: Function(DomNode)[]
		//		Post content dom filter function register array.
		//		These filters are executed on the editing area dom.
		//		The result from these will be passed to contentPostFilters.
		this.contentDomPostFilters = [];

		// editingAreaStyleSheets: dojo._URL[]
		//		array to store all the stylesheets applied to the editing area
		this.editingAreaStyleSheets = [];

		// Make a copy of this.events before we start writing into it, otherwise we
		// will modify the prototype which leads to bad things on pages w/multiple editors
		this.events = [].concat(this.events);

		this._keyHandlers = {};

		if(params && dojo.isString(params.value)){
			this.value = params.value;
		}

		this.onLoadDeferred = new dojo.Deferred();
	},

	baseClass: "dijitEditor",

	// inheritWidth: Boolean
	//		whether to inherit the parent's width or simply use 100%
	inheritWidth: false,

	// focusOnLoad: [deprecated] Boolean
	//		Focus into this widget when the page is loaded
	focusOnLoad: false,

	// name: String?
	//		Specifies the name of a (hidden) <textarea> node on the page that's used to save
	//		the editor content on page leave.   Used to restore editor contents after navigating
	//		to a new page and then hitting the back button.
	name: "",

	// styleSheets: [const] String
	//		semicolon (";") separated list of css files for the editing area
	styleSheets: "",

	// height: String
	//		Set height to fix the editor at a specific height, with scrolling.
	//		By default, this is 300px.  If you want to have the editor always
	//		resizes to accommodate the content, use AlwaysShowToolbar plugin
	//		and set height="".  If this editor is used within a layout widget,
	//		set height="100%".
	height: "300px",

	// minHeight: String
	//		The minimum height that the editor should have.
	minHeight: "1em",

	// isClosed: [private] Boolean
	isClosed: true,

	// isLoaded: [private] Boolean
	isLoaded: false,

	// _SEPARATOR: [private] String
	//		Used to concat contents from multiple editors into a single string,
	//		so they can be saved into a single <textarea> node.  See "name" attribute.
	_SEPARATOR: "@@**%%__RICHTEXTBOUNDRY__%%**@@",

	// _NAME_CONTENT_SEP: [private] String
	//		USed to separate name from content.  Just a colon isn't safe.
	_NAME_CONTENT_SEP: "@@**%%:%%**@@",

	// onLoadDeferred: [readonly] dojo.Deferred
	//		Deferred which is fired when the editor finishes loading.
	//		Call myEditor.onLoadDeferred.then(callback) it to be informed
	//		when the rich-text area initialization is finalized.
	onLoadDeferred: null,

	// isTabIndent: Boolean
	//		Make tab key and shift-tab indent and outdent rather than navigating.
	//		Caution: sing this makes web pages inaccessible to users unable to use a mouse.
	isTabIndent: false,

	// disableSpellCheck: [const] Boolean
	//		When true, disables the browser's native spell checking, if supported.
	//		Works only in Firefox.
	disableSpellCheck: false,

	postCreate: function(){
		if("textarea" == this.domNode.tagName.toLowerCase()){
			console.warn("RichText should not be used with the TEXTAREA tag.  See dijit._editor.RichText docs.");
		}

		// Push in the builtin filters now, making them the first executed, but not over-riding anything
		// users passed in.  See: #6062
		this.contentPreFilters = [dojo.hitch(this, "_preFixUrlAttributes")].concat(this.contentPreFilters);
		if(dojo.isMoz){
			this.contentPreFilters = [this._normalizeFontStyle].concat(this.contentPreFilters);
			this.contentPostFilters = [this._removeMozBogus].concat(this.contentPostFilters);
		}
		if(dojo.isWebKit){
			// Try to clean up WebKit bogus artifacts.  The inserted classes
			// made by WebKit sometimes messes things up.
			this.contentPreFilters = [this._removeWebkitBogus].concat(this.contentPreFilters);
			this.contentPostFilters = [this._removeWebkitBogus].concat(this.contentPostFilters);
		}
		if(dojo.isIE){
			// IE generates <strong> and <em> but we want to normalize to <b> and <i>
			this.contentPostFilters = [this._normalizeFontStyle].concat(this.contentPostFilters);
		}
		this.inherited(arguments);

		dojo.publish(dijit._scopeName + "._editor.RichText::init", [this]);
		this.open();
		this.setupDefaultShortcuts();
	},

	setupDefaultShortcuts: function(){
		// summary:
		//		Add some default key handlers
		// description:
		// 		Overwrite this to setup your own handlers. The default
		// 		implementation does not use Editor commands, but directly
		//		executes the builtin commands within the underlying browser
		//		support.
		// tags:
		//		protected
		var exec = dojo.hitch(this, function(cmd, arg){
			return function(){
				return !this.execCommand(cmd,arg);
			};
		});

		var ctrlKeyHandlers = {
			b: exec("bold"),
			i: exec("italic"),
			u: exec("underline"),
			a: exec("selectall"),
			s: function(){ this.save(true); },
			m: function(){ this.isTabIndent = !this.isTabIndent; },

			"1": exec("formatblock", "h1"),
			"2": exec("formatblock", "h2"),
			"3": exec("formatblock", "h3"),
			"4": exec("formatblock", "h4"),

			"\\": exec("insertunorderedlist")
		};

		if(!dojo.isIE){
			ctrlKeyHandlers.Z = exec("redo"); //FIXME: undo?
		}

		for(var key in ctrlKeyHandlers){
			this.addKeyHandler(key, true, false, ctrlKeyHandlers[key]);
		}
	},

	// events: [private] String[]
	//		 events which should be connected to the underlying editing area
	events: ["onKeyPress", "onKeyDown", "onKeyUp"], // onClick handled specially

	// captureEvents: [deprecated] String[]
	//		 Events which should be connected to the underlying editing
	//		 area, events in this array will be addListener with
	//		 capture=true.
	// TODO: looking at the code I don't see any distinction between events and captureEvents,
	// so get rid of this for 2.0 if not sooner
	captureEvents: [],

	_editorCommandsLocalized: false,
	_localizeEditorCommands: function(){
		// summary:
		//		When IE is running in a non-English locale, the API actually changes,
		//		so that we have to say (for example) danraku instead of p (for paragraph).
		//		Handle that here.
		// tags:
		//		private
		if(dijit._editor._editorCommandsLocalized){
			// Use the already generate cache of mappings.  
			this._local2NativeFormatNames = dijit._editor._local2NativeFormatNames;
			this._native2LocalFormatNames = dijit._editor._native2LocalFormatNames;
			return;
		}
		dijit._editor._editorCommandsLocalized = true;
		dijit._editor._local2NativeFormatNames = {};
		dijit._editor._native2LocalFormatNames = {};
		this._local2NativeFormatNames = dijit._editor._local2NativeFormatNames;
		this._native2LocalFormatNames = dijit._editor._native2LocalFormatNames;
		//in IE, names for blockformat is locale dependent, so we cache the values here

		//put p after div, so if IE returns Normal, we show it as paragraph
		//We can distinguish p and div if IE returns Normal, however, in order to detect that,
		//we have to call this.document.selection.createRange().parentElement() or such, which
		//could slow things down. Leave it as it is for now
		var formats = ['div', 'p', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ol', 'ul', 'address'];
		var localhtml = "", format, i=0;
		while((format=formats[i++])){
			//append a <br> after each element to separate the elements more reliably
			if(format.charAt(1) !== 'l'){
				localhtml += "<"+format+"><span>content</span></"+format+"><br/>";
			}else{
				localhtml += "<"+format+"><li>content</li></"+format+"><br/>";
			}
		}
		// queryCommandValue returns empty if we hide editNode, so move it out of screen temporary
		// Also, IE9 does weird stuff unless we do it inside the editor iframe.
		var style = { position: "absolute", top: "0px", zIndex: 10, opacity: 0.01 };
		var div = dojo.create('div', {style: style, innerHTML: localhtml});
		dojo.body().appendChild(div);

		// IE9 has a timing issue with doing this right after setting
		// the inner HTML, so put a delay in.
		var inject = dojo.hitch(this, function(){
			var node = div.firstChild;
			while(node){
				try{
					dijit._editor.selection.selectElement(node.firstChild);
					var nativename = node.tagName.toLowerCase();
					this._local2NativeFormatNames[nativename] = document.queryCommandValue("formatblock");
					this._native2LocalFormatNames[this._local2NativeFormatNames[nativename]] = nativename;
					node = node.nextSibling.nextSibling;
					//console.log("Mapped: ", nativename, " to: ", this._local2NativeFormatNames[nativename]);
				}catch(e) { /*Sqelch the occasional IE9 error */ }
			}
			div.parentNode.removeChild(div);
			div.innerHTML = "";
		});
		setTimeout(inject, 0);
	},

	open: function(/*DomNode?*/ element){
		// summary:
		//		Transforms the node referenced in this.domNode into a rich text editing
		//		node.
		// description:
		//		Sets up the editing area asynchronously. This will result in
		//		the creation and replacement with an iframe.
		// tags:
		//		private

		if(!this.onLoadDeferred || this.onLoadDeferred.fired >= 0){
			this.onLoadDeferred = new dojo.Deferred();
		}

		if(!this.isClosed){ this.close(); }
		dojo.publish(dijit._scopeName + "._editor.RichText::open", [ this ]);

		if(arguments.length == 1 && element.nodeName){ // else unchanged
			this.domNode = element;
		}

		var dn = this.domNode;

		// "html" will hold the innerHTML of the srcNodeRef and will be used to
		// initialize the editor.
		var html;

		if(dojo.isString(this.value)){
			// Allow setting the editor content programmatically instead of
			// relying on the initial content being contained within the target
			// domNode.
			html = this.value;
			delete this.value;
			dn.innerHTML = "";
		}else if(dn.nodeName && dn.nodeName.toLowerCase() == "textarea"){
			// if we were created from a textarea, then we need to create a
			// new editing harness node.
			var ta = (this.textarea = dn);
			this.name = ta.name;
			html = ta.value;
			dn = this.domNode = dojo.doc.createElement("div");
			dn.setAttribute('widgetId', this.id);
			ta.removeAttribute('widgetId');
			dn.cssText = ta.cssText;
			dn.className += " " + ta.className;
			dojo.place(dn, ta, "before");
			var tmpFunc = dojo.hitch(this, function(){
				//some browsers refuse to submit display=none textarea, so
				//move the textarea off screen instead
				dojo.style(ta, {
					display: "block",
					position: "absolute",
					top: "-1000px"
				});

				if(dojo.isIE){ //nasty IE bug: abnormal formatting if overflow is not hidden
					var s = ta.style;
					this.__overflow = s.overflow;
					s.overflow = "hidden";
				}
			});
			if(dojo.isIE){
				setTimeout(tmpFunc, 10);
			}else{
				tmpFunc();
			}

			if(ta.form){
				var resetValue = ta.value;
				this.reset = function(){
					var current = this.getValue();
					if(current != resetValue){
						this.replaceValue(resetValue);
					}
				};
				dojo.connect(ta.form, "onsubmit", this, function(){
					// Copy value to the <textarea> so it gets submitted along with form.
					// FIXME: should we be calling close() here instead?
					dojo.attr(ta, 'disabled', this.disabled); // don't submit the value if disabled
					ta.value = this.getValue();
				});
			}
		}else{
			html = dijit._editor.getChildrenHtml(dn);
			dn.innerHTML = "";
		}

		var content = dojo.contentBox(dn);
		this._oldHeight = content.h;
		this._oldWidth = content.w;

		this.value = html;

		// If we're a list item we have to put in a blank line to force the
		// bullet to nicely align at the top of text
		if(dn.nodeName && dn.nodeName == "LI"){
			dn.innerHTML = " <br>";
		}
	
		// Construct the editor div structure.
		this.header = dn.ownerDocument.createElement("div");
		dn.appendChild(this.header);
		this.editingArea = dn.ownerDocument.createElement("div");
		dn.appendChild(this.editingArea);
		this.footer = dn.ownerDocument.createElement("div");
		dn.appendChild(this.footer);

		if(!this.name){
			this.name = this.id + "_AUTOGEN";
		}

		// User has pressed back/forward button so we lost the text in the editor, but it's saved
		// in a hidden <textarea> (which contains the data for all the editors on this page),
		// so get editor value from there
		if(this.name !== "" && (!dojo.config["useXDomain"] || dojo.config["allowXdRichTextSave"])){
			var saveTextarea = dojo.byId(dijit._scopeName + "._editor.RichText.value");
			if(saveTextarea && saveTextarea.value !== ""){
				var datas = saveTextarea.value.split(this._SEPARATOR), i=0, dat;
				while((dat=datas[i++])){
					var data = dat.split(this._NAME_CONTENT_SEP);
					if(data[0] == this.name){
						html = data[1];
						datas = datas.splice(i, 1);
						saveTextarea.value = datas.join(this._SEPARATOR);
						break;
					}
				}
			}

			if(!dijit._editor._globalSaveHandler){
				dijit._editor._globalSaveHandler = {};
				dojo.addOnUnload(function() {
					var id;
					for(id in dijit._editor._globalSaveHandler){
						var f = dijit._editor._globalSaveHandler[id];
						if(dojo.isFunction(f)){
							f();
						}
					}
				});
			}
			dijit._editor._globalSaveHandler[this.id] = dojo.hitch(this, "_saveContent");
		}

		this.isClosed = false;

		var ifr = (this.editorObject = this.iframe = dojo.doc.createElement('iframe'));
		ifr.id = this.id+"_iframe";
		this._iframeSrc = this._getIframeDocTxt();
		ifr.style.border = "none";
		ifr.style.width = "100%";
		if(this._layoutMode){
			// iframe should be 100% height, thus getting it's height from surrounding
			// <div> (which has the correct height set by Editor)
			ifr.style.height = "100%";
		}else{
			if(dojo.isIE >= 7){
				if(this.height){
					ifr.style.height = this.height;
				}
				if(this.minHeight){
					ifr.style.minHeight = this.minHeight;
				}
			}else{
				ifr.style.height = this.height ? this.height : this.minHeight;
			}
		}
		ifr.frameBorder = 0;
		ifr._loadFunc = dojo.hitch( this, function(win){
			this.window = win;
			this.document = this.window.document;

			if(dojo.isIE){
				this._localizeEditorCommands();
			}
			
			// Do final setup and set initial contents of editor
			this.onLoad(html);
		});

		// Set the iframe's initial (blank) content.
		var s = 'javascript:parent.' + dijit._scopeName + '.byId("'+this.id+'")._iframeSrc';
		ifr.setAttribute('src', s);
		this.editingArea.appendChild(ifr);

		if(dojo.isSafari <= 4){
			var src = ifr.getAttribute("src");
			if(!src || src.indexOf("javascript") == -1){
				// Safari 4 and earlier sometimes act oddly
				// So we have to set it again.
				setTimeout(function(){ifr.setAttribute('src', s);},0);
			}
		}

		// TODO: this is a guess at the default line-height, kinda works
		if(dn.nodeName == "LI"){
			dn.lastChild.style.marginTop = "-1.2em";
		}

		dojo.addClass(this.domNode, this.baseClass);
	},

	//static cache variables shared among all instance of this class
	_local2NativeFormatNames: {},
	_native2LocalFormatNames: {},

	_getIframeDocTxt: function(){
		// summary:
		//		Generates the boilerplate text of the document inside the iframe (ie, <html><head>...</head><body/></html>).
		//		Editor content (if not blank) should be added afterwards.
		// tags:
		//		private
		var _cs = dojo.getComputedStyle(this.domNode);

		// The contents inside of <body>.  The real contents are set later via a call to setValue().
		var html = "";
		var setBodyId = true;
		if(dojo.isIE || dojo.isWebKit || (!this.height && !dojo.isMoz)){
			// In auto-expand mode, need a wrapper div for AlwaysShowToolbar plugin to correctly
			// expand/contract the editor as the content changes.
			html = "<div id='dijitEditorBody'></div>";
			setBodyId = false;
		}else if(dojo.isMoz){
			// workaround bug where can't select then delete text (until user types something
			// into the editor)... and/or issue where typing doesn't erase selected text
			this._cursorToStart = true;
			html = "&nbsp;";
		}

		var font = [ _cs.fontWeight, _cs.fontSize, _cs.fontFamily ].join(" ");

		// line height is tricky - applying a units value will mess things up.
		// if we can't get a non-units value, bail out.
		var lineHeight = _cs.lineHeight;
		if(lineHeight.indexOf("px") >= 0){
			lineHeight = parseFloat(lineHeight)/parseFloat(_cs.fontSize);
			// console.debug(lineHeight);
		}else if(lineHeight.indexOf("em")>=0){
			lineHeight = parseFloat(lineHeight);
		}else{
			// If we can't get a non-units value, just default
			// it to the CSS spec default of 'normal'.  Seems to
			// work better, esp on IE, than '1.0'
			lineHeight = "normal";
		}
		var userStyle = "";
		var self = this;
		this.style.replace(/(^|;)\s*(line-|font-?)[^;]+/ig, function(match){
			match = match.replace(/^;/ig,"") + ';';
			var s = match.split(":")[0];
			if(s){
				s = dojo.trim(s);
				s = s.toLowerCase();
				var i;
				var sC = "";
				for(i = 0; i < s.length; i++){
					var c = s.charAt(i);
					switch(c){
						case "-":
							i++;
							c = s.charAt(i).toUpperCase();
						default:
							sC += c;
					}
				}
				dojo.style(self.domNode, sC, "");
			}
			userStyle += match + ';';
		});


		// need to find any associated label element and update iframe document title
		var label=dojo.query('label[for="'+this.id+'"]');

		return [
			this.isLeftToRight() ? "<html>\n<head>\n" : "<html dir='rtl'>\n<head>\n",
			(dojo.isMoz && label.length ? "<title>" + label[0].innerHTML + "</title>\n" : ""),
			"<meta http-equiv='Content-Type' content='text/html'>\n",
			"<style>\n",
			"\tbody,html {\n",
			"\t\tbackground:transparent;\n",
			"\t\tpadding: 1px 0 0 0;\n",
			"\t\tmargin: -1px 0 0 0;\n", // remove extraneous vertical scrollbar on safari and firefox

			// Set the html/body sizing.  Webkit always needs this, other browsers
			// only set it when height is defined (not auto-expanding), otherwise
			// scrollers do not appear.
			((dojo.isWebKit)?"\t\twidth: 100%;\n":""),
			((dojo.isWebKit)?"\t\theight: 100%;\n":""),
			"\t}\n",
			
			// TODO: left positioning will cause contents to disappear out of view
			//	   if it gets too wide for the visible area
			"\tbody{\n",
			"\t\ttop:0px;\n",
			"\t\tleft:0px;\n",
			"\t\tright:0px;\n",
			"\t\tfont:", font, ";\n",
				((this.height||dojo.isOpera) ? "" : "\t\tposition: fixed;\n"),
			// FIXME: IE 6 won't understand min-height?
			"\t\tmin-height:", this.minHeight, ";\n",
			"\t\tline-height:", lineHeight,";\n",
			"\t}\n",
			"\tp{ margin: 1em 0; }\n",
			
			// Determine how scrollers should be applied.  In autoexpand mode (height = "") no scrollers on y at all.
			// But in fixed height mode we want both x/y scrollers.  Also, if it's using wrapping div and in auto-expand
			// (Mainly IE) we need to kill the y scroller on body and html.
			(!setBodyId && !this.height ? "\tbody,html {overflow-y: hidden;}\n" : ""),
			"\t#dijitEditorBody{overflow-x: auto; overflow-y:" + (this.height ? "auto;" : "hidden;") + " outline: 0px;}\n",
			"\tli > ul:-moz-first-node, li > ol:-moz-first-node{ padding-top: 1.2em; }\n",
			// Can't set min-height in IE9, it puts layout on li, which puts move/resize handles.
			(!dojo.isIE ? "\tli{ min-height:1.2em; }\n" : ""), 
			"</style>\n",
			this._applyEditingAreaStyleSheets(),"\n",
			"</head>\n<body ",
			(setBodyId?"id='dijitEditorBody' ":""),
			"onload='frameElement._loadFunc(window,document)' style='"+userStyle+"'>", html, "</body>\n</html>"
		].join(""); // String
	},

	_applyEditingAreaStyleSheets: function(){
		// summary:
		//		apply the specified css files in styleSheets
		// tags:
		//		private
		var files = [];
		if(this.styleSheets){
			files = this.styleSheets.split(';');
			this.styleSheets = '';
		}

		//empty this.editingAreaStyleSheets here, as it will be filled in addStyleSheet
		files = files.concat(this.editingAreaStyleSheets);
		this.editingAreaStyleSheets = [];

		var text='', i=0, url;
		while((url=files[i++])){
			var abstring = (new dojo._Url(dojo.global.location, url)).toString();
			this.editingAreaStyleSheets.push(abstring);
			text += '<link rel="stylesheet" type="text/css" href="'+abstring+'"/>';
		}
		return text;
	},

	addStyleSheet: function(/*dojo._Url*/ uri){
		// summary:
		//		add an external stylesheet for the editing area
		// uri:
		//		A dojo.uri.Uri pointing to the url of the external css file
		var url=uri.toString();

		//if uri is relative, then convert it to absolute so that it can be resolved correctly in iframe
		if(url.charAt(0) == '.' || (url.charAt(0) != '/' && !uri.host)){
			url = (new dojo._Url(dojo.global.location, url)).toString();
		}

		if(dojo.indexOf(this.editingAreaStyleSheets, url) > -1){
//			console.debug("dijit._editor.RichText.addStyleSheet: Style sheet "+url+" is already applied");
			return;
		}

		this.editingAreaStyleSheets.push(url);
		this.onLoadDeferred.addCallback(dojo.hitch(this, function(){
			if(this.document.createStyleSheet){ //IE
				this.document.createStyleSheet(url);
			}else{ //other browser
				var head = this.document.getElementsByTagName("head")[0];
				var stylesheet = this.document.createElement("link");
				stylesheet.rel="stylesheet";
				stylesheet.type="text/css";
				stylesheet.href=url;
				head.appendChild(stylesheet);
			}
		}));
	},

	removeStyleSheet: function(/*dojo._Url*/ uri){
		// summary:
		//		remove an external stylesheet for the editing area
		var url=uri.toString();
		//if uri is relative, then convert it to absolute so that it can be resolved correctly in iframe
		if(url.charAt(0) == '.' || (url.charAt(0) != '/' && !uri.host)){
			url = (new dojo._Url(dojo.global.location, url)).toString();
		}
		var index = dojo.indexOf(this.editingAreaStyleSheets, url);
		if(index == -1){
//			console.debug("dijit._editor.RichText.removeStyleSheet: Style sheet "+url+" has not been applied");
			return;
		}
		delete this.editingAreaStyleSheets[index];
		dojo.withGlobal(this.window,'query', dojo, ['link:[href="'+url+'"]']).orphan();
	},

	// disabled: Boolean
	//		The editor is disabled; the text cannot be changed.
	disabled: false,

	_mozSettingProps: {'styleWithCSS':false},
	_setDisabledAttr: function(/*Boolean*/ value){
		value = !!value;
		this._set("disabled", value);
		if(!this.isLoaded){ return; } // this method requires init to be complete
		if(dojo.isIE || dojo.isWebKit || dojo.isOpera){
			var preventIEfocus = dojo.isIE && (this.isLoaded || !this.focusOnLoad);
			if(preventIEfocus){ this.editNode.unselectable = "on"; }
			this.editNode.contentEditable = !value;
			if(preventIEfocus){
				var _this = this;
				setTimeout(function(){ _this.editNode.unselectable = "off"; }, 0);
			}
		}else{ //moz
			try{
				this.document.designMode=(value?'off':'on');
			}catch(e){ return; } // ! _disabledOK
			if(!value && this._mozSettingProps){
				var ps = this._mozSettingProps;
				for(var n in ps){
					if(ps.hasOwnProperty(n)){
						try{
							this.document.execCommand(n,false,ps[n]);
						}catch(e2){}
					}
				}
			}
//			this.document.execCommand('contentReadOnly', false, value);
//				if(value){
//					this.blur(); //to remove the blinking caret
//				}
		}
		this._disabledOK = true;
	},

/* Event handlers
 *****************/

	onLoad: function(/*String*/ html){
		// summary:
		//		Handler after the iframe finishes loading.
		// html: String
		//		Editor contents should be set to this value
		// tags:
		//		protected

		// TODO: rename this to _onLoad, make empty public onLoad() method, deprecate/make protected onLoadDeferred handler?

		if(!this.window.__registeredWindow){
			this.window.__registeredWindow = true;
			this._iframeRegHandle = dijit.registerIframe(this.iframe);
		}
		if(!dojo.isIE && !dojo.isWebKit && (this.height || dojo.isMoz)){
			this.editNode=this.document.body;
		}else{
			// there's a wrapper div around the content, see _getIframeDocTxt().
			this.editNode=this.document.body.firstChild;
			var _this = this;
			if(dojo.isIE){ // #4996 IE wants to focus the BODY tag
				this.tabStop = dojo.create('div', { tabIndex: -1 }, this.editingArea);
				this.iframe.onfocus = function(){ _this.editNode.setActive(); };
			}
		}
		this.focusNode = this.editNode; // for InlineEditBox


		var events = this.events.concat(this.captureEvents);
		var ap = this.iframe ? this.document : this.editNode;
		dojo.forEach(events, function(item){
			this.connect(ap, item.toLowerCase(), item);
		}, this);

		this.connect(ap, "onmouseup", "onClick"); // mouseup in the margin does not generate an onclick event

		if(dojo.isIE){ // IE contentEditable
			this.connect(this.document, "onmousedown", "_onIEMouseDown"); // #4996 fix focus

			// give the node Layout on IE
			// TODO: this may no longer be needed, since we've reverted IE to using an iframe,
			// not contentEditable.   Removing it would also probably remove the need for creating
			// the extra <div> in _getIframeDocTxt()
			this.editNode.style.zoom = 1.0;
		}else{
			this.connect(this.document, "onmousedown", function(){
				// Clear the moveToStart focus, as mouse
				// down will set cursor point.  Required to properly
				// work with selection/position driven plugins and clicks in
				// the window. refs: #10678
				delete this._cursorToStart;
			});
		}
		
		if(dojo.isWebKit){
			//WebKit sometimes doesn't fire right on selections, so the toolbar
			//doesn't update right.  Therefore, help it out a bit with an additional
			//listener.  A mouse up will typically indicate a display change, so fire this
			//and get the toolbar to adapt.  Reference: #9532
			this._webkitListener = this.connect(this.document, "onmouseup", "onDisplayChanged");
			this.connect(this.document, "onmousedown", function(e){
				var t = e.target;
				if(t && (t === this.document.body || t === this.document)){
					// Since WebKit uses the inner DIV, we need to check and set position.
					// See: #12024 as to why the change was made.
					setTimeout(dojo.hitch(this, "placeCursorAtEnd"), 0);
				}
			});
		}
		
		if(dojo.isIE){
			// Try to make sure 'hidden' elements aren't visible in edit mode (like browsers other than IE
			// do).  See #9103
			try{
				this.document.execCommand('RespectVisibilityInDesign', true, null);
			}catch(e){/* squelch */}
		}

		this.isLoaded = true;

		this.set('disabled', this.disabled); // initialize content to editable (or not)

		// Note that setValue() call will only work after isLoaded is set to true (above)

		// Set up a function to allow delaying the setValue until a callback is fired
		// This ensures extensions like dijit.Editor have a way to hold the value set
		// until plugins load (and do things like register filters).
		var setContent = dojo.hitch(this, function(){
			this.setValue(html);
			if(this.onLoadDeferred){
				this.onLoadDeferred.callback(true);
			}
			this.onDisplayChanged();
			if(this.focusOnLoad){
				// after the document loads, then set focus after updateInterval expires so that
				// onNormalizedDisplayChanged has run to avoid input caret issues
				dojo.addOnLoad(dojo.hitch(this, function(){ setTimeout(dojo.hitch(this, "focus"), this.updateInterval); }));
			}
			// Save off the initial content now
			this.value = this.getValue(true);
		});
		if(this.setValueDeferred){
			this.setValueDeferred.addCallback(setContent);
		}else{
			setContent();
		}
	},

	onKeyDown: function(/* Event */ e){
		// summary:
		//		Handler for onkeydown event
		// tags:
		//		protected

		// we need this event at the moment to get the events from control keys
		// such as the backspace. It might be possible to add this to Dojo, so that
		// keyPress events can be emulated by the keyDown and keyUp detection.

		if(e.keyCode === dojo.keys.TAB && this.isTabIndent ){
			dojo.stopEvent(e); //prevent tab from moving focus out of editor

			// FIXME: this is a poor-man's indent/outdent. It would be
			// better if it added 4 "&nbsp;" chars in an undoable way.
			// Unfortunately pasteHTML does not prove to be undoable
			if(this.queryCommandEnabled((e.shiftKey ? "outdent" : "indent"))){
				this.execCommand((e.shiftKey ? "outdent" : "indent"));
			}
		}
		if(dojo.isIE){
			if(e.keyCode == dojo.keys.TAB && !this.isTabIndent){
				if(e.shiftKey && !e.ctrlKey && !e.altKey){
					// focus the BODY so the browser will tab away from it instead
					this.iframe.focus();
				}else if(!e.shiftKey && !e.ctrlKey && !e.altKey){
					// focus the BODY so the browser will tab away from it instead
					this.tabStop.focus();
				}
			}else if(e.keyCode === dojo.keys.BACKSPACE && this.document.selection.type === "Control"){
				// IE has a bug where if a non-text object is selected in the editor,
				// hitting backspace would act as if the browser's back button was
				// clicked instead of deleting the object. see #1069
				dojo.stopEvent(e);
				this.execCommand("delete");
			}else if((65 <= e.keyCode && e.keyCode <= 90) ||
				(e.keyCode>=37 && e.keyCode<=40) // FIXME: get this from connect() instead!
			){ //arrow keys
				e.charCode = e.keyCode;
				this.onKeyPress(e);
			}
		}
		return true;
	},

	onKeyUp: function(e){
		// summary:
		//		Handler for onkeyup event
		// tags:
		//      callback
		return;
	},

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated, use set('disabled', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated('dijit.Editor::setDisabled is deprecated','use dijit.Editor::attr("disabled",boolean) instead', 2.0);
		this.set('disabled',disabled);
	},
	_setValueAttr: function(/*String*/ value){
		// summary:
		//      Registers that attr("value", foo) should call setValue(foo)
		this.setValue(value);
	},
	_setDisableSpellCheckAttr: function(/*Boolean*/ disabled){
		if(this.document){
			dojo.attr(this.document.body, "spellcheck", !disabled);
		}else{
			// try again after the editor is finished loading
			this.onLoadDeferred.addCallback(dojo.hitch(this, function(){
				dojo.attr(this.document.body, "spellcheck", !disabled);
			}));
		}
		this._set("disableSpellCheck", disabled);
	},

	onKeyPress: function(e){
		// summary:
		//		Handle the various key events
		// tags:
		//		protected

		var c = (e.keyChar && e.keyChar.toLowerCase()) || e.keyCode,
			handlers = this._keyHandlers[c],
			args = arguments;

		if(handlers && !e.altKey){
			dojo.some(handlers, function(h){
				// treat meta- same as ctrl-, for benefit of mac users
				if(!(h.shift ^ e.shiftKey) && !(h.ctrl ^ (e.ctrlKey||e.metaKey))){
					if(!h.handler.apply(this, args)){
						e.preventDefault();
					}
					return true;
				}
			}, this);
		}

		// function call after the character has been inserted
		if(!this._onKeyHitch){
			this._onKeyHitch = dojo.hitch(this, "onKeyPressed");
		}
		setTimeout(this._onKeyHitch, 1);
		return true;
	},

	addKeyHandler: function(/*String*/ key, /*Boolean*/ ctrl, /*Boolean*/ shift, /*Function*/ handler){
		// summary:
		//		Add a handler for a keyboard shortcut
		// description:
		//		The key argument should be in lowercase if it is a letter character
		// tags:
		//		protected
		if(!dojo.isArray(this._keyHandlers[key])){
			this._keyHandlers[key] = [];
		}
		//TODO: would be nice to make this a hash instead of an array for quick lookups
		this._keyHandlers[key].push({
			shift: shift || false,
			ctrl: ctrl || false,
			handler: handler
		});
	},

	onKeyPressed: function(){
		// summary:
		//		Handler for after the user has pressed a key, and the display has been updated.
		//		(Runs on a timer so that it runs after the display is updated)
		// tags:
		//		private
		this.onDisplayChanged(/*e*/); // can't pass in e
	},

	onClick: function(/*Event*/ e){
		// summary:
		//		Handler for when the user clicks.
		// tags:
		//		private

		// console.info('onClick',this._tryDesignModeOn);
		this.onDisplayChanged(e);
	},

	_onIEMouseDown: function(/*Event*/ e){
		// summary:
		//		IE only to prevent 2 clicks to focus
		// tags:
		//		protected

		if(!this._focused && !this.disabled){
			this.focus();
		}
	},

	_onBlur: function(e){
		// summary:
		//		Called from focus manager when focus has moved away from this editor
		// tags:
		//		protected

		// console.info('_onBlur')

		this.inherited(arguments);

		var newValue = this.getValue(true);
		if(newValue != this.value){
			this.onChange(newValue);
		}
		this._set("value", newValue);
	},

	_onFocus: function(/*Event*/ e){
		// summary:
		//		Called from focus manager when focus has moved into this editor
		// tags:
		//		protected

		// console.info('_onFocus')
		if(!this.disabled){
			if(!this._disabledOK){
				this.set('disabled', false);
			}
			this.inherited(arguments);
		}
	},

	// TODO: remove in 2.0
	blur: function(){
		// summary:
		//		Remove focus from this instance.
		// tags:
		//		deprecated
		if(!dojo.isIE && this.window.document.documentElement && this.window.document.documentElement.focus){
			this.window.document.documentElement.focus();
		}else if(dojo.doc.body.focus){
			dojo.doc.body.focus();
		}
	},

	focus: function(){
		// summary:
		//		Move focus to this editor
		if(!this.isLoaded){
			this.focusOnLoad = true;
			return;
		}
		if(this._cursorToStart){
			delete this._cursorToStart;
			if(this.editNode.childNodes){
				this.placeCursorAtStart(); // this calls focus() so return
				return;
			}
		}
		if(!dojo.isIE){
			dijit.focus(this.iframe);
		}else if(this.editNode && this.editNode.focus){
			// editNode may be hidden in display:none div, lets just punt in this case
			//this.editNode.focus(); -> causes IE to scroll always (strict and quirks mode) to the top the Iframe
			// if we fire the event manually and let the browser handle the focusing, the latest
			// cursor position is focused like in FF
			this.iframe.fireEvent('onfocus', document.createEventObject()); // createEventObject only in IE
		//	}else{
		// TODO: should we throw here?
		// console.debug("Have no idea how to focus into the editor!");
		}
	},

	// _lastUpdate: 0,
	updateInterval: 200,
	_updateTimer: null,
	onDisplayChanged: function(/*Event*/ e){
		// summary:
		//		This event will be fired everytime the display context
		//		changes and the result needs to be reflected in the UI.
		// description:
		//		If you don't want to have update too often,
		//		onNormalizedDisplayChanged should be used instead
		// tags:
		//		private

		// var _t=new Date();
		if(this._updateTimer){
			clearTimeout(this._updateTimer);
		}
		if(!this._updateHandler){
			this._updateHandler = dojo.hitch(this,"onNormalizedDisplayChanged");
		}
		this._updateTimer = setTimeout(this._updateHandler, this.updateInterval);
		
		// Technically this should trigger a call to watch("value", ...) registered handlers,
		// but getValue() is too slow to call on every keystroke so we don't.
	},
	onNormalizedDisplayChanged: function(){
		// summary:
		//		This event is fired every updateInterval ms or more
		// description:
		//		If something needs to happen immediately after a
		//		user change, please use onDisplayChanged instead.
		// tags:
		//		private
		delete this._updateTimer;
	},
	onChange: function(newContent){
		// summary:
		//		This is fired if and only if the editor loses focus and
		//		the content is changed.
	},
	_normalizeCommand: function(/*String*/ cmd, /*Anything?*/argument){
		// summary:
		//		Used as the advice function by dojo.connect to map our
		//		normalized set of commands to those supported by the target
		//		browser.
		// tags:
		//		private

		var command = cmd.toLowerCase();
		if(command == "formatblock"){
			if(dojo.isSafari && argument === undefined){ command = "heading"; }
		}else if(command == "hilitecolor" && !dojo.isMoz){
			command = "backcolor";
		}

		return command;
	},

	_qcaCache: {},
	queryCommandAvailable: function(/*String*/ command){
		// summary:
		//		Tests whether a command is supported by the host. Clients
		//		SHOULD check whether a command is supported before attempting
		//		to use it, behaviour for unsupported commands is undefined.
		// command:
		//		The command to test for
		// tags:
		//		private

		// memoizing version. See _queryCommandAvailable for computing version
		var ca = this._qcaCache[command];
		if(ca !== undefined){ return ca; }
		return (this._qcaCache[command] = this._queryCommandAvailable(command));
	},

	_queryCommandAvailable: function(/*String*/ command){
		// summary:
		//		See queryCommandAvailable().
		// tags:
		//		private

		var ie = 1;
		var mozilla = 1 << 1;
		var webkit = 1 << 2;
		var opera = 1 << 3;

		function isSupportedBy(browsers){
			return {
				ie: Boolean(browsers & ie),
				mozilla: Boolean(browsers & mozilla),
				webkit: Boolean(browsers & webkit),
				opera: Boolean(browsers & opera)
			};
		}

		var supportedBy = null;

		switch(command.toLowerCase()){
			case "bold": case "italic": case "underline":
			case "subscript": case "superscript":
			case "fontname": case "fontsize":
			case "forecolor": case "hilitecolor":
			case "justifycenter": case "justifyfull": case "justifyleft":
			case "justifyright": case "delete": case "selectall": case "toggledir":
				supportedBy = isSupportedBy(mozilla | ie | webkit | opera);
				break;

			case "createlink": case "unlink": case "removeformat":
			case "inserthorizontalrule": case "insertimage":
			case "insertorderedlist": case "insertunorderedlist":
			case "indent": case "outdent": case "formatblock":
			case "inserthtml": case "undo": case "redo": case "strikethrough": case "tabindent":
				supportedBy = isSupportedBy(mozilla | ie | opera | webkit);
				break;

			case "blockdirltr": case "blockdirrtl":
			case "dirltr": case "dirrtl":
			case "inlinedirltr": case "inlinedirrtl":
				supportedBy = isSupportedBy(ie);
				break;
			case "cut": case "copy": case "paste":
				supportedBy = isSupportedBy( ie | mozilla | webkit);
				break;

			case "inserttable":
				supportedBy = isSupportedBy(mozilla | ie);
				break;

			case "insertcell": case "insertcol": case "insertrow":
			case "deletecells": case "deletecols": case "deleterows":
			case "mergecells": case "splitcell":
				supportedBy = isSupportedBy(ie | mozilla);
				break;

			default: return false;
		}

		return (dojo.isIE && supportedBy.ie) ||
			(dojo.isMoz && supportedBy.mozilla) ||
			(dojo.isWebKit && supportedBy.webkit) ||
			(dojo.isOpera && supportedBy.opera);	// Boolean return true if the command is supported, false otherwise
	},

	execCommand: function(/*String*/ command, argument){
		// summary:
		//		Executes a command in the Rich Text area
		// command:
		//		The command to execute
		// argument:
		//		An optional argument to the command
		// tags:
		//		protected
		var returnValue;

		//focus() is required for IE to work
		//In addition, focus() makes sure after the execution of
		//the command, the editor receives the focus as expected
		this.focus();

		command = this._normalizeCommand(command, argument);

		if(argument !== undefined){
			if(command == "heading"){
				throw new Error("unimplemented");
			}else if((command == "formatblock") && dojo.isIE){
				argument = '<'+argument+'>';
			}
		}

		//Check to see if we have any over-rides for commands, they will be functions on this
		//widget of the form _commandImpl.  If we don't, fall through to the basic native
		//exec command of the browser.
		var implFunc = "_" + command + "Impl";
		if(this[implFunc]){
			returnValue = this[implFunc](argument);
		}else{
			argument = arguments.length > 1 ? argument : null;
			if(argument || command!="createlink"){
				returnValue = this.document.execCommand(command, false, argument);
			}
		}

		this.onDisplayChanged();
		return returnValue;
	},

	queryCommandEnabled: function(/*String*/ command){
		// summary:
		//		Check whether a command is enabled or not.
		// tags:
		//		protected
		if(this.disabled || !this._disabledOK){ return false; }
		command = this._normalizeCommand(command);
		if(dojo.isMoz || dojo.isWebKit){
			if(command == "unlink"){ // mozilla returns true always
				// console.debug(this._sCall("hasAncestorElement", ['a']));
				return this._sCall("hasAncestorElement", ["a"]);
			}else if(command == "inserttable"){
				return true;
			}
		}
		//see #4109
		if(dojo.isWebKit){
			if(command == "cut" || command == "copy") {
				// WebKit deems clipboard activity as a security threat and natively would return false
				var sel = this.window.getSelection();
				if(sel){ sel = sel.toString(); }
				return !!sel;
			}else if(command == "paste"){
				return true;
			}
		}

		var elem = dojo.isIE ? this.document.selection.createRange() : this.document;
		try{
			return elem.queryCommandEnabled(command);
		}catch(e){
			//Squelch, occurs if editor is hidden on FF 3 (and maybe others.)
			return false;
		}

	},

	queryCommandState: function(command){
		// summary:
		//		Check the state of a given command and returns true or false.
		// tags:
		//		protected

		if(this.disabled || !this._disabledOK){ return false; }
		command = this._normalizeCommand(command);
		try{
			return this.document.queryCommandState(command);
		}catch(e){
			//Squelch, occurs if editor is hidden on FF 3 (and maybe others.)
			return false;
		}
	},

	queryCommandValue: function(command){
		// summary:
		//		Check the value of a given command. This matters most for
		//		custom selections and complex values like font value setting.
		// tags:
		//		protected

		if(this.disabled || !this._disabledOK){ return false; }
		var r;
		command = this._normalizeCommand(command);
		if(dojo.isIE && command == "formatblock"){
			r = this._native2LocalFormatNames[this.document.queryCommandValue(command)];
		}else if(dojo.isMoz && command === "hilitecolor"){
			var oldValue;
			try{
				oldValue = this.document.queryCommandValue("styleWithCSS");
			}catch(e){
				oldValue = false;
			}
			this.document.execCommand("styleWithCSS", false, true);
			r = this.document.queryCommandValue(command);
			this.document.execCommand("styleWithCSS", false, oldValue);
		}else{
			r = this.document.queryCommandValue(command);
		}
		return r;
	},

	// Misc.

	_sCall: function(name, args){
		// summary:
		//		Run the named method of dijit._editor.selection over the
		//		current editor instance's window, with the passed args.
		// tags:
		//		private
		return dojo.withGlobal(this.window, name, dijit._editor.selection, args);
	},

	// FIXME: this is a TON of code duplication. Why?

	placeCursorAtStart: function(){
		// summary:
		//		Place the cursor at the start of the editing area.
		// tags:
		//		private

		this.focus();

		//see comments in placeCursorAtEnd
		var isvalid=false;
		if(dojo.isMoz){
			// TODO:  Is this branch even necessary?
			var first=this.editNode.firstChild;
			while(first){
				if(first.nodeType == 3){
					if(first.nodeValue.replace(/^\s+|\s+$/g, "").length>0){
						isvalid=true;
						this._sCall("selectElement", [ first ]);
						break;
					}
				}else if(first.nodeType == 1){
					isvalid=true;
					var tg = first.tagName ? first.tagName.toLowerCase() : "";
					// Collapse before childless tags.
					if(/br|input|img|base|meta|area|basefont|hr|link/.test(tg)){
						this._sCall("selectElement", [ first ]);
					}else{
						// Collapse inside tags with children.
						this._sCall("selectElementChildren", [ first ]);
					}
					break;
				}
				first = first.nextSibling;
			}
		}else{
			isvalid=true;
			this._sCall("selectElementChildren", [ this.editNode ]);
		}
		if(isvalid){
			this._sCall("collapse", [ true ]);
		}
	},

	placeCursorAtEnd: function(){
		// summary:
		//		Place the cursor at the end of the editing area.
		// tags:
		//		private

		this.focus();

		//In mozilla, if last child is not a text node, we have to use
		// selectElementChildren on this.editNode.lastChild otherwise the
		// cursor would be placed at the end of the closing tag of
		//this.editNode.lastChild
		var isvalid=false;
		if(dojo.isMoz){
			var last=this.editNode.lastChild;
			while(last){
				if(last.nodeType == 3){
					if(last.nodeValue.replace(/^\s+|\s+$/g, "").length>0){
						isvalid=true;
						this._sCall("selectElement", [ last ]);
						break;
					}
				}else if(last.nodeType == 1){
					isvalid=true;
					if(last.lastChild){
						this._sCall("selectElement", [ last.lastChild ]);
					}else{
						this._sCall("selectElement", [ last ]);
					}
					break;
				}
				last = last.previousSibling;
			}
		}else{
			isvalid=true;
			this._sCall("selectElementChildren", [ this.editNode ]);
		}
		if(isvalid){
			this._sCall("collapse", [ false ]);
		}
	},

	getValue: function(/*Boolean?*/ nonDestructive){
		// summary:
		//		Return the current content of the editing area (post filters
		//		are applied).  Users should call get('value') instead.
		//	nonDestructive:
		//		defaults to false. Should the post-filtering be run over a copy
		//		of the live DOM? Most users should pass "true" here unless they
		//		*really* know that none of the installed filters are going to
		//		mess up the editing session.
		// tags:
		//		private
		if(this.textarea){
			if(this.isClosed || !this.isLoaded){
				return this.textarea.value;
			}
		}

		return this._postFilterContent(null, nonDestructive);
	},
	_getValueAttr: function(){
		// summary:
		//		Hook to make attr("value") work
		return this.getValue(true);
	},

	setValue: function(/*String*/ html){
		// summary:
		//		This function sets the content. No undo history is preserved.
		//		Users should use set('value', ...) instead.
		// tags:
		//		deprecated

		// TODO: remove this and getValue() for 2.0, and move code to _setValueAttr()

		if(!this.isLoaded){
			// try again after the editor is finished loading
			this.onLoadDeferred.addCallback(dojo.hitch(this, function(){
				this.setValue(html);
			}));
			return;
		}
		this._cursorToStart = true;
		if(this.textarea && (this.isClosed || !this.isLoaded)){
			this.textarea.value=html;
		}else{
			html = this._preFilterContent(html);
			var node = this.isClosed ? this.domNode : this.editNode;
			if(html && dojo.isMoz && html.toLowerCase() == "<p></p>"){
				html = "<p>&nbsp;</p>";
			}

			// Use &nbsp; to avoid webkit problems where editor is disabled until the user clicks it
			if(!html && dojo.isWebKit){
				html = "&nbsp;";
			}
			node.innerHTML = html;
			this._preDomFilterContent(node);
		}

		this.onDisplayChanged();
		this._set("value", this.getValue(true));
	},

	replaceValue: function(/*String*/ html){
		// summary:
		//		This function set the content while trying to maintain the undo stack
		//		(now only works fine with Moz, this is identical to setValue in all
		//		other browsers)
		// tags:
		//		protected

		if(this.isClosed){
			this.setValue(html);
		}else if(this.window && this.window.getSelection && !dojo.isMoz){ // Safari
			// look ma! it's a totally f'd browser!
			this.setValue(html);
		}else if(this.window && this.window.getSelection){ // Moz
			html = this._preFilterContent(html);
			this.execCommand("selectall");
			if(!html){
				this._cursorToStart = true;
				html = "&nbsp;";
			}
			this.execCommand("inserthtml", html);
			this._preDomFilterContent(this.editNode);
		}else if(this.document && this.document.selection){//IE
			//In IE, when the first element is not a text node, say
			//an <a> tag, when replacing the content of the editing
			//area, the <a> tag will be around all the content
			//so for now, use setValue for IE too
			this.setValue(html);
		}

		this._set("value", this.getValue(true));
	},

	_preFilterContent: function(/*String*/ html){
		// summary:
		//		Filter the input before setting the content of the editing
		//		area. DOM pre-filtering may happen after this
		//		string-based filtering takes place but as of 1.2, this is not
		//		guaranteed for operations such as the inserthtml command.
		// tags:
		//		private

		var ec = html;
		dojo.forEach(this.contentPreFilters, function(ef){ if(ef){ ec = ef(ec); } });
		return ec;
	},
	_preDomFilterContent: function(/*DomNode*/ dom){
		// summary:
		//		filter the input's live DOM. All filter operations should be
		//		considered to be "live" and operating on the DOM that the user
		//		will be interacting with in their editing session.
		// tags:
		//		private
		dom = dom || this.editNode;
		dojo.forEach(this.contentDomPreFilters, function(ef){
			if(ef && dojo.isFunction(ef)){
				ef(dom);
			}
		}, this);
	},

	_postFilterContent: function(
		/*DomNode|DomNode[]|String?*/ dom,
		/*Boolean?*/ nonDestructive){
		// summary:
		//		filter the output after getting the content of the editing area
		//
		// description:
		//		post-filtering allows plug-ins and users to specify any number
		//		of transforms over the editor's content, enabling many common
		//		use-cases such as transforming absolute to relative URLs (and
		//		vice-versa), ensuring conformance with a particular DTD, etc.
		//		The filters are registered in the contentDomPostFilters and
		//		contentPostFilters arrays. Each item in the
		//		contentDomPostFilters array is a function which takes a DOM
		//		Node or array of nodes as its only argument and returns the
		//		same. It is then passed down the chain for further filtering.
		//		The contentPostFilters array behaves the same way, except each
		//		member operates on strings. Together, the DOM and string-based
		//		filtering allow the full range of post-processing that should
		//		be necessaray to enable even the most agressive of post-editing
		//		conversions to take place.
		//
		//		If nonDestructive is set to "true", the nodes are cloned before
		//		filtering proceeds to avoid potentially destructive transforms
		//		to the content which may still needed to be edited further.
		//		Once DOM filtering has taken place, the serialized version of
		//		the DOM which is passed is run through each of the
		//		contentPostFilters functions.
		//
		//	dom:
		//		a node, set of nodes, which to filter using each of the current
		//		members of the contentDomPostFilters and contentPostFilters arrays.
		//
		//	nonDestructive:
		//		defaults to "false". If true, ensures that filtering happens on
		//		a clone of the passed-in content and not the actual node
		//		itself.
		//
		// tags:
		//		private

		var ec;
		if(!dojo.isString(dom)){
			dom = dom || this.editNode;
			if(this.contentDomPostFilters.length){
				if(nonDestructive){
					dom = dojo.clone(dom);
				}
				dojo.forEach(this.contentDomPostFilters, function(ef){
					dom = ef(dom);
				});
			}
			ec = dijit._editor.getChildrenHtml(dom);
		}else{
			ec = dom;
		}

		if(!dojo.trim(ec.replace(/^\xA0\xA0*/, '').replace(/\xA0\xA0*$/, '')).length){
			ec = "";
		}

		//	if(dojo.isIE){
		//		//removing appended <P>&nbsp;</P> for IE
		//		ec = ec.replace(/(?:<p>&nbsp;</p>[\n\r]*)+$/i,"");
		//	}
		dojo.forEach(this.contentPostFilters, function(ef){
			ec = ef(ec);
		});

		return ec;
	},

	_saveContent: function(/*Event*/ e){
		// summary:
		//		Saves the content in an onunload event if the editor has not been closed
		// tags:
		//		private

		var saveTextarea = dojo.byId(dijit._scopeName + "._editor.RichText.value");
		if(saveTextarea.value){
			saveTextarea.value += this._SEPARATOR;
		}
		saveTextarea.value += this.name + this._NAME_CONTENT_SEP + this.getValue(true);
	},


	escapeXml: function(/*String*/ str, /*Boolean*/ noSingleQuotes){
		// summary:
		//		Adds escape sequences for special characters in XML.
		//		Optionally skips escapes for single quotes
		// tags:
		//		private

		str = str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
		if(!noSingleQuotes){
			str = str.replace(/'/gm, "&#39;");
		}
		return str; // string
	},

	getNodeHtml: function(/* DomNode */ node){
		// summary:
		//		Deprecated.   Use dijit._editor._getNodeHtml() instead.
		// tags:
		//		deprecated
		dojo.deprecated('dijit.Editor::getNodeHtml is deprecated','use dijit._editor.getNodeHtml instead', 2);
		return dijit._editor.getNodeHtml(node); // String
	},

	getNodeChildrenHtml: function(/* DomNode */ dom){
		// summary:
		//		Deprecated.   Use dijit._editor.getChildrenHtml() instead.
		// tags:
		//		deprecated
		dojo.deprecated('dijit.Editor::getNodeChildrenHtml is deprecated','use dijit._editor.getChildrenHtml instead', 2);
		return dijit._editor.getChildrenHtml(dom);
	},

	close: function(/*Boolean?*/ save){
		// summary:
		//		Kills the editor and optionally writes back the modified contents to the
		//		element from which it originated.
		// save:
		//		Whether or not to save the changes. If false, the changes are discarded.
		// tags:
		//		private

		if(this.isClosed){ return; }

		if(!arguments.length){ save = true; }
		if(save){
			this._set("value", this.getValue(true));
		}

		// line height is squashed for iframes
		// FIXME: why was this here? if (this.iframe){ this.domNode.style.lineHeight = null; }

		if(this.interval){ clearInterval(this.interval); }

		if(this._webkitListener){
			//Cleaup of WebKit fix: #9532
			this.disconnect(this._webkitListener);
			delete this._webkitListener;
		}

		// Guard against memory leaks on IE (see #9268)
		if(dojo.isIE){
			 this.iframe.onfocus = null;
		}
		this.iframe._loadFunc = null;

		if(this._iframeRegHandle){
			dijit.unregisterIframe(this._iframeRegHandle);
			delete this._iframeRegHandle;
		}

		if(this.textarea){
			var s = this.textarea.style;
			s.position = "";
			s.left = s.top = "";
			if(dojo.isIE){
				s.overflow = this.__overflow;
				this.__overflow = null;
			}
			this.textarea.value = this.value;
			dojo.destroy(this.domNode);
			this.domNode = this.textarea;
		}else{
			// Note that this destroys the iframe
			this.domNode.innerHTML = this.value;
		}
		delete this.iframe;

		dojo.removeClass(this.domNode, this.baseClass);
		this.isClosed = true;
		this.isLoaded = false;

		delete this.editNode;
		delete this.focusNode;

		if(this.window && this.window._frameElement){
			this.window._frameElement = null;
		}

		this.window = null;
		this.document = null;
		this.editingArea = null;
		this.editorObject = null;
	},

	destroy: function(){
		if(!this.isClosed){ this.close(false); }
		this.inherited(arguments);
		if(dijit._editor._globalSaveHandler){
			delete dijit._editor._globalSaveHandler[this.id];
		}
	},

	_removeMozBogus: function(/* String */ html){
		// summary:
		//		Post filter to remove unwanted HTML attributes generated by mozilla
		// tags:
		//		private
		return html.replace(/\stype="_moz"/gi, '').replace(/\s_moz_dirty=""/gi, '').replace(/_moz_resizing="(true|false)"/gi,''); // String
	},
	_removeWebkitBogus: function(/* String */ html){
		// summary:
		//		Post filter to remove unwanted HTML attributes generated by webkit
		// tags:
		//		private
		html = html.replace(/\sclass="webkit-block-placeholder"/gi, '');
		html = html.replace(/\sclass="apple-style-span"/gi, '');
		// For some reason copy/paste sometime adds extra meta tags for charset on
		// webkit (chrome) on mac.They need to be removed.  See: #12007"
		html = html.replace(/<meta charset=\"utf-8\" \/>/gi, '');
		return html; // String
	},
	_normalizeFontStyle: function(/* String */ html){
		// summary:
		//		Convert 'strong' and 'em' to 'b' and 'i'.
		// description:
		//		Moz can not handle strong/em tags correctly, so to help
		//		mozilla and also to normalize output, convert them to 'b' and 'i'.
		//
		//		Note the IE generates 'strong' and 'em' rather than 'b' and 'i'
		// tags:
		//		private
		return html.replace(/<(\/)?strong([ \>])/gi, '<$1b$2')
			.replace(/<(\/)?em([ \>])/gi, '<$1i$2' ); // String
	},

	_preFixUrlAttributes: function(/* String */ html){
		// summary:
		//		Pre-filter to do fixing to href attributes on <a> and <img> tags
		// tags:
		//		private
		return html.replace(/(?:(<a(?=\s).*?\shref=)("|')(.*?)\2)|(?:(<a\s.*?href=)([^"'][^ >]+))/gi,
				'$1$4$2$3$5$2 _djrealurl=$2$3$5$2')
			.replace(/(?:(<img(?=\s).*?\ssrc=)("|')(.*?)\2)|(?:(<img\s.*?src=)([^"'][^ >]+))/gi,
				'$1$4$2$3$5$2 _djrealurl=$2$3$5$2'); // String
	},

	/*****************************************************************************
		The following functions implement HTML manipulation commands for various
		browser/contentEditable implementations.  The goal of them is to enforce
		standard behaviors of them.
	******************************************************************************/

	_inserthorizontalruleImpl: function(argument){
		// summary:
		//		This function implements the insertion of HTML 'HR' tags.
		//		into a point on the page.  IE doesn't to it right, so
		//		we have to use an alternate form
		// argument:
		//		arguments to the exec command, if any.
		// tags:
		//		protected
		if(dojo.isIE){
			return this._inserthtmlImpl("<hr>");
		}
		return this.document.execCommand("inserthorizontalrule", false, argument);
	},

	_unlinkImpl: function(argument){
		// summary:
		//		This function implements the unlink of an 'a' tag.
		// argument:
		//		arguments to the exec command, if any.
		// tags:
		//		protected
		if((this.queryCommandEnabled("unlink")) && (dojo.isMoz || dojo.isWebKit)){
			var a = this._sCall("getAncestorElement", [ "a" ]);
			this._sCall("selectElement", [ a ]);
			return this.document.execCommand("unlink", false, null);
		}
		return this.document.execCommand("unlink", false, argument);
	},

	_hilitecolorImpl: function(argument){
		// summary:
		//		This function implements the hilitecolor command
		// argument:
		//		arguments to the exec command, if any.
		// tags:
		//		protected
		var returnValue;
		if(dojo.isMoz){
			// mozilla doesn't support hilitecolor properly when useCSS is
			// set to false (bugzilla #279330)
			this.document.execCommand("styleWithCSS", false, true);
			returnValue = this.document.execCommand("hilitecolor", false, argument);
			this.document.execCommand("styleWithCSS", false, false);
		}else{
			returnValue = this.document.execCommand("hilitecolor", false, argument);
		}
		return returnValue;
	},

	_backcolorImpl: function(argument){
		// summary:
		//		This function implements the backcolor command
		// argument:
		//		arguments to the exec command, if any.
		// tags:
		//		protected
		if(dojo.isIE){
			// Tested under IE 6 XP2, no problem here, comment out
			// IE weirdly collapses ranges when we exec these commands, so prevent it
			//	var tr = this.document.selection.createRange();
			argument = argument ? argument : null;
		}
		return this.document.execCommand("backcolor", false, argument);
	},

	_forecolorImpl: function(argument){
		// summary:
		//		This function implements the forecolor command
		// argument:
		//		arguments to the exec command, if any.
		// tags:
		//		protected
		if(dojo.isIE){
			// Tested under IE 6 XP2, no problem here, comment out
			// IE weirdly collapses ranges when we exec these commands, so prevent it
			//	var tr = this.document.selection.createRange();
			argument = argument? argument : null;
		}
		return this.document.execCommand("forecolor", false, argument);
	},

	_inserthtmlImpl: function(argument){
		// summary:
		//		This function implements the insertion of HTML content into
		//		a point on the page.
		// argument:
		//		The content to insert, if any.
		// tags:
		//		protected
		argument = this._preFilterContent(argument);
		var rv = true;
		var usrAgent = window.navigator.userAgent;
		if(dojo.isIE){
			var insertRange = this.document.selection.createRange();
			if(this.document.selection.type.toUpperCase() == 'CONTROL'){
				var n=insertRange.item(0);
				while(insertRange.length){
					insertRange.remove(insertRange.item(0));
				}
				n.outerHTML=argument;
			}else{
				insertRange.pasteHTML(argument);
			}
			insertRange.select();
			//insertRange.collapse(true);
		}
		
		else if(usrAgent.indexOf("Trident/") != -1)
		{
			 var sel, range, documentfrag;
			 
			 sel = this.document.getSelection();
			 range = sel.getRangeAt(0);
			 documentfrag = range.createContextualFragment(argument);
			 range.insertNode(documentfrag);
			 sel.removeAllRanges();
			 sel.addRange(range);
			 sel.collapseToEnd();
		}
		
		else if(dojo.isMoz && !argument.length){
			//mozilla can not inserthtml an empty html to delete current selection
			//so we delete the selection instead in this case
			this._sCall("remove"); // FIXME
		}else{
			rv = this.document.execCommand("inserthtml", false, argument);
		}
		return rv;
	},

	_boldImpl: function(argument){
		// summary:
		//		This function implements an over-ride of the bold command.
		// argument:
		//		Not used, operates by selection.
		// tags:
		//		protected
		if(dojo.isIE){
			this._adaptIESelection()
		}
		return this.document.execCommand("bold", false, argument);
	},
	
	_italicImpl: function(argument){
		// summary:
		//		This function implements an over-ride of the italic command.
		// argument:
		//		Not used, operates by selection.
		// tags:
		//		protected
		if(dojo.isIE){
			this._adaptIESelection()
		}
		return this.document.execCommand("italic", false, argument);
	},

	_underlineImpl: function(argument){
		// summary:
		//		This function implements an over-ride of the underline command.
		// argument:
		//		Not used, operates by selection.
		// tags:
		//		protected
		if(dojo.isIE){
			this._adaptIESelection()
		}
		return this.document.execCommand("underline", false, argument);
	},
	
	_strikethroughImpl: function(argument){
		// summary:
		//		This function implements an over-ride of the strikethrough command.
		// argument:
		//		Not used, operates by selection.
		// tags:
		//		protected
		if(dojo.isIE){
			this._adaptIESelection()
		}
		return this.document.execCommand("strikethrough", false, argument);
	},

	getHeaderHeight: function(){
		// summary:
		//		A function for obtaining the height of the header node
		return this._getNodeChildrenHeight(this.header); // Number
	},

	getFooterHeight: function(){
		// summary:
		//		A function for obtaining the height of the footer node
		return this._getNodeChildrenHeight(this.footer); // Number
	},

	_getNodeChildrenHeight: function(node){
		// summary:
		//		An internal function for computing the cumulative height of all child nodes of 'node'
		// node:
		//		The node to process the children of;
		var h = 0;
		if(node && node.childNodes){
			// IE didn't compute it right when position was obtained on the node directly is some cases,
			// so we have to walk over all the children manually.
			var i;
			for(i = 0; i < node.childNodes.length; i++){
				var size = dojo.position(node.childNodes[i]);
				h += size.h;
			}
		}
		return h; // Number
	},
	
	_isNodeEmpty: function(node, startOffset){
		// summary:
		//		Function to test if a node is devoid of real content.
		// node:
		//		The node to check.
		// tags:
		//		private.
		if(node.nodeType == 1/*element*/){
			if(node.childNodes.length > 0){
				return this._isNodeEmpty(node.childNodes[0], startOffset);
	}
			return true;
		}else if(node.nodeType == 3/*text*/){
			return (node.nodeValue.substring(startOffset) == "");
		}
		return false;
	},
	
	_removeStartingRangeFromRange: function(node, range){
		// summary:
		//		Function to adjust selection range by removing the current
		//		start node.
		// node:
		//		The node to remove from the starting range.
		// range:
		//		The range to adapt.
		// tags:
		//		private
		if(node.nextSibling){
			range.setStart(node.nextSibling,0);
		}else{
			var parent = node.parentNode;
			while(parent && parent.nextSibling == null){
				//move up the tree until we find a parent that has another node, that node will be the next node
				parent = parent.parentNode;
			}
			if(parent){
				range.setStart(parent.nextSibling,0);
			}
		}
		return range;
	},
	
	_adaptIESelection: function(){
		// summary:
		//		Function to adapt the IE range by removing leading 'newlines'
		//		Needed to fix issue with bold/italics/underline not working if
		//		range included leading 'newlines'.
		//		In IE, if a user starts a selection at the very end of a line,
		//		then the native browser commands will fail to execute correctly.
		//		To work around the issue,  we can remove all empty nodes from
		//		the start of the range selection.
		var selection = dijit.range.getSelection(this.window);
		if(selection && selection.rangeCount && !selection.isCollapsed){
			var range = selection.getRangeAt(0);
			var firstNode = range.startContainer;
			var startOffset = range.startOffset;

			while(firstNode.nodeType == 3/*text*/ && startOffset >= firstNode.length && firstNode.nextSibling){
				//traverse the text nodes until we get to the one that is actually highlighted
				startOffset = startOffset - firstNode.length;
				firstNode = firstNode.nextSibling;
			}

			//Remove the starting ranges until the range does not start with an empty node.
			var lastNode=null;
			while(this._isNodeEmpty(firstNode, startOffset) && firstNode != lastNode){
				lastNode =firstNode; //this will break the loop in case we can't find the next sibling
				range = this._removeStartingRangeFromRange(firstNode, range); //move the start container to the next node in the range
				firstNode = range.startContainer;
				startOffset = 0; //start at the beginning of the new starting range
			}
			selection.removeAllRanges();// this will work as long as users cannot select multiple ranges. I have not been able to do that in the editor.
			selection.addRange(range);
		}
	}
});

}

if(!dojo._hasResource["dijit.ToolbarSeparator"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.ToolbarSeparator"] = true;
dojo.provide("dijit.ToolbarSeparator");




dojo.declare("dijit.ToolbarSeparator",
		[ dijit._Widget, dijit._Templated ],
		{
		// summary:
		//		A spacer between two `dijit.Toolbar` items
		templateString: '<div class="dijitToolbarSeparator dijitInline" role="presentation"></div>',
		buildRendering: function(){
			this.inherited(arguments);
			dojo.setSelectable(this.domNode, false);
		},
		isFocusable: function(){
			// summary:
			//		This widget isn't focusable, so pass along that fact.
			// tags:
			//		protected
			return false;
		}

	});

}

if(!dojo._hasResource["dijit.Toolbar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Toolbar"] = true;
dojo.provide("dijit.Toolbar");






// Note: require of ToolbarSeparator is for back-compat, remove for 2.0

dojo.declare("dijit.Toolbar",
	[dijit._Widget, dijit._Templated, dijit._KeyNavContainer],
	{
	// summary:
	//		A Toolbar widget, used to hold things like `dijit.Editor` buttons

	templateString:
		'<div class="dijit" role="toolbar" tabIndex="${tabIndex}" dojoAttachPoint="containerNode">' +
		//	'<table style="table-layout: fixed" class="dijitReset dijitToolbarTable">' + // factor out style
		//		'<tr class="dijitReset" dojoAttachPoint="containerNode"></tr>'+
		//	'</table>' +
		'</div>',

	baseClass: "dijitToolbar",

	postCreate: function(){
		this.inherited(arguments);

		this.connectKeyNavHandlers(
			this.isLeftToRight() ? [dojo.keys.LEFT_ARROW] : [dojo.keys.RIGHT_ARROW],
			this.isLeftToRight() ? [dojo.keys.RIGHT_ARROW] : [dojo.keys.LEFT_ARROW]
		);
	},

	startup: function(){
		if(this._started){ return; }

		this.startupKeyNavChildren();

		this.inherited(arguments);
	}
}
);

}

if(!dojo._hasResource["dijit._editor._Plugin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor._Plugin"] = true;
dojo.provide("dijit._editor._Plugin");




dojo.declare("dijit._editor._Plugin", null, {
	// summary
	//		Base class for a "plugin" to the editor, which is usually
	//		a single button on the Toolbar and some associated code

	constructor: function(/*Object?*/args, /*DomNode?*/node){
		this.params = args || {};
		dojo.mixin(this, this.params);
		this._connects=[];
		this._attrPairNames = {};
	},

	// editor: [const] dijit.Editor
	//		Points to the parent editor
	editor: null,

	// iconClassPrefix: [const] String
	//		The CSS class name for the button node is formed from `iconClassPrefix` and `command`
	iconClassPrefix: "dijitEditorIcon",

	// button: dijit._Widget?
	//		Pointer to `dijit.form.Button` or other widget (ex: `dijit.form.FilteringSelect`)
	//		that is added to the toolbar to control this plugin.
	//		If not specified, will be created on initialization according to `buttonClass`
	button: null,

	// command: String
	//		String like "insertUnorderedList", "outdent", "justifyCenter", etc. that represents an editor command.
	//		Passed to editor.execCommand() if `useDefaultCommand` is true.
	command: "",

	// useDefaultCommand: Boolean
	//		If true, this plugin executes by calling Editor.execCommand() with the argument specified in `command`.
	useDefaultCommand: true,

	// buttonClass: Widget Class
	//		Class of widget (ex: dijit.form.Button or dijit.form.FilteringSelect)
	//		that is added to the toolbar to control this plugin.
	//		This is used to instantiate the button, unless `button` itself is specified directly.
	buttonClass: dijit.form.Button,

	// disabled: Boolean
	//		Flag to indicate if this plugin has been disabled and should do nothing
	//		helps control button state, among other things.  Set via the setter api.
	disabled: false,

	getLabel: function(/*String*/key){
		// summary:
		//		Returns the label to use for the button
		// tags:
		//		private
		return this.editor.commands[key];		// String
	},

	_initButton: function(){
		// summary:
		//		Initialize the button or other widget that will control this plugin.
		//		This code only works for plugins controlling built-in commands in the editor.
		// tags:
		//		protected extension
		if(this.command.length){
			var label = this.getLabel(this.command),
				editor = this.editor,
				className = this.iconClassPrefix+" "+this.iconClassPrefix + this.command.charAt(0).toUpperCase() + this.command.substr(1);
			if(!this.button){
				var props = dojo.mixin({
					label: label,
					dir: editor.dir,
					lang: editor.lang,
					showLabel: false,
					iconClass: className,
					dropDown: this.dropDown,
					tabIndex: "-1"
				}, this.params || {});
				this.button = new this.buttonClass(props);
			}
		}
		if(this.get("disabled") && this.button){
			this.button.set("disabled", this.get("disabled"));
		}
	},

	destroy: function(){
		// summary:
		//		Destroy this plugin

		dojo.forEach(this._connects, dojo.disconnect);
		if(this.dropDown){
			this.dropDown.destroyRecursive();
		}
	},

	connect: function(o, f, tf){
		// summary:
		//		Make a dojo.connect() that is automatically disconnected when this plugin is destroyed.
		//		Similar to `dijit._Widget.connect`.
		// tags:
		//		protected
		this._connects.push(dojo.connect(o, f, this, tf));
	},

	updateState: function(){
		// summary:
		//		Change state of the plugin to respond to events in the editor.
		// description:
		//		This is called on meaningful events in the editor, such as change of selection
		//		or caret position (but not simple typing of alphanumeric keys).   It gives the
		//		plugin a chance to update the CSS of its button.
		//
		//		For example, the "bold" plugin will highlight/unhighlight the bold button depending on whether the
		//		characters next to the caret are bold or not.
		//
		//		Only makes sense when `useDefaultCommand` is true, as it calls Editor.queryCommandEnabled(`command`).
		var e = this.editor,
			c = this.command,
			checked, enabled;
		if(!e || !e.isLoaded || !c.length){ return; }
		var disabled = this.get("disabled");
		if(this.button){
			try{
				enabled = !disabled && e.queryCommandEnabled(c);
				if(this.enabled !== enabled){
					this.enabled = enabled;
					this.button.set('disabled', !enabled);
				}
				if(typeof this.button.checked == 'boolean'){
					checked = e.queryCommandState(c);
					if(this.checked !== checked){
						this.checked = checked;
						this.button.set('checked', e.queryCommandState(c));
					}
				}
			}catch(e){
				console.log(e); // FIXME: we shouldn't have debug statements in our code.  Log as an error?
			}
		}
	},

	setEditor: function(/*dijit.Editor*/ editor){
		// summary:
		//		Tell the plugin which Editor it is associated with.

		// TODO: refactor code to just pass editor to constructor.

		// FIXME: detach from previous editor!!
		this.editor = editor;

		// FIXME: prevent creating this if we don't need to (i.e., editor can't handle our command)
		this._initButton();

		// Processing for buttons that execute by calling editor.execCommand()
		if(this.button && this.useDefaultCommand){
			if(this.editor.queryCommandAvailable(this.command)){
				this.connect(this.button, "onClick",
					dojo.hitch(this.editor, "execCommand", this.command, this.commandArg)
				);
			}else{
				// hide button because editor doesn't support command (due to browser limitations)
				this.button.domNode.style.display = "none";
			}
		}

		this.connect(this.editor, "onNormalizedDisplayChanged", "updateState");
	},

	setToolbar: function(/*dijit.Toolbar*/ toolbar){
		// summary:
		//		Tell the plugin to add it's controller widget (often a button)
		//		to the toolbar.  Does nothing if there is no controller widget.

		// TODO: refactor code to just pass toolbar to constructor.

		if(this.button){
			toolbar.addChild(this.button);
		}
		// console.debug("adding", this.button, "to:", toolbar);
	},
	
	set: function(/* attribute */ name, /* anything */ value){
		// summary:
		//		Set a property on a plugin
		//	name:
		//		The property to set.
		//	value:
		//		The value to set in the property.
		// description:
		//		Sets named properties on a plugin which may potentially be handled by a
		// 		setter in the plugin.
		// 		For example, if the plugin has a properties "foo"
		//		and "bar" and a method named "_setFooAttr", calling:
		//	|	plugin.set("foo", "Howdy!");
		//		would be equivalent to writing:
		//	|	plugin._setFooAttr("Howdy!");
		//		and:
		//	|	plugin.set("bar", 3);
		//		would be equivalent to writing:
		//	|	plugin.bar = 3;
		//
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|	plugin.set({
		//	|		foo: "Howdy",
		//	|		bar: 3
		//	|	})
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
		if(typeof name === "object"){
			for(var x in name){
				this.set(x, name[x]);
	}
			return this;
		}
		var names = this._getAttrNames(name);
		if(this[names.s]){
			// use the explicit setter
			var result = this[names.s].apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			this._set(name, value);
		}
		return result || this;
	},

	get: function(name){
		// summary:
		//		Get a property from a plugin.
		//	name:
		//		The property to get.
		// description:
		//		Get a named property from a plugin. The property may
		//		potentially be retrieved via a getter method. If no getter is defined, this
		// 		just retrieves the object's property.
		// 		For example, if the plugin has a properties "foo"
		//		and "bar" and a method named "_getFooAttr", calling:
		//	|	plugin.get("foo");
		//		would be equivalent to writing:
		//	|	plugin._getFooAttr();
		//		and:
		//	|	plugin.get("bar");
		//		would be equivalent to writing:
		//	|	plugin.bar;
		var names = this._getAttrNames(name);
		return this[names.g] ? this[names.g]() : this[name];
	},

	_setDisabledAttr: function(disabled){
		// summary:
		//		Function to set the plugin state and call updateState to make sure the
		//		button is updated appropriately.
		this.disabled = disabled;
		this.updateState();
	},
	
	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		var uc = name.charAt(0).toUpperCase() + name.substr(1);
		return (apn[name] = {
			s: "_set"+uc+"Attr",
			g: "_get"+uc+"Attr"
		});
	},
	
	_set: function(/*String*/ name, /*anything*/ value){
		// summary:
		//		Helper function to set new value for specified attribute
		var oldValue = this[name];
		this[name] = value;
	}
});

}

if(!dojo._hasResource["dojox.editor.plugins.ToolbarLineBreak"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.editor.plugins.ToolbarLineBreak"] = true;
dojo.provide("dojox.editor.plugins.ToolbarLineBreak");









dojo.declare("dojox.editor.plugins.ToolbarLineBreak",
	[ dijit._Widget, dijit._Templated ],
	{
	// summary:
	//		A 'line break' between two `dijit.Toolbar` items so that very
	//		long toolbars can be organized a bit.
	templateString: "<span class='dijit dijitReset'><br></span>",
	postCreate: function(){ dojo.setSelectable(this.domNode, false); },
	isFocusable: function(){
		// summary:
		//		This widget isn't focusable, so pass along that fact.
		// tags:
		//		protected
		return false;
	}
});


// Register this plugin.
dojo.subscribe(dijit._scopeName + ".Editor.getPlugin",null,function(o){
	if(o.plugin){ return; }
	var name = o.args.name.toLowerCase();
	if(name ===  "||" || name === "toolbarlinebreak"){
		o.plugin = new dijit._editor._Plugin({
			button: new dojox.editor.plugins.ToolbarLineBreak(),
			setEditor: function(editor){
				this.editor = editor;
			}
		});
	}
});

}

if(!dojo._hasResource["dijit._editor.plugins.FontChoice"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor.plugins.FontChoice"] = true;
dojo.provide("dijit._editor.plugins.FontChoice");









dojo.declare("dijit._editor.plugins._FontDropDown",
	[dijit._Widget, dijit._Templated],{
	// summary:
	//		Base class for widgets that contains a label (like "Font:")
	//		and a FilteringSelect drop down to pick a value.
	//		Used as Toolbar entry.

	// label: [public] String
	//		The label to apply to this particular FontDropDown.
	label: "",

	// widgetsInTemplate: [public] boolean
	//		Over-ride denoting the template has widgets to parse.
	widgetsInTemplate: true,

	// plainText: [public] boolean
	//		Flag to indicate that the returned label should be plain text
	//		instead of an example.
	plainText: false,

	// templateString: [public] String
	//		The template used to construct the labeled dropdown.
	templateString:
		"<span style='white-space: nowrap' class='dijit dijitReset dijitInline'>" +
			"<label class='dijitLeft dijitInline' for='${selectId}'>${label}</label>" +
			"<input dojoType='dijit.form.FilteringSelect' required='false' labelType='html' labelAttr='label' searchAttr='name' " +
					"tabIndex='-1' id='${selectId}' dojoAttachPoint='select' value=''/>" +
		"</span>",

	postMixInProperties: function(){
		// summary:
		//		Over-ride to set specific properties.
		this.inherited(arguments);

		this.strings = dojo.i18n.getLocalization("dijit._editor", "FontChoice");

		// Set some substitution variables used in the template
		this.label = this.strings[this.command];
		this.id = dijit.getUniqueId(this.declaredClass.replace(/\./g,"_"));
		this.selectId = this.id + "_select";

		this.inherited(arguments);
	},

	postCreate: function(){
		// summary:
		//		Over-ride for the default postCreate action
		//		This establishes the filtering selects and the like.

		// Initialize the list of items in the drop down by creating data store with items like:
		// {value: 1, name: "xx-small", label: "<font size=1>xx-small</font-size>" }
		var	items = dojo.map(this.values, function(value){
				var name = this.strings[value] || value;
				return {
					label: this.getLabel(value, name),
					name: name,
					value: value
				};
			}, this);

		this.select.store = new dojo.data.ItemFileReadStore({
			data: {
				identifier: "value",
				items: items
			}
		});

		this.select.set("value", "", false);
		this.disabled = this.select.get("disabled");
	},

	_setValueAttr: function(value, priorityChange){
		// summary:
		//		Over-ride for the default action of setting the
		//		widget value, maps the input to known values
		// value: Object|String
		//		The value to set in the select.
		// priorityChange:
		//		Optional parameter used to tell the select whether or not to fire
		//		onChange event.

		//if the value is not a permitted value, just set empty string to prevent showing the warning icon
		priorityChange = priorityChange !== false?true:false;
		this.select.set('value', dojo.indexOf(this.values,value) < 0 ? "" : value, priorityChange);
		if(!priorityChange){
			// Clear the last state in case of updateState calls.  Ref: #10466
			this.select._lastValueReported=null;
		}
	},

	_getValueAttr: function(){
		// summary:
		//		Allow retreiving the value from the composite select on
		//		call to button.get("value");
		return this.select.get('value');
	},

	focus: function(){
		// summary:
		//		Over-ride for focus control of this widget.  Delegates focus down to the
		//		filtering select.
		this.select.focus();
	},

	_setDisabledAttr: function(value){
		// summary:
		//		Over-ride for the button's 'disabled' attribute so that it can be
		//		disabled programmatically.

		// Save off ths disabled state so the get retrieves it correctly
		//without needing to have a function proxy it.
		this.disabled = value;
		this.select.set("disabled", value);
	}
});


dojo.declare("dijit._editor.plugins._FontNameDropDown", dijit._editor.plugins._FontDropDown, {
	// summary:
	//		Dropdown to select a font; goes in editor toolbar.

	// generic: Boolean
	//		Use generic (web standard) font names
	generic: false,

	// command: [public] String
	//		The editor 'command' implemented by this plugin.
	command: "fontName",

	postMixInProperties: function(){
		// summary:
		//		Over-ride for the default posr mixin control
		if(!this.values){
			this.values = this.generic ?
				["serif", "sans-serif", "monospace", "cursive", "fantasy"] : // CSS font-family generics
					["Arial", "Times New Roman", "Comic Sans MS", "Courier New"];
		}
		this.inherited(arguments);
	},

	getLabel: function(value, name){
		// summary:
		//		Function used to generate the labels of the format dropdown
		//		will return a formatted, or plain label based on the value
		//		of the plainText option.
		// value: String
		//		The 'insert value' associated with a name
		// name: String
		//		The text name of the value
		if(this.plainText){
			return name;
		}else{
			return "<div style='font-family: "+value+"'>" + name + "</div>";
		}
	},

	_setValueAttr: function(value, priorityChange){
		// summary:
		//		Over-ride for the default action of setting the
		//		widget value, maps the input to known values

		priorityChange = priorityChange !== false?true:false;
		if(this.generic){
			var map = {
				"Arial": "sans-serif",
				"Helvetica": "sans-serif",
				"Myriad": "sans-serif",
				"Times": "serif",
				"Times New Roman": "serif",
				"Comic Sans MS": "cursive",
				"Apple Chancery": "cursive",
				"Courier": "monospace",
				"Courier New": "monospace",
				"Papyrus": "fantasy"
//					,"????": "fantasy" TODO: IE doesn't map fantasy font-family?
			};
			value = map[value] || value;
		}
		// In chrome the intial value is coming as 'Arial, Helvetica, sans-serif' - change it to Arial
		if(value.indexOf("Arial") !== -1) {
			value = "Arial";
		}
		this.inherited(arguments, [value, priorityChange]);
	}
});

dojo.declare("dijit._editor.plugins._FontSizeDropDown", dijit._editor.plugins._FontDropDown, {
	// summary:
	//		Dropdown to select a font size; goes in editor toolbar.

	// command: [public] String
	//		The editor 'command' implemented by this plugin.
	command: "fontSize",

	// values: [public] Number[]
	//		The HTML font size values supported by this plugin
	values: [1,2,3,4,5,6,7], // sizes according to the old HTML FONT SIZE

	getLabel: function(value, name){
		// summary:
		//		Function used to generate the labels of the format dropdown
		//		will return a formatted, or plain label based on the value
		//		of the plainText option.
		//		We're stuck using the deprecated FONT tag to correspond
		//		with the size measurements used by the editor
		// value: String
		//		The 'insert value' associated with a name
		// name: String
		//		The text name of the value
		if(this.plainText){
			return name;
		}else{
			return "<font size=" + value + "'>" + name + "</font>";
		}
	},

	_setValueAttr: function(value, priorityChange){
		// summary:
		//		Over-ride for the default action of setting the
		//		widget value, maps the input to known values
		priorityChange = priorityChange !== false?true:false;
		if(value.indexOf && value.indexOf("px") != -1){
			var pixels = parseInt(value, 10);
			value = {10:1, 13:2, 16:3, 18:4, 24:5, 32:6, 48:7}[pixels] || value;
		}

		this.inherited(arguments, [value, priorityChange]);
	}
});


dojo.declare("dijit._editor.plugins._FormatBlockDropDown", dijit._editor.plugins._FontDropDown, {
	// summary:
	//		Dropdown to select a format (like paragraph or heading); goes in editor toolbar.

	// command: [public] String
	//		The editor 'command' implemented by this plugin.
	command: "formatBlock",

	// values: [public] Array
	//		The HTML format tags supported by this plugin
	values: ["noFormat", "p", "h1", "h2", "h3", "pre"],

	postCreate: function(){
		// Init and set the default value to no formatting.  Update state will adjust it
		// as needed.
		this.inherited(arguments);
		this.set("value", "noFormat", false);
	},

	getLabel: function(value, name){
		// summary:
		//		Function used to generate the labels of the format dropdown
		//		will return a formatted, or plain label based on the value
		//		of the plainText option.
		// value: String
		//		The 'insert value' associated with a name
		// name: String
		//		The text name of the value
		if(this.plainText || value == "noFormat"){
			return name;
		}else{
			return "<" + value + ">" + name + "</" + value + ">";
		}
	},

	_execCommand: function(editor, command, choice){
		// summary:
		//		Over-ride for default exec-command label.
		// 		Allows us to treat 'none' as special.
		if(choice === "noFormat"){
			var start;
			var end;
			var sel = dijit.range.getSelection(editor.window);
			if(sel && sel.rangeCount > 0){
				var range = sel.getRangeAt(0);
				var node, tag;
				if(range){
					start = range.startContainer;
					end = range.endContainer;

					// find containing nodes of start/end.
					while(start && start !== editor.editNode &&
						  start !== editor.document.body &&
						  start.nodeType !== 1){
						start = start.parentNode;
					}

					while(end && end !== editor.editNode &&
						  end !== editor.document.body &&
						  end.nodeType !== 1){
						end = end.parentNode;
					}

					var processChildren = dojo.hitch(this, function(node, array){
						if(node.childNodes && node.childNodes.length){
							var i;
							for(i = 0; i < node.childNodes.length; i++){
								var c = node.childNodes[i];
								if(c.nodeType == 1){
									if(dojo.withGlobal(editor.window, "inSelection", dijit._editor.selection, [c])){
										var tag = c.tagName? c.tagName.toLowerCase(): "";
										if(dojo.indexOf(this.values, tag) !== -1){
											array.push(c);
										}
										processChildren(c,array);
									}
								}
							}
						}
					});

					var unformatNodes = dojo.hitch(this, function(nodes){
						// summary:
						//		Internal function to clear format nodes.
						// nodes:
						//		The array of nodes to strip formatting from.
						if(nodes && nodes.length){
							editor.beginEditing();
							while(nodes.length){
								this._removeFormat(editor, nodes.pop());
							}
							editor.endEditing();
						}
					});

					var clearNodes = [];
					if(start == end){
						//Contained within the same block, may be collapsed, but who cares, see if we
						// have a block element to remove.
						var block;
						node = start;
						while(node && node !== editor.editNode && node !== editor.document.body){
							if(node.nodeType == 1){
								tag = node.tagName? node.tagName.toLowerCase(): "";
								if(dojo.indexOf(this.values, tag) !== -1){
									block = node;
									break;
								}
							}
							node = node.parentNode;
						}

						//Also look for all child nodes in the selection that may need to be
						//cleared of formatting
						processChildren(start, clearNodes);
						if(block) { clearNodes = [block].concat(clearNodes); }
						unformatNodes(clearNodes);
					}else{
						// Probably a multi select, so we have to process it.  Whee.
						node = start;
						while(dojo.withGlobal(editor.window, "inSelection", dijit._editor.selection, [node])){
							if(node.nodeType == 1){
								tag = node.tagName? node.tagName.toLowerCase(): "";
								if(dojo.indexOf(this.values, tag) !== -1){
									clearNodes.push(node);
								}
								processChildren(node,clearNodes);
							}
							node = node.nextSibling;
						}
						unformatNodes(clearNodes);
					}
					editor.onDisplayChanged();
				}
			}
		}else{
			editor.execCommand(command, choice);
		}
	},

	_removeFormat: function(editor, node){
		// summary:
		//		function to remove the block format node.
		// node:
		//		The block format node to remove (and leave the contents behind)
		if(editor.customUndo){
			// So of course IE doesn't work right with paste-overs.
			// We have to do this manually, which is okay since IE already uses
			// customUndo and we turned it on for WebKit.  WebKit pasted funny,
			// so couldn't use the execCommand approach
			while(node.firstChild){
				dojo.place(node.firstChild, node, "before");
			}
			node.parentNode.removeChild(node);
		}else{
			// Everyone else works fine this way, a paste-over and is native
			// undo friendly.
			dojo.withGlobal(editor.window,
				 "selectElementChildren", dijit._editor.selection, [node]);
			var html = 	dojo.withGlobal(editor.window,
				 "getSelectedHtml", dijit._editor.selection, [null]);
			dojo.withGlobal(editor.window,
				 "selectElement", dijit._editor.selection, [node]);
			editor.execCommand("inserthtml", html||"");
		}
	}
});

// TODO: for 2.0, split into FontChoice plugin into three separate classes,
// one for each command (and change registry below)
dojo.declare("dijit._editor.plugins.FontChoice", dijit._editor._Plugin,{
	// summary:
	//		This plugin provides three drop downs for setting style in the editor
	//		(font, font size, and format block), as controlled by command.
	//
	// description:
	//		The commands provided by this plugin are:
	//
	//		* fontName
	//	|		Provides a drop down to select from a list of font names
	//		* fontSize
	//	|		Provides a drop down to select from a list of font sizes
	//		* formatBlock
	//	|		Provides a drop down to select from a list of block styles
	//	|
	//
	//		which can easily be added to an editor by including one or more of the above commands
	//		in the `plugins` attribute as follows:
	//
	//	|	plugins="['fontName','fontSize',...]"
	//
	//		It is possible to override the default dropdown list by providing an Array for the `custom` property when
	//		instantiating this plugin, e.g.
	//
	//	|	plugins="[{name:'dijit._editor.plugins.FontChoice', command:'fontName', custom:['Verdana','Myriad','Garamond']},...]"
	//
	//		Alternatively, for `fontName` only, `generic:true` may be specified to provide a dropdown with
	//		[CSS generic font families](http://www.w3.org/TR/REC-CSS2/fonts.html#generic-font-families)
	//
	//		Note that the editor is often unable to properly handle font styling information defined outside
	//		the context of the current editor instance, such as pre-populated HTML.

	// useDefaultCommand: [protected] booleam
	//		Override _Plugin.useDefaultCommand...
	//		processing is handled by this plugin, not by dijit.Editor.
	useDefaultCommand: false,

	_initButton: function(){
		// summary:
		//		Overrides _Plugin._initButton(), to initialize the FilteringSelect+label in toolbar,
		//		rather than a simple button.
		// tags:
		//		protected

		// Create the widget to go into the toolbar (the so-called "button")
		var clazz = {
				fontName: dijit._editor.plugins._FontNameDropDown,
				fontSize: dijit._editor.plugins._FontSizeDropDown,
				formatBlock: dijit._editor.plugins._FormatBlockDropDown
			}[this.command],
		params = this.params;

		// For back-compat reasons support setting custom values via "custom" parameter
		// rather than "values" parameter
		if(this.params.custom){
			params.values = this.params.custom;
		}

		var editor = this.editor;
		this.button = new clazz(dojo.delegate({dir: editor.dir, lang: editor.lang}, params));

		// Reflect changes to the drop down in the editor
		this.connect(this.button.select, "onChange", function(choice){
			// User invoked change, since all internal updates set priorityChange to false and will
			// not trigger an onChange event.
			this.editor.focus();
			
			if(this.command == "fontName" && choice.indexOf(" ") != -1){ choice = "'" + choice + "'"; }

			// Invoke, the editor already normalizes commands called through its
			// execCommand.
			if(this.button._execCommand){
				this.button._execCommand(this.editor, this.command, choice);
			}else{
				this.editor.execCommand(this.command, choice);
			}
		});
	},

	updateState: function(){
		// summary:
		//		Overrides _Plugin.updateState().  This controls updating the menu
		//		options to the right values on state changes in the document (that trigger a
		//		test of the actions.)
		//		It set value of drop down in toolbar to reflect font/font size/format block
		//		of text at current caret position.
		// tags:
		//		protected
		var _e = this.editor;
		var _c = this.command;
		if(!_e || !_e.isLoaded || !_c.length){ return; }
		
		if(this.button){
			var disabled = this.get("disabled");
			this.button.set("disabled", disabled);
			if(disabled){ return; }
			var value;
			try{
				value = _e.queryCommandValue(_c) || "";
			}catch(e){
				//Firefox may throw error above if the editor is just loaded, ignore it
				value = "";
			}

			// strip off single and double quotes, if any
			var quoted = dojo.isString(value) && (value.match(/'([^']*)'/) || value.match(/"([^"]*)"/));
			if(quoted){ value = quoted[1]; }

			if(_c === "formatBlock"){
				if(!value || value == "p"){
					// Some browsers (WebKit) doesn't actually get the tag info right.
					// and IE returns paragraph when in a DIV!, so incorrect a lot,
					// so we have double-check it.
					value = null;
					var elem;
					// Try to find the current element where the caret is.
					var sel = dijit.range.getSelection(this.editor.window);
					if(sel && sel.rangeCount > 0){
						var range = sel.getRangeAt(0);
						if(range){
							elem = range.endContainer;
						}
					}

					// Okay, now see if we can find one of the formatting types we're in.
					while(elem && elem !== _e.editNode && elem !== _e.document){
						var tg = elem.tagName?elem.tagName.toLowerCase():"";
						if(tg && dojo.indexOf(this.button.values, tg) > -1){
							value = tg;
							break;
						}
						elem = elem.parentNode;
					}
					if(!value){
						// Still no value, so lets select 'none'.
						value = "noFormat";
					}
				}else{
					// Check that the block format is one allowed, if not,
					// null it so that it gets set to empty.
					if(dojo.indexOf(this.button.values, value) < 0){
						value = "noFormat";
					}
				}
			}
			if(value !== "" && value !== this.button.get("value")){
				// Set the value, but denote it is not a priority change, so no
				// onchange fires.
				this.button.set('value', value, false);
			}
		}
	}
});

// Register this plugin.
dojo.subscribe(dijit._scopeName + ".Editor.getPlugin",null,function(o){
	if(o.plugin){ return; }
	switch(o.args.name){
	case "fontName": case "fontSize": case "formatBlock":
		o.plugin = new dijit._editor.plugins.FontChoice({
			command: o.args.name,
			plainText: o.args.plainText?o.args.plainText:false
		});
	}
});

}

if(!dojo._hasResource["dojo.colors"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.colors"] = true;
dojo.provide("dojo.colors");

dojo.getObject("colors", true, dojo);

//TODO: this module appears to break naming conventions

/*=====
dojo.colors = {
	// summary: Color utilities
}
=====*/

(function(){
	// this is a standard conversion prescribed by the CSS3 Color Module
	var hue2rgb = function(m1, m2, h){
		if(h < 0){ ++h; }
		if(h > 1){ --h; }
		var h6 = 6 * h;
		if(h6 < 1){ return m1 + (m2 - m1) * h6; }
		if(2 * h < 1){ return m2; }
		if(3 * h < 2){ return m1 + (m2 - m1) * (2 / 3 - h) * 6; }
		return m1;
	};
	
	dojo.colorFromRgb = function(/*String*/ color, /*dojo.Color?*/ obj){
		// summary:
		//		get rgb(a) array from css-style color declarations
		// description:
		//		this function can handle all 4 CSS3 Color Module formats: rgb,
		//		rgba, hsl, hsla, including rgb(a) with percentage values.
		var m = color.toLowerCase().match(/^(rgba?|hsla?)\(([\s\.\-,%0-9]+)\)/);
		if(m){
			var c = m[2].split(/\s*,\s*/), l = c.length, t = m[1], a;
			if((t == "rgb" && l == 3) || (t == "rgba" && l == 4)){
				var r = c[0];
				if(r.charAt(r.length - 1) == "%"){
					// 3 rgb percentage values
					a = dojo.map(c, function(x){
						return parseFloat(x) * 2.56;
					});
					if(l == 4){ a[3] = c[3]; }
					return dojo.colorFromArray(a, obj);	// dojo.Color
				}
				return dojo.colorFromArray(c, obj);	// dojo.Color
			}
			if((t == "hsl" && l == 3) || (t == "hsla" && l == 4)){
				// normalize hsl values
				var H = ((parseFloat(c[0]) % 360) + 360) % 360 / 360,
					S = parseFloat(c[1]) / 100,
					L = parseFloat(c[2]) / 100,
					// calculate rgb according to the algorithm
					// recommended by the CSS3 Color Module
					m2 = L <= 0.5 ? L * (S + 1) : L + S - L * S,
					m1 = 2 * L - m2;
				a = [
					hue2rgb(m1, m2, H + 1 / 3) * 256,
					hue2rgb(m1, m2, H) * 256,
					hue2rgb(m1, m2, H - 1 / 3) * 256,
					1
				];
				if(l == 4){ a[3] = c[3]; }
				return dojo.colorFromArray(a, obj);	// dojo.Color
			}
		}
		return null;	// dojo.Color
	};
	
	var confine = function(c, low, high){
		// summary:
		//		sanitize a color component by making sure it is a number,
		//		and clamping it to valid values
		c = Number(c);
		return isNaN(c) ? high : c < low ? low : c > high ? high : c;	// Number
	};
	
	dojo.Color.prototype.sanitize = function(){
		// summary: makes sure that the object has correct attributes
		var t = this;
		t.r = Math.round(confine(t.r, 0, 255));
		t.g = Math.round(confine(t.g, 0, 255));
		t.b = Math.round(confine(t.b, 0, 255));
		t.a = confine(t.a, 0, 1);
		return this;	// dojo.Color
	};
})();


dojo.colors.makeGrey = function(/*Number*/ g, /*Number?*/ a){
	// summary: creates a greyscale color with an optional alpha
	return dojo.colorFromArray([g, g, g, a]);
};

// mixin all CSS3 named colors not already in _base, along with SVG 1.0 variant spellings
dojo.mixin(dojo.Color.named, {
	aliceblue:	[240,248,255],
	antiquewhite:	[250,235,215],
	aquamarine:	[127,255,212],
	azure:	[240,255,255],
	beige:	[245,245,220],
	bisque:	[255,228,196],
	blanchedalmond:	[255,235,205],
	blueviolet:	[138,43,226],
	brown:	[165,42,42],
	burlywood:	[222,184,135],
	cadetblue:	[95,158,160],
	chartreuse:	[127,255,0],
	chocolate:	[210,105,30],
	coral:	[255,127,80],
	cornflowerblue:	[100,149,237],
	cornsilk:	[255,248,220],
	crimson:	[220,20,60],
	cyan:	[0,255,255],
	darkblue:	[0,0,139],
	darkcyan:	[0,139,139],
	darkgoldenrod:	[184,134,11],
	darkgray:	[169,169,169],
	darkgreen:	[0,100,0],
	darkgrey:	[169,169,169],
	darkkhaki:	[189,183,107],
	darkmagenta:	[139,0,139],
	darkolivegreen:	[85,107,47],
	darkorange:	[255,140,0],
	darkorchid:	[153,50,204],
	darkred:	[139,0,0],
	darksalmon:	[233,150,122],
	darkseagreen:	[143,188,143],
	darkslateblue:	[72,61,139],
	darkslategray:	[47,79,79],
	darkslategrey:	[47,79,79],
	darkturquoise:	[0,206,209],
	darkviolet:	[148,0,211],
	deeppink:	[255,20,147],
	deepskyblue:	[0,191,255],
	dimgray:	[105,105,105],
	dimgrey:	[105,105,105],
	dodgerblue:	[30,144,255],
	firebrick:	[178,34,34],
	floralwhite:	[255,250,240],
	forestgreen:	[34,139,34],
	gainsboro:	[220,220,220],
	ghostwhite:	[248,248,255],
	gold:	[255,215,0],
	goldenrod:	[218,165,32],
	greenyellow:	[173,255,47],
	grey:	[128,128,128],
	honeydew:	[240,255,240],
	hotpink:	[255,105,180],
	indianred:	[205,92,92],
	indigo:	[75,0,130],
	ivory:	[255,255,240],
	khaki:	[240,230,140],
	lavender:	[230,230,250],
	lavenderblush:	[255,240,245],
	lawngreen:	[124,252,0],
	lemonchiffon:	[255,250,205],
	lightblue:	[173,216,230],
	lightcoral:	[240,128,128],
	lightcyan:	[224,255,255],
	lightgoldenrodyellow:	[250,250,210],
	lightgray:	[211,211,211],
	lightgreen:	[144,238,144],
	lightgrey:	[211,211,211],
	lightpink:	[255,182,193],
	lightsalmon:	[255,160,122],
	lightseagreen:	[32,178,170],
	lightskyblue:	[135,206,250],
	lightslategray:	[119,136,153],
	lightslategrey:	[119,136,153],
	lightsteelblue:	[176,196,222],
	lightyellow:	[255,255,224],
	limegreen:	[50,205,50],
	linen:	[250,240,230],
	magenta:	[255,0,255],
	mediumaquamarine:	[102,205,170],
	mediumblue:	[0,0,205],
	mediumorchid:	[186,85,211],
	mediumpurple:	[147,112,219],
	mediumseagreen:	[60,179,113],
	mediumslateblue:	[123,104,238],
	mediumspringgreen:	[0,250,154],
	mediumturquoise:	[72,209,204],
	mediumvioletred:	[199,21,133],
	midnightblue:	[25,25,112],
	mintcream:	[245,255,250],
	mistyrose:	[255,228,225],
	moccasin:	[255,228,181],
	navajowhite:	[255,222,173],
	oldlace:	[253,245,230],
	olivedrab:	[107,142,35],
	orange:	[255,165,0],
	orangered:	[255,69,0],
	orchid:	[218,112,214],
	palegoldenrod:	[238,232,170],
	palegreen:	[152,251,152],
	paleturquoise:	[175,238,238],
	palevioletred:	[219,112,147],
	papayawhip:	[255,239,213],
	peachpuff:	[255,218,185],
	peru:	[205,133,63],
	pink:	[255,192,203],
	plum:	[221,160,221],
	powderblue:	[176,224,230],
	rosybrown:	[188,143,143],
	royalblue:	[65,105,225],
	saddlebrown:	[139,69,19],
	salmon:	[250,128,114],
	sandybrown:	[244,164,96],
	seagreen:	[46,139,87],
	seashell:	[255,245,238],
	sienna:	[160,82,45],
	skyblue:	[135,206,235],
	slateblue:	[106,90,205],
	slategray:	[112,128,144],
	slategrey:	[112,128,144],
	snow:	[255,250,250],
	springgreen:	[0,255,127],
	steelblue:	[70,130,180],
	tan:	[210,180,140],
	thistle:	[216,191,216],
	tomato:	[255,99,71],
	transparent: [0, 0, 0, 0],
	turquoise:	[64,224,208],
	violet:	[238,130,238],
	wheat:	[245,222,179],
	whitesmoke:	[245,245,245],
	yellowgreen:	[154,205,50]
});

}

if(!dojo._hasResource["dijit._PaletteMixin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._PaletteMixin"] = true;
dojo.provide("dijit._PaletteMixin");



dojo.declare("dijit._PaletteMixin",
	[dijit._CssStateMixin],
	{
	// summary:
	//		A keyboard accessible palette, for picking a color/emoticon/etc.
	// description:
	//		A mixin for a grid showing various entities, so the user can pick a certain entity.

	// defaultTimeout: Number
	//		Number of milliseconds before a held key or button becomes typematic
	defaultTimeout: 500,

	// timeoutChangeRate: Number
	//		Fraction of time used to change the typematic timer between events
	//		1.0 means that each typematic event fires at defaultTimeout intervals
	//		< 1.0 means that each typematic event fires at an increasing faster rate
	timeoutChangeRate: 0.90,

	// value: String
	//		Currently selected color/emoticon/etc.
	value: null,
	
	// _selectedCell: [private] Integer
	//		Index of the currently selected cell. Initially, none selected
	_selectedCell: -1,

/*=====
	// _currentFocus: [private] DomNode
	//		The currently focused cell (if the palette itself has focus), or otherwise
	//		the cell to be focused when the palette itself gets focus.
	//		Different from value, which represents the selected (i.e. clicked) cell.
	_currentFocus: null,
=====*/

/*=====
	// _xDim: [protected] Integer
	//		This is the number of cells horizontally across.
	_xDim: null,
=====*/

/*=====
	// _yDim: [protected] Integer
	//		This is the number of cells vertically down.
	_yDim: null,
=====*/

	// tabIndex: String
	//		Widget tab index.
	tabIndex: "0",

	// cellClass: [protected] String
	//		CSS class applied to each cell in the palette
	cellClass: "dijitPaletteCell",

	// dyeClass: [protected] String
	//	 Name of javascript class for Object created for each cell of the palette.
	//	 dyeClass should implements dijit.Dye interface
	dyeClass: '',

	_preparePalette: function(choices, titles, dyeClassObj) {
		// summary:
		//		Subclass must call _preparePalette() from postCreate(), passing in the tooltip
		//		for each cell
		// choices: String[][]
		//		id's for each cell of the palette, used to create Dye JS object for each cell
		// titles: String[]
		//		Localized tooltip for each cell
		// dyeClassObj: Constructor?
		//		If specified, use this constructor rather than this.dyeClass

		this._cells = [];
		var url = this._blankGif;
		
		dyeClassObj = dyeClassObj || dojo.getObject(this.dyeClass);

		for(var row=0; row < choices.length; row++){
			var rowNode = dojo.create("tr", {tabIndex: "-1"}, this.gridNode);
			for(var col=0; col < choices[row].length; col++){
				var value = choices[row][col];
				if(value){
					var cellObject = new dyeClassObj(value, row, col);
					
					var cellNode = dojo.create("td", {
						"class": this.cellClass,
						tabIndex: "-1",
						title: titles[value]
					});

					// prepare cell inner structure
					cellObject.fillCell(cellNode, url);

					this.connect(cellNode, "ondijitclick", "_onCellClick");
					this._trackMouseState(cellNode, this.cellClass);

					dojo.place(cellNode, rowNode);

					cellNode.index = this._cells.length;

					// save cell info into _cells
					this._cells.push({node:cellNode, dye:cellObject});
				}
			}
		}
		this._xDim = choices[0].length;
		this._yDim = choices.length;

		// Now set all events
		// The palette itself is navigated to with the tab key on the keyboard
		// Keyboard navigation within the Palette is with the arrow keys
		// Spacebar selects the cell.
		// For the up key the index is changed by negative the x dimension.

		var keyIncrementMap = {
			UP_ARROW: -this._xDim,
			// The down key the index is increase by the x dimension.
			DOWN_ARROW: this._xDim,
			// Right and left move the index by 1.
			RIGHT_ARROW: this.isLeftToRight() ? 1 : -1,
			LEFT_ARROW: this.isLeftToRight() ? -1 : 1
		};
		for(var key in keyIncrementMap){
			this._connects.push(
				dijit.typematic.addKeyListener(
					this.domNode,
					{charOrCode:dojo.keys[key], ctrlKey:false, altKey:false, shiftKey:false},
					this,
					function(){
						var increment = keyIncrementMap[key];
						return function(count){ this._navigateByKey(increment, count); };
					}(),
					this.timeoutChangeRate,
					this.defaultTimeout
				)
			);
		}
	},

	postCreate: function(){
		this.inherited(arguments);

		// Set initial navigable node.
		this._setCurrent(this._cells[0].node);
	},

	focus: function(){
		// summary:
		//		Focus this widget.  Puts focus on the most recently focused cell.

		// The cell already has tabIndex set, just need to set CSS and focus it
		dijit.focus(this._currentFocus);
	},

	_onCellClick: function(/*Event*/ evt){
		// summary:
		//		Handler for click, enter key & space key. Selects the cell.
		// evt:
		//		The event.
		// tags:
		//		private

		var target = evt.currentTarget,
			value = this._getDye(target).getValue();

		// First focus the clicked cell, and then send onChange() notification.
		// onChange() (via _setValueAttr) must be after the focus call, because
		// it may trigger a refocus to somewhere else (like the Editor content area), and that
		// second focus should win.
		// Use setTimeout because IE doesn't like changing focus inside of an event handler.
		this._setCurrent(target);
		setTimeout(dojo.hitch(this, function(){
			dijit.focus(target);
			this._setValueAttr(value, true);
		}));

		// workaround bug where hover class is not removed on popup because the popup is
		// closed and then there's no onblur event on the cell
		dojo.removeClass(target, "dijitPaletteCellHover");

		dojo.stopEvent(evt);
	},

	_setCurrent: function(/*DomNode*/ node){
		// summary:
		//		Sets which node is the focused cell.
		// description:
   		//		At any point in time there's exactly one
		//		cell with tabIndex != -1.   If focus is inside the palette then
		// 		focus is on that cell.
		//
		//		After calling this method, arrow key handlers and mouse click handlers
		//		should focus the cell in a setTimeout().
		// tags:
		//		protected
		if("_currentFocus" in this){
			// Remove tabIndex on old cell
			dojo.attr(this._currentFocus, "tabIndex", "-1");
		}

		// Set tabIndex of new cell
		this._currentFocus = node;
		if(node){
			dojo.attr(node, "tabIndex", this.tabIndex);
		}
	},

	_setValueAttr: function(value, priorityChange){
		// summary:
		// 		This selects a cell. It triggers the onChange event.
		// value: String value of the cell to select
		// tags:
		//		protected
		// priorityChange:
		//		Optional parameter used to tell the select whether or not to fire
		//		onChange event.
		
		// clear old selected cell
		if(this._selectedCell >= 0){
			dojo.removeClass(this._cells[this._selectedCell].node, "dijitPaletteCellSelected");
		}
		this._selectedCell = -1;

		// search for cell matching specified value
		if(value){
			for(var i = 0; i < this._cells.length; i++){
				if(value == this._cells[i].dye.getValue()){
					this._selectedCell = i;
					dojo.addClass(this._cells[i].node, "dijitPaletteCellSelected");
					break;
				}
			}
		}
		
		// record new value, or null if no matching cell
		this._set("value", this._selectedCell >= 0 ? value : null);

		if(priorityChange || priorityChange === undefined){
			this.onChange(value);
		}
	},

	onChange: function(value){
		// summary:
		//		Callback when a cell is selected.
		// value: String
		//		Value corresponding to cell.
	},

	_navigateByKey: function(increment, typeCount){
		// summary:
		// 	  	This is the callback for typematic.
		// 		It changes the focus and the highlighed cell.
		// increment:
		// 		How much the key is navigated.
		// typeCount:
		//		How many times typematic has fired.
		// tags:
		//		private

		// typecount == -1 means the key is released.
		if(typeCount == -1){ return; }

		var newFocusIndex = this._currentFocus.index + increment;
		if(newFocusIndex < this._cells.length && newFocusIndex > -1){
			var focusNode = this._cells[newFocusIndex].node;
			this._setCurrent(focusNode);

			// Actually focus the node, for the benefit of screen readers.
			// Use setTimeout because IE doesn't like changing focus inside of an event handler
			setTimeout(dojo.hitch(dijit, "focus", focusNode), 0);
		}
	},

	_getDye: function(/*DomNode*/ cell){
		// summary:
		//		Get JS object for given cell DOMNode

		return this._cells[cell.index].dye;
	}
});

/*=====
dojo.declare("dijit.Dye",
	null,
	{
		// summary:
		//		Interface for the JS Object associated with a palette cell (i.e. DOMNode)

		constructor: function(alias, row, col){
			// summary:
			//		Initialize according to value or alias like "white"
			// alias: String
		},

		getValue: function(){
			// summary:
			//		Return "value" of cell; meaning of "value" varies by subclass.
			// description:
			//		For example color hex value, emoticon ascii value etc, entity hex value.
		},

		fillCell: function(cell, blankGif){
			// summary:
			//		Add cell DOMNode inner structure
			//	cell: DomNode
			//		The surrounding cell
			//	blankGif: String
			//		URL for blank cell image
		}
	}
);
=====*/

}

if(!dojo._hasResource["dijit.ColorPalette"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.ColorPalette"] = true;
dojo.provide("dijit.ColorPalette");









dojo.declare("dijit.ColorPalette",
	[dijit._Widget, dijit._Templated, dijit._PaletteMixin],
	{
	// summary:
	//		A keyboard accessible color-picking widget
	// description:
	//		Grid showing various colors, so the user can pick a certain color.
	//		Can be used standalone, or as a popup.
	//
	// example:
	// |	<div dojoType="dijit.ColorPalette"></div>
	//
	// example:
	// |	var picker = new dijit.ColorPalette({ },srcNode);
	// |	picker.startup();


	// palette: [const] String
	//		Size of grid, either "7x10" or "3x4".
	palette: "7x10",

	// _palettes: [protected] Map
	// 		This represents the value of the colors.
	//		The first level is a hashmap of the different palettes available.
	//		The next two dimensions represent the columns and rows of colors.
	_palettes: {
		"7x10":	[["white", "seashell", "cornsilk", "lemonchiffon","lightyellow", "palegreen", "paleturquoise", "lightcyan",	"lavender", "plum"],
				["lightgray", "pink", "bisque", "moccasin", "khaki", "lightgreen", "lightseagreen", "lightskyblue", "cornflowerblue", "violet"],
				["silver", "lightcoral", "sandybrown", "orange", "palegoldenrod", "chartreuse", "mediumturquoise", 	"skyblue", "mediumslateblue","orchid"],
				["gray", "red", "orangered", "darkorange", "yellow", "limegreen", 	"darkseagreen", "royalblue", "slateblue", "mediumorchid"],
				["dimgray", "crimson", 	"chocolate", "coral", "gold", "forestgreen", "seagreen", "blue", "blueviolet", "darkorchid"],
				["darkslategray","firebrick","saddlebrown", "sienna", "olive", "green", "darkcyan", "mediumblue","darkslateblue", "darkmagenta" ],
				["black", "darkred", "maroon", "brown", "darkolivegreen", "darkgreen", "midnightblue", "navy", "indigo", 	"purple"]],

		"3x4": [["white", "lime", "green", "blue"],
			["silver", "yellow", "fuchsia", "navy"],
			["gray", "red", "purple", "black"]]
	},

	// templateString: String
	//		The template of this widget.
	templateString: dojo.cache("dijit", "templates/ColorPalette.html", "<div class=\"dijitInline dijitColorPalette\">\n\t<table class=\"dijitPaletteTable\" cellSpacing=\"0\" cellPadding=\"0\">\n\t\t<tbody dojoAttachPoint=\"gridNode\"></tbody>\n\t</table>\n</div>\n"),

	baseClass: "dijitColorPalette",

	buildRendering: function(){
		// Instantiate the template, which makes a skeleton into which we'll insert a bunch of
		// <img> nodes
		this.inherited(arguments);

		// Creates <img> nodes in each cell of the template.
		// Pass in "customized" dijit._Color constructor for specified palette and high-contrast vs. normal mode
		this._preparePalette(
			this._palettes[this.palette],
			dojo.i18n.getLocalization("dojo", "colors", this.lang),
			dojo.declare(dijit._Color, {
				hc: dojo.hasClass(dojo.body(), "dijit_a11y"),
				palette: this.palette
			})
		);
	}
});

dojo.declare("dijit._Color", dojo.Color, {
	// summary:
	//		Object associated with each cell in a ColorPalette palette.
	//		Implements dijit.Dye.

	// Template for each cell in normal (non-high-contrast mode).  Each cell contains a wrapper
	// node for showing the border (called dijitPaletteImg for back-compat), and dijitColorPaletteSwatch
	// for showing the color.
	template:
		"<span class='dijitInline dijitPaletteImg'>" +
			"<img src='${blankGif}' alt='${alt}' class='dijitColorPaletteSwatch' style='background-color: ${color}'/>" +
		"</span>",

	// Template for each cell in high contrast mode.  Each cell contains an image with the whole palette,
	// but scrolled and clipped to show the correct color only
	hcTemplate:
		"<span class='dijitInline dijitPaletteImg' style='position: relative; overflow: hidden; height: 12px; width: 14px;'>" +
			"<img src='${image}' alt='${alt}' style='position: absolute; left: ${left}px; top: ${top}px; ${size}'/>" +
		"</span>",

	// _imagePaths: [protected] Map
	//		This is stores the path to the palette images used for high-contrast mode display
	_imagePaths: {
		"7x10": dojo.moduleUrl("dijit.themes", "a11y/colors7x10.png"),
		"3x4": dojo.moduleUrl("dijit.themes", "a11y/colors3x4.png")
	},

	constructor: function(/*String*/alias, /*Number*/ row, /*Number*/ col){
		this._alias = alias;
		this._row = row;
		this._col = col;
		this.setColor(dojo.Color.named[alias]);
	},

	getValue: function(){
		// summary:
		//		Note that although dijit._Color is initialized with a value like "white" getValue() always
		//		returns a hex value
		return this.toHex();
	},

	fillCell: function(/*DOMNode*/ cell, /*String*/ blankGif){
		var html = dojo.string.substitute(this.hc ? this.hcTemplate : this.template, {
			// substitution variables for normal mode
			color: this.toHex(),
			blankGif: blankGif,
			alt: this._alias,
			
			// variables used for high contrast mode
			image: this._imagePaths[this.palette].toString(),
			left: this._col * -20 - 5,
			top: this._row * -20 - 5,
			size: this.palette == "7x10" ? "height: 145px; width: 206px" : "height: 64px; width: 86px"
		});

		dojo.place(html, cell);
	}
});

}

if(!dojo._hasResource["dijit._editor.plugins.TextColor"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor.plugins.TextColor"] = true;
dojo.provide("dijit._editor.plugins.TextColor");




dojo.declare("dijit._editor.plugins.TextColor", dijit._editor._Plugin, {
	// summary:
	//		This plugin provides dropdown color pickers for setting text color and background color
	//
	// description:
	//		The commands provided by this plugin are:
	//		* foreColor - sets the text color
	//		* hiliteColor - sets the background color
	
	// Override _Plugin.buttonClass to use DropDownButton (with ColorPalette) to control this plugin
	buttonClass: dijit.form.DropDownButton,
	
	// useDefaultCommand: Boolean
	//		False as we do not use the default editor command/click behavior.
	useDefaultCommand: false,

	constructor: function(){
		this.dropDown = new dijit.ColorPalette();
		this.connect(this.dropDown, "onChange", function(color){
			this.editor.execCommand(this.command, color);
			
		});
	},

	updateState: function(){
		// summary:
		//		Overrides _Plugin.updateState().  This updates the ColorPalette
		//		to show the color of the currently selected text.
		// tags:
		//		protected
		
		var _e = this.editor;
		var _c = this.command;
		if(!_e || !_e.isLoaded || !_c.length){
			return;
		}
		
		if(this.button){
			var disabled = this.get("disabled");
			this.button.set("disabled", disabled);
			if(disabled){ return; }
			
			var value;
			try{
				value = _e.queryCommandValue(_c)|| "";
			}catch(e){
				//Firefox may throw error above if the editor is just loaded, ignore it
				value = "";
			}
		}
		
		if(value == ""){
			value = "#000000";
		}
		if(value == "transparent"){
			value = "#ffffff";
		}

		if(typeof value == "string"){
			//if RGB value, convert to hex value
			if(value.indexOf("rgb")> -1){
				value = dojo.colorFromRgb(value).toHex();
			}
		}else{	//it's an integer(IE returns an MS access #)
			value =((value & 0x0000ff)<< 16)|(value & 0x00ff00)|((value & 0xff0000)>>> 16);
			value = value.toString(16);
			value = "#000000".slice(0, 7 - value.length)+ value;
			
		}
		
		if(value !== this.dropDown.get('value')){
			this.dropDown.set('value', value, false);
		}
	}
});

// Register this plugin.
dojo.subscribe(dijit._scopeName + ".Editor.getPlugin", null, function(o){
	if(o.plugin){
		return;
	}
	switch(o.args.name){
		case "foreColor":
		case "hiliteColor":
			o.plugin = new dijit._editor.plugins.TextColor({
				command: o.args.name
			});
	}
});

}

if(!dojo._hasResource["dijit._editor.plugins.EnterKeyHandling"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit._editor.plugins.EnterKeyHandling"] = true;
dojo.provide("dijit._editor.plugins.EnterKeyHandling");





dojo.declare("dijit._editor.plugins.EnterKeyHandling", dijit._editor._Plugin, {
	// summary:
	//		This plugin tries to make all browsers behave consistently with regard to
	//		how ENTER behaves in the editor window.  It traps the ENTER key and alters
	//		the way DOM is constructed in certain cases to try to commonize the generated
	//		DOM and behaviors across browsers.
	//
	// description:
	//		This plugin has three modes:
	//
	//			* blockModeForEnter=BR
	//			* blockModeForEnter=DIV
	//			* blockModeForEnter=P
	//
	//		In blockModeForEnter=P, the ENTER key starts a new
	//		paragraph, and shift-ENTER starts a new line in the current paragraph.
	//		For example, the input:
	//
	//		|	first paragraph <shift-ENTER>
	//		|	second line of first paragraph <ENTER>
	//		|	second paragraph
	//
	//		will generate:
	//
	//		|	<p>
	//		|		first paragraph
	//		|		<br/>
	//		|		second line of first paragraph
	//		|	</p>
	//		|	<p>
	//		|		second paragraph
	//		|	</p>
	//
	//		In BR and DIV mode, the ENTER key conceptually goes to a new line in the
	//		current paragraph, and users conceptually create a new paragraph by pressing ENTER twice.
	//		For example, if the user enters text into an editor like this:
	//
	//		|		one <ENTER>
	//		|		two <ENTER>
	//		|		three <ENTER>
	//		|		<ENTER>
	//		|		four <ENTER>
	//		|		five <ENTER>
	//		|		six <ENTER>
	//
	//		It will appear on the screen as two 'paragraphs' of three lines each.  Markupwise, this generates:
	//
	//		BR:
	//		|		one<br/>
	//		|		two<br/>
	//		|		three<br/>
	//		|		<br/>
	//		|		four<br/>
	//		|		five<br/>
	//		|		six<br/>
	//
	//		DIV:
	//		|		<div>one</div>
	//		|		<div>two</div>
	//		|		<div>three</div>
	//		|		<div>&nbsp;</div>
	//		|		<div>four</div>
	//		|		<div>five</div>
	//		|		<div>six</div>

	// blockNodeForEnter: String
	//		This property decides the behavior of Enter key. It can be either P,
	//		DIV, BR, or empty (which means disable this feature). Anything else
	//		will trigger errors.  The default is 'BR'
	//
	//		See class description for more details.
	blockNodeForEnter: 'BR',

	constructor: function(args){
		if(args){
			if("blockNodeForEnter" in args){
				args.blockNodeForEnter = args.blockNodeForEnter.toUpperCase();
			}
			dojo.mixin(this,args);
		}
	},

	setEditor: function(editor){
		// Overrides _Plugin.setEditor().
		if(this.editor === editor) { return; }
		this.editor = editor;
		if(this.blockNodeForEnter == 'BR'){
			// While Moz has a mode tht mostly works, it's still a little different,
			// So, try to just have a common mode and be consistent.  Which means
			// we need to enable customUndo, if not already enabled.
			this.editor.customUndo = true;
				editor.onLoadDeferred.addCallback(dojo.hitch(this,function(d){
				this.connect(editor.document, "onkeypress", function(e){
					if(e.charOrCode == dojo.keys.ENTER){
						// Just do it manually.  The handleEnterKey has a shift mode that
						// Always acts like <br>, so just use it.
						var ne = dojo.mixin({},e);
						ne.shiftKey = true;
						if(!this.handleEnterKey(ne)){
							dojo.stopEvent(e);
						}
					}
				});
					return d;
				}));
		}else if(this.blockNodeForEnter){
			// add enter key handler
			// FIXME: need to port to the new event code!!
			var h = dojo.hitch(this,this.handleEnterKey);
			editor.addKeyHandler(13, 0, 0, h); //enter
			editor.addKeyHandler(13, 0, 1, h); //shift+enter
			this.connect(this.editor,'onKeyPressed','onKeyPressed');
		}
	},
	onKeyPressed: function(e){
		// summary:
		//		Handler for keypress events.
		// tags:
		//		private
		if(this._checkListLater){
			if(dojo.withGlobal(this.editor.window, 'isCollapsed', dijit)){
				var liparent=dojo.withGlobal(this.editor.window, 'getAncestorElement', dijit._editor.selection, ['LI']);
				if(!liparent){
					// circulate the undo detection code by calling RichText::execCommand directly
					dijit._editor.RichText.prototype.execCommand.call(this.editor, 'formatblock',this.blockNodeForEnter);
					// set the innerHTML of the new block node
					var block = dojo.withGlobal(this.editor.window, 'getAncestorElement', dijit._editor.selection, [this.blockNodeForEnter]);
					if(block){
						block.innerHTML=this.bogusHtmlContent;
						if(dojo.isIE){
							// move to the start by moving backwards one char
							var r = this.editor.document.selection.createRange();
							r.move('character',-1);
							r.select();
						}
					}else{
						console.error('onKeyPressed: Cannot find the new block node'); // FIXME
					}
				}else{
					if(dojo.isMoz){
						if(liparent.parentNode.parentNode.nodeName == 'LI'){
							liparent=liparent.parentNode.parentNode;
						}
					}
					var fc=liparent.firstChild;
					if(fc && fc.nodeType == 1 && (fc.nodeName == 'UL' || fc.nodeName == 'OL')){
						liparent.insertBefore(fc.ownerDocument.createTextNode('\xA0'),fc);
						var newrange = dijit.range.create(this.editor.window);
						newrange.setStart(liparent.firstChild,0);
						var selection = dijit.range.getSelection(this.editor.window, true);
						selection.removeAllRanges();
						selection.addRange(newrange);
					}
				}
			}
			this._checkListLater = false;
		}
		if(this._pressedEnterInBlock){
			// the new created is the original current P, so we have previousSibling below
			if(this._pressedEnterInBlock.previousSibling){
				this.removeTrailingBr(this._pressedEnterInBlock.previousSibling);
			}
			delete this._pressedEnterInBlock;
		}
	},

	// bogusHtmlContent: [private] String
	//		HTML to stick into a new empty block
	bogusHtmlContent: '&nbsp;',

	// blockNodes: [private] Regex
	//		Regex for testing if a given tag is a block level (display:block) tag
	blockNodes: /^(?:P|H1|H2|H3|H4|H5|H6|LI)$/,

	handleEnterKey: function(e){
		// summary:
		//		Handler for enter key events when blockModeForEnter is DIV or P.
		// description:
		//		Manually handle enter key event to make the behavior consistent across
		//		all supported browsers. See class description for details.
		// tags:
		//		private

		var selection, range, newrange, startNode, endNode, brNode, doc=this.editor.document,br,rs,txt;
		if(e.shiftKey){		// shift+enter always generates <br>
			var parent = dojo.withGlobal(this.editor.window, "getParentElement", dijit._editor.selection);
			var header = dijit.range.getAncestor(parent,this.blockNodes);
			if(header){
				if(header.tagName == 'LI'){
					return true; // let browser handle
				}
				selection = dijit.range.getSelection(this.editor.window);
				range = selection.getRangeAt(0);
				if(!range.collapsed){
					range.deleteContents();
					selection = dijit.range.getSelection(this.editor.window);
					range = selection.getRangeAt(0);
				}
				if(dijit.range.atBeginningOfContainer(header, range.startContainer, range.startOffset)){
						br=doc.createElement('br');
						newrange = dijit.range.create(this.editor.window);
						header.insertBefore(br,header.firstChild);
						newrange.setStartBefore(br.nextSibling);
						selection.removeAllRanges();
						selection.addRange(newrange);
				}else if(dijit.range.atEndOfContainer(header, range.startContainer, range.startOffset)){
					newrange = dijit.range.create(this.editor.window);
					br=doc.createElement('br');
						header.appendChild(br);
						header.appendChild(doc.createTextNode('\xA0'));
						newrange.setStart(header.lastChild,0);
					selection.removeAllRanges();
					selection.addRange(newrange);
				}else{
					rs = range.startContainer;
					if(rs && rs.nodeType == 3){
						// Text node, we have to split it.
						txt = rs.nodeValue;
						dojo.withGlobal(this.editor.window, function(){
							startNode = doc.createTextNode(txt.substring(0, range.startOffset));
							endNode = doc.createTextNode(txt.substring(range.startOffset));
							brNode = doc.createElement("br");
							
							if(endNode.nodeValue == "" && dojo.isWebKit){
								endNode = doc.createTextNode('\xA0')
							}
							dojo.place(startNode, rs, "after");
							dojo.place(brNode, startNode, "after");
							dojo.place(endNode, brNode, "after");
							dojo.destroy(rs);
							newrange = dijit.range.create(dojo.gobal);
							newrange.setStart(endNode,0);
							selection.removeAllRanges();
							selection.addRange(newrange);
						});
						return false;
					}
					return true; // let browser handle
				}
			}else{
				selection = dijit.range.getSelection(this.editor.window);
				if(selection.rangeCount){
					range = selection.getRangeAt(0);
					if(range && range.startContainer){
						if(!range.collapsed){
							range.deleteContents();
							selection = dijit.range.getSelection(this.editor.window);
							range = selection.getRangeAt(0);
						}
						rs = range.startContainer;
						if(rs && rs.nodeType == 3){
							// Text node, we have to split it.
							dojo.withGlobal(this.editor.window, dojo.hitch(this, function(){
								var endEmpty = false;
							
								var offset = range.startOffset;
								if(rs.length < offset){
									//We are not splitting the right node, try to locate the correct one
									ret = this._adjustNodeAndOffset(rs, offset);
									rs = ret.node;
									offset = ret.offset;
								}
								txt = rs.nodeValue;
				
								startNode = doc.createTextNode(txt.substring(0, offset));
								endNode = doc.createTextNode(txt.substring(offset));
								brNode = doc.createElement("br");
								
								if(!endNode.length){
									endNode = doc.createTextNode('\xA0');
									endEmpty = true;
								}
								
								if(startNode.length){
									dojo.place(startNode, rs, "after");
								}else{
									startNode = rs;
								}
								dojo.place(brNode, startNode, "after");
								dojo.place(endNode, brNode, "after");
								dojo.destroy(rs);
								newrange = dijit.range.create(dojo.gobal);
								newrange.setStart(endNode,0);
								newrange.setEnd(endNode, endNode.length);
								selection.removeAllRanges();
								selection.addRange(newrange);
								if(endEmpty && !dojo.isWebKit){
									dijit._editor.selection.remove();
								}else{
									dijit._editor.selection.collapse(true);
								}
							}));
						}else{
							dojo.withGlobal(this.editor.window, dojo.hitch(this, function(){
								var brNode = doc.createElement("br");
								rs.appendChild(brNode);
								var endNode = doc.createTextNode('\xA0');
								rs.appendChild(endNode);
								newrange = dijit.range.create(dojo.global);
								newrange.setStart(endNode,0);
								newrange.setEnd(endNode, endNode.length);
								selection.removeAllRanges();
								selection.addRange(newrange);
								dijit._editor.selection.collapse(true);
							}));
						}
					}
				}else{
					// don't change this: do not call this.execCommand, as that may have other logic in subclass
					dijit._editor.RichText.prototype.execCommand.call(this.editor, 'inserthtml', '<br>');
				}
			}
			return false;
		}
		var _letBrowserHandle = true;

		// first remove selection
		selection = dijit.range.getSelection(this.editor.window);
		range = selection.getRangeAt(0);
		if(!range.collapsed){
			range.deleteContents();
			selection = dijit.range.getSelection(this.editor.window);
			range = selection.getRangeAt(0);
		}

		var block = dijit.range.getBlockAncestor(range.endContainer, null, this.editor.editNode);
		var blockNode = block.blockNode;

		// if this is under a LI or the parent of the blockNode is LI, just let browser to handle it
		if((this._checkListLater = (blockNode && (blockNode.nodeName == 'LI' || blockNode.parentNode.nodeName == 'LI')))){
			if(dojo.isMoz){
				// press enter in middle of P may leave a trailing <br/>, let's remove it later
				this._pressedEnterInBlock = blockNode;
			}
			// if this li only contains spaces, set the content to empty so the browser will outdent this item
			if(/^(\s|&nbsp;|\xA0|<span\b[^>]*\bclass=['"]Apple-style-span['"][^>]*>(\s|&nbsp;|\xA0)<\/span>)?(<br>)?$/.test(blockNode.innerHTML)){
				// empty LI node
				blockNode.innerHTML = '';
				if(dojo.isWebKit){ // WebKit tosses the range when innerHTML is reset
					newrange = dijit.range.create(this.editor.window);
					newrange.setStart(blockNode, 0);
					selection.removeAllRanges();
					selection.addRange(newrange);
				}
				this._checkListLater = false; // nothing to check since the browser handles outdent
			}
			return true;
		}

		// text node directly under body, let's wrap them in a node
		if(!block.blockNode || block.blockNode===this.editor.editNode){
			try{
				dijit._editor.RichText.prototype.execCommand.call(this.editor, 'formatblock',this.blockNodeForEnter);
			}catch(e2){ /*squelch FF3 exception bug when editor content is a single BR*/ }
			// get the newly created block node
			// FIXME
			block = {blockNode:dojo.withGlobal(this.editor.window, "getAncestorElement", dijit._editor.selection, [this.blockNodeForEnter]),
					blockContainer: this.editor.editNode};
			if(block.blockNode){
				if(block.blockNode != this.editor.editNode &&
					(!(block.blockNode.textContent || block.blockNode.innerHTML).replace(/^\s+|\s+$/g, "").length)){
					this.removeTrailingBr(block.blockNode);
					return false;
				}
			}else{	// we shouldn't be here if formatblock worked
				block.blockNode = this.editor.editNode;
			}
			selection = dijit.range.getSelection(this.editor.window);
			range = selection.getRangeAt(0);
		}

		var newblock = doc.createElement(this.blockNodeForEnter);
		newblock.innerHTML=this.bogusHtmlContent;
		this.removeTrailingBr(block.blockNode);
		var endOffset = range.endOffset;
		var node = range.endContainer;
		if(node.length < endOffset){
			//We are not checking the right node, try to locate the correct one
			var ret = this._adjustNodeAndOffset(node, endOffset);
			node = ret.node;
			endOffset = ret.offset;
		}
		if(dijit.range.atEndOfContainer(block.blockNode, node, endOffset)){
			if(block.blockNode === block.blockContainer){
				block.blockNode.appendChild(newblock);
			}else{
				dojo.place(newblock, block.blockNode, "after");
			}
			_letBrowserHandle = false;
			// lets move caret to the newly created block
			newrange = dijit.range.create(this.editor.window);
			newrange.setStart(newblock, 0);
			selection.removeAllRanges();
			selection.addRange(newrange);
			if(this.editor.height){
				dojo.window.scrollIntoView(newblock);
			}
		}else if(dijit.range.atBeginningOfContainer(block.blockNode,
				range.startContainer, range.startOffset)){
			dojo.place(newblock, block.blockNode, block.blockNode === block.blockContainer ? "first" : "before");
			if(newblock.nextSibling && this.editor.height){
				// position input caret - mostly WebKit needs this
				newrange = dijit.range.create(this.editor.window);
				newrange.setStart(newblock.nextSibling, 0);
				selection.removeAllRanges();
				selection.addRange(newrange);
				// browser does not scroll the caret position into view, do it manually
				dojo.window.scrollIntoView(newblock.nextSibling);
			}
			_letBrowserHandle = false;
		}else{ //press enter in the middle of P/DIV/Whatever/
			if(block.blockNode === block.blockContainer){
				block.blockNode.appendChild(newblock);
			}else{
				dojo.place(newblock, block.blockNode, "after");
			}
			_letBrowserHandle = false;

			// Clone any block level styles.
			if(block.blockNode.style){
				if(newblock.style){
					if(block.blockNode.style.cssText){
						newblock.style.cssText = block.blockNode.style.cssText;
					}
				}
			}
			
			// Okay, we probably have to split.
			rs = range.startContainer;
			var firstNodeMoved;
			if(rs && rs.nodeType == 3){ 
				// Text node, we have to split it.
				var nodeToMove, tNode;
				endOffset = range.endOffset;
				if(rs.length < endOffset){
					//We are not splitting the right node, try to locate the correct one
					ret = this._adjustNodeAndOffset(rs, endOffset);
					rs = ret.node;
					endOffset = ret.offset;
				}
				
				txt = rs.nodeValue;
				startNode = doc.createTextNode(txt.substring(0, endOffset));
				endNode = doc.createTextNode(txt.substring(endOffset, txt.length));

				// Place the split, then remove original nodes.
				dojo.place(startNode, rs, "before");
				dojo.place(endNode, rs, "after");
				dojo.destroy(rs);

				// Okay, we split the text.  Now we need to see if we're
				// parented to the block element we're splitting and if
				// not, we have to split all the way up.  Ugh.
				var parentC = startNode.parentNode;
				while(parentC !== block.blockNode){
					var tg = parentC.tagName;
					var newTg = doc.createElement(tg);
					// Clone over any 'style' data.
					if(parentC.style){
						if(newTg.style){
							if(parentC.style.cssText){
								newTg.style.cssText = parentC.style.cssText;
							}
						}
					}
					// If font also need to clone over any font data. 
					if(parentC.tagName === "FONT"){
						if(parentC.color){
							newTg.color = parentC.color;
						}
						if(parentC.face){
							newTg.face = parentC.face;
						}
						if(parentC.size){  // this check was necessary on IE
							newTg.size = parentC.size;
						}
					}
					
					nodeToMove = endNode;
					while(nodeToMove){
						tNode = nodeToMove.nextSibling;
						newTg.appendChild(nodeToMove);
						nodeToMove = tNode;
					}
					dojo.place(newTg, parentC, "after");
					startNode = parentC;
					endNode = newTg;
					parentC = parentC.parentNode;
				}

				// Lastly, move the split out tags to the new block.
				// as they should now be split properly.
				nodeToMove = endNode;
				if(nodeToMove.nodeType == 1 || (nodeToMove.nodeType == 3 && nodeToMove.nodeValue)){
					// Non-blank text and non-text nodes need to clear out that blank space
					// before moving the contents.
					newblock.innerHTML = "";
				}
				firstNodeMoved = nodeToMove;
				while(nodeToMove){
					tNode = nodeToMove.nextSibling;
					newblock.appendChild(nodeToMove);
					nodeToMove = tNode;
				}
			}
			
			//lets move caret to the newly created block
			newrange = dijit.range.create(this.editor.window);
			var nodeForCursor;
			var innerMostFirstNodeMoved = firstNodeMoved;
			if(this.blockNodeForEnter !== 'BR'){
				while(innerMostFirstNodeMoved){
					nodeForCursor = innerMostFirstNodeMoved;
					tNode = innerMostFirstNodeMoved.firstChild;
					innerMostFirstNodeMoved = tNode;
				}
				if(nodeForCursor && nodeForCursor.parentNode){
					newblock = nodeForCursor.parentNode;
					newrange.setStart(newblock, 0);
					selection.removeAllRanges();
					selection.addRange(newrange);
					if(this.editor.height){
						dijit.scrollIntoView(newblock);
					}
					if(dojo.isMoz){
						// press enter in middle of P may leave a trailing <br/>, let's remove it later
						this._pressedEnterInBlock = block.blockNode;
					}					
				}else{
					_letBrowserHandle = true;
				}
			}else{
				newrange.setStart(newblock, 0);
				selection.removeAllRanges();
				selection.addRange(newrange);
				if(this.editor.height){
					dijit.scrollIntoView(newblock);
				}
				if(dojo.isMoz){
					// press enter in middle of P may leave a trailing <br/>, let's remove it later
					this._pressedEnterInBlock = block.blockNode;
				}
			}
		}
		return _letBrowserHandle;
	},

	_adjustNodeAndOffset: function(/*DomNode*/node, /*Int*/offset){
		// summary:
		//              In the case there are multiple text nodes in a row the offset may not be within the node.  If the offset is larger than the node length, it will attempt to find
		//              the next text sibling until it locates the text node in which the offset refers to
		// node:
		//              The node to check.
		// offset:
		//              The position to find within the text node
		// tags:
		//              private.
		while(node.length < offset && node.nextSibling && node.nextSibling.nodeType==3){
			//Adjust the offset and node in the case of multiple text nodes in a row
			offset = offset - node.length;
			node = node.nextSibling;
		}
		var ret = {"node": node, "offset": offset};
		return ret;
	},

	removeTrailingBr: function(container){
		// summary:
		//		If last child of container is a <br>, then remove it.
		// tags:
		//		private
		var para = /P|DIV|LI/i.test(container.tagName) ?
			container : dijit._editor.selection.getParentOfType(container,['P','DIV','LI']);

		if(!para){ return; }
		if(para.lastChild){
			if((para.childNodes.length > 1 && para.lastChild.nodeType == 3 && /^[\s\xAD]*$/.test(para.lastChild.nodeValue)) ||
				para.lastChild.tagName=='BR'){

				dojo.destroy(para.lastChild);
			}
		}
		if(!para.childNodes.length){
			para.innerHTML=this.bogusHtmlContent;
		}
	}
});

}

if(!dojo._hasResource["dijit.Editor"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Editor"] = true;
dojo.provide("dijit.Editor");















dojo.declare(
	"dijit.Editor",
	dijit._editor.RichText,
	{
		// summary:
		//		A rich text Editing widget
		//
		// description:
		//		This widget provides basic WYSIWYG editing features, based on the browser's
		//		underlying rich text editing capability, accompanied by a toolbar (`dijit.Toolbar`).
		//		A plugin model is available to extend the editor's capabilities as well as the
		//		the options available in the toolbar.  Content generation may vary across
		//		browsers, and clipboard operations may have different results, to name
		//		a few limitations.  Note: this widget should not be used with the HTML
		//		&lt;TEXTAREA&gt; tag -- see dijit._editor.RichText for details.

		// plugins: [const] Object[]
		//		A list of plugin names (as strings) or instances (as objects)
		//		for this widget.
		//
		//		When declared in markup, it might look like:
		//	|	plugins="['bold',{name:'dijit._editor.plugins.FontChoice', command:'fontName', generic:true}]"
		plugins: null,

		// extraPlugins: [const] Object[]
		//		A list of extra plugin names which will be appended to plugins array
		extraPlugins: null,

		constructor: function(){
			// summary:
			//		Runs on widget initialization to setup arrays etc.
			// tags:
			//		private

			if(!dojo.isArray(this.plugins)){
				this.plugins=["undo","redo","|","cut","copy","paste","|",
				              "bold","italic","underline","strikethrough","|",
				              "insertOrderedList","insertUnorderedList","indent","outdent","|",
				              "justifyLeft","justifyRight","justifyCenter","justifyFull","|",
				              "foreColor","hiliteColor","||",
				              "fontName","||","fontSize","||","formatBlock",
				              "dijit._editor.plugins.EnterKeyHandling" /*, "createLink"*/];
			}

			this._plugins=[];
			this._editInterval = this.editActionInterval * 1000;

			//IE will always lose focus when other element gets focus, while for FF and safari,
			//when no iframe is used, focus will be lost whenever another element gets focus.
			//For IE, we can connect to onBeforeDeactivate, which will be called right before
			//the focus is lost, so we can obtain the selected range. For other browsers,
			//no equivelent of onBeforeDeactivate, so we need to do two things to make sure
			//selection is properly saved before focus is lost: 1) when user clicks another
			//element in the page, in which case we listen to mousedown on the entire page and
			//see whether user clicks out of a focus editor, if so, save selection (focus will
			//only lost after onmousedown event is fired, so we can obtain correct caret pos.)
			//2) when user tabs away from the editor, which is handled in onKeyDown below.
			if(dojo.isIE){
				this.events.push("onBeforeDeactivate");
				this.events.push("onBeforeActivate");
			}
		},

		setupDefaultShortcuts: function(){},
		
		postMixInProperties: function() {
			// summary:
			//	Extension to make sure a deferred is in place before certain functions
			//	execute, like making sure all the plugins are properly inserted.

			// Set up a deferred so that the value isn't applied to the editor
			// until all the plugins load, needed to avoid timing condition
			// reported in #10537.
			this.setValueDeferred = new dojo.Deferred();
			this.inherited(arguments);
		},
	
		postCreate: function(){
			//for custom undo/redo, if enabled.
			this._steps=this._steps.slice(0);
			this._undoedSteps=this._undoedSteps.slice(0);

			if(dojo.isArray(this.extraPlugins)){
				this.plugins=this.plugins.concat(this.extraPlugins);
			}

			this.inherited(arguments);

			this.commands = dojo.i18n.getLocalization("dijit._editor", "commands", this.lang);

			if(!this.toolbar){
				// if we haven't been assigned a toolbar, create one
				this.toolbar = new dijit.Toolbar({
					dir: this.dir,
					lang: this.lang
				});
				this.header.appendChild(this.toolbar.domNode);
			}

			dojo.forEach(this.plugins, this.addPlugin, this);

			// Okay, denote the value can now be set.
			this.setValueDeferred.callback(true);

			dojo.addClass(this.iframe.parentNode, "dijitEditorIFrameContainer");
			dojo.addClass(this.iframe, "dijitEditorIFrame");
			dojo.attr(this.iframe, "allowTransparency", true);

			if(dojo.isWebKit){
				// Disable selecting the entire editor by inadvertant double-clicks.
				// on buttons, title bar, etc.  Otherwise clicking too fast on
				// a button such as undo/redo selects the entire editor.
				dojo.style(this.domNode, "KhtmlUserSelect", "none");
			}
			this.toolbar.startup();
			this.onNormalizedDisplayChanged(); //update toolbar button status
		},
		destroy: function(){
			dojo.forEach(this._plugins, function(p){
				if(p && p.destroy){
					p.destroy();
				}
			});
			this._plugins=[];
			this.toolbar.destroyRecursive();
			delete this.toolbar;
			this.inherited(arguments);
		},
		addPlugin: function(/*String||Object*/plugin, /*Integer?*/index){
			// summary:
			//		takes a plugin name as a string or a plugin instance and
			//		adds it to the toolbar and associates it with this editor
			//		instance. The resulting plugin is added to the Editor's
			//		plugins array. If index is passed, it's placed in the plugins
			//		array at that index. No big magic, but a nice helper for
			//		passing in plugin names via markup.
			//
			// plugin: String, args object or plugin instance
			//
			// args:
			//		This object will be passed to the plugin constructor
			//
			// index: Integer
			//		Used when creating an instance from
			//		something already in this.plugins. Ensures that the new
			//		instance is assigned to this.plugins at that index.
			var args=dojo.isString(plugin)?{name:plugin}:plugin;
			if(!args.setEditor){
				var o={"args":args,"plugin":null,"editor":this};
				dojo.publish(dijit._scopeName + ".Editor.getPlugin",[o]);
				if(!o.plugin){
					var pc = dojo.getObject(args.name);
					if(pc){
						o.plugin=new pc(args);
					}
				}
				if(!o.plugin){
					console.warn('Cannot find plugin',plugin);
					return;
				}
				plugin=o.plugin;
			}
			if(arguments.length > 1){
				this._plugins[index] = plugin;
			}else{
				this._plugins.push(plugin);
			}
			plugin.setEditor(this);
			if(dojo.isFunction(plugin.setToolbar)){
				plugin.setToolbar(this.toolbar);
			}
		},
		//the following 3 functions are required to make the editor play nice under a layout widget, see #4070
		startup: function(){
			// summary:
			//		Exists to make Editor work as a child of a layout widget.
			//		Developers don't need to call this method.
			// tags:
			//		protected
			//console.log('startup',arguments);
		},
		resize: function(size){
			// summary:
			//		Resize the editor to the specified size, see `dijit.layout._LayoutWidget.resize`
			if(size){
				// we've been given a height/width for the entire editor (toolbar + contents), calls layout()
				// to split the allocated size between the toolbar and the contents
				dijit.layout._LayoutWidget.prototype.resize.apply(this, arguments);
			}
			/*
			else{
				// do nothing, the editor is already laid out correctly.   The user has probably specified
				// the height parameter, which was used to set a size on the iframe
			}
			*/
		},
		layout: function(){
			// summary:
			//		Called from `dijit.layout._LayoutWidget.resize`.  This shouldn't be called directly
			// tags:
			//		protected

			// Converts the iframe (or rather the <div> surrounding it) to take all the available space
			// except what's needed for the header (toolbars) and footer (breadcrumbs, etc).
			// A class was added to the iframe container and some themes style it, so we have to
			// calc off the added margins and padding too. See tracker: #10662
			var areaHeight = (this._contentBox.h -
				(this.getHeaderHeight() + this.getFooterHeight() +
				 dojo._getPadBorderExtents(this.iframe.parentNode).h +
				 dojo._getMarginExtents(this.iframe.parentNode).h));
			this.editingArea.style.height = areaHeight + "px";
			if(this.iframe){
				this.iframe.style.height="100%";
			}
			this._layoutMode = true;
		},
		_onIEMouseDown: function(/*Event*/ e){
			// summary:
			//		IE only to prevent 2 clicks to focus
			// tags:
			//		private
			var outsideClientArea;
			// IE 8's componentFromPoint is broken, which is a shame since it
			// was smaller code, but oh well.  We have to do this brute force
			// to detect if the click was scroller or not.
			var b = this.document.body;
			var clientWidth = b.clientWidth;
			var clientHeight = b.clientHeight;
			var clientLeft = b.clientLeft;
			var offsetWidth = b.offsetWidth;
			var offsetHeight = b.offsetHeight;
			var offsetLeft = b.offsetLeft;

			//Check for vertical scroller click.
			bodyDir = b.dir ? b.dir.toLowerCase() : "";
			if(bodyDir != "rtl"){
				if(clientWidth < offsetWidth && e.x > clientWidth && e.x < offsetWidth){
					// Check the click was between width and offset width, if so, scroller
					outsideClientArea = true;
				}
			}else{
				// RTL mode, we have to go by the left offsets.
				if(e.x < clientLeft && e.x > offsetLeft){
					// Check the click was between width and offset width, if so, scroller
					outsideClientArea = true;
				}
			}
			if(!outsideClientArea){
				// Okay, might be horiz scroller, check that.
				if(clientHeight < offsetHeight && e.y > clientHeight && e.y < offsetHeight){
					// Horizontal scroller.
					outsideClientArea = true;
				}
			}
			if(!outsideClientArea){
				delete this._cursorToStart; // Remove the force to cursor to start position.
				delete this._savedSelection; // new mouse position overrides old selection
				if(e.target.tagName == "BODY"){
					setTimeout(dojo.hitch(this, "placeCursorAtEnd"), 0);
				}
				this.inherited(arguments);
			}
		},
		onBeforeActivate: function(e){
			this._restoreSelection();
		},
		onBeforeDeactivate: function(e){
			// summary:
			//		Called on IE right before focus is lost.   Saves the selected range.
			// tags:
			//		private
			if(this.customUndo){
				this.endEditing(true);
			}
			//in IE, the selection will be lost when other elements get focus,
			//let's save focus before the editor is deactivated
			if(e.target.tagName != "BODY"){
				this._saveSelection();
			}
			//console.log('onBeforeDeactivate',this);
		},

		/* beginning of custom undo/redo support */

		// customUndo: Boolean
		//		Whether we shall use custom undo/redo support instead of the native
		//		browser support. By default, we now use custom undo.  It works better
		//		than native browser support and provides a consistent behavior across
		//		browsers with a minimal performance hit.  We already had the hit on
		//		the slowest browser, IE, anyway.
		customUndo: true,

		// editActionInterval: Integer
		//		When using customUndo, not every keystroke will be saved as a step.
		//		Instead typing (including delete) will be grouped together: after
		//		a user stops typing for editActionInterval seconds, a step will be
		//		saved; if a user resume typing within editActionInterval seconds,
		//		the timeout will be restarted. By default, editActionInterval is 3
		//		seconds.
		editActionInterval: 3,

		beginEditing: function(cmd){
			// summary:
			//		Called to note that the user has started typing alphanumeric characters, if it's not already noted.
			//		Deals with saving undo; see editActionInterval parameter.
			// tags:
			//		private
			if(!this._inEditing){
				this._inEditing=true;
				this._beginEditing(cmd);
			}
			if(this.editActionInterval>0){
				if(this._editTimer){
					clearTimeout(this._editTimer);
				}
				this._editTimer = setTimeout(dojo.hitch(this, this.endEditing), this._editInterval);
			}
		},

		// TODO: declaring these in the prototype is meaningless, just create in the constructor/postCreate
		_steps:[],
		_undoedSteps:[],

		execCommand: function(cmd){
			// summary:
			//		Main handler for executing any commands to the editor, like paste, bold, etc.
			//      Called by plugins, but not meant to be called by end users.
			// tags:
			//		protected
			if(this.customUndo && (cmd == 'undo' || cmd == 'redo')){
				return this[cmd]();
			}else{
				if(this.customUndo){
					this.endEditing();
					this._beginEditing();
				}
				var r;
				var isClipboard = /copy|cut|paste/.test(cmd);
				try{
					r = this.inherited(arguments);
					if(dojo.isWebKit && isClipboard && !r){ //see #4598: webkit does not guarantee clipboard support from js
						throw { code: 1011 }; // throw an object like Mozilla's error
					}
				}catch(e){
					//TODO: when else might we get an exception?  Do we need the Mozilla test below?
					if(e.code == 1011 /* Mozilla: service denied */ && isClipboard){
						// Warn user of platform limitation.  Cannot programmatically access clipboard. See ticket #4136
						var sub = dojo.string.substitute,
							accel = {cut:'X', copy:'C', paste:'V'};
						alert(sub(this.commands.systemShortcut,
							[this.commands[cmd], sub(this.commands[dojo.isMac ? 'appleKey' : 'ctrlKey'], [accel[cmd]])]));
					}
					r = false;
				}
				if(this.customUndo){
					this._endEditing();
				}
				return r;
			}
		},
		queryCommandEnabled: function(cmd){
			// summary:
			//		Returns true if specified editor command is enabled.
			//      Used by the plugins to know when to highlight/not highlight buttons.
			// tags:
			//		protected
			if(this.customUndo && (cmd == 'undo' || cmd == 'redo')){
				return cmd == 'undo' ? (this._steps.length > 1) : (this._undoedSteps.length > 0);
			}else{
				return this.inherited(arguments);
			}
		},
		_moveToBookmark: function(b){
			// summary:
			//		Selects the text specified in bookmark b
			// tags:
			//		private
			var bookmark = b.mark;
			var mark = b.mark;
			var col = b.isCollapsed;
			var r, sNode, eNode, sel;
			if(mark){
				if(dojo.isIE < 9){
					if(dojo.isArray(mark)){
						//IE CONTROL, have to use the native bookmark.
						bookmark = [];
						dojo.forEach(mark,function(n){
							bookmark.push(dijit.range.getNode(n,this.editNode));
						},this);
						dojo.withGlobal(this.window,'moveToBookmark',dijit,[{mark: bookmark, isCollapsed: col}]);
					}else{
						if(mark.startContainer && mark.endContainer){
							// Use the pseudo WC3 range API.  This works better for positions
							// than the IE native bookmark code.
							sel = dijit.range.getSelection(this.window);
							if(sel && sel.removeAllRanges){
								sel.removeAllRanges();
								r = dijit.range.create(this.window);
								sNode = dijit.range.getNode(mark.startContainer,this.editNode);
								eNode = dijit.range.getNode(mark.endContainer,this.editNode);
								if(sNode && eNode){
									// Okay, we believe we found the position, so add it into the selection
									// There are cases where it may not be found, particularly in undo/redo, when
									// IE changes the underlying DOM on us (wraps text in a <p> tag or similar.
									// So, in those cases, don't bother restoring selection.
									r.setStart(sNode,mark.startOffset);
									r.setEnd(eNode,mark.endOffset);
									sel.addRange(r);
								}
							}
						}
					}
				}else{//w3c range
					sel = dijit.range.getSelection(this.window);
					if(sel && sel.removeAllRanges){
						sel.removeAllRanges();
						r = dijit.range.create(this.window);
						sNode = dijit.range.getNode(mark.startContainer,this.editNode);
						eNode = dijit.range.getNode(mark.endContainer,this.editNode);
						if(sNode && eNode){
							// Okay, we believe we found the position, so add it into the selection
							// There are cases where it may not be found, particularly in undo/redo, when
							// formatting as been done and so on, so don't restore selection then.
							r.setStart(sNode,mark.startOffset);
							r.setEnd(eNode,mark.endOffset);
							sel.addRange(r);
						}
					}
				}
			}
		},
		_changeToStep: function(from, to){
			// summary:
			//		Reverts editor to "to" setting, from the undo stack.
			// tags:
			//		private
			this.setValue(to.text);
			var b=to.bookmark;
			if(!b){ return; }
			this._moveToBookmark(b);
		},
		undo: function(){
			// summary:
			//		Handler for editor undo (ex: ctrl-z) operation
			// tags:
			//		private
			//console.log('undo');
			var ret = false;
			if(!this._undoRedoActive){
				this._undoRedoActive = true;
				this.endEditing(true);
				var s=this._steps.pop();
				if(s && this._steps.length>0){
					this.focus();
					this._changeToStep(s,this._steps[this._steps.length-1]);
					this._undoedSteps.push(s);
					this.onDisplayChanged();
					delete this._undoRedoActive;
					ret = true;
				}
				delete this._undoRedoActive;
			}
			return ret;
		},
		redo: function(){
			// summary:
			//		Handler for editor redo (ex: ctrl-y) operation
			// tags:
			//		private
			//console.log('redo');
			var ret = false;
			if(!this._undoRedoActive){
				this._undoRedoActive = true;
				this.endEditing(true);
				var s=this._undoedSteps.pop();
				if(s && this._steps.length>0){
					this.focus();
					this._changeToStep(this._steps[this._steps.length-1],s);
					this._steps.push(s);
					this.onDisplayChanged();
					ret = true;
				}
				delete this._undoRedoActive;
			}
			return ret;
		},
		endEditing: function(ignore_caret){
			// summary:
			//		Called to note that the user has stopped typing alphanumeric characters, if it's not already noted.
			//		Deals with saving undo; see editActionInterval parameter.
			// tags:
			//		private
			if(this._editTimer){
				clearTimeout(this._editTimer);
			}
			if(this._inEditing){
				this._endEditing(ignore_caret);
				this._inEditing=false;
			}
		},

		_getBookmark: function(){
			// summary:
			//		Get the currently selected text
			// tags:
			//		protected
			var b=dojo.withGlobal(this.window,dijit.getBookmark);
			var tmp=[];
			if(b && b.mark){
				var mark = b.mark;
				if(dojo.isIE < 9){
					// Try to use the pseudo range API on IE for better accuracy.
					var sel = dijit.range.getSelection(this.window);
					if(!dojo.isArray(mark)){
						if(sel){
							var range;
							if(sel.rangeCount){
								range = sel.getRangeAt(0);
							}
							if(range){
								b.mark = range.cloneRange();
							}else{
								b.mark = dojo.withGlobal(this.window,dijit.getBookmark);
							}
						}
					}else{
						// Control ranges (img, table, etc), handle differently.
						dojo.forEach(b.mark,function(n){
							tmp.push(dijit.range.getIndex(n,this.editNode).o);
						},this);
						b.mark = tmp;
					}
				}
				try{
					if(b.mark && b.mark.startContainer){
						tmp=dijit.range.getIndex(b.mark.startContainer,this.editNode).o;
						b.mark={startContainer:tmp,
							startOffset:b.mark.startOffset,
							endContainer:b.mark.endContainer===b.mark.startContainer?tmp:dijit.range.getIndex(b.mark.endContainer,this.editNode).o,
							endOffset:b.mark.endOffset};
					}
				}catch(e){
					b.mark = null;
				}
			}
			return b;
		},
		_beginEditing: function(cmd){
			// summary:
			//		Called when the user starts typing alphanumeric characters.
			//		Deals with saving undo; see editActionInterval parameter.
			// tags:
			//		private
			if(this._steps.length === 0){
				// You want to use the editor content without post filtering
				// to make sure selection restores right for the 'initial' state.
				// and undo is called.  So not using this.value, as it was 'processed'
				// and the line-up for selections may have been altered.
				this._steps.push({'text':dijit._editor.getChildrenHtml(this.editNode),'bookmark':this._getBookmark()});
			}
		},
		_endEditing: function(ignore_caret){
			// summary:
			//		Called when the user stops typing alphanumeric characters.
			//		Deals with saving undo; see editActionInterval parameter.
			// tags:
			//		private
			// Avoid filtering to make sure selections restore.
			var v = dijit._editor.getChildrenHtml(this.editNode);

			this._undoedSteps=[];//clear undoed steps
			this._steps.push({text: v, bookmark: this._getBookmark()});
		},
		onKeyDown: function(e){
			// summary:
			//		Handler for onkeydown event.
			// tags:
			//		private

			//We need to save selection if the user TAB away from this editor
			//no need to call _saveSelection for IE, as that will be taken care of in onBeforeDeactivate
			if(!dojo.isIE && !this.iframe && e.keyCode == dojo.keys.TAB && !this.tabIndent){
				this._saveSelection();
			}
			if(!this.customUndo){
				this.inherited(arguments);
				return;
			}
			var k = e.keyCode, ks = dojo.keys;
			if(e.ctrlKey && !e.altKey){//undo and redo only if the special right Alt + z/y are not pressed #5892
				if(k == 90 || k == 122){ //z
					dojo.stopEvent(e);
					this.undo();
					return;
				}else if(k == 89 || k == 121){ //y
					dojo.stopEvent(e);
					this.redo();
					return;
				}
			}
			this.inherited(arguments);

			switch(k){
					case ks.ENTER:
					case ks.BACKSPACE:
					case ks.DELETE:
						this.beginEditing();
						break;
					case 88: //x
					case 86: //v
						if(e.ctrlKey && !e.altKey && !e.metaKey){
							this.endEditing();//end current typing step if any
							if(e.keyCode == 88){
								this.beginEditing('cut');
								//use timeout to trigger after the cut is complete
								setTimeout(dojo.hitch(this, this.endEditing), 1);
							}else{
								this.beginEditing('paste');
								//use timeout to trigger after the paste is complete
								setTimeout(dojo.hitch(this, this.endEditing), 1);
							}
							break;
						}
						//pass through
					case ks.ALT:
						this.endEditing();
						break;
					case ks.UP_ARROW:
					case ks.DOWN_ARROW:
					case ks.LEFT_ARROW:
					case ks.RIGHT_ARROW:
					case ks.HOME:
					case ks.END:
					case ks.PAGE_UP:
					case ks.PAGE_DOWN:
						this.endEditing(true);
						break;
					//maybe ctrl+backspace/delete, so don't endEditing when ctrl is pressed
					case ks.CTRL:
					case ks.SHIFT:
					case ks.TAB:
						break;
					default:
						if(!e.ctrlKey && !e.altKey && !e.metaKey && (e.keyCode<dojo.keys.F1 || e.keyCode>dojo.keys.F15)){
							this.beginEditing();
							break;
						}
				}
		},
		_onBlur: function(){
			// summary:
			//		Called from focus manager when focus has moved away from this editor
			// tags:
			//		protected

			//this._saveSelection();
			this.inherited(arguments);
			this.endEditing(true);
		},
		_saveSelection: function(){
			// summary:
			//		Save the currently selected text in _savedSelection attribute
			// tags:
			//		private
			try{
				this._savedSelection=this._getBookmark();
			}catch(e){ /* Squelch any errors that occur if selection save occurs due to being hidden simultaniously. */}
		},
		_restoreSelection: function(){
			// summary:
			//		Re-select the text specified in _savedSelection attribute;
			//		see _saveSelection().
			// tags:
			//		private
			if(this._savedSelection){
				// Clear off cursor to start, we're deliberately going to a selection.
				delete this._cursorToStart;
				// only restore the selection if the current range is collapsed
				// if not collapsed, then it means the editor does not lose
				// selection and there is no need to restore it
				if(dojo.withGlobal(this.window,'isCollapsed',dijit)){
					this._moveToBookmark(this._savedSelection);
				}
				delete this._savedSelection;
			}
		},

		onClick: function(){
			// summary:
			//		Handler for when editor is clicked
			// tags:
			//		protected
			this.endEditing(true);
			this.inherited(arguments);
		},

		replaceValue: function(/*String*/ html){
			// summary:
			//		over-ride of replaceValue to support custom undo and stack maintainence.
			// tags:
			//		protected
			if(!this.customUndo){
				this.inherited(arguments);
			}else{
				if(this.isClosed){
					this.setValue(html);
				}else{
					this.beginEditing();
					if(!html){
						html = "&nbsp;";
					}
					this.setValue(html);
					this.endEditing();
				}
			}
		},
		
		_setDisabledAttr: function(/*Boolean*/ value){
			var disableFunc = dojo.hitch(this, function(){
				if((!this.disabled && value) || (!this._buttonEnabledPlugins && value)){
				// Disable editor: disable all enabled buttons and remember that list
					dojo.forEach(this._plugins, function(p){
						p.set("disabled", true);
				});
			}else if(this.disabled && !value){
					// Restore plugins to being active.
					dojo.forEach(this._plugins, function(p){
						p.set("disabled", false);
				});
			}
			});
			this.setValueDeferred.addCallback(disableFunc);
			this.inherited(arguments);
		},
		
		_setStateClass: function(){
			try{
				this.inherited(arguments);
			
				// Let theme set the editor's text color based on editor enabled/disabled state.
				// We need to jump through hoops because the main document (where the theme CSS is)
				// is separate from the iframe's document.
				if(this.document && this.document.body){
					dojo.style(this.document.body, "color", dojo.style(this.iframe, "color"));
				}
			}catch(e){ /* Squelch any errors caused by focus change if hidden during a state change */}
		}
	}
);

// Register the "default plugins", ie, the built-in editor commands
dojo.subscribe(dijit._scopeName + ".Editor.getPlugin",null,function(o){
	if(o.plugin){ return; }
	var args = o.args, p;
	var _p = dijit._editor._Plugin;
	var _fName = dijit._editor.plugins._FontNameDropDown;
	var _fSize = dijit._editor.plugins._FontSizeDropDown;
	var _fBlock = dijit._editor.plugins._FormatBlockDropDown;
	var _fColor = dijit._editor.plugins.TextColor;
	var name = args.name;
	switch(name){
		case "undo": case "redo": case "cut": case "copy": case "paste": case "insertOrderedList":
		case "insertUnorderedList": case "indent": case "outdent": case "justifyCenter":
		case "justifyFull": case "justifyLeft": case "justifyRight": case "delete":
		case "selectAll": case "removeFormat": case "unlink":
		case "insertHorizontalRule":
			p = new _p({ command: name });
			break;
		case "fontName": 
			p = new _fName({command: name});
			break;
		case "fontSize":
			p = new _fSize({command: name});
			break;
		case "formatBlock":
			p = new _fBlock({command: name});
			break;
		case "bold": case "italic": case "underline": case "strikethrough":
		case "subscript": case "superscript":
			p = new _p({ buttonClass: dijit.form.ToggleButton, command: name });
			break;
		case "|":
			p = new _p({ button: new dijit.ToolbarSeparator(), setEditor: function(editor) {this.editor = editor;} });
			break;
		default: 
		break;
	}
//	console.log('name',name,p);
	o.plugin=p;
});

}

if(!dojo._hasResource["dojox.grid.cells.dijit"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.cells.dijit"] = true;
dojo.provide("dojox.grid.cells.dijit");



// TODO: shouldn't it be the test file's job to require these modules,
// if it is using them?  Most of these modules aren't referenced by this file.













(function(){
	var dgc = dojox.grid.cells;
	dojo.declare("dojox.grid.cells._Widget", dgc._Base, {
		widgetClass: dijit.form.TextBox,
		constructor: function(inCell){
			this.widget = null;
			if(typeof this.widgetClass == "string"){
				dojo.deprecated("Passing a string to widgetClass is deprecated", "pass the widget class object instead", "2.0");
				this.widgetClass = dojo.getObject(this.widgetClass);
			}
		},
		formatEditing: function(inDatum, inRowIndex){
			this.needFormatNode(inDatum, inRowIndex);
			return "<div></div>";
		},
		getValue: function(inRowIndex){
			return this.widget.get('value');
		},
		setValue: function(inRowIndex, inValue){
			if(this.widget&&this.widget.set){
				//Look for lazy-loading editor and handle it via its deferred.
				if(this.widget.onLoadDeferred){
					var self = this;
					this.widget.onLoadDeferred.addCallback(function(){
						self.widget.set("value",inValue===null?"":inValue);
					});
				}else{
					this.widget.set("value", inValue);
				}
			}else{
				this.inherited(arguments);
			}
		},
		getWidgetProps: function(inDatum){
			return dojo.mixin(
				{
					dir: this.dir,
					lang: this.lang
				},
				this.widgetProps||{},
				{
					constraints: dojo.mixin({}, this.constraint) || {}, //TODO: really just for ValidationTextBoxes
					value: inDatum
				}
			);
		},
		createWidget: function(inNode, inDatum, inRowIndex){
			return new this.widgetClass(this.getWidgetProps(inDatum), inNode);
		},
		attachWidget: function(inNode, inDatum, inRowIndex){
			inNode.appendChild(this.widget.domNode);
			this.setValue(inRowIndex, inDatum);
		},
		formatNode: function(inNode, inDatum, inRowIndex){
			if(!this.widgetClass){
				return inDatum;
			}
			if(!this.widget){
				this.widget = this.createWidget.apply(this, arguments);
			}else{
				this.attachWidget.apply(this, arguments);
			}
			this.sizeWidget.apply(this, arguments);
			this.grid.views.renormalizeRow(inRowIndex);
			this.grid.scroller.rowHeightChanged(inRowIndex, true/*fix #11101*/);
			this.focus();
			return undefined;
		},
		sizeWidget: function(inNode, inDatum, inRowIndex){
			var
				p = this.getNode(inRowIndex),
				box = dojo.contentBox(p);
			dojo.marginBox(this.widget.domNode, {w: box.w});
		},
		focus: function(inRowIndex, inNode){
			if(this.widget){
				setTimeout(dojo.hitch(this.widget, function(){
					dojox.grid.util.fire(this, "focus");
				}), 0);
			}
		},
		_finish: function(inRowIndex){
			this.inherited(arguments);
			dojox.grid.util.removeNode(this.widget.domNode);
			if(dojo.isIE){
				dojo.setSelectable(this.widget.domNode, true);
			}
		}
	});
	dgc._Widget.markupFactory = function(node, cell){
		dgc._Base.markupFactory(node, cell);
		var d = dojo;
		var widgetProps = d.trim(d.attr(node, "widgetProps")||"");
		var constraint = d.trim(d.attr(node, "constraint")||"");
		var widgetClass = d.trim(d.attr(node, "widgetClass")||"");
		if(widgetProps){
			cell.widgetProps = d.fromJson(widgetProps);
		}
		if(constraint){
			cell.constraint = d.fromJson(constraint);
		}
		if(widgetClass){
			cell.widgetClass = d.getObject(widgetClass);
		}
	};

	dojo.declare("dojox.grid.cells.ComboBox", dgc._Widget, {
		widgetClass: dijit.form.ComboBox,
		getWidgetProps: function(inDatum){
			var items=[];
			dojo.forEach(this.options, function(o){
				items.push({name: o, value: o});
			});
			var store = new dojo.data.ItemFileReadStore({data: {identifier:"name", items: items}});
			return dojo.mixin({}, this.widgetProps||{}, {
				value: inDatum,
				store: store
			});
		},
		getValue: function(){
			var e = this.widget;
			// make sure to apply the displayed value
			e.set('displayedValue', e.get('displayedValue'));
			return e.get('value');
		}
	});
	dgc.ComboBox.markupFactory = function(node, cell){
		dgc._Widget.markupFactory(node, cell);
		var d=dojo;
		var options = d.trim(d.attr(node, "options")||"");
		if(options){
			var o = options.split(',');
			if(o[0] != options){
				cell.options = o;
			}
		}
	};

	dojo.declare("dojox.grid.cells.DateTextBox", dgc._Widget, {
		widgetClass: dijit.form.DateTextBox,
		setValue: function(inRowIndex, inValue){
			if(this.widget){
				this.widget.set('value', new Date(inValue));
			}else{
				this.inherited(arguments);
			}
		},
		getWidgetProps: function(inDatum){
			return dojo.mixin(this.inherited(arguments), {
				value: new Date(inDatum)
			});
		}
	});
	dgc.DateTextBox.markupFactory = function(node, cell){
		dgc._Widget.markupFactory(node, cell);
	};

	dojo.declare("dojox.grid.cells.CheckBox", dgc._Widget, {
		widgetClass: dijit.form.CheckBox,
		getValue: function(){
			return this.widget.checked;
		},
		setValue: function(inRowIndex, inValue){
			if(this.widget&&this.widget.attributeMap.checked){
				this.widget.set("checked", inValue);
			}else{
				this.inherited(arguments);
			}
		},
		sizeWidget: function(inNode, inDatum, inRowIndex){
			return;
		}
	});
	dgc.CheckBox.markupFactory = function(node, cell){
		dgc._Widget.markupFactory(node, cell);
	};

	dojo.declare("dojox.grid.cells.Editor", dgc._Widget, {
		widgetClass: dijit.Editor,
		getWidgetProps: function(inDatum){
			return dojo.mixin({}, this.widgetProps||{}, {
				height: this.widgetHeight || "100px"
			});
		},
		createWidget: function(inNode, inDatum, inRowIndex){
			// widget needs its value set after creation
			var widget = new this.widgetClass(this.getWidgetProps(inDatum), inNode);
			dojo.connect(widget, 'onLoad', dojo.hitch(this, 'populateEditor'));
			return widget;
		},
		formatNode: function(inNode, inDatum, inRowIndex){
			this.content = inDatum;
			this.inherited(arguments);
			if(dojo.isMoz){
				// FIXME: seem to need to reopen the editor and display the toolbar
				var e = this.widget;
				e.open();
				if(this.widgetToolbar){
					dojo.place(e.toolbar.domNode, e.editingArea, "before");
				}
			}
		},
		populateEditor: function(){
			this.widget.set('value', this.content);
			this.widget.placeCursorAtEnd();
		}
	});
	dgc.Editor.markupFactory = function(node, cell){
		dgc._Widget.markupFactory(node, cell);
		var d = dojo;
		var h = dojo.trim(dojo.attr(node, "widgetHeight")||"");
		if(h){
			if((h != "auto")&&(h.substr(-2) != "em")){
				h = parseInt(h, 10)+"px";
			}
			cell.widgetHeight = h;
		}
	};
})();

}

if(!dojo._hasResource["dojox.grid.enhanced._Plugin"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.enhanced._Plugin"] = true;
dojo.provide("dojox.grid.enhanced._Plugin");


dojo.declare("dojox.grid.enhanced._Plugin", null, {
	// summary:
	//		Base class for all plugins.
	//
	// description:
	//		Provides common plugin functionality and basic life cycle management.
	//
	//		Each concrete plugin must have a name field and is responsible for registering itself to the global plugin registry
	//		e.g. for dnd plugin:
	// |		dojox.grid.EnhancedGrid.registerPlugin("dnd" /*plugin name*/,
	// |												dojox.grid.enhanced.plugins.DnD /*full class name of a plugin*/
	// |												{"preInit": false, "dependency": ["nestedSorting"]} /*properties*/);
	//
	//		[Keywords] of plugin properties(case sensitive)
	//		- "preInit": boolean, whether a plugin should be created before EnhancedGrid.postCreate(),
	//		   false by default(plugins are created after EnhancedGrid.postCreate()).
	//		- "dependency": array or string, plugin(s) indicated by "dependency" will be created before the current one.
	//		   Note: recursive cycle dependencies are not supported e.g. following dependency is invalid:
	//		   pluginA -> pluginB -> pluginA
	//
	// example:
	//		1. Customize default DnD plugin
	// |	dojo.declare("mygrid.MyDnD", dojox.grid.enhanced.plugins.DnD, {
	// |		name:"dnd" //still reuse the plugin name
	// |		constructor: function(inGrid, option){ ... }
	// |	});
	// |	dojox.grid.EnhancedGrid.registerPlugin("dnd", mygrid.MyDnD);
	//
	//		2. Add new plugin - PluginA
	// |	dojo.declare("mygrid.PluginA", dojox.grid.enhanced._Plugin, {
	// |		name: "pA",
	// |		constructor: function(inGrid, option){ ... }
	// |	});
	// |	dojox.grid.EnhancedGrid.registerPlugin("pA",mygrid.PluginA);
	//
	//		3. Use plugins
	// |	dojo.require("mygrid.MyDnD");
	// |	dojo.require("mygrid.PluginA");
	
	// |	<script type="text/javascript">
	// |		var grid = new dojox.grid.EnhancedGrid(
	// |		{plugins: {dnd:true, pA:true}, ... }, dojo.byId("gridDiv"));
	// |		grid.startup();
	// |	</script>

	//name: String
	//		Plugin name, e.g. 'nestedSorting', 'dnd'...
	name: 'plugin',
	
	//grid: Object
	//		Grid that the plugin belongs to
	grid: null,

	//option: Object
	//		Plugin properties - leveraged with default and user specified properties.
	//		e.g. for dnd plugin, it may look like {"class": dojox.grid.enhanced.plugins.DnD, "dependency": ["nestedSorting"], ...}
	option: {},

	//_connects: Array
	//		List of all connections.
	_connects: [],
	
	//_subscribes: Array
	//		List of all subscribes.
	_subscribes: [],

	//privates: Object
	//		Private properties/methods shouldn't be mixin-ed anytime.
	privates: {},
	
	constructor: function(inGrid, option){
		this.grid = inGrid;
		this.option = option;
		this._connects = [];
		this._subscribes = [];
		this.privates = dojo.mixin({},dojox.grid.enhanced._Plugin.prototype);
		this.init();
	},
	
	init: function(){},
	
	onPreInit: function(){},
	
	onPostInit: function(){},
	
	onStartUp: function(){},
	
	connect: function(obj, event, method){
		// summary:
		//		Connects specified obj/event to specified method of this object.
		// example:
		//	|	var plugin = new dojox.grid.enhanced._Plugin(grid,"myPlugin",{...});
		//	|	// when foo.bar() is called, call the listener in the scope of plugin
		//	|	plugin.connect(foo, "bar", function(){
		//	|		console.debug(this.xxx());//"this" - plugin scope
		//	|	});
		var conn = dojo.connect(obj, event, this, method);
		this._connects.push(conn);
		return conn;
	},
	disconnect: function(handle){
		// summary:
		//		Disconnects handle and removes it from connection list.
		dojo.some(this._connects, function(conn, i, conns){
			if(conn == handle){
				dojo.disconnect(handle);
				conns.splice(i, 1);
				return true;
			}
			return false;
		});
	},
	subscribe: function(topic, method){
		// summary:
		//		Subscribes to the specified topic and calls the specified method
		//		of this object.
		// example:
		//	|	var plugin = new dojox.grid.enhanced._Plugin(grid,"myPlugin",{...});
		//	|	// when /my/topic is published, call the subscriber in the scope of plugin
		//	|	// with passed parameter - "v"
		//	|	plugin.subscribe("/my/topic", function(v){
		//	|		console.debug(this.xxx(v));//"this" - plugin scope
		//	|	});
		var subscribe = dojo.subscribe(topic, this, method);
		this._subscribes.push(subscribe);
		return subscribe;
	},
	unsubscribe: function(handle){
		// summary:
		//		Un-subscribes handle and removes it from subscriptions list.
		dojo.some(this._subscribes, function(subscribe, i, subscribes){
			if(subscribe == handle){
				dojo.unsubscribe(handle);
				subscribes.splice(i, 1);
				return true;
			}
			return false;
		});
	},
	onSetStore: function(store){
		// summary:
		//		Called when store is changed.
	},
	destroy: function(){
		// summary:
		//		Destroy all resources.
		dojo.forEach(this._connects, dojo.disconnect);
		dojo.forEach(this._subscribes, dojo.unsubscribe);
		delete this._connects;
		delete this._subscribes;
		delete this.option;
		delete this.privates;
		//console.log('Plugin [', this.name, '].destroy() executed!');
	}
});

//Each plugin is responsible for registering itself
// e.g. for DnD plugin(name:'dnd'):
// |	dojox.grid.EnhancedGrid.registerPlugin(dojox.grid.enhanced.plugins.DnD/*class*/,
// |		{"dependency": ["nestedSorting"]}/*Optional - properties*/);

}

if(!dojo._hasResource["dojox.grid.enhanced.plugins.IndirectSelection"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.enhanced.plugins.IndirectSelection"] = true;
dojo.provide("dojox.grid.enhanced.plugins.IndirectSelection");





dojo.declare("dojox.grid.enhanced.plugins.IndirectSelection", dojox.grid.enhanced._Plugin, {
	// summary:
	//		A handy way for adding check boxe/radio button for rows, and selecting rows by swiping(or keyboard)

	// description:
	//		For better rendering performance, div(images) are used to simulate radio button|check boxes
	//
	// example:
	//		<div dojoType="dojox.grid.EnhancedGrid" plugins="{indirectSelection: true}" ...></div>
	//		or <div dojoType="dojox.grid.EnhancedGrid" plugins="{indirectSelection: {name: 'xxx', width:'30px', styles:'text-align: center;'}}" ...></div>

	//name: String
	//		Plugin name
	name: "indirectSelection",
	
	constructor: function(){
		//Hook layout.setStructure(), so that indirectSelection is always included
		var layout = this.grid.layout;
		this.connect(layout, 'setStructure', dojo.hitch(layout, this.addRowSelectCell, this.option));
	},
	addRowSelectCell: function(option){
		// summary:
		//		Add indirectSelection cell(mapped to a column of radio button|check boxes)
		if(!this.grid.indirectSelection || this.grid.selectionMode == 'none'){
			return;
		}
		var rowSelectCellAdded = false, inValidFields = ['get', 'formatter', 'field', 'fields'],
		defaultCellDef = {type: dojox.grid.cells.MultipleRowSelector, name: '', width:'30px', styles:'text-align: center;'};
		if(option.headerSelector){ option.name = ''; }//mutual conflicting attrs

		if(this.grid.rowSelectCell){//remove the existed one
			this.grid.rowSelectCell.destroy();
		}
		
		dojo.forEach(this.structure, function(view){
			var cells = view.cells;
			if(cells && cells.length > 0 && !rowSelectCellAdded){
				var firstRow = cells[0];
				if(firstRow[0] && firstRow[0].isRowSelector){
					console.debug('addRowSelectCell() - row selector cells already added, return.');
					rowSelectCellAdded = true;
					return;
				}
				var selectDef, cellType = this.grid.selectionMode == 'single' ? dojox.grid.cells.SingleRowSelector : dojox.grid.cells.MultipleRowSelector;
				selectDef = dojo.mixin(defaultCellDef, option, {type: cellType, editable: false, notselectable: true, filterable: false, navigatable: true, nosort: true});
				dojo.forEach(inValidFields, function(field){//remove invalid fields
					if(field in selectDef){ delete selectDef[field]; }
				});
				if(cells.length > 1){ selectDef.rowSpan = cells.length; }//for complicate layout
				dojo.forEach(this.cells, function(cell, i){
					if(cell.index >= 0){
						cell.index += 1;
						//console.debug('cell '+ (cell.index - 1) +  ' is updated to index ' + cell.index);
					}else{
						console.warn('Error:IndirectSelection.addRowSelectCell()-  cell ' + i + ' has no index!');
					}
				});
				var rowSelectCell = this.addCellDef(0, 0, selectDef);
				rowSelectCell.index = 0;
				firstRow.unshift(rowSelectCell);
				this.cells.unshift(rowSelectCell);
				this.grid.rowSelectCell = rowSelectCell;
				rowSelectCellAdded = true;
			}
		}, this);
		this.cellCount = this.cells.length;
	},
	destroy: function(){
		if(this.grid && this.grid.rowSelectCell) {
			this.grid.rowSelectCell.destroy();
			delete this.grid.rowSelectCell;
		}
		this.inherited(arguments);
	}
});

dojo.declare("dojox.grid.cells.RowSelector", dojox.grid.cells._Widget, {
	// summary:
	//		 Common attributes & functions for row selectors(Radio|CheckBox)

	//inputType: String
	//		Input type - Radio|CheckBox
	inputType: "",
	
	//map: Object
	//		Cache div refs of radio|checkbox to avoid querying each time
	map: null,
	
	//disabledMap: Object
	//		Cache index of disabled rows
	disabledMap: null,
	
	//isRowSelector: Boolean
	//		Marker of indirectSelection cell(column)
	isRowSelector: true,

	//_connects: Array
	//		List of all connections.
	_connects: null,
	
	//_subscribes: Array
	//		List of all subscribes.
	_subscribes: null,

	//checkedText: String
	//		Checked character for high contrast mode
	checkedText: '&#8730;',

	//unCheckedText: String
	//		Unchecked character for high contrast mode
	unCheckedText: 'O',

	constructor: function(){
		this.map = {}; this.disabledMap = {}, this.disabledCount= 0;
		this._connects = []; this._subscribes = [];
		this.inA11YMode = dojo.hasClass(dojo.body(), "dijit_a11y");
		
		this.baseClass = "dojoxGridRowSelector dijitReset dijitInline dijit" + this.inputType;
		this.checkedClass = " dijit" + this.inputType + "Checked";
		this.disabledClass = " dijit" + this.inputType + "Disabled";
		this.checkedDisabledClass = " dijit" + this.inputType + "CheckedDisabled";
		this.statusTextClass = " dojoxGridRowSelectorStatusText";//a11y use

		this._connects.push(dojo.connect(this.grid, 'dokeyup', this, '_dokeyup'));
		this._connects.push(dojo.connect(this.grid.selection, 'onSelected', this, '_onSelected'));
		this._connects.push(dojo.connect(this.grid.selection, 'onDeselected', this, '_onDeselected'));
		this._connects.push(dojo.connect(this.grid.scroller, 'invalidatePageNode', this, '_pageDestroyed'));
		this._connects.push(dojo.connect(this.grid, 'onCellClick', this, '_onClick'));
		this._connects.push(dojo.connect(this.grid, 'updateRow', this, '_onUpdateRow'));
	},
	formatter: function(data, rowIndex){
		// summary:
		//		Overwritten, see dojox.grid.cells._Widget
		var clazz = this.baseClass;
		var checked = this.getValue(rowIndex);
		var disabled = !!this.disabledMap[rowIndex];//normalize 'undefined'
		
		if(checked){
			clazz += this.checkedClass;
			if(disabled){ clazz += this.checkedDisabledClass; }
		}else if(disabled){
			clazz += this.disabledClass;
		}
		if(window.isAccessibilityEnabled ) {
			
			var tempHtmlText =  (checked) ? (this.inputType + " " + misys.getLocalization('checked')) :  (this.inputType + " " + misys.getLocalization('unchecked')) ;
				
			return ["<div tabindex = -1 ",
					"id = '" + this.grid.id + "_rowSelector_" + rowIndex + "' ",
					"name = '" + this.grid.id + "_rowSelector' class = '" + clazz + "' ",
					"role = 'presentation' aria-checked = '" + checked + "' aria-disabled = '" + disabled +
					"' aria-label = '" + dojo.string.substitute(this.grid._nls["indirectSelection" + this.inputType], [rowIndex + 1]) + " " + tempHtmlText + "' >",
					"<span class = '" + this.statusTextClass + "'>" + (checked ? this.checkedText : this.unCheckedText) + "</span>",
					"<span class = 'sr-only' aria-live='polite' id='" + this.grid.id + "_rowSelector_" + rowIndex + "live' />",
					"</div>"].join("");
		} else {
			return ["<div tabindex = -1 ",
					"id = '" + this.grid.id + "_rowSelector_" + rowIndex + "' ",
					"name = '" + this.grid.id + "_rowSelector' class = '" + clazz + "' ",
					"role = 'presentation' aria-pressed = '" + checked + "' aria-disabled = '" + disabled +
					"' aria-label = '" + dojo.string.substitute(this.grid._nls["indirectSelection" + this.inputType], [rowIndex + 1]) + "'>",
					"<span class = '" + this.statusTextClass + "'>" + (checked ? this.checkedText : this.unCheckedText) + "</span>",
					"</div>"].join("");			
		}
	},
	setValue: function(rowIndex, inValue){
		// summary:
		//		Overwritten, see dojox.grid.cells._Widget
		//		Simply return, no action
	},
	getValue: function(rowIndex){
		// summary:
		//		Overwritten, see dojox.grid.cells._Widget
		return this.grid.selection.isSelected(rowIndex);
	},
	toggleRow: function(index, value){
		// summary:
		//		toggle checked | unchecked state for given row
		// index: Integer
		//		Row index
		// value: Boolean
		//		True - checked | False - unchecked
		this._nativeSelect(index, value);
	},
	setDisabled: function(index, disabled){
		// summary:
		//		toggle disabled | enabled state for given row
		// idx: Integer
		//		Row index
		// disabled: Boolean
		//		True - disabled | False - enabled
		if(index < 0){ return; }
		this._toggleDisabledStyle(index, disabled);
	},
	disabled: function(index){
		// summary:
		//		Check if one row is disabled
		return !!this.disabledMap[index];
	},
	_onClick: function(e){
		// summary:
		//		When mouse click on the selector cell, select/deselect the row.
		if(e.cell === this){
			this._selectRow(e);
		}
	},
	_dokeyup: function(e){
		// summary:
		//		Event handler for key up event
		//		- from dojox.grid.enhanced._Events.dokeyup()
		// e: Event
		//		Key up event
		if(e.cellIndex == this.index && e.rowIndex >= 0 && e.keyCode == dojo.keys.SPACE){
			this._selectRow(e);
		}
	},
	focus: function(rowIndex){
		// summary:
		//		Set focus to given row
		// rowIndex: Integer
		//		Target row
		var selector = this.map[rowIndex];
		if(selector){ selector.focus(); }
	},
	_focusEndingCell: function(rowIndex, cellIndex){
		// summary:
		//		Set focus to the ending grid cell(rowIndex,cellIndex) when swipe selection finished
		// rowIndex: Integer
		//		Row index
		// cellIndex: Integer
		//		Column index
		var cell = this.grid.getCell(cellIndex);
		this.grid.focus.setFocusCell(cell, rowIndex);
	},
	_nativeSelect: function(index, value){
		// summary:
		//		Use grid's native selection
		this.grid.selection[value ? 'select' : 'deselect'](index);
	},
	_onSelected: function(index){
		// summary:
		//		Triggered when a row is selected
		this._toggleCheckedStyle(index, true);
	},
	_onDeselected: function(index){
		// summary:
		//		Triggered when a row is deselected
		this._toggleCheckedStyle(index, false);
	},
	_onUpdateRow: function(index){
		// summary:
		//		Clear cache when row is re-built.
		delete this.map[index];
	},
	_toggleCheckedStyle: function(index, value){
		// summary:
		//		Change css styles for checked | unchecked
		var selector = this._getSelector(index);
		if(selector){
			dojo.toggleClass(selector, this.checkedClass, value);
			if(this.disabledMap[index]){
				dojo.toggleClass(selector, this.checkedDisabledClass, value);
			}
			dijit.setWaiState(selector, 'checked', value);
			if(this.inA11YMode){
				dojo.attr(selector.firstChild, 'innerHTML', value ? this.checkedText : this.unCheckedText);
			}
			if(dojo.query("#"+this.grid.id + "_rowSelector_"+index+"live") && dojo.query("#"+this.grid.id + "_rowSelector_"+index+"live").length>0) 
			{
				var tempHtmlText1 =  (value) ? (this.inputType + " " + misys.getLocalization('checked')) :  (this.inputType + " " + misys.getLocalization('unchecked')) ;
				
				dojo.attr(dojo.query("#" + this.grid.id + "_rowSelector_"+index)[0],'aria-label', 
							dojo.string.substitute(this.grid._nls["indirectSelection" + this.inputType], [index + 1]) + " " + tempHtmlText1);
				
				var temp = dojo.query("#" + this.grid.id + "_rowSelector_"+index+"live")[0];
				var tempHtmlText = "";
				if(value) {
					tempHtmlText = this.inputType + " " + misys.getLocalization('checked');
					tempHtmlText = tempHtmlText + " " + dojo.string.substitute(this.grid._nls["indirectSelection" + this.inputType], [index + 1]) + " " + misys.getLocalization('checked') + ".";;
				} else {
					tempHtmlText = this.inputType + " " + misys.getLocalization('unchecked');
					tempHtmlText = tempHtmlText + " " + dojo.string.substitute(this.grid._nls["indirectSelection" + this.inputType], [index + 1]) + " " + misys.getLocalization('unchecked') + ".";;
				}	
				dojo.attr(temp, 'innerHTML',tempHtmlText);
			}			
		}
	},
	_toggleDisabledStyle: function(index, disabled){
		// summary:
		//		Change css styles for disabled | enabled
		var selector = this._getSelector(index);
		if(selector){
			dojo.toggleClass(selector, this.disabledClass, disabled);
			if(this.getValue(index)){
				dojo.toggleClass(selector, this.checkedDisabledClass, disabled);
			}
			dijit.setWaiState(selector, 'disabled', disabled);
		}
		this.disabledMap[index] = disabled;
		if(index >= 0){
			this.disabledCount += disabled ? 1 : -1;
		}
	},
	_getSelector: function(index){
		// summary:
		//		Find selector for given row caching it if 1st time found
		var selector = this.map[index];
		if(!selector){//use accurate query for better performance
			var rowNode = this.view.rowNodes[index];
			if(rowNode){
				selector = dojo.query('.dojoxGridRowSelector', rowNode)[0];
				if(selector){ this.map[index] = selector; }
			}
		}
		return selector;
	},
	_pageDestroyed: function(pageIndex){
		// summary:
		//		Explicitly empty map cache when a page destroyed
		//		See dojox.grid._Scroller.invalidatePageNode()
		// pageIndex: Integer
		//		Index of destroyed page
		var rowsPerPage = this.grid.scroller.rowsPerPage;
		var start = pageIndex * rowsPerPage, end = start + rowsPerPage - 1;
		for(var i = start; i <= end; i++){
			if(!this.map[i]){continue;}
			dojo.destroy(this.map[i]);
			delete this.map[i];
		}
		//console.log("Page ",pageIndex, " destroyed, Map=",this.map);
	},
	destroy: function(){
		for(var i in this.map){
			dojo.destroy(this.map[i]);
			delete this.map[i];
		}
		for(i in this.disabledMap){ delete this.disabledMap[i]; }
		dojo.forEach(this._connects, dojo.disconnect);
		dojo.forEach(this._subscribes, dojo.unsubscribe);
		delete this._connects;
		delete this._subscribes;
		//console.log('Single(Multiple)RowSelector.destroy() executed!');
	}
});

dojo.declare("dojox.grid.cells.SingleRowSelector", dojox.grid.cells.RowSelector, {
	// summary:
	//		IndirectSelection cell(column) for single selection mode, using styles of dijit.form.RadioButton
	inputType: "Radio",

	_selectRow: function(e){
		// summary:
		//		Select the target row
		// e: Event
		//		Event fired on the target row
		var index = e.rowIndex;
		if(this.disabledMap[index]){ return; }
		this._focusEndingCell(index, 0);
		this._nativeSelect(index, !this.grid.selection.selected[index]);
	},
	toggleAllSelection:function(checked){
		// summary:
		//		Toggle select all|deselect all
		// checked: Boolean
		//		True - select all, False - deselect all
		var grid = this.grid, selection = grid.selection;
		if(checked){
			selection.selectRange(0, grid.rowCount-1);
		}else{
			selection.deselectAll();
		}
		this.toggleAllTrigerred = true;
		
		var rowCount =  this.grid.rowCount; 
    	for(var i=0;i<rowCount;i++){
    		var item = this.grid.getItem(i);
    		var flag;
			if(item){ 
				flag = this.grid.store.getValue(item,'disable_selection'); 
			} 
			if(flag === 'Y'){
				this.grid.rowSelectCell.toggleRow(i, false);
			}
    	}
	}
});

dojo.declare("dojox.grid.cells.MultipleRowSelector", dojox.grid.cells.RowSelector, {
	// summary:
	//		Indirect selection cell for multiple or extended mode, using dijit.form.CheckBox
	inputType: "CheckBox",
	
	//swipeStartRowIndex: Integer
	//		Start row index for swipe selection
	swipeStartRowIndex: -1,

	//swipeMinRowIndex: Integer
	//		Min row index for swipe selection
	swipeMinRowIndex: -1,
	
	//swipeMinRowIndex: Integer
	//		Max row index for swipe selection
	swipeMaxRowIndex: -1,
	
	//toSelect: Boolean
	//		new state for selection
	toSelect: false,
	
	//lastClickRowIdx: Integer
	//		Row index for last click, used for range selection via Shift + click
	lastClickRowIdx: -1,
	
	//toggleAllTrigerred: Boolean
	//		Whether toggle all has been triggered or not
	toggleAllTrigerred: false,
	
	unCheckedText: '&#9633;',

	constructor: function(){
		this._connects.push(dojo.connect(dojo.doc, 'onmouseup', this, '_domouseup'));
		this._connects.push(dojo.connect(this.grid, 'onRowMouseOver', this, '_onRowMouseOver'));
		this._connects.push(dojo.connect(this.grid.focus, 'move', this, '_swipeByKey'));
		this._connects.push(dojo.connect(this.grid, 'onCellMouseDown', this, '_onMouseDown'));
		if(this.headerSelector){//option set by user to add a select-all checkbox in column header
			this._connects.push(dojo.connect(this.grid.views, 'render', this, '_addHeaderSelector'));
			this._connects.push(dojo.connect(this.grid, 'onSelectionChanged', this, '_onSelectionChanged'));
			this._connects.push(dojo.connect(this.grid, 'onKeyDown', this, function(e){
				if(e.rowIndex == -1 && e.cellIndex == this.index && e.keyCode == dojo.keys.SPACE){
					this._toggletHeader();//TBD - a better way
				}
			}));
		}
	},
	toggleAllSelection:function(checked){
		// summary:
		//		Toggle select all|deselect all
		// checked: Boolean
		//		True - select all, False - deselect all
		var grid = this.grid, selection = grid.selection;
		if(checked){
			selection.selectRange(0, grid.rowCount-1);
		}else{
			selection.deselectAll();
		}
		this.toggleAllTrigerred = true;
	},
	_onMouseDown: function(e){
		if(e.cell == this){
			this._startSelection(e.rowIndex);
			dojo.stopEvent(e);
		}
	},
	_onRowMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over a data row(outside of this column).
		//      - from dojox.grid.enhanced._Events.onRowMouseOver()
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this._updateSelection(e, 0);
	},
	_domouseup: function(e){
		// summary:
		//		Event handler for mouse up event - from dojo.doc.domouseup()
		// e: Event
		//		Mouse up event
		if(dojo.isIE){
			this.view.content.decorateEvent(e);//TODO - why only e in IE hasn't been decorated?
		}
		var inSwipeSelection = e.cellIndex >= 0 && this.inSwipeSelection() && !this.grid.edit.isEditRow(e.rowIndex);
		if(inSwipeSelection){
			this._focusEndingCell(e.rowIndex, e.cellIndex);
		}
		this._finishSelect();
	},
	_dokeyup: function(e){
		// summary:
		//		Event handler for key up event
		//		- from dojox.grid.enhanced._Events.dokeyup()
		// e: Event
		//		Key up event
		this.inherited(arguments);
		if(!e.shiftKey){
			this._finishSelect();
		}
	},
	_startSelection: function(rowIndex){
		// summary:
		//		Initialize parameters to start a new swipe selection
		// rowIndex: Integer
		//		Index of the start row
		this.swipeStartRowIndex = this.swipeMinRowIndex = this.swipeMaxRowIndex = rowIndex;
		this.toSelect = !this.getValue(rowIndex);
	},
	_updateSelection: function(e, delta){
		// summary:
		//		Update row selections, fired during a swipe selection
		// e: Event
		//		Event of the current row,
		// delta: Integer
		//		Row index delta, used for swipe selection via Shift + Arrow key
		//		0: not via key, -1 : Shift +  Up, 1 : Shift + Down
		if(!this.inSwipeSelection()){ return; }
		
		var byKey = delta !== 0;//whether via Shift + Arrow Key
		var currRow = e.rowIndex, deltaRow = currRow - this.swipeStartRowIndex + delta;
		if(deltaRow > 0 && this.swipeMaxRowIndex < currRow + delta){
			this.swipeMaxRowIndex = currRow + delta;
		}
		if(deltaRow < 0 && this.swipeMinRowIndex > currRow + delta){
			this.swipeMinRowIndex = currRow + delta;
		}

		var min = deltaRow > 0 ? this.swipeStartRowIndex : currRow + delta;
		var max = deltaRow > 0 ? currRow + delta : this.swipeStartRowIndex;
		for(var i = this.swipeMinRowIndex; i <= this.swipeMaxRowIndex; i++){
			if(this.disabledMap[i] || i < 0){ continue; }
			if(i >= min && i <= max){//deltaRow != 0 || this.toSelect
				this._nativeSelect(i, this.toSelect);
			}else if(!byKey){
				this._nativeSelect(i, !this.toSelect);
			}
		}
	},
	_swipeByKey: function(rowOffset, colOffset, e){
		// summary:
		//		Update row selections, fired when Shift + Cursor is used for swipe selection
		//		See dojox.grid.enhanced._Events.onKeyDown
		// e: Event
		//		Event of the current row,
		// rowOffset: Integer
		//		Row offset, used for swipe selection via Shift + Cursor
		//		-1 : Shift +  Up, 1 : Shift + Down
		if(!e || rowOffset === 0 || !e.shiftKey || e.cellIndex != this.index ||
			this.grid.focus.rowIndex < 0){ //TBD - e.rowIndex == 0 && delta == -1
			return;
		}
		var rowIndex = e.rowIndex;
		if(this.swipeStartRowIndex < 0){
			//A new swipe selection starts via Shift + Arrow key
			this.swipeStartRowIndex = rowIndex;
			if(rowOffset > 0){//Shift + Down
				this.swipeMaxRowIndex = rowIndex + rowOffset;
				this.swipeMinRowIndex = rowIndex;
			}else{//Shift + UP
				this.swipeMinRowIndex = rowIndex + rowOffset;
				this.swipeMaxRowIndex = rowIndex;
			}
			this.toSelect = this.getValue(rowIndex);
		}
		this._updateSelection(e, rowOffset);
	},
	_finishSelect: function(){
		// summary:
		//		Reset parameters to end a swipe selection
		this.swipeStartRowIndex = -1;
		this.swipeMinRowIndex = -1;
		this.swipeMaxRowIndex = -1;
		this.toSelect = false;
	},
	inSwipeSelection: function(){
		// summary:
		//		Check if during a swipe selection
		// return: Boolean
		//		Whether in swipe selection
		return this.swipeStartRowIndex >= 0;
	},
	_nativeSelect: function(index, value){
		// summary:
		//		Overwritten
		this.grid.selection[value ? 'addToSelection' : 'deselect'](index);
	},
	_selectRow: function(e){
		// summary:
		//		Select the target row or range or rows
		// e: Event
		//		Event fired on the target row
		var rowIndex = e.rowIndex;
		if(this.disabledMap[rowIndex]){ return; }
		dojo.stopEvent(e);
		this._focusEndingCell(rowIndex, 0);
		
		var delta = rowIndex - this.lastClickRowIdx;
		var newValue = !this.grid.selection.selected[rowIndex];
		if(this.lastClickRowIdx >= 0 && !e.ctrlKey && !e.altKey && e.shiftKey){
			var min = delta > 0 ? this.lastClickRowIdx : rowIndex;
			var max = delta > 0 ? rowIndex : this.lastClickRowIdx;
			for(var i = min; i >= 0 && i <= max; i++){
				this._nativeSelect(i, newValue);
			}
		}else{
			this._nativeSelect(rowIndex, newValue);
		}
		this.lastClickRowIdx = rowIndex;
	},
	getValue: function(rowIndex){
		// summary:
		//		Overwritten
		if(rowIndex == -1){//header selector
			var g = this.grid;
			return g.rowCount > 0 && g.rowCount <= g.selection.getSelectedCount();
		}
		return this.inherited(arguments);
	},
	_addHeaderSelector: function(){
		// summary:
		//		Add selector in column header for selecting|deselecting all
		var headerCellNode = this.view.getHeaderCellNode(this.index);
		if(!headerCellNode){ return; }
		dojo.empty(headerCellNode);
		var g = this.grid;
		var selector = headerCellNode.appendChild(dojo.create("div", {
			"tabindex": -1, "id": g.id + "_rowSelector_-1", "class": this.baseClass, "role": "presentation",
			"innerHTML": "<span class = '" + this.statusTextClass +
				"'></span><span style='height: 0; width: 0; overflow: hidden; display: block;'>" +
				g._nls["selectAll"] + "</span>"
		}));
		this.map[-1] = selector;
		var idx = this._headerSelectorConnectIdx;
		if(idx !== undefined){
			dojo.disconnect(this._connects[idx]);
			this._connects.splice(idx, 1);
		}
		this._headerSelectorConnectIdx = this._connects.length;
		this._connects.push(dojo.connect(selector, 'onclick', this, '_toggletHeader'));
		this._onSelectionChanged();
	},
	_toggletHeader: function(){
		// summary:
		//		Toggle state for head selector
		if(!!this.disabledMap[-1]){ return; }
		this.grid._selectingRange = true;
		this.toggleAllSelection(!this.getValue(-1));
		this._onSelectionChanged();
		this.grid._selectingRange = false;
	},
	_onSelectionChanged: function(){
		// summary:
		//		Update header selector anytime selection changed
		var g = this.grid;
		if(!this.map[-1] || g._selectingRange){ return; }
		this._toggleCheckedStyle(-1, this.getValue(-1));
	},
	_toggleDisabledStyle: function(index, disabled){
		// summary:
		//		Overwritten
		this.inherited(arguments);
		if(this.headerSelector){
			var allDisabled = (this.grid.rowCount == this.disabledCount);
			if(allDisabled != !!this.disabledMap[-1]){//only if needed
				arguments[0] = -1;
				arguments[1] = allDisabled;
				this.inherited(arguments);
			}
		}
	}
});

dojox.grid.EnhancedGrid.registerPlugin(dojox.grid.enhanced.plugins.IndirectSelection/*name:'indirectSelection'*/, {"preInit": true});

}

if(!dojo._hasResource["dojo.NodeList-traverse"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.NodeList-traverse"] = true;
dojo.provide("dojo.NodeList-traverse");


/*=====
dojo["NodeList-traverse"] = {
	// summary: Adds a chainable methods to dojo.query() / Nodelist instances for traversing the DOM
};
=====*/

dojo.extend(dojo.NodeList, {
	_buildArrayFromCallback: function(/*Function*/callback){
		// summary:
		// 		builds a new array of possibly differing size based on the input list.
		// 		Since the returned array is likely of different size than the input array,
		// 		the array's map function cannot be used.
		var ary = [];
		for(var i = 0; i < this.length; i++){
			var items = callback.call(this[i], this[i], ary);
			if(items){
				ary = ary.concat(items);
			}
		}
		return ary;
	},

	_getUniqueAsNodeList: function(nodes){
		// summary:
		// 		given a list of nodes, make sure only unique
		// 		elements are returned as our NodeList object.
		// 		Does not call _stash().
		var ary = [];
		//Using for loop for better speed.
		for(var i = 0, node; node = nodes[i]; i++){
			//Should be a faster way to do this. dojo.query has a private
			//_zip function that may be inspirational, but there are pathways
			//in query that force nozip?
			if(node.nodeType == 1 && dojo.indexOf(ary, node) == -1){
				ary.push(node);
			}
		}
		return this._wrap(ary, null, this._NodeListCtor);	 //dojo.NodeList
	},

	_getUniqueNodeListWithParent: function(nodes, query){
		// summary:
		// 		gets unique element nodes, filters them further
		// 		with an optional query and then calls _stash to track parent NodeList.
		var ary = this._getUniqueAsNodeList(nodes);
		ary = (query ? dojo._filterQueryResult(ary, query) : ary);
		return ary._stash(this);  //dojo.NodeList
	},

	_getRelatedUniqueNodes: function(/*String?*/query, /*Function*/callback){
		// summary:
		// 		cycles over all the nodes and calls a callback
		// 		to collect nodes for a possible inclusion in a result.
		// 		The callback will get two args: callback(node, ary),
		// 		where ary is the array being used to collect the nodes.
		return this._getUniqueNodeListWithParent(this._buildArrayFromCallback(callback), query);  //dojo.NodeList
	},

	children: function(/*String?*/query){
		// summary:
		// 		Returns all immediate child elements for nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the child elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, all immediate child elements for the nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".container").children();
		//		returns the four divs that are children of the container div.
		//		Running this code:
		//	|	dojo.query(".container").children(".red");
		//		returns the two divs that have the class "red".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			return dojo._toArray(node.childNodes);
		}); //dojo.NodeList
	},

	closest: function(/*String*/query, /*String|DOMNode?*/ root){
		// summary:
		// 		Returns closest parent that matches query, including current node in this
		// 		dojo.NodeList if it matches the query.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// root:
		//		If specified, query is relative to "root" rather than document body.
		// returns:
		//		dojo.NodeList, the closest parent that matches the query, including the current
		//		node in this dojo.NodeList if it matches the query.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".red").closest(".container");
		//		returns the div with class "container".
		return this._getRelatedUniqueNodes(null, function(node, ary){
			do{
				if(dojo._filterQueryResult([node], query, root).length){
					return node;
				}
			}while(node != root && (node = node.parentNode) && node.nodeType == 1);
			return null; //To make rhino strict checking happy.
		}); //dojo.NodeList
	},

	parent: function(/*String?*/query){
		// summary:
		// 		Returns immediate parent elements for nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the parent elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, immediate parent elements for nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first"><span class="text">Blue One</span></div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue"><span class="text">Blue Two</span></div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".text").parent();
		//		returns the two divs with class "blue".
		//		Running this code:
		//	|	dojo.query(".text").parent(".first");
		//		returns the one div with class "blue" and "first".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			return node.parentNode;
		}); //dojo.NodeList
	},

	parents: function(/*String?*/query){
		// summary:
		// 		Returns all parent elements for nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the child elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, all parent elements for nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first"><span class="text">Blue One</span></div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue"><span class="text">Blue Two</span></div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".text").parents();
		//		returns the two divs with class "blue", the div with class "container",
		// 	|	the body element and the html element.
		//		Running this code:
		//	|	dojo.query(".text").parents(".container");
		//		returns the one div with class "container".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = []
			while(node.parentNode){
				node = node.parentNode;
				pary.push(node);
			}
			return pary;
		}); //dojo.NodeList
	},

	siblings: function(/*String?*/query){
		// summary:
		// 		Returns all sibling elements for nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the sibling elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, all sibling elements for nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".first").siblings();
		//		returns the two divs with class "red" and the other div
		// 	|	with class "blue" that does not have "first".
		//		Running this code:
		//	|	dojo.query(".first").siblings(".red");
		//		returns the two div with class "red".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = []
			var nodes = (node.parentNode && node.parentNode.childNodes);
			for(var i = 0; i < nodes.length; i++){
				if(nodes[i] != node){
					pary.push(nodes[i]);
				}
			}
			return pary;
		}); //dojo.NodeList
	},

	next: function(/*String?*/query){
		// summary:
		// 		Returns the next element for nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the next elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, the next element for nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue last">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".first").next();
		//		returns the div with class "red" and has innerHTML of "Red Two".
		//		Running this code:
		//	|	dojo.query(".last").next(".red");
		//		does not return any elements.
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var next = node.nextSibling;
			while(next && next.nodeType != 1){
				next = next.nextSibling;
			}
			return next;
		}); //dojo.NodeList
	},

	nextAll: function(/*String?*/query){
		// summary:
		// 		Returns all sibling elements that come after the nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the sibling elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, all sibling elements that come after the nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red next">Red Two</div>
		// 	|		<div class="blue next">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".first").nextAll();
		//		returns the two divs with class of "next".
		//		Running this code:
		//	|	dojo.query(".first").nextAll(".red");
		//		returns the one div with class "red" and innerHTML "Red Two".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = []
			var next = node;
			while((next = next.nextSibling)){
				if(next.nodeType == 1){
					pary.push(next);
				}
			}
			return pary;
		}); //dojo.NodeList
	},

	prev: function(/*String?*/query){
		// summary:
		// 		Returns the previous element for nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the previous elements.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, the previous element for nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".first").prev();
		//		returns the div with class "red" and has innerHTML of "Red One".
		//		Running this code:
		//	|	dojo.query(".first").prev(".blue");
		//		does not return any elements.
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var prev = node.previousSibling;
			while(prev && prev.nodeType != 1){
				prev = prev.previousSibling;
			}
			return prev;
		}); //dojo.NodeList
	},

	prevAll: function(/*String?*/query){
		// summary:
		// 		Returns all sibling elements that come before the nodes in this dojo.NodeList.
		// 		Optionally takes a query to filter the sibling elements.
		// description:
		// 		The returned nodes will be in reverse DOM order -- the first node in the list will
		// 		be the node closest to the original node/NodeList.
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		//	query:
		//		a CSS selector.
		// returns:
		//		dojo.NodeList, all sibling elements that come before the nodes in this dojo.NodeList.
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red prev">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue prev">Blue One</div>
		// 	|		<div class="red second">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".second").prevAll();
		//		returns the two divs with class of "prev".
		//		Running this code:
		//	|	dojo.query(".first").prevAll(".red");
		//		returns the one div with class "red prev" and innerHTML "Red One".
		return this._getRelatedUniqueNodes(query, function(node, ary){
			var pary = []
			var prev = node;
			while((prev = prev.previousSibling)){
				if(prev.nodeType == 1){
					pary.push(prev);
				}
			}
			return pary;
		}); //dojo.NodeList
	},

	andSelf: function(){
		// summary:
		// 		Adds the nodes from the previous dojo.NodeList to the current dojo.NodeList.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// returns:
		//		dojo.NodeList
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red prev">Red One</div>
		// 	|		Some Text
		// 	|		<div class="blue prev">Blue One</div>
		// 	|		<div class="red second">Red Two</div>
		// 	|		<div class="blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".second").prevAll().andSelf();
		//		returns the two divs with class of "prev", as well as the div with class "second".
		return this.concat(this._parent);
	},

	//Alternate methods for the :first/:last/:even/:odd pseudos.
	first: function(){
		// summary:
		// 		Returns the first node in this dojo.NodeList as a dojo.NodeList.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// returns:
		//		dojo.NodeList, with the first node in this dojo.NodeList
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue last">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".blue").first();
		//		returns the div with class "blue" and "first".
		return this._wrap(((this[0] && [this[0]]) || []), this); //dojo.NodeList
	},

	last: function(){
		// summary:
		// 		Returns the last node in this dojo.NodeList as a dojo.NodeList.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// returns:
		//		dojo.NodeList, with the last node in this dojo.NodeList
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="red">Red One</div>
		// 	|		<div class="blue first">Blue One</div>
		// 	|		<div class="red">Red Two</div>
		// 	|		<div class="blue last">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".blue").last();
		//		returns the last div with class "blue",
		return this._wrap((this.length ? [this[this.length - 1]] : []), this); //dojo.NodeList
	},

	even: function(){
		// summary:
		// 		Returns the even nodes in this dojo.NodeList as a dojo.NodeList.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// returns:
		//		dojo.NodeList, with the even nodes in this dojo.NodeList
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="interior red">Red One</div>
		// 	|		<div class="interior blue">Blue One</div>
		// 	|		<div class="interior red">Red Two</div>
		// 	|		<div class="interior blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".interior").even();
		//		returns the two divs with class "blue"
		return this.filter(function(item, i){
			return i % 2 != 0;
		}); //dojo.NodeList
	},

	odd: function(){
		// summary:
		// 		Returns the odd nodes in this dojo.NodeList as a dojo.NodeList.
		// description:
		// 		.end() can be used on the returned dojo.NodeList to get back to the
		// 		original dojo.NodeList.
		// returns:
		//		dojo.NodeList, with the odd nodes in this dojo.NodeList
		//	example:
		//		assume a DOM created by this markup:
		//	|	<div class="container">
		// 	|		<div class="interior red">Red One</div>
		// 	|		<div class="interior blue">Blue One</div>
		// 	|		<div class="interior red">Red Two</div>
		// 	|		<div class="interior blue">Blue Two</div>
		//	|	</div>
		//		Running this code:
		//	|	dojo.query(".interior").odd();
		//		returns the two divs with class "red"
		return this.filter(function(item, i){
			return i % 2 == 0;
		}); //dojo.NodeList
	}
});

}

if(!dojo._hasResource["dojox.NodeList.delegate"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.NodeList.delegate"] = true;
dojo.provide("dojox.NodeList.delegate");



dojo.extend(dojo.NodeList, {
	delegate: function(/*String*/ selector, /*String*/ eventName, /*Function*/ fn){
		// summary:
		//		Monitor nodes in this NodeList for [bubbled] events on nodes that match selector.
		//		Calls fn(evt) for those events, where (inside of fn()), this == the node
		//		that matches the selector.
		// description:
		//		Sets up event handlers that can catch events on any subnodes matching a given selector,
		//		including nodes created after delegate() has been called.
		//
		//		This allows an app to setup a single event handler on a high level node, rather than many
		//		event handlers on subnodes. For example, one onclick handler for a Tree widget, rather than separate
		//		handlers for each node in the tree.
		//		Since setting up many event handlers is expensive, this can increase performance.
		//
		//		Note that delegate() will not work for events that don't bubble, like focus.
		//		onmouseenter/onmouseleave also don't currently work.
		// selector:
		//		CSS selector valid to `dojo.query`, like ".foo" or "div > span".  The
		//		selector is relative to the nodes in this NodeList, not the document root.
		//		For example myNodeList.delegate("> a", "onclick", ...) will catch events on
		//		anchor nodes which are (immediate) children of the nodes in myNodeList.
		// eventName:
		//		Standard event name used as an argument to `dojo.connect`, like "onclick".
		// fn:
		//		Callback function passed the event object, and where this == the node that matches the selector.
		//		That means that for example, after setting up a handler via
		//			 dojo.query("body").delegate("fieldset", "onclick", ...)
		//		clicking on a fieldset or *any nodes inside of a fieldset* will be reported
		//		as a click on the fieldset itself.
		// example:
		//	|	dojo.query("navbar").delegate("a", "onclick", function(evt){
		//	|			console.log("user clicked anchor ", this.node);
		//	|	});

		// Possible future tasks:
		//	- change signature of callback to be fn(node, evt), and then have scope argument
		//		to delegate(selector, eventName, scope, fn)?
		//	- support non-bubbling events like focus
		//	- support onmouseenter/onmouseleave
		// 	- maybe should return an array of connect handles instead, to allow undelegate()?
		//	- single node version

		return this.connect(eventName, function(evt){
			var closest = dojo.query(evt.target).closest(selector, this);
			if(closest.length){
				fn.call(closest[0], evt);
			}
		}); //dojo.NodeList
	}
});


}

if(!dojo._hasResource["misys.grid._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.grid._base"] = true;
dojo.provide("misys.grid._base");

// Copyright (c) 2000-2011 Misys (http://www.misys.com),
// All Rights Reserved. 
//
// summary: 
// 		Functions for grids
//
// description:
// 		Common methods for grid/list actions. Should be loaded first, as
// 		it creates the initial m.grid object
//
// version:   1.2
// date:      24/03/2011
// author:    Cormac Flynn





(function(/*Dojo*/d, /*Dijit*/dj, /*Misys*/m) {

	 // ECMA5 Strict Mode
	
	function _processRecords( /*Dijit._widget | Array of grids*/ grids,
							  /*String*/ url,
							  /*String*/ keys,
							  /*Function*/ handleCallback) {
		// summary: 
		//		Process records
	    // description: 
		//		The parameters to pass to xhrGet, the url, how to handle it,
		// 		and the callbacks.
		
		grids = d.isArray(grids) ? grids : [grids];
		
		var 
			urlParams = {
				"list_keys": keys
			},
			targetNode = d.byId("batchContainer"),
			xhrArgs;
		
		if(dj.byId("reauth_password")) {
			d.mixin(urlParams, {
				"reauth_password" : dj.byId("reauth_password").get("value")
			});
		}
		
		xhrArgs = {
				url: m.getServletURL(url),
				handleAs: "text",
				sync : true,
				content: urlParams,
				load: function(data){
					// Replace newlines with nice HTML tags.
					data = data.replace(/\n/g, "<br>");
		
					// Replace tabs with spaces.
					data = data.replace(/\t/g, "&nbsp;&nbsp;&nbsp;");
					targetNode.innerHTML = data;
		
					 setTimeout(function(){
				        	m.animate("wipeIn", "batchContainer");
					    }, 500);
		
					// Deselect all rows & rerender grids
					m._config.groups = [];
					d.forEach(grids, function(g){
						// Reload data
						g.setStore(g.store);
						d.hitch(g, "render")();
		   
						// Clear selection once data fetch complete
						m.connect(g, "_onFetchComplete", function(){
							g.selection.clear();
						});
					});
		        }
		};
		
		if (handleCallback)
		{
			d.mixin(xhrArgs, {handle: handleCallback});
		}	   

		// Call the asynchronous xhrPost
		m.xhrPost(xhrArgs);
	}
	
	//Holidays And CutOffTime Error Dialog With Auto Forward Operation
	/**
	 * <h4>Summary:</h4>
	 * This method is for showing error dialog for the holiday and cutoff time error.
	 * @param {String} mode
	 * @param {boolean} autoFormwardEnabled
	 * @method _showHolidaysNCutOffTimeErrorDialog
	 */
	function _showHolidaysNCutOffTimeErrorDialog(/*boolean*/autoForwardEnabled, /*String*/ message, /*boolean*/ reauthEnabled , xhrParams)
	{	
   	 	var mode = dijit.byId("mode") ? dijit.byId("mode").get("value") : "";
   	 	var autoForwardButton  = dijit.byId("forwardHolidayButtonId") ? dijit.byId("forwardHolidayButtonId") : new dj.form.Button({label:m.getLocalization("autoForwardMessage"),id:"forwardHolidayButtonId"});
   	 	//if holidayCutOffDialog not defined
   	 	if(!dj.byId("holidayCutOffDialog"))
   	 	{
   	 		d.require('misys.widget.Dialog');
			d.require('dijit.form.Button');
			
			//Create a dialog
			var dialog = new dj.Dialog({id: 'holidayCutOffDialog',
			    title: 'Confirmation',draggable: false});
			
			//Create dialog content
			var dialogContent = d.create("div", { id: "holidayCutOffDialogContent"});
			var dialogText = d.create("div", {id:"dialogHolidayText"},dialogContent,'first');
			var dialogButtons =   d.create("div",{id:"holidayCutOffDialogButtons",style:"text-align:center;"},dialogContent,'last');
			
			//Cancel Button
			var cancelButton  = new dj.form.Button({label:m.getLocalization("cancelMessage"),id:"cancelHolidayButtonId"});
			
			d.place(cancelButton.domNode,dialogButtons);
			dialog.set("content", dialogContent);
   	 	}
   	 	
		var holidayDialog = dj.byId("holidayCutOffDialog");
		if(autoForwardEnabled === true)
		{
			d.place(autoForwardButton.domNode,d.byId("holidayCutOffDialogButtons"),'first');
			m.dialog.connect(dj.byId('forwardHolidayButtonId'), 'onClick', function(){
				if(reauthEnabled)
				{
					holidayDialog.hide();
					m._config.doReauthSubmit(xhrParams);
					autoForwardButton.destroy();
				}
				else
				{
					holidayDialog.hide();
					m.xhrPost (xhrParams);
					setTimeout(d.hitch(grid, "render"), 100);
				}
			}, holidayDialog.id);
		}
		else
		{
			autoForwardButton.destroy();
			//dojo.destroy("forwardHolidayButtonId");
		}
		//Set the Error into the Dialog
		if(d.byId("dialogHolidayText"))
		{
			d.byId("dialogHolidayText").innerHTML = message;
			d.byId("dialogHolidayText").innerHTML =  d.byId("dialogHolidayText").innerHTML.replace(/\,/g,"");
		}
		// Disable window closing by using the escape key
		m.dialog.connect(holidayDialog, 'onKeyPress', function(evt) {
			if (evt.keyCode == d.keys.ESCAPE) {
				d.stopEvent(evt);
			}
		});
		
		//Dialog Connects
		
		m.dialog.connect(dj.byId('cancelHolidayButtonId'), 'onClick', function(){
			m.dialog.hide();
			autoForwardButton.destroy();
			holidayDialog.hide();
		}, holidayDialog.id);
		
		//On Hide of Dialog
		m.dialog.connect(holidayDialog, 'onHide', function() {
			autoForwardButton.destroy();
			m.dialog.disconnect(holidayDialog);
			m.dialog.hide();
		});
		
		//Show the Dialog
		holidayDialog.show();
	}
	
	//Excluding operations to skip traversing to first page in case of Pagination change
	/**
	 * <h4>Summary:</h4>
	 * This method returns boolean value based on excluding operations to skip traversing to first page in case of Pagination change
	 */
	function _isNotExcludedOperationTraversingToFirstPage()
	{
		var isNotExcludedOperation = true;
		if(dijit.byId('operation') && dijit.byId('operation').get('value') === "LIST_FX_DEALS")
		{
			isNotExcludedOperation = false;
		}	
		return isNotExcludedOperation;
	}

	//
	// Public functions & variables
	//
	m.grid = m.grid || {};
	d.mixin(m.grid, {
		setStore : function( /*Json store*/ storeJson, 
							 /*Obj*/ ioArgs, 
							 /*Dijit._widget*/ gridObj) {
			// summary:
			//		Sets the store on a grid
			//
			// @deprecated should be removed in favour of DataStores defined in the
			// HTML, and attached to the DataGrid via the store attribute
			
			var grid = gridObj || ioArgs.args.grid,
				store;
			if(grid) {
				store = grid.store;
				if (store && store !== null) {
					store.close();
				}
				
				console.debug("[misys.grid._base] Setting the gridstore of grid", grid.id);
				grid.setStore(new dojo.data.ItemFileReadStore({
					data: storeJson,
					urlPreventCache: true,
					clearOnClose: true
				}));
			}
		},
		
		setStoreURL : function( /*Dijit._widget || String*/ node,
                    			/*String*/ url,
                    			/*Object*/ queryOptions) {
			// summary:
			//	Sets the url on the given grid.
			//
			// description:
			//	Set a url on a grid and refreshes its content. The first time this is called, 
			//  the store will be created. Subsequent calls will close the store and refresh the 
			//	grid.
			//
			//	Note that the url parameter is optional. Called without, the grid will be
			//  refreshed using whatever store it is already linked to
			
			var grid = dj.byId(node),
				gridURL, gridQueryOptions,
			    store;
			if(grid) {
				store = grid.store;
				if(store) {
					gridURL = url || store.url;
					gridQueryOptions = queryOptions || grid.queryOptions;
					store.close();
					store.url = gridURL;
					if (store.declaredClass === 'dojox.data.QueryReadStore') {
						grid.setStore(store, queryOptions);
					} else {
						grid.setStore(store, null, queryOptions);					
					}
				} else {
					grid.setStore(new misys.data.ItemFileReadStore({
						url: url,
						urlPreventCache: true,
						clearOnClose: true
					}), null, queryOptions);
				}
			}
		},		
		
		filter : function( /*Dijit._widget || DomNode || String*/ node,
                		   /*Array*/ jsonKeys,
                		   /*Array*/ fieldIds) {
			//  summary:
			//            Filters a grid where jsonKeys[i] is the json key and
			//            dj.byId(fieldIds[i]).get('value') is the corresponding value.
			//
			// TODO Extend for QueryReadStore case

			var grid = dj.byId(node),
				filterString = [],
				field;
			
			if(grid && (jsonKeys.length === fieldIds.length)) {
				d.forEach(jsonKeys, function(key, i){
					field = dj.byId(fieldIds[i]);
					if(field) {
						var fieldValue = field.get("value");
						fieldValue = fieldValue.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
						if(fieldValue !== ""){
							filterString.push(key, ":'", fieldValue, "',");
						}
					}
				});
				
				filterString = filterString.join("");
				if(filterString.charAt(filterString.length -1) === ",") {
					filterString = filterString.substring(0,  filterString.length);
				}

				console.debug("[misys.grid._base] Filtering grid", grid.id,
						"with filter string", filterString.substring(0, filterString.length-1));
				// Mixin with existing queryOptions that may contain url parameters 
				grid.queryOptions = d.mixin(grid.queryOptions, {ignoreCase: true});
				grid.filter(d.fromJson("{" + filterString.substring(0, filterString.length-1)+"}"),true);
			}
		}, 
		
		selectAll : function() {
			// summary:
			//    
			// TODO Not yet transitioned to Dojo
			
			var blnChecked = d.byId("select_all_box").checked,
			    checkList = d.query("input[type=checkbox]");
			
			for(var x = 0, len=checkList.length; x < len; x++) {
				 checkList[x].checked = blnChecked;
			}
		},
		
		reloadForSearchTerms : function() {
			// summary: 
			//
			
			var form = dj.byId("TransactionSearchForm"),
				grids = d.query(".dojoxGrid"),
				gridContainer = d.query(".gridContainer")[0],
				dateRegex = /Date/,
				timeRegex = /Time/,
				queryOptions = {},
				store, baseURL, grid;

			// Find the first grid that doesn't have the .noReload class
			// This is to prevent loading grids that don't take search terms (in the rare
			// case where these is more than one grid in the page. An example is the "Open Account"
			// folder screen)
			
			for(var i = 0, len = grids.length; i < len; i++) {
				if(!d.hasClass(grids[i], "noReload")) {
					grid = dj.byId(grids[i].id);
					break;
				}
			}
			
			if(grid && form) {
				
				// Always goto the first page after reload
				if(dojo.isFunction(grid.gotoFirstPage) && _isNotExcludedOperationTraversingToFirstPage()){
					grid.gotoFirstPage();				
					}
				// Collect the search form field values as a JSON object
				
				// show the grid, if hidden
				if(gridContainer) {
					d.removeClass(gridContainer, "notready");
				}
				

				if(d.byId("divResults")){
					   d.style("divResults", "margin", 0);
				}

				store = grid.get("store");
				m.connect(grid, "_onFetchComplete", function(){
					setTimeout(function(){
						grid.resize();
					}, 500);		 			
				});
				baseURL = store.url;
				if(baseURL.indexOf("&") !== -1) {
					baseURL = baseURL.substring(0, baseURL.indexOf("&"));
				}
				if(baseURL.indexOf("EventsSearchAction") !== -1)
				{
				   if(baseURL.indexOf("?") !== -1) 
				   {
				   baseURL = baseURL.substring(0, baseURL.indexOf("?"));
				   }
				}
				
				form.getDescendants().forEach(function(field, i){
					if(field.name) {
						var value ;
						// special case if the field is a radio button
						if(field.declaredClass == 'dijit.form.RadioButton')
						{
							var radioDomNodes = dojo.query("[name='" + field.name + "']", form.domNode);
							// iterate through radio buttons
							d.some(radioDomNodes, function(radioDomNode){
								var radioWidget=dj.byNode(radioDomNode.parentNode);
								// if the radio button checked get its value
								if(radioWidget.checked)
								 {
									value = radioWidget.params.value;
								 }
								
							});
						}
						else
						{
							value = field.get("value");
						}
						if(dateRegex.test(field.declaredClass) || (timeRegex.test(field.declaredClass))) {
							value = field.get("displayedValue");
						}
						if(value === " ") {
							value = "";
						}
						queryOptions[field.get("name")] = value;
					}
				});
				queryOptions["searchFlag"] = true;
				
				//On search action the clean script should be call.
				var script = grid.onSelectionClearedScript;
				if (script){
				console.debug("[misys.grid._base] eval:", script);
				d.eval(script);
				}
				
				// If selectionMode not null, deselect all first then load new store
				// It is important to deselect first because listener may need store before 
				// it is discarded
				if (grid.selection && grid.get("selectionMode") !== "") {
					grid.selection.clear();
				}
						
				store.close();
				store.url = baseURL;
				console.debug("[misys.grid._base] Resetting grid store URL to", store.url, queryOptions);
				if(queryOptions.list_keys)
				{
					queryOptions.list_keys = "";
				}
				if (store.declaredClass === 'dojox.data.QueryReadStore'){
					grid.setStore(store, queryOptions);
				} else {
					grid.setStore(store, null, queryOptions);					
				}
			}
		},
		
		onSelection : function() {
			//  summary:
		    //            Execute Script
			//
			//	TODO	remove use of eval here 
			
			if (this.selection.selectedIndex!=-1) {
				var script = this.store.getValue(this.getItem(this.selection.selectedIndex), 
						"onSelectionChangedScript");
				console.debug("[misys.grid._base] eval:", script);
				d.eval(script);
				this.updateRowStyles(this.selection.selectedIndex);
			} 
			
		},
		
		getCellData : function(item, field){
			// TODO Why is this a function? Shouldn't it just be called directly?
			console.debug("[misys.grid._base] get cell data (usage?) from: ", item, ", ", field); 
			return this.grid.store.getValue(item, field);
		},
		
		formatJSLink : function( /*String*/ result) {
			//  summary:
			//    		Formats an URL in a column. The data is taken from misys.grid.getURL.
			
			return (result && d.isObject(result)) ? d.string.substitute(
					"<a href='javascript:${href}'>${text}</a>", 
					result) : result;
		},

		formatSelectField : function(rowIndex, item) {
			//
			// summary:
			//	Generates select box in a column. The "box" field contains the reference.
			//
			// TODO rowIndex param is unused
			// TODO Should use d.create to create the select box. Anyway, shouldn't
			//      it be a Dijit?
			
			if(!item) {
				return this.defaultValue;
			}
			var reference = this.grid.store.getValue(item, "box_ref"),
				checked = this.grid.store.getValue(item, "box_checked") === "true";
			return "<input id='" + value + "' name='" + value +
					 "' onclick='alert('To implement')' type='checkbox' " + checked ? 
					 "checked='checked'" : "";
		},

		formatGroupsAndAggregates : function(result, idx) {
			// summary:
			//		Formats a group footer.
			if (result) {
				return m.grid.formatHTML(result);
			} else {
				return result;
			}
		},
		
		formatSimpleHTML : function(/*String*/ text) {
			   // summary: 
			   //		Formats the content, replacing a limited number of low risk entities with
			   //       their HTML equivalents.

			   text = text.replace(/&amp;nbsp;/g, "&nbsp;");
			   text = text.replace(/&amp;#x27;/g, "&#x27;");
			   text = text.replace(/&amp;#x2F;/g, "&#x2F;");
			   text = text.replace(/&amp;#34;/g, "&#34;");
			   text = text.replace(/&amp;#x28;/g,"(");
			   text = text.replace(/&amp;#x29;/g,")");
			   text = text.replace(/&amp;#x26;/g,"&");
			   return text.replace(/&amp;amp;/g, "&amp;");
		},
		
		formatHTML : function( /*String*/ text) {
		    // summary: 
			//			Formats content containing HTML elements such as <img>. Should *only*
		    //          be used on grid cells containing trusted data.
		    //          
			// TODO Replace with more robust regular expressions
			/*text = text.replace(/&lt;img/g, "<img");
			text = text.replace(/&lt;input/g, "<input");
			text = text.replace(/&lt;span/g, "<span");
			text = text.replace(/&lt;\/span/g, "</span");
			text = text.replace(/&lt;div/g, "<div");
			text = text.replace(/&lt;\/div/g, "</div");
			text = text.replace(/&lt;table/g, "<table");
			text = text.replace(/&lt;\/table/g, "</table");
			text = text.replace(/&lt;tr/g, "<tr");
			text = text.replace(/&lt;\/tr/g, "</tr");
			text = text.replace(/&lt;i&gt;/g, "<i>");
			text = text.replace(/&lt;\/i&gt;/g, "</i>");
			text = text.replace(/&lt;i>/g, "<i>");
			text = text.replace(/&lt;\/i>/g, "</i>");
			text = text.replace(/&lt;a/g, "<a");
			text = text.replace(/&lt;\/a>/g, "</a>");
			text = text.replace(/&lt;br/g, "<br");
			text = text.replace(/&gt;/g, ">");
			
			return m.grid.formatSimpleHTML(text);*/
			return text;
		},
		/**
		 * <h4>Summary:</h4>
		 * Encodes the content containing HTML elements for UI
		 * only.
		 * <h4>Description:</h4>
		 * This method will encodes the input content containing
		 * HTML elements for UI only.
		 * 
		 * @param {String}
		 *            text
		 * @method sanitizeHTMLDataForUI
		 * @return {String} Returns sanitized text
		 */
		sanitizeHTMLDataForUI : function( /*String*/ text) {
			if(text) {
				text = text.replace(/<img/g, "&lt;img");
				text = text.replace(/>/g, "&gt;");
			}
			return text;
		},
		/**
		 * <h4>Summary:</h4>
		 *  HTML type Integer for DataGridHeader Formatter. Function returns the integer number
		 */
		formatHTMLInteger : function( /*Integer*/ number) {
		   
			return number;
		},

		formatDate : function(/*String*/ dateString){
			var startindex = dateString.indexOf(">");
			var endIndex = dateString.indexOf("<", 1);
			return dateString.substring(startindex+1, endIndex);
		},
		
		formatFlagImage : function( /*String*/ flagName) {
			// summary: 
			//		format a flag in a rates grid
			//
			// TODO Should create an image with dojo.create
			var flag = flagName.toLowerCase();
			if(misys._config.fbccVersion!=="" || misys._config.fbccVersion !== null)
			{
				return m.grid.formatHTML("<img src='" + m.getContextualURL(m._config.imagesSrc + "flags/") + 
						flag + ".png?v=" +misys._config.fbccVersion+"'alt='" +flag+ "'/>");
			}
			else
			{
				return m.grid.formatHTML("<img src='" + m.getContextualURL(m._config.imagesSrc + "flags/") + 
						flag + ".png' alt='" +flag+ "'/>");
			}
			
		},
		
		formatCurrencyFlagImage : function( /*String*/ curCode) {
			// summary: 
			//		format a flag in a lisdef screen 
			//
			var	flag = curCode.toLowerCase().substring(0, 2);
			if(misys._config.fbccVersion!=="" || misys._config.fbccVersion !== null)
			{
				return m.grid.formatHTML("<img src='" + m.getContextualURL(m._config.imagesSrc + "flags/") + 
						flag + ".png?v=" +misys._config.fbccVersion+"'alt='" +flag+ "'/>");
			}
			else
			{
				return m.grid.formatHTML("<img src='" + m.getContextualURL(m._config.imagesSrc + "flags/") + 
						flag + ".png' alt='" +flag+ "'/>");
			}
		},

		formatSummary : function (value, rowIdx, cell, sing, plur) {
			// summary:
			//    TODO
			
			if(value === 0) {
				return "";
			}
			var str;
			if(rowIdx >= 0) {
				return value;
			}
			if(rowIdx === -1) {
				str = m.getLocalization("totalPrefix") + " (${numItems} ${displayName})";
			}else{
				str = "${numItems} ${displayName}";
			}
			return d.string.substitute(str, {numItems: value, 
						displayName: (value === 1) ? sing : plur});			
		},

		formatOperationsSummary : function (value, rowIdx) {
			// summary:
			//
			
			return m.grid.formatSummary(value, rowIdx, this, "Operation", "Operations");
		},

		formatTypesSummary : function (value, rowIdx) {
			// summary:
			//
			
			return m.grid.formatSummary(value, rowIdx, this, "Type", "Types");
		},

		formatDataSummary : function (value, rowIdx) {
			// summary:
			//  TODO
			
			return (value === 0) ? "" : value;
		},

		formatTitlesSummary :function (value, rowIdx){
			// summary:
			//	TODO
			
			return m.grid.formatSummary(value, rowIdx, this, "Title", "Titles");
		},

		formatURL : function(result) {
			//	summary:
			//		Formats an URL in a column. The data is taken from m.grid.getURL.
			// TODO Shouldn't use strings to build HTML 
			
			if(!window.isAccessibilityEnabled) {
				return (result && d.isObject(result)) ? d.string.substitute(
						"<a href='${href}'>${text}</a>", 
						result) : result;
			} else {
				var linkText = misys.getLocalization('link');
				return (result && d.isObject(result)) ? d.string.substitute(
								"<a href='${href}' aria-labelledby='${href}_link_span'>${text}</a><span class='sr-only' id='${href}_link_span'>"+linkText+"</span>", 
								result)  : result;
			}
		},
		
		formatReportActions : function(rowIndex, item, cell) {
			//  summary:
			//          Generate the HTML containing the different possible actions in a grid.

			// TODO Temporarily named this until we establish which formatActions function is
			//	the appropriate one to use
			var displayMode=cell.grid.gridMultipleItemsWidget.overrideDisplaymode;
			
			var divId = cell.grid.gridMultipleItemsWidget.id;
			
			var parent=dojo.create('div');
				
			var div=dojo.create('div',{'class':'gridActions'},parent);
			
			if (displayMode && displayMode=='view')
			{
				dojo.create ('img',{'src': misys._config.context + misys._config.imagesSrc + "pic_text.gif" , 'alt' : 'View', border : '0',	'type' : 'view'},div);
			}
			else
			{
				dojo.create ('img',{'src': misys.getContextualURL(misys._config.imagesSrc + m._config.imageStore.editIcon),'title':'Edit','alt':'Edit','border' : '0', 'type': 'edit'},div);
				dojo.create ('img',{'src': misys.getContextualURL(misys._config.imagesSrc + m._config.imageStore.deleteIcon),'title':'Delete','alt':'Delete','border' : '0', 'type': 'remove'},div);
				if(divId === 'columns') 
				{
					dojo.create ('img',{'src': misys._config.context + misys._config.imagesSrc + "action-up.png" , 'alt' : 'Move Up', border : '0',	'type' : 'moveup'},div);
					dojo.create ('img',{'src': misys._config.context + misys._config.imagesSrc + "action-down.png" , 'alt' : 'Move Down', border : '0',	'type' : 'movedown'},div);
				}

			}
			
			return parent.innerHTML;
			
		},
		
		/*
		 * Grid actions only with edit and view option in case of Accounts
		 */
		formatAccountActions : function(rowIndex, item, cell)
		{	
			var displayMode=cell.grid.gridMultipleItemsWidget.overrideDisplaymode;
			var divId = cell.grid.gridMultipleItemsWidget.id;
			var parent=dojo.create('div');
			var div=dojo.create('div',{'class':'gridActions'},parent);
			if (displayMode && displayMode=='view')
			{
				dojo.create ('img',{'src': misys._config.context + misys._config.imagesSrc + "pic_text.gif" , 'alt' : 'View', border : '0',	'type' : 'view'},div);
			}
			else
			{
				dojo.create ('img',{'src': misys.getContextualURL(misys._config.imagesSrc + m._config.imageStore.editIcon),'title':'Edit','alt':'Edit','border' : '0', 'type': 'edit'},div);
			}
			return parent.innerHTML;
		},
		
		/*
		 * Grid actions only with delete option
		 */
		formatDeleteActions : function(rowIndex, item, cell) {
			//  summary:
			//          Generate the HTML containing the different possible actions in a grid.

			// TODO Temporarily named this until we establish which formatActions function is
			//	the appropriate one to use
			var displayMode=cell.grid.gridMultipleItemsWidget.overrideDisplaymode;
			var parent=dojo.create('div');
			var div=dojo.create('div',{'class':'gridActions'},parent);
			dojo.create ('img',{'src': misys.getContextualURL(misys._config.imagesSrc + m._config.imageStore.deleteIcon),'alt':'Delete','border' : '0', 'type': 'remove'},div);	
			return parent.innerHTML;
		},	
		/*
		 * Grid actions only with counterparty delete option
		 */
		formatCptyDeleteActions : function(rowIndex, item, cell) {
			//  summary:
			//          Generate the HTML containing the different possible actions in a grid.

			// TODO Temporarily named this until we establish which formatActions function is
			//	the appropriate one to use
			var displayMode=cell.grid.gridMultipleItemsWidget.overrideDisplaymode;
			var parent=dojo.create('div');
			var div=dojo.create('div',{'class':'gridActions'},parent);
			if(cell.grid._by_idx[item] && cell.grid._by_idx[item].item && cell.grid._by_idx[item].item.cpty_showDelete[0] && cell.grid._by_idx[item].item.cpty_showDelete[0]==="true")
			{
				dojo.create ('img',{'src': misys.getContextualURL(misys._config.imagesSrc + m._config.imageStore.deleteIcon),'alt':'Delete','border' : '0', 'type': 'remove'},div);
			}			
			return parent.innerHTML;
		},		
		formatActions : function(result) {
			// summary:
			//		Format actions in a column. The data is taken from m.grid.getActions
			
			return (result && d.isObject(result) ? result.href : result);
		},
		
		confirmDeleteRecords : function( /*Dojox Grid*/ grid,
									  	 /*String*/ url) {
			// summary:
			//	TODO
			
			var numSelected = grid.selection.getSelected().length;
			var storeSize	= grid.store._items.length;
			if(numSelected > 0 && storeSize > 0) {
				m.dialog.show("CONFIRMATION", 
						m.getLocalization("deleteTransactionsConfirmation", 
								[grid.selection.getSelected().length]), "", 
								function(){ m.grid.processRecords(grid, url);});
			} else {
				m.dialog.show("ERROR", m.getLocalization("noTransactionsSelectedError"));
			}
		},
		
		confirmSubmitRecords: function( /*Dojox Grid*/ grid,
									  	 /*String*/ url) {
			// summary:
			//	TODO
			var numSelected = grid.selection.getSelected().length;
			var storeSize	= grid.store._items.length;
			if(numSelected > 0 && storeSize > 0) 
			{
				m.dialog.show("CONFIRMATION", 
						m.getLocalization("submitTransactionsConfirmation", 
								[grid.selection.getSelected().length]), "", 
								function(){ m.grid.processRecordsWithHolidayCutOffValidation(grid, url);});
			} 
			else 
			{
				m.dialog.show("ERROR", m.getLocalization("noTransactionsSelectedError"));
			}
		},
		
		confirmResendRecords: function( /*Dojox Grid*/ grid,
										/*String*/ url) {
		 	// summary:
		 	//      TODO
		 	var numSelected = grid.selection.getSelected().length;
		 	var storeSize   = grid.store._items.length;
		 	if(numSelected > 0 && storeSize > 0) {
		 		m.dialog.show("CONFIRMATION",
		 				m.getLocalization("resendTransactionsConfirmation",
		 						[grid.selection.getSelected().length]), "",
		 						function(){
		 			setTimeout(function(){
		 				m.grid.processRecords(grid, url);
		 			}, 100);});
		 		//processRecordsWithHolidayCutOffValidation(grid, url);
		 	} else {
		 		m.dialog.show("ERROR", m.getLocalization("noTransactionsSelectedError"));
		 	}
		},
		
		/*
		 * Grid actions only with cancel option
		 */
		confirmCancelRecords : function( /*Dojox Grid*/ grid,
						  	 /*String*/ url, /*String*/ viewRecords) {
			// summary:
			//	TODO
			
			var targetNode = d.byId("batchContainer"), 
			items = grid.selection.getSelected(),
			strListKeys = "",
			intNbKeys = 0,
			reference, xhr,
			isValid = true;
			var reauth = dj.byId("reauth_perform");
			m.animate("wipeOut", targetNode);
			
			if(items.length) 
			{
				// Iterate through the list of selected items.
				d.forEach(items, function(selectedItem) {
					// extract the reference
					reference = grid.store.getValues(selectedItem, "box_ref");
					
					// separator
					if("S" + strListKeys != "S"){ strListKeys = strListKeys + ",";}
					strListKeys = strListKeys + reference;
					intNbKeys++;
				}); // end forEach
				
				if(intNbKeys > 0)
				{
					var callBack = function()
								   {
										var xhrParams	= {
														      url: m.getServletURL(url),
														      handleAs: "text",
														      content: {list_keys: strListKeys},
														      load: function(data)
														      {
															        // Replace newlines with nice HTML tags.
															        data = data.replace(/\n/g, "<br>");
										
															        // Replace tabs with spaces.
															        data = data.replace(/\t/g, "&nbsp;&nbsp;&nbsp;");
															        
															        targetNode.innerHTML = data;
															        
															        m.animate("wipeIn", "batchContainer");
															        
															        // Deselect all rows
															        grid.selection.clear();
															        grid.setStore(grid.store);
														      }
										                };
										
										var fncCallBack = function()
											{
												m.xhrPost (xhrParams);
												setTimeout(d.hitch(grid, "render"), 100);
											};
										if((reauth && reauth.get('value') === "Y") && d.isFunction(m._config.doReauthSubmit))
										{
											m._config.doReauthSubmit(xhrParams);
										}
										else
										{
											fncCallBack();
										}
								   };
					m.dialog.show("CONFIRMATION", m.getLocalization("cancelledTransactionsConfirmation",[grid.selection.getSelected().length]),'',callBack);
				}
			}
			else
			{
				m.dialog.show('ERROR', m.getLocalization('noTransactionsSelectedError'));
			}
		},
	
		confirmForwardRecords : function( /*Dojox Grid*/ grid, 
									  	  /*String*/ url) {
			// summary:
			//		TODO
			
			var numSelected = grid.selection.getSelected().length;
			if(numSelected > 0) {
				m.dialog.show('CONFIRMATION', 
						m.getLocalization('forwardsTransactionConfirmation', 
											[grid.selection.getSelected().length]), 
											'', function(){
												m.rocessRecords(grid, url);
											}
				);
			} else {
				m.dialog.show('ERROR', m.getLocalization('noTransactionsSelectedError'));
			}
		},
		

		processRecordsWithHolidayCutOffValidation : function( /*Dojox Grid*/ grid, /*String*/ url) {
			// summary:
			//		Triggers the submission of transaction records along with holiday cut-off validation.
			// 		Also promts user to Auto Forward Dates with Holiday-CutOff Validation Fails
			
			var targetNode = d.byId("batchContainer"), 
			items = grid.selection.getSelected(),
			strListKeys = "",
			intNbKeys = 0,
			reference, xhr,
			isValid = true, autoForwardTransactionDetails,failedTransactionDetailsHolidays,failedTransactionDetailsCutOff,autoForwardEnabled;
			var details = [];
			
			
			m.animate("wipeOut", targetNode);
			var reauth = dj.byId("reauth_perform");
			if(items.length) 
			{
				// Iterate through the list of selected items.
				d.forEach(items, function(selectedItem) {
					// extract the reference
					reference = grid.store.getValues(selectedItem, "box_ref");
					
					// separator
					if("S" + strListKeys != "S"){ strListKeys = strListKeys + ",";}
					strListKeys = strListKeys + reference;
					intNbKeys++;
				}); // end forEach
				
				if(intNbKeys > 0)
				{
					m.xhrPost({
						url : m.getServletURL("/screen/AjaxScreen/action/ValidateHolidayCutOffMultipleSubmission"),
						handleAs : "json",
						preventCache : true,
						sync : true,
						content: {list_keys: strListKeys},
						load : function(response, args){
							autoForwardEnabled = response.autoForwardEnabled;
							isValid = response.isValid;
							autoForwardTransactionDetails = response.autoForwardTransactionDetails;
							failedTransactionDetailsCutOff = response.failedTransactionDetailsCutOff;
							failedTransactionDetailsHolidays = response.failedTransactionDetailsHolidays;
						},
						error : function(response, args){
							console.error("[misys.grid._base] processRecordsWithHolidayCutOffValidation error", response);
						}
					});
				
					if(isValid)
					{
						var xhrParams	= {
							      url: m.getServletURL(url),
							      handleAs: "text",
							      content: {list_keys: strListKeys},
							      load: function(data)
							      {
								        // Replace newlines with nice HTML tags.
								        data = data.replace(/\n/g, "<br>");
			
								        // Replace tabs with spaces.
								        data = data.replace(/\t/g, "&nbsp;&nbsp;&nbsp;");
								        
								        targetNode.innerHTML = data;
								        								        
								        // Deselect all rows
								        grid.selection.clear();
								        grid.setStore(grid.store);
								        
								        setTimeout(function(){
								        	m.animate("wipeIn", "batchContainer");
								        }, 1000);
							      }
							};
						var fncCallBack = function(){
							m.xhrPost (xhrParams);
							setTimeout(d.hitch(grid, "render"), 10000);
						};
						//If doReauthSubmit is overridden in client specific then doReauthSubmit will take the flow control
						
						if((reauth && reauth.get('value') === "Y") && d.isFunction(m._config.doReauthSubmit))
						{
							m._config.doReauthSubmit(xhrParams);
						}
						else
						{
							fncCallBack();
						}
					}
					else if(autoForwardEnabled && autoForwardEnabled === "N")
						{

						details = [];
						details.push("<div style='display:block;'>" + m.getLocalization("Cutoffdatepassed")+ "<br/>");
						
						d.forEach(autoForwardTransactionDetails,function(node){
							details.push("<li>"+node+"</li>");
						});
						
						details.push("</div>");
						//If doReauthSubmit is overridden in client specific then it will take the flow control 
						if((reauth && reauth.get('value') === "Y") && d.isFunction(m._config.doReauthSubmit))
						{
							fncCallBack = function(){m._config.doReauthSubmit(xhrParams);};
							m.dialog.show("CUSTOM-NO-CANCEL",details.join(''),'',fncCallBack);
						}
						else
						{
							m.dialog.show("CUSTOM-NO-CANCEL",details.join(''),'',callBack);
						}
					
						}
					else
					{
						details = [];
						if(autoForwardEnabled)
						{
							if (failedTransactionDetailsCutOff.length > 0)
							{
								details.push("<div <b>" + m.getLocalization("failedMultipleSubmissionCutOff")+ "</b><br/>");
								d.forEach(failedTransactionDetailsCutOff,function(node){
									details.push("<li>"+node+"</li>");
								});
								details.push("</div>");
							}
							if (failedTransactionDetailsHolidays.length > 0)
							{
								details.push("<div style='display:block;'><b>" + m.getLocalization("failedMultipleSubmissionHoliday")+ "</b><br/>");
								d.forEach(failedTransactionDetailsHolidays,function(node){
									details.push("<li>"+node+"</li>");
								});
								details.push("</div>");
							}
							details.push("<div style='display:block;'><b>" + m.getLocalization("autoForwardMultipleSubmission")+ "</b><br/>");
							details.push("</div>");
							xhrParams	=	{
									  url: m.getServletURL(url),
								      handleAs: "text",
								      content: {list_keys: strListKeys, autoForward: "Y"},
								      load: function(data)
								      {
									        // Replace newlines with nice HTML tags.
									        data = data.replace(/\n/g, "<br>");
				
									        // Replace tabs with spaces.
									        data = data.replace(/\t/g, "&nbsp;&nbsp;&nbsp;");
									        
									        targetNode.innerHTML = data;
									        
									        m.animate("wipeIn", "batchContainer");
									        
									        // Deselect all rows
									        grid.selection.clear();
									        grid.setStore(grid.store);
							      	  }
							}; 
							
							//If doReauthSubmit is overridden in client specific then it will take the flow control 
							if((reauth && reauth.get('value') === "Y") && d.isFunction(m._config.doReauthSubmit))
							{
								_showHolidaysNCutOffTimeErrorDialog(autoForwardEnabled , details, true, xhrParams);
							}
							else
							{
								_showHolidaysNCutOffTimeErrorDialog(autoForwardEnabled, details , false ,xhrParams);
							}
						}
						else
						{
							if (failedTransactionDetailsCutOff.length > 0)
							{
								details.push("<div style='display:block;'><b>" + m.getLocalization("failedMultipleSubmissionCutOff")+ "</b><br/>");
								d.forEach(failedTransactionDetailsCutOff,function(node){
									details.push("<li>"+node+"</li>");
								});
							}
							if (failedTransactionDetailsHolidays.length > 0)
							{
								details.push("<div style='display:block;'><b>" + m.getLocalization("failedMultipleSubmissionHoliday")+ "</b><br/>");
								d.forEach(failedTransactionDetailsHolidays,function(node){
									details.push("<li>"+node+"</li>");
								});
							}
							_showHolidaysNCutOffTimeErrorDialog(autoForwardEnabled, details , false , xhrParams);
						}
					}
				}
			}
		},
		
		processDeletionOfBatch: function( /*Dojox Grid*/ grid, /*String*/ url) {
			// summary:
			//		Triggers the submission of transaction records along with holiday cut-off validation.
			// 		Also promts user to Auto Forward Dates with Holiday-CutOff Validation Fails
			
			var targetNode = d.byId("batchContainer"), 
			items = grid.selection.getSelected(),
			strListKeys = "",
			intNbKeys = 0,
			reference, xhr,
			isValid = true;
			
			m.animate("wipeOut", targetNode);
			
			if(items.length) 
			{
				// Iterate through the list of selected items.
				d.forEach(items, function(selectedItem) {
					// extract the reference
					reference = grid.store.getValues(selectedItem, "box_ref");
					
					// separator
					if("S" + strListKeys != "S"){ strListKeys = strListKeys + ",";}
					strListKeys = strListKeys + reference;
					intNbKeys++;
				}); // end forEach
				
				if(intNbKeys > 0)
				{
					var callBack = function(){
						m.xhrPost ({
							  url: m.getServletURL(url),
						      handleAs: "text",
						      content: {list_keys: strListKeys},
						      load: function(data)
						      {
							        // Replace newlines with nice HTML tags.
							        data = data.replace(/\n/g, "<br>");
		
							        // Replace tabs with spaces.
							        data = data.replace(/\t/g, "&nbsp;&nbsp;&nbsp;");
							        
							        targetNode.innerHTML = data;
							        
							        m.animate("wipeIn", "batchContainer");
							        
							        grid.setStore(grid.store);
							        setTimeout(d.hitch(grid, "render"), 300);
					   
									// Clear selection once data fetch complete
									m.connect(grid, "_onFetchComplete", function(){
										grid.selection.clear();
									});
					      	  }
						});
					};
					m.dialog.show("CONFIRMATION",m.getLocalization("batchSelectedDelete"),'',callBack);
				}
			}
			else if (items.length === 0){
				m.dialog.show("ERROR", m.getLocalization("noTransactionsSelectedError"));
			}
		},
		
		processBatchingOfRecords : function( /*Dojox Grid*/ grid, /*String*/ url) {
			// summary:
			//		Triggers the submission of transaction records along with holiday cut-off validation.
			// 		Also promts user to Auto Forward Dates with Holiday-CutOff Validation Fails
			
			var targetNode = d.byId("batchContainer"), 
			items = grid.selection.getSelected(),
			strListKeys = "",
			intNbKeys = 0,
			reference, xhr,
			isValid = true;
			
			m.animate("wipeOut", targetNode);
			
			if(items.length) 
			{
				// Iterate through the list of selected items.
				d.forEach(items, function(selectedItem) {
					// extract the reference
					reference = grid.store.getValues(selectedItem, "box_ref");
					
					// separator
					if("S" + strListKeys != "S"){ strListKeys = strListKeys + ",";}
					strListKeys = strListKeys + reference;
					intNbKeys++;
				}); // end forEach
				
				if(intNbKeys > 0)
				{
					m.xhrPost({
						url : m.getServletURL("/screen/AjaxScreen/action/ValidateBatchCriteria"),
						handleAs : "json",
						preventCache : true,
						sync : true,
						content: {list_keys: strListKeys},
						load : function(response, args){
							isValid = response.isValid;
						},
						error : function(response, args){
							console.error("[misys.grid._base] processBatchingOfRecords error", response);
						}
					});
				
					if(!isValid)
					{
						m.dialog.show("ERROR",m.getLocalization("batchTransactionsError"));
					}
					else
					{
						m.xhrPost ({
						      url: m.getServletURL(url),
						      handleAs: "text",
						      sync : true,
						      content: {list_keys: strListKeys},
						      load: function(data)
						      {
							        // Replace newlines with nice HTML tags.
							        data = data.replace(/\n/g, "<br>");
		
							        // Replace tabs with spaces.
							        data = data.replace(/\t/g, "&nbsp;&nbsp;&nbsp;");
							        
							        targetNode.innerHTML = data;
							        
							        // Deselect all rows
							        grid.selection.clear();
							        grid.setStore(grid.store);
							        
							        setTimeout(function(){
							        	m.animate("wipeIn", "batchContainer");
								    }, 3000);
							  }
						});
						
						setTimeout(d.hitch(grid, "render"), 100);
					}
				}
				
			}
			else if (items.length === 0){
				m.dialog.show("ERROR", m.getLocalization("noTransactionsSelectedError"));
			}
		},

		processRecords : function( /*Dojox Grid || Array of Grids*/ grid,
								   /*String*/ url,
								   /*Function*/ handleCallback) {
			// summary:
			//		Triggers the submission of transaction records (msg = 22).
			// 
			//	TODO This appears to be only partially implemented
		    
			var grids = d.isArray(grid) ? grid : [grid],
				targetNode = d.byId("batchContainer"),
				items = [],
				keys = "",
				intNbKeys = 0,
				reference, xhrArgs;
				m.animate("wipeOut", targetNode);
			d.forEach(grids, function(grid){
				items = grid.selection.getSelected();
				if(items && items.length) {
					d.forEach(items, function(selectedItem) {
						// extract the reference
						reference = grid.store.getValues(selectedItem, "box_ref");

						// separator
						if(keys !== ""){
							keys += ", ";
						}
						keys += reference;
						intNbKeys++;
					});
				}
			});
			
			if(intNbKeys > 0) {
				// TODO This should be implemented properly
				_processRecords(grids, url, keys, handleCallback);
				/*if(true  fncShowConfirmation(22, intNbKeys) ) {
					 // Call the asynchronous xhrGet
				    var reauth = dj.byId("reauth_dialog");
					if(reauth) {
						m.dialog.connect("doReauthentication", "onClick", function(){
							_processRecords(grids, url, keys);
						});
						dj.byId("reauth_pwd").set("value", "");
						reauth.show();
					} else {
						_processRecords(grids, url, keys);
					}
				}*/
			}	
			grid.multipleSelectItems = new Object();
		},
		
		setListKey : function(/*Dijit._widget*/ grid) {
			var keys = "",
				items = grid.selection.getSelected(),
				intNbKeys = 0,
				listkey = dj.byId("list_keys"),
				reference;
				
			if(items.length) {
				d.forEach(items, function(selectedItem) {
					reference = grid.store.getValues(selectedItem, "box_ref");

					if(intNbKeys !== 0){ 
						keys += ",";
					}
					
					keys += reference;
					intNbKeys++;
				});

			}

			if (listkey && listkey !== null){
				listkey.set("value", keys);
			}
			
			if (intNbKeys === 0 && 
					dj.byId("export_list") && 
					dj.byId("export_list").get("value") === "zip"){
				m.dialog.show("ERROR", m.getLocalization("noTransactionsSelectedError"));
				e.preventDefault();
			}
		},

		beforeRow : function(rowIndex, cells) {
			// summary:
			//		
			// Description: 
			//	cells is an array of subRows. we hide the summary subRow except for every nth
			//  row should hide the normal row and the group row according to the row's values
			if (cells.length >= 2)
			{
				//Fixed as part of MPS-45351, in case of grouping, values like group-0 and group-1 were added while creating the grid.
				//In case of delayed response from Server side these values (group-0, group-1) which are for internal processing were displayed instead of actual data.
				//To stop these values showing up in the rows, the rows containing these values are hidden initially and later loaded when the actual data load into the grid.
				if(cells[1] && !cells[1].hidden)
				{
					cells[1].hidden = true;
				}
				if (rowIndex === -1) {
					if (!cells.headerDisplayed) {
						cells.headerDisplayed = true;
					} else {
						cells[1].hidden = true;
						if (cells.length === 3) {
							cells[2].hidden = true;
						}
					}
				} else {
					var item = this.grid.getItem(rowIndex);
					if (item) {
						var rowType = this.grid.store.getValue(item, "_row_type");
						if (rowType === 2 || rowType === 3) {
							cells[1].hidden = false;
						} 
						else if (rowType === 4) {
							cells[1].hidden = false;
							cells[2].hidden = false;
						} 
						else {
							cells[1].hidden = true;
							if (cells.length === 3) {
								cells[2].hidden = true;
							}
						}
					} else {
						cells[1].hidden = true;
						if (cells.length === 3) {
							cells[2].hidden = true;
						}
					}
				}
			}
		},

		// TODO Should be in validations. Or grid validations? 
		validateSearchDateRange : function() {
			//  summary:
		    //        Validates the date range for a search screen. 
		    //  Description:
			//		  Expects the fields to be named "start" and "end"
	
			// TODO Move into validations/common
			
			var range = dj.byId("range").get("value"),
				start = dj.byId("startdate"),
				end = dj.byId("enddate"),
				diff = 0;
			
			if(start && end) {
				diff = d.date.difference(dj.byId("startdate").get("value"), 
						dj.byId("enddate").get("value"), "day");
			}	
			
		    var days;
		    if(range == 1)
		    {
		      days=31;
		    }
		    else
		    {
		      days=92;
		    }
		    if(diff < 0 || diff > days) {
		    var changed = false;
                if(range == 1){
                                m.connect("startdate", "onChange", function(){
                                if(!changed)
                                {
                                	var date1 = dojo.date.add(dj.byId("startdate").get("value"), "month", 1);
                                	dijit.byId('enddate').set('value', date1);
                                	changed=true;
                                }
                	           });
                	
                               m.connect("enddate", "onChange", function(){
                            	if(!changed)
                            	{   
                            		var date1 = dojo.date.add(dj.byId("enddate").get("value"), "month", -1);
                            		dijit.byId('startdate').set('value', date1);
                            		changed=true;
                            	}
                                });
                               }
                	           else if(range == 3)
                	           {
                	        	   m.connect("startdate", "onChange", function(){
                	        	   if(!changed)
                	        	   {
                	        		   var date1 = dojo.date.add(dj.byId("startdate").get("value"), "month", 3);
                	        		   dijit.byId('enddate').set('value', date1);
                	        		   changed=true;
                	        	   }
                               });
                               m.connect("enddate", "onChange", function()
                            	  {
                            	   if(!changed)
                            	   {
                            		   var date1 = dojo.date.add(dj.byId("enddate").get("value"), "month", -3);
                            		   dijit.byId('startdate').set('value', date1);
                            		   changed=true;
                            	   }
                               });
                               }
            else
            {
				
				this.invalidMessage = m.getLocalization("monthRangeValidityMessage", 
									[range, dj.byId("startdate").get("displayedValue")]);
				return false;
			} 
			}
			return true;
		},

		redirect : function( /*Grid Row Click Action*/ event){
			//  summary:
			//            Event called when you click on an item in the ongoing tasks table.

			// Retrieve the grid elements
			var grid = event.grid,
				item = grid.getItem(event.rowIndex),
				url = grid.store.getValue(item, "SCREEN");

			// Set the page URL
			if (url) {
				var prodCode = m.getQueryParameterByName('productcode', url);
				var subProductCode = m.getQueryParameterByName('subproductcode', url);
				console.debug('prodcut code is: ' + prodCode);
				console.debug('subProductCode is: ' + subProductCode);
				var angularUrl = [];
				if (misys._config.isBank === 'false' && misys._config.fccuiEnabled && misys._config.fccuiEnabled === 'true' && m.isAngularProductUrl(prodCode, subProductCode)) {
					angularUrl.push("/productScreen?");
					angularUrl.push("refId=", m.getQueryParameterByName('referenceid', url));
					angularUrl.push("&tnxId=", m.getQueryParameterByName('tnxid', url));
					angularUrl.push("&productCode=", prodCode);
					angularUrl.push("&subProductCode=", subProductCode);
					angularUrl.push("&mode=", m.getQueryParameterByName('mode', url));
					angularUrl.push("&tnxTypeCode=", m.getQueryParameterByName('tnxtype', url));
					angularUrl.push("&subTnxTypeCode=", m.getQueryParameterByName('subTnxTypeCode', url));
					window.location = m.getServletURL('').replace(/.$/,"#") + angularUrl.join("");
				} else {
					console.debug("[misys.grid._base] Redirecting to URL", url);
					window.location = url;
				}
			}
		},

		noSortOnSecondColumn : function( /*int*/ colIndex) {
			// summary: 
			//		Whether to sort a column in the rate table, all but column 2  
			//		(flags) should be sortable
			
			return Math.abs(colIndex) !== 2;
		},

		toggleExpandedList : function( /*String*/ id, 
				   /*Integer*/ limit) {
			// summary: 
			//		Expands or collapses a long <UL> list
			
			d.query("#"+id+" li").forEach(function(l, i){
				if(i >= limit) {
					d.toggleClass(l, "hide");
				}
			});
			d.toggleClass(id+"_show", "hide");
			d.toggleClass(id+"_hide", "hide");
		},

		noSortOnThirdColumn : function( /*int*/ colIndex){
			// summary:
			//
			
			return Math.abs(colIndex) !== 3;
		},

		noSortOnFourthColumn : function( /*int*/ colIndex){
			// summary:
			//
			
			return Math.abs(colIndex) !== 4;
		},

		noSortOnFifthColumn : function( /*int*/ colIndex){
			// summary:
			//
			
			return Math.abs(colIndex) !== 5;
		},

		noSortOnSixthColumn : function(/*int*/ colIndex){
			// summary:
			//
			
			return Math.abs(colIndex) !== 6;
		},

		noSortOnSeventhColumn : function( /*int*/ colIndex){
			// summary:
			//
			
			return Math.abs(colIndex) !== 7;
		},

		noSortOnEighthColumn : function( /*int*/ colIndex){
			// summary:
			//
			
			return Math.abs(colIndex) !== 8;
		},
		
		noSortOnNinthColumn : function( /*int*/ colIndex){
			// summary:
			//
			
			return Math.abs(colIndex) !== 9;
		},
		
		noSortOnEleventhColumn : function( /*int*/ colIndex){
			// summary:
			//
			
			return Math.abs(colIndex) !== 11;
		},
		
		noSortOnThirteenthColumn : function( /*int*/ colIndex){
			// summary:
			//
			
			return Math.abs(colIndex) !== 13;
		},
		noSortOnThirdFourthAndFifthColumn : function( /*int*/ colIndex){
			// summary:
			//
			
			return Math.abs(colIndex) !== 3 && Math.abs(colIndex) !== 4 && Math.abs(colIndex) !== 5;
		},
		
		noSortOnAllColumns : function( /*int*/ colIndex){
			
			return false;
		},
		
		noSortOnThirdAndSeventhColumn : function( /*int*/ colIndex){
			// summary:
			//
			
			return Math.abs(colIndex) !== 3 && Math.abs(colIndex) !== 7;
		},

		noSortOnLastColumn : function( /*int*/ colIndex){
			   // summary:
			   //
			   
			   return Math.abs(colIndex) !== this.layout.cellCount;
		},
		
		noSortEnabledOnColumn  : function(colIndex){
			return this.noSortColumnIndex.indexOf(colIndex) === -1;
		},
		
		noSortColumnConfiguredOnHeader : function(colIndex){
            var grid = this;
            var column = "";
            if(grid.structure.cells[0][colIndex - 1])
			{
            	column = grid.structure.cells[0][colIndex - 1];
				if(grid.selectionMode && (grid.selectionMode === 'single' || grid.selectionMode === 'multiple'))
				{
					column = grid.structure.cells[0][colIndex - 2];
				}
			}
			if(grid.structure.cells[1])
			{
				column = grid.structure.cells[1][colIndex - 2];
				if(grid.selectionMode && (grid.selectionMode === 'single' || grid.selectionMode === 'multiple'))
				{
					column = grid.structure.cells[1][colIndex - 3];
				}
			}
            if(column)
            {
                    if(column["sort"] && column["sort"] === "false")
                    {
                            return false;
                    }
                    else
                    {
                            return true;
                    }
            }
            else
            {
                    return true;
            }
    },
		
		sortAmountColumn : function( /* String */a,
				/* String */b)
				{
					// summary: Filter for sorting String
					// amount(formatted) values in a grid.
					// TODO:Handle different currency formats like Yen
					
					var amtA = a;
					var amtB = b;
					if(!amtA || amtA == "" || amtA == null){
						amtA = 0;
					}
					else{
						//remove delimiters
						amtA = amtA.replace(/\./g, "");
						amtA = amtA.replace("/ /g", "");
						amtA = amtA.replace(/\,/g, "");
						amtA = parseFloat(amtA);
					}
					if(!amtB || amtB == "" || amtB == null){
						amtB = 0;
					}
					else{
						//remove delimiters
						amtB = amtB.replace(/\./g, "");
						amtB = amtB.replace("/ /g", "");
						amtB = amtB.replace(/\,/g, "");
						amtB = parseFloat(amtB);
					}		
					
					if (amtA > amtB)
					{
						return 1;
					}
					if (amtA < amtB)
					{
						return -1;
					}
					return 0;
				},
				
				sortAccountNumberColumn : function( /* String */a,
						/* String */b)
						{
				    //  summary:
					//            Filter for sorting columns in a grid that contain links, based on the 
					//            innerText of the link ie. <a>sort text</a>
					
					var accntA = a.substring(a.indexOf(">", 1)+1, a.indexOf("<", 1));
					var accntB = b.substring(b.indexOf(">", 1)+1, b.indexOf("<", 1));
					 
							if (accntA > accntB)
							{
								return -1;
							}
							if (accntA < accntB)
							{
								return 1;
							}
							return 0;
						},

		sortFloatColumn : function( /*Int,Float*/ a, 
									/*Int,Float*/ b){
			//  summary:
			//            Filter for sorting float values in a grid.

			var floatA = parseFloat(a);
			var floatB = parseFloat(b);
			if((isNaN(floatA) && isNaN(floatB)) || (floatA === floatB)) {
				return 0; 
			}// null considered as larger value
			else if(isNaN(floatA) || (floatA > floatB)){   
				return 1; 
			}
			else{
				return -1;
			} 
		},

		sortLinkColumn : function(a, b) {
			//  summary:
			//            Filter for sorting columns in a grid that contain links, based on the 
			//            innerText of the link ie. <a>sort text</a>
		    //  tags:
		    //            public
			var innerA = a.substring(a.indexOf(">", 1)+1, a.indexOf("<", 1));
			var innerB = b.substring(b.indexOf(">", 1)+1, b.indexOf("<", 1));
			
			if(innerA > innerB) {
				return 1;
			}
			if(innerA < innerB) {
				return -1;
			}

			return 0;
		},
		sortLinkDateColumn : function(a, b) {
			//  summary:
			//            Filter for sorting date-columns in a grid that contain links, based on the 
			//            innerText of the link. That is,<a>sort date-text inside link</a>
		    //  tags:
		    //            public
			var innerA = a.substring(a.indexOf(">", 1)+1, a.indexOf("<", 1));
			var innerB = b.substring(b.indexOf(">", 1)+1, b.indexOf("<", 1));
			
			return m.grid.sortDateColumn(innerA, innerB);
		},
		//format the milliseconds date to user local format
		formatDateTimeColumn : function(dateTimeColumnValue) {
					if(!dateTimeColumnValue.match(/^[0-9]+$/i)) 
					{
					    return dateTimeColumnValue;
					}
					else{
					var dateTimeMillis = eval(dateTimeColumnValue);
					console.warn('formatDateTimeColumn has been called!!');
					var formattedString = dojo.date.locale.format(new Date(dateTimeMillis), {datePattern: m.getLocalization("g_strGlobalDateFormat"), selector: "date"});
					return formattedString;
				}
		},
		
		sortCaseSensetiveColumn : function(a, b) {
			//  summary:
			//            Filter for sorting columns in a grid that contain links, based on the 
			//            innerText of the link ie. <a>sort text</a>
		    //  tags:
		    //            public
			var A = a.toLowerCase();
			var B = b.toLowerCase();
			
			if(A > B) {
				return 1;
			}
			if(A < B) {
				return -1;
			}

			return 0;
		},
		
		sortOnAnchorDescriptionCaseSensetive : function(a, b) {
			
			var element = document.createElement("div");
			element.innerHTML = a;
			var innerTextA = element.innerText;
			element.innerHTML = b;
			var innerTextB = element.innerText;
			
			return misys.grid.sortCaseSensetiveColumn(innerTextA, innerTextB);
		},


		sortDateColumn : function( /*String*/ a, 
								   /*String*/ b) {
			// summary: 
			//		Sorts a grid column containing dates

			var dateFormat = m.getLocalization("g_strGlobalDateFormat");
			var dateA = d.date.locale.parse(a, {
				selector :"date",
				datePattern : dateFormat
			});
			var dateB = d.date.locale.parse(b, {
				selector :"date",
				datePattern : dateFormat
			});
			return d.date.compare(dateA, dateB);
		},
		sortFormatDateColumn : function( /*String*/ a, 
						   /*String*/ b) {
			// summary: 
			//		Sorts a grid column containing dates with formatted string
			
			var dateFormat = m.getLocalization("g_strGlobalDateFormat");
			var formattedA = m.grid.formatDate(a);
			var formattedB = m.grid.formatDate(b);
			var dateA = d.date.locale.parse(formattedA, {
				selector :"date",
				datePattern : dateFormat
			});
			var dateB = d.date.locale.parse(formattedB, {
				selector :"date",
				datePattern : dateFormat
			});
			return d.date.compare(dateA, dateB);
		},

		getURL : function(rowIndex, item) {
			//	summary:
			//		Gets an URL in a column. The URI is taken from <column_name>_uri. Scope is a
			//		Cell.
			
			if(!item || !item.i[this.field]) {
				return this.defaultValue;
			}
			
			if (!item.i[this.field + "_uri"]){
				return this.grid.store.getValue(item, this.field);
			}
			
			// NOTE Be careful not to introduce a carriage return here
			// otherwise it will return "undefined"
			return {
				text: this.grid.store.getValue(item, this.field),
				href: this.grid.store.getValue(item, this.field + "_uri")
			};
		},

		getActions : function(rowIndex, item) {
			//	summary:
			//		Generates actions in an action column. Just copy the value of
			//		<column_name>_uri field.
			
			if(!item) {
				return this.defaultValue;
			}

			return { href: this.grid.store.getValue(item, this.field + "_uri")};
		},

		//
		// The follow functions are (probably) deprecated
		//
		deleteRecords : function() {
			//  summary:
			//            Trigger the deletion of transaction records.
			
			m.concatCheckboxes(m.getLocalization("deleteTransactionsConfirmation"));
		},
		
		loadRecords : function() {
			//  summary:
			//            Trigger the loading of records.
			
			var count = 0;
			d.query(".gridCheckbox").forEach(function(checkbox){
				if(d.attr(checkbox, "checked")) {
					count++;
				}
			});

			if(count > 0) {
				m.concatCheckboxes(m.getLocalization("loadRecordsConfirmation", [count]));
			} else {
				m.dialog.show("ERROR", m.getLocalization("noTemplateSelectedError"));
			}
		}, 

		submitRecords : function() {
			//  summary:
			//            Trigger the submission of transaction records.
			
			m.concatCheckboxes(m.getLocalization("submitTransactionsConfirmation"));
		},

		//
		// The following functions are for the PO Group Folder
		// Consult also the binding create_po_folder.js
		//
		
		submitOpenAccount : function() {
			// TODO Temporary implementation
			// TODO This is called in a listdef, and so there's no way of getting a reference to 
			//		the grid or the action of the form.
			
			var handleCallback = function(){
				dj.byId("dijit_form_Button_3").set("disabled", false);
			};
			
			//dj.byId("dijit_form_Button_3").set("disabled", true);
			
			var grids = [];
			
			d.query(".dojoxGrid").forEach(function(g){
				grids.push(dj.byId(g.id));
			});
			
			var referenceId = dj.byId("referenceid") ? dj.byId("referenceid").get("value") : "";
			var tnxid = dj.byId("tnxid") ? dj.byId("tnxid").get("value") : "";
			var url = "/screen/AjaxScreen/action/RunPOGroupSubmission?s=PurchaseOrderScreen&operation=SUBMIT&option=PO_FOLDER&mode=DRAFT&tnxtype=01";
			
			if(referenceId) {
				url += "&referenceid=" + referenceId;
			}
			if(tnxid) {
				url += "&tnxid=" + tnxid;
			}				

			//m.grid.processRecords(grids, url, handleCallback);
			m.grid.processRecords(grids, url);
		},

		saveOpenAccount : function() {
			// TODO Temporary implementation
			// TODO This is called in a listdef, and so there's no way of getting a reference to 
			//		the grid or the action of the form.
			
			var grids = [];
			
			d.query(".dojoxGrid").forEach(function(g){
				grids.push(dj.byId(g.id));
			});
			
			var referenceId = dj.byId("referenceid") ? dj.byId("referenceid").get("value") : "";
			var tnxid = dj.byId("tnxid") ? dj.byId("tnxid").get("value") : "";
			var url = "/screen/AjaxScreen/action/RunPOGroupSubmission?s=PurchaseOrderScreen&operation=SAVE&option=PO_FOLDER&mode=DRAFT&tnxtype=01";
			
			if(referenceId) {
				url += "&referenceid=" + referenceId;
			}
			if(tnxid) {
				url += "&tnxid=" + tnxid;
			}			
			
			m.grid.processRecords(grids, url);
		},

		submitBankerGuarantee : function() {
			// TODO Temporary implementation
			// TODO This is called in a listdef, and so there's no way of getting a reference to 
			//		the grid or the action of the form.
			
			var grids = [];
			
			d.query(".dojoxGrid").forEach(function(g){
				grids.push(dj.byId(g.id));
			});
			
			var referenceId = dijit.byId("referenceid") ? dijit.byId("referenceid").get("value") : "";
			var tnxid = dijit.byId("tnxid") ? dijit.byId("tnxid").get("value") : "";
			var url = "/screen/AjaxScreen/action/RunGroupBGDelete?s=BankerGuaranteeScreen&operation=DELETE&option=PRODUCTS_MAINTENANCE";
			
			if(referenceId) {
				url += "&referenceid=" + referenceId;
			}
			if(tnxid) {
				url += "&tnxid=" + tnxid;
			}
			
			m.grid.processRecords(grids, url);
		},
		
		selectFolderRow : function( /*Dijit._widget*/ grid,
									/*Dijit._widget*/ gridItem, 
				  					/*Object*/ gridSelection) {
			// summary:
			//		Called onRowClick for a grid of PO transactions in the group folder screen
			
			var gridItems = [],
				selectGroup = false,
				rowIndex,
				arrayIndex,
				selectStartIndex,
				selectEndIndex;
			
			if(gridItem.i._row_type === 0) {
				// 1. Get all children for the group
				// 2. Pass to updateFolderTotal
				
				// Consult m._config.groups, which stores the rowIndex of all groups
				
				rowIndex = gridItem.n;
				
				// 1. Find the location of the groupId in the groups array
				if(rowIndex && rowIndex != null) {
					arrayIndex = d.indexOf(m._config.groups, rowIndex);
					if(arrayIndex > -1) {
						selectStartIndex = m._config.groups[arrayIndex] + 1;
						selectEndIndex = m._config.groups[arrayIndex + 1];
						selectGroup = gridSelection[rowIndex];
						
						// Reset folder total to zero
						m._config.folderTotals = m._config.folderTotals || {};
						m._config.folderTotals[gridItem.i._group_id] = 0;
						
						console.debug("[grid/_base] Toggling rows in range [", selectStartIndex, ",", selectEndIndex, ")");
						
						for(;selectStartIndex < selectEndIndex; selectStartIndex++) {
							grid.selection.setSelected(selectStartIndex, selectGroup);
							gridItems.push(grid.getItem(selectStartIndex));
						}
					} else {
						console.error("[grid/_base] Problem finding group Id index",
								groupId, " group row number array", m._config.groups);
					}
				}
			} 
			else if(gridItem.i._row_type === 1){
				gridItems.push(gridItem);
			}
		},
		
		selectUnsignedFolderRow : function( /*Dijit._widget*/ grid,
											/*Dijit._widget*/ gridItem, 
											/*Object*/ gridSelection) {
			// summary:
			//		Called onRowClick for a grid of PO transactions in the group unsigned folder
			//		screen
			var gridItems = d.isArray(gridItem) ? gridItem : [gridItem];
		},

		groupRecords : function() {
			//  summary:
			//            Trigger the submission of transaction records.
			m.concatCheckboxes(m.getLocalization("deleteRoutingSummariesConfirmation"));
		},

		printRecords : function( /*Dojox Grid*/ grid,
			  	 /*String*/ url) {

			// summary:
			var numSelected = grid.selection.getSelected().length;
			var storeSize	= grid.store._items.length;
			if(numSelected > 0 && storeSize > 0) {
				m.dialog.show("CONFIRMATION", 
						m.getLocalization("printTransactionsConfirmation", 
								[grid.selection.getSelected().length]), "", 
								function(){
					var grids = d.isArray(grid) ? grid : [grid],
							items = [],
							keys = "",
							intNbKeys = 0,
							reference, xhrArgs;
							
					d.forEach(grids, function(grid){
						items = grid.selection.getSelected();
						if(items && items.length) {
							d.forEach(items, function(selectedItem) {
								// extract the reference
								reference = grid.store.getValues(selectedItem, "box_ref");

								// separator
								if(keys !== ""){
									keys += ", ";
								}
								keys += reference;
								intNbKeys++;
							});
						}
					});
					var 
					urlParams = {
						"list_keys": keys
					};
										
					var form = new dijit.form.Form({
					    method: "POST",
					    action: m.getServletURL(url),
					    content: urlParams
					  }, "submitForm");
					var textarea = new dijit.form.SimpleTextarea({
					    name: "list_keys",
					    style: "width:auto;visibility:hidden;"
					  }, "list_keys");
					textarea.set("value",keys);
					form.domNode.appendChild(textarea.domNode);
					document.body.appendChild(form.domNode);
					form.domNode.appendChild(dijit.byId('token').domNode);
					form.submit();
					d.forEach(grids, function(g){
						// Reload data
						g.setStore(g.store);
						d.hitch(g, "render")();
		   
						// Clear selection once data fetch complete
						m.connect(g, "_onFetchComplete", function(){
							g.selection.clear();
						});
					});
				});
			} else {
				m.dialog.show("ERROR", m.getLocalization("noTransactionsSelectedError"));
			}
		
		},
		
		selectAllRecords : function(/*String*/ gridId) {
			//  summary:
			var i;
			for (i=0; i< dj.byId(gridId).rowCount; i++)
			{
				dj.byId(gridId).selection.addToSelection(i);
			}
		},
		
		deselectAllRecords : function(/*String*/ gridId) {
			//  summary:
			dj.byId(gridId).selection.deselectAll();
		},
		
		reloadDialogGridForSearchTerms : function(/*String*/formId,/*String*/ gridId) {
			// summary: 
			// This method is used for Search Criteria when using a ListDef in a Dialog
			
			var form = dj.byId(formId),
				grid = dj.byId(gridId),
				dateRegex = /Date/,
				timeRegex = /Time/,
				params = "?",
				store, baseURL;

			if(grid && form) {
				// Collect the search form field values as a JSON object
				
				if(dojo.byId('divResults')){
					   d.style("divResults", "margin", 0);
				}

				store = grid.get("store");
				misys.connect(grid, "_onFetchComplete", function(){
					setTimeout(function(){
						grid.resize();
					}, 500);		 			
				});
				baseURL = store.url;
				if(baseURL.indexOf("?listdef=") !== -1) {
					if(baseURL.indexOf("&") !== -1) {
					 params = baseURL.substring(baseURL.indexOf("?listdef="), 
							 baseURL.indexOf("&")) + "&";
					} else {
					 params = baseURL.substring(baseURL.indexOf("?listdef=")) + "&";	
					}
				}
				
				if(baseURL.indexOf("&fields=") !== -1) {
					var tempParams =  baseURL.substring(baseURL.indexOf("fields="));
					if(tempParams.indexOf("&") !== -1)
					{
						tempParams = tempParams.substring(tempParams.indexOf("fields="), tempParams.indexOf("&"));
					}
					params += tempParams + "&";	
				}
				
				form.getDescendants().forEach(function(field, i){
					if(field.name) {
						if(i !== 0) {
							params += "&";
						}
						var value = field.get("value");
						if(dateRegex.test(field.declaredClass) || (timeRegex.test(field.declaredClass))) {
							value = field.get("displayedValue");
						}
						
						if(value === " ") {
							value = "";
						}
						
						params += field.get("name") + "=" + encodeURIComponent(value);
					}
				});
				
				// If selectionMode not null, deselect all first then load new store
				// It is important to deselect first because listener may need store before 
				// it is discarded
				if (grid.selection && grid.get("selectionMode") !== "") {
					grid.selection.clear();
				}
						
				if(store.url.indexOf("?") !== -1) {
					baseURL = store.url.substring(0, store.url.indexOf("?"));
				}
				store.close();
				store.url = baseURL + params;
				console.debug("[misys.grid._base] Resetting grid store URL to", store.url);
				grid.setStore(store);
				
			}
		},
		
		// Open Account - Add Product Identifier, Product Characteristic, Product Category formatter
		formatOpenAccountProductType: function(rowIndex, item) {
			var type = dojo.isArray(item.type) ? item.type[0] : item.type;
			var typeLabel = dojo.isArray(item.type_label) ? item.type_label[0] : item.type_label;
			var otherType = dojo.isArray(item.other_type) ? item.other_type[0] : item.other_type;
			return (type == "OTHR" ? otherType : typeLabel);
		},

		showGroups : function( /*String*/ gridId,
							   /*String*/ buttonId) {
			// summary:
			//		Shows groups and hide the "open" button
			
			m.grid.toggleAllGroups(gridId, true);
			d.style(d.byId("open" + buttonId), "display", "none");
			d.style(d.byId("close" + buttonId), "display", "inline");
		},

		hideGroups : function( /*String*/ gridId,
							   /*String*/ buttonId) {
			// summary:
			//		Hide groups and hide the "close" button
			
			m.grid.toggleAllGroups(gridId, false);
			d.style(d.byId("close" + buttonId), "display", "none");
			d.style(d.byId("open" + buttonId), "display", "inline");
		},

		toggleAllGroups : function( /*Dijit._widget || DomNode || String*/ node,
									/*Boolean*/ inShow) {
			// summary:
			//		Shows/hides all groups.
			//
			// Description: 
			//		inShow true is should show the group, false otherwise the id of the
			//		group to show/hide
			
			var grid = dj.byId(node);
			if(grid && "expandedGroups" in grid) {
				for(var i = 1, rowCount = grid.rowCount; i <= rowCount; i++){
					grid.expandedGroups[i] = inShow;
				}
			}
			grid.update();
		}, 
		
		toggleAllGroupsWithTimeOut : function( /*Dijit._widget || DomNode || String*/ node,
				/*Boolean*/ inShow) {
			// summary:
			//		Shows/hides all groups.
			//
			// Description: 
			//		inShow true is should show the group, false otherwise the id of the
			//		group to show/hide

			var grid = dj.byId(node);
			if(grid && "expandedGroups" in grid) {
				for(var i = 1, rowCount = grid.rowCount; i <= rowCount; i++){
					grid.expandedGroups[i] = inShow;
				}
			}
			else
			{
				setTimeout(function(){
					if(grid && "expandedGroups" in grid) {
						for(var i = 1, rowCount = grid.rowCount; i <= rowCount; i++){
							grid.expandedGroups[i] = inShow;
						}
				}}, 1000);
			}
			grid.update();
		}, 

		getGroupHeader : function(rowIndex, item) {
			// summary:
			//		Builds the data for the group header.
			// description:
			//		return a JSON object with all data nicely set for the
			// 		misys.grid.formatGroupHeader() formatter
			
			if(!item) {
				return "undefined";
			}
			this.grid.expandedGroups = this.grid.expandedGroups || [];

			var groupId = this.grid.store.getValue(item, "_group_id"),
			
				// determine the target state
				// TODO Can this guard ever be true?
				show = (typeof this.grid.expandedGroups[groupId] !== "undefined" && 
						!this.grid.expandedGroups[groupId]);
			
			m._config.groups = m._config.groups || [];
			m._config.groups.push(rowIndex);
			
			// NOTE Be careful not to introduce a carriage return here
			// otherwise it will return "undefined"
			return {
				groupId: groupId,
				show: show,
				name: this.grid.store.getValue(item, "_group_name"),
				gridId: this.grid.id,
				rowIndex: rowIndex
			};
		}, 
		
		getGroupFooter : function(inRowIndex, item) {
			// summary: 
			//
			// Description: 
			//	return a JSON object with all data nicely set for the
			//  m.grid.formatGroupHeader() formatter
			
			if(!item) {
				return "undefined";
			}
			
			// return a JSON object with all data nicely set for the
			// m.grid.formatGroupHeader() formatter
			
			// NOTE Be careful not to introduce a carriage return here
			// otherwise it will return "undefined"
		
			return {
				name: this.grid.store.getValue(item, "_group_name"),
				value: this.grid.store.getValue(item, "_group_footer"),
				gridId: this.grid.id
			};
		},
		
		formatGroupFooter : function(result, idx) {
			// summary:
			//		Formats a group footer.
			
			if (result && d.isObject(result)) {
				if (result.name === "_root") {
					return d.string.substitute("<b>${value}</b>", result);
				}

				return d.string.substitute("<i>${value}</i>", result);
			} else {
				return result;
			}
		},

		formatGroupHeader : function( /*JSON*/ result) {
			// summary:
			//		Formats a group header. The data is extracted by m.getGroupHeader().
			//
			// TODO Should create an image with dojo.create
			
			if (result && d.isObject(result)) {
				if(result.name === "_root") {
					return "";
				}

				result.image = result.show ? "closed.gif" : "open.gif";
				return d.string.substitute(
								"<img src='" + m.getContextualURL('/content/images/${image}') + 
								"' onclick='misys.grid.toggleGroup(${show}, \"${groupId}\"," +
								"\"${gridId}\")' height='11' width='11'> ${name}",
								result);
			} else {
				return result;
			}
		},

		setGroupBeforeRow : function(inDataIndex, inRow) {
			// summary:
			//		
			// Description: 
			//	inRow is an array of subRows. we hide the summary subRow except for every nth
			//  row should hide the normal row and the group row according to the row's values

			var footerPresent = inRow[2],
				headerIndex = 0,
				rowIndex = 1,
				item,
				groupId,
				rowType,
				groupName;
			
			inRow[headerIndex].hidden = false;
			inRow[rowIndex].hidden = false;
			if(footerPresent) {
				inRow[2].hidden = false;
			}
			
			if(inDataIndex < 0) {
				// This is the list header row
				inRow[headerIndex].hidden = true;
				// only show the regular rows header, this is because of a Dojo bug.
				inRow[rowIndex].hidden = false;
				if(footerPresent) {
					inRow[2].hidden = true;
				}

				return;
			}
			
			// Test the group row
			item = this.grid.getItem(inDataIndex);
			if (item) {
				groupId = this.grid.store.getValue(item, "_group_id");	// extract group id
				rowType = this.grid.store.getValue(item, "_row_type");	// extract row type
				groupName = this.grid.store.getValue(item, "_group_name"); // extract row type										
				// If this is a header
				if (rowType === 0) {
					if(groupName === "_root")
					{
						inRow[headerIndex].hidden = true;
					}
					else
					{
						inRow[headerIndex].hidden = false;
					}
					inRow[rowIndex].hidden = true;	// hide details
					if(footerPresent) {
						inRow[2].hidden = true;	// hide footer
					}
				}
				// If this is a detail row
				else if (rowType === 1)
				{
					inRow[headerIndex].hidden = true;	// hide header
					if (typeof this.grid.expandedGroups[groupId] != "undefined" && 
							!this.grid.expandedGroups[groupId]) {
						inRow[rowIndex].hidden = true; // hide details
					} else {
						inRow[rowIndex].hidden = false; // show details
					}
					if(footerPresent) {
						inRow[2].hidden = true; // hide footer
					}
				}
				// If this is a footer
				else if (rowType === 2) {
					inRow[headerIndex].hidden = true;	// hide header
					inRow[rowIndex].hidden = true;	// hide details
					if(footerPresent) {
						inRow[2].hidden = false;// show footer
					}
				}
			}
		},

		toggleGroup : function( /*Boolean*/ inShow,
								/*String*/ groupId, 
								/*String*/ gridId) {
			// summary:
			// 		Shows/hides a group.
			//
			// Description: 
			//       inShow true is should show the group, false otherwise @param groupid
			//		 the id of the group to show/hide
			
			var grid = dj.byId(gridId);
			grid.expandedGroups[groupId] = inShow;	// update the group state array
			grid.sizeChange();
		}
	});
	
	d.mixin(m, {
		redirectWithConfirmation : function( /*String*/ strURL, 
											 /*String*/ intMessageCode) {
			// summary: 
			//    Before redirecting the user, we ask for a confirmation if applicable
			//
			// TODO Should be retested
			
			if (intMessageCode) {
			    m.dialog.show("CONFIRMATION", intMessageCode, "", function(){
			    	window.location.href = strURL;
			    });
			} else {
				window.location.href = strURL;
			}
		}, 
		
		toggleHistoryButton : function(/*String*/ type) {
			// summary:
			//
			// TODO Where is this used? Shouldn't it just use m.toggleFields ?
			
			var height;
			if(type === "STANDARD") {
				height = d.position(dj.byId("threadHistoryButton").domNode).h;
				d.style(dj.byId("threadHistoryButton").domNode, "display", "none");
				d.style(dj.byId("historyButton").domNode, "display", "block");
			} else {
				height = d.position(dj.byId("historyButton").domNode).h;
				d.style(dj.byId("threadHistoryButton").domNode, "display", "block");
				d.style(dj.byId("historyButton").domNode, "display", "none");
			}
			
			d.style("historyButtons", "height", height+"px");
		},
		
		// TODO Rearrange arguments
		concatCheckboxes : function( /*String*/ confirmationMessage,
									 /*Boolean*/ doAction,
									 /*String*/ actionType) {
			//  summary:
			//            Trigger the deletion/submission/initiation of transaction records.
			//
			// TODO Needs to be retested
			var keys = "",
				intNbKeys = 0,
				theTopForm,
				theRealForm; 
			
			if(doAction)
			{
				// The list of keys specifying the records to concat 
				// (whether ref_ids, tnx_ids or product code)
				theTopForm = dj.byId("TransactionSearchForm");
				theRealForm = dj.byId("RealForm"); 
				
				//Scan the form containing the list
				d.query(".gridCheckbox").forEach(function(checkbox){
					if(d.attr(checkbox, "checked")) {
						if(keys.length !== 0) {
							keys += ", ";
						} 
						keys += checkbox.id;
						intNbKeys++;
					}
				});
				
				if(keys.length > 0) {
					console.debug("[misys.grid._base] ListKeys are", keys);
					dj.byId("list_keys").set("value", keys);
					if (actionType === "dissociate"){
						theRealForm.set("action", 
								m.getServletURL("/screen/BankSystemFeaturesScreen?operation=" + 
									"REMOVE_CUSTOMER_AS_COUNTERPARTY&option=CUSTOMER_COUNTERPARTY"));
					}
					
					theRealForm.submit();
				}

				
				/*var checkList = d.query(".gridCheckbox");
				for(var i=0;i<checkList.length;i++)
				{
				 if((checkList[i].type === "checkbox") && (checkList[i].name != "select_all_box"))
				 {
				  if(checkList[i].checked)
				  {
					  // If this is not the first element in the list, we add a comma separator
				      if("S" + keys != "S"){
				    	  keys = keys + ", ";
				      }
				      // And then we add the key (name of the checkbox) related to the record
				      keys = keys +  checkList[i].name ;
				      intNbKeys++;
				   }
				  }
				}
				console.debug("[misys.grid._base] ListKeys = " + keys);
			    // If the list is not empty (some records need to be deleted or submitted), 
			    // we post the form with the list as a parameter
			    if("S" + keys != "S")
			    {  
			     theRealForm.list_keys.value = keys;
			     theRealForm.submit();
			    }*/
			}
			else
			{
				m.dialog.show("CONFIRMATION", confirmationMessage, "", function(){
					m.concatCheckboxes(confirmationMessage, true, actionType);
				});
			}
		},
		
		showTransactionUsersDialog : function(parameterSet, productCode, title) {
			var node = d.query(".grid")[0],
				grid,
				selectedIndex;
			
			if(node) {
				grid = dj.byId(node.id);
				selectedIndex = grid.focus.rowIndex;
				if(grid.selection.isSelected(selectedIndex)) {
					grid.selection.deselect(selectedIndex);
				}
				else {
					grid.selection.setSelected(selectedIndex, true);
				}
			}
			
			m.showSearchDialog("User", "", parameterSet, 
					"AjaxScreen/action/GetValidationUsersPopup", productCode, 
					"width:700px;height:600px;overflow:auto;", title, "", "GetValidationUsersList");
		},
		
		toggleSearchGrid : function(){
			var downArrow = d.byId("actionDown");
			var upArrow = d.byId("actionUp");
			var searchDiv = d.byId("searchCriteria");
			if(d.style("searchCriteria","display") === "none")
			{
				m.animate('wipeIn',searchDiv);
				d.style('actionDown',"display","none");
				d.style('actionUp',"display","block");
				if(window.isAccessibilityEnabled) {
					d.style('actionUp', "cursor", "default");
				} else {
					d.style('actionUp', "cursor", "pointer");
				}
			}
			else
			{
				m.animate('wipeOut',searchDiv);
				d.style('actionUp',"display","none");
				d.style('actionDown',"display","block");
				if(window.isAccessibilityEnabled) {
					d.style('actionDown', "cursor", "default");
				} else {
					d.style('actionDown', "cursor", "pointer");
				}
			}
		}		
		
	});

	// 
	// Onload/Unload/onWidgetLoad Events
	//
})(dojo, dijit, misys);

}

if(!dojo._hasResource["misys.widget.Bookmark"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.widget.Bookmark"] = true;
dojo.provide("misys.widget.Bookmark");
/*
 -----------------------------------------------------------------------------
 Scripts for saving bookmarks/favourites

 Copyright (c) 2000-2010 Misys (http://www.misys.com),
 All Rights Reserved. 

 version:   1.0
 date:      15/02/08
 -----------------------------------------------------------------------------
*/

fncSaveBookmarkAction = function(/*String*/ link, /*String*/ actionValue, /*String*/ screenValue)
{  
	//      summary:
    //            Saves a screen bookmark
    //      tags:
    //            protected
	var text = '';
	var xmlString =['<?xml version=\"1.0\" encoding=\"UTF-8\"?><bookmark>'];
	var nodeBookmark = dijit.byId('sendBookmark');
	dojo.forEach(nodeBookmark.getDescendants(),
			function(field){
				xmlString.push("<", field.get("name"), ">",
								field.get("value"),
								"</", field.get("name"), ">");
			}
	);
	
	xmlString.push('<bookmark_id>', link, '</bookmark_id>'); 
	xmlString.push('<action>', link, '</action></bookmark>');
	
	console.debug('[Bookmarks] Adding Bookmark - Request XML');
	console.debug('[Bookmarks] ' + xmlString.join(''));
	var deferred = misys.xhrPost( {
		url : misys.getServletURL('/screen/BookmarkScreen?currentActionCode=' +actionValue+'&currentScreen='+screenValue),
		postData: xmlString.join(''),
		load : function(response){
			text = response;
		}
	});
	
	deferred.then(function(){
		console.debug('[Bookmarks] Adding Bookmrk - Response = ' + text);
		var favorites = dojo.byId('favorites');
		if(!dijit.byId('sendBookmark')){
		 dojo.parser.parse(dojo.byId('favorites'));
		}
		misys.animate("wipeOut", favorites, function(){
			dijit.byId('sendBookmark').destroyRecursive(true);
			// substring is used to avoid duplicated favorites node
			favorites.innerHTML = text.substring(20, text.length - 6);
			misys.animate("wipeIn",favorites);
		});
	});
	return deferred;
};

fncDeleteBookmarkAction = function(/*String*/ id, /*String*/ action, /*String*/ actionValue, /*String*/ screenValue)
{
    //  summary:
    //            Deletes a bookmark
    //      tags:
    //            protected
	var xmlString = ['<?xml version=\"1.0\" encoding=\"UTF-8\"?><bookmark>'];
	var nodeBookmark = dijit.byId('sendBookmark');
	dojo.forEach(nodeBookmark.getDescendants(),
			function(field){
				if(field.id != 'bookmark_'+id) {
					xmlString.push("<", field.get("name"), ">",
							field.get("value"),
							"</", field.get("name"), ">");
				}
			}
	);
	
	xmlString.push('<action>', action, '</action></bookmark>');
	
	console.debug('[Bookmarks] Deleting Bookmark - Request XML');
	console.debug('[Bookmarks] ' + xmlString);
	var text = '';
	var deferred = misys.xhrPost( {
		url : misys.getServletURL('/screen/BookmarkScreen?currentActionCode=' +actionValue+'&currentScreen='+screenValue),
		postData: xmlString.join(""),
		load : function(response){
			text = response;
		}
	});
	
	deferred.then(function(){
		//console.debug('[Bookmarks] Deleting Bookmark - Response = ' + text);
		var favorites = dojo.byId('favorites');
		if(!dijit.byId('sendBookmark')){
		 dojo.parser.parse(dojo.byId('favorites'));
		}
		misys.animate("wipeOut", favorites, function(){
			// destroy java script object that will be changed by the innerHTML update
			dijit.byId('sendBookmark').destroyRecursive(true);
			// substring is used to avoid duplicated favorites node
			favorites.innerHTML = text.substring(20, text.length - 6);
			
			// parse the new html block to register new java script objects.
			misys.animate("wipeIn", favorites);
		});

		
	});
	return deferred;
};


fncDoBookmarkAction = function( /*String*/ type,
        /*String*/ action, 
        /*String*/ id, 
        /*String*/ actionValue, 
        /*String*/ screenValue){
//      summary:
//            Save or Deletes a bookmark, and ensures everything is parsed and loaded first.
//      tags:
//            protected
if(!dijit.byId('sendBookmark'))
{

dojo.parser.parse('favorites');
}

if (type == 'SAVE') {
fncSaveBookmarkAction(action, actionValue, screenValue);
} else { 
fncDeleteBookmarkAction(id, action, actionValue, screenValue);
}
};

}

if(!dojo._hasResource["misys.binding.SessionTimer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.binding.SessionTimer"] = true;
/**
 * Created : 05/05/2011
 * Timer to handle Idle Session timeout and Session Duration timeout
*/
dojo.provide("misys.binding.SessionTimer");

// TODO This should be turned into a proper widget. It's not really
//		a proper binding file, it doesn't match the others (+ name is wrong)

(function(/*Dojo*/ d, /*Misys*/m){
	
	 // ECMA5 Strict Mode
	
	/*
	 -----------------------------------------------------------------------------
	 Copyright (c) 2000-2011 Misys (http://www.misys.com),
	 All Rights Reserved. 

	 version:   1.1
	 date:      28/06/2011
	 -----------------------------------------------------------------------------
	*/
	
	//Dialog for After Max duration over Session
	function _showMaxDurationOverDialog(){
		
		var sessionMaxDurationOverDialog = dijit.byId("sessionMaxDurationOverDialog");
		var sessionMaxDurationOverDialogButtons = dojo.byId('sessionMaxDurationOverDialogButtons'),
		sessionMaxDurationOverButton = dijit.byId('sessionMaxDurationOverButton').domNode;
		var sessionMaxDurationOverDialogContent = dojo.byId('sessionMaxDurationOverDialogContent'); 

		dojo.style(sessionMaxDurationOverDialogButtons, 'display', 'block');
		dojo.style(sessionMaxDurationOverDialogContent, 'display', 'block');
		dojo.style(sessionMaxDurationOverButton, 'display', 'inline-block');
		dojo.style(sessionMaxDurationOverDialog.closeButtonNode, 'display', 'none');
		sessionMaxDurationOverDialog.set('title', misys.getLocalization('sessionalertMessage'));
		
		// Disable window closing by using the escape key
		misys.dialog.connect(sessionMaxDurationOverDialog, 'onKeyPress', function(evt) {
			if (evt.keyCode == dojo.keys.ESCAPE) {
				dojo.stopEvent(evt);
			}
		});
			
		misys.dialog.connect(dijit.byId('sessionMaxDurationOverButton'), 'onClick', function(){
			misys.dialog.disconnect(sessionMaxDurationOverDialog);
			sessionMaxDurationOverDialog.hide();
			document.location.href = dojo.byId('loginAction').value;
		}, sessionMaxDurationOverDialog.id);
		
		misys.dialog.connect(sessionMaxDurationOverDialog, 'onHide', function() {
				misys.dialog.disconnect(sessionMaxDurationOverDialog);
		});
		
		sessionMaxDurationOverDialog.show();
	}

	
	
	//Dialog for Alerting Idle Session Timeout 
	function _showIdleSessionDialog(){
		var idleDialog = dijit.byId("idleSessionDialog");
		var idleSessionDialogButtons = dojo.byId('idleSessionDialogButtons'),
			sessionContinueButtonNode = dijit.byId('sessionContinueButton').domNode,
			logButtonNode = dijit.byId('sessionlogButton').domNode;
		var idleSessionDialogContent = dojo.byId('idleSessionDialogContent'); 

		dojo.style(idleSessionDialogButtons, 'display', 'block');
		dojo.style(idleSessionDialogContent, 'display', 'block');
		dojo.style(sessionContinueButtonNode, 'display', 'inline-block');
		dojo.style(logButtonNode, 'display', 'inline-block');
		dojo.style(idleDialog.closeButtonNode, 'display', 'none');
		idleDialog.set('title', misys.getLocalization('sessionalertMessage'));
		
		// Disable window closing by using the escape key
		misys.dialog.connect(idleDialog, 'onKeyPress', function(evt) {
			if (evt.keyCode == dojo.keys.ESCAPE) {
				dojo.stopEvent(evt);
			}
		});
		
		misys.dialog.connect(dijit.byId('sessionContinueButton'), 'onClick', function(){

			var sessionOver = false;
			misys.xhrGet( {
				url : misys.getServletURL("/screen/AjaxScreen/action/PingAction"),
				sync : true,
				handleAs : "text",
				load : function(response, args){
					if(response.indexOf('SC_UNAUTHORIZED') !== -1)
					{
						sessionOver = true;
					}							
				},
				customError : function(response, ioArgs) {				
					sessionOver = true;
				}
			});
			
			if(sessionOver){
				misys.showSessionOverDialog();
				misys.dialog.disconnect(idleDialog);
				idleDialog.hide();
			}else{
				misys.idleSessionTimer(0);
				misys.dialog.disconnect(idleDialog);
				idleDialog.hide();
			}
			
		
		}, idleDialog.id);
		
		misys.dialog.connect(dijit.byId('sessionlogButton'), 'onClick', function(){
			misys.dialog.disconnect(idleDialog);
			idleDialog.hide();
			if(dojo.byId('_token') && dojo.byId('logoutAction'))
			{
				misys.post({action:dojo.byId('logoutAction').value, params : [{name:'commonToken', value:dojo.byId('_token').value}]});	
			}
		}, idleDialog.id);
		
		misys.dialog.connect(idleDialog, 'onHide', function() {
				misys.dialog.disconnect(idleDialog);
		});
		
		
		idleDialog.show();
	}
	
	//Dialog for Alerting Max Session Duration Timeout
	function _showDurationSessionDialog(){
		
		//console.debug("Inside _showDurationSessionDialog method starting...... ");
		
		var durationDialog = dijit.byId("durationSessionDialog");
		var durationSessionDialogButtons = dojo.byId('durationSessionDialogButtons'),
			okButtonNode = dijit.byId('OkSessionButton').domNode;
		var durationSessionDialogContent = dojo.byId('durationSessionDialogContent'); 
	
		dojo.style(durationSessionDialogButtons, 'display', 'block');
		dojo.style(durationSessionDialogContent, 'display', 'block');
		dojo.style(okButtonNode, 'display', 'inline-block');
		dojo.style(durationDialog.closeButtonNode, 'display', 'none');
		durationDialog.set('title', misys.getLocalization('sessionalertMessage'));
		
		// Disable window closing by using the escape key
		misys.dialog.connect(durationDialog, 'onKeyPress', function(evt) {
			if (evt.keyCode == dojo.keys.ESCAPE) {
				dojo.stopEvent(evt);
			}
		});
		
		misys.dialog.connect(dijit.byId('OkSessionButton'), 'onClick', function(){
			
			var sessionOver = true;
			misys.xhrGet( {
				url : misys.getServletURL("/screen/AjaxScreen/action/PingAction"),
				sync : true,
				handleAs : "text",
				load : function(response, args){
					if(response.indexOf('SC_UNAUTHORIZED') === -1)
					{
						sessionOver = false;
					}							
				},
				customError : function(response, ioArgs) {				
					sessionOver = false;
				}
			});
			
			if(sessionOver){
				misys.showSessionOverDialog();
				misys.dialog.disconnect(durationDialog);
				durationDialog.hide();
			}else{
				
				misys.dialog.disconnect(durationDialog);
				durationDialog.hide();
			}
			
			
		}, durationDialog.id);
		
		misys.dialog.connect(durationDialog, 'onHide', function() {
				misys.dialog.disconnect(durationDialog);
		});
		
		durationDialog.show();
//		console.debug("Inside _showDurationSessionDialog after showing durationDialog....");
//		console.debug("Inside _showDurationSessionDialog calling startAutoLogoutCounter...... ");
		misys.startAutoLogoutCounter(misys._config.sessionMaxDurationTimeAlert);
	}
	
	
	d.mixin(m, {
		
		//Dialog for Already Expired Session
		showSessionOverDialog : function(){
			
			var sessionOverDialog = dijit.byId("sessionOverDialog");
			var sessionOverDialogButtons = dojo.byId('sessionOverDialogButtons'),
				sessionOverButton = dijit.byId('sessionOverButton').domNode;
			var sessionOverDialogContent = dojo.byId('sessionOverDialogContent'); 

			dojo.style(sessionOverDialogButtons, 'display', 'block');
			dojo.style(sessionOverDialogContent, 'display', 'block');
			dojo.style(sessionOverButton, 'display', 'inline-block');
			dojo.style(sessionOverDialog.closeButtonNode, 'display', 'none');
			sessionOverDialog.set('title', misys.getLocalization('sessionalertMessage'));
			
			// Disable window closing by using the escape key
			misys.dialog.connect(sessionOverDialog, 'onKeyPress', function(evt) {
				if (evt.keyCode == dojo.keys.ESCAPE) {
					dojo.stopEvent(evt);
				}
			});
				
			misys.dialog.connect(dijit.byId('sessionOverButton'), 'onClick', function(){
				misys.dialog.disconnect(sessionOverDialog);
				sessionOverDialog.hide();
				if(dojo.byId('customLoginAction') && dojo.byId('customLoginAction').value)
				{
					document.location.href = dojo.byId('customLoginAction').value;
				}
				else
				{
					document.location.href = dojo.byId('loginAction').value;
				}
			}, sessionOverDialog.id);
			
			misys.dialog.connect(sessionOverDialog, 'onHide', function() {
					misys.dialog.disconnect(sessionOverDialog);
			});
			
			sessionOverDialog.show();
		},
		
		startAutoLogoutCounter : function(sessionMaxDurationTimeAlert){	
			
//			console.debug("Inside startAutoLogoutCounter starting...");
//			console.debug("sessionMaxDurationDialogTimeAlert parameter passes is "+sessionMaxDurationTimeAlert);
			
			var durationDialog = dijit.byId("durationSessionDialog");
			
			//Counter
			if(sessionMaxDurationTimeAlert <= misys._config.sessionMaxDurationTime)
			{
				sessionMaxDurationTimeAlert = sessionMaxDurationTimeAlert+1;
				setTimeout("misys.startAutoLogoutCounter("+sessionMaxDurationTimeAlert+")",1000);
			}
			//TimeOut
			else 
			{
				sessionMaxDurationTimeAlert = 0;
				//fire an ajax for auto logout
				var sessionOver = false;
				misys.xhrGet( {
					url : misys.getServletURL("/screen/AjaxScreen/action/PingAction"),
					sync : true,
					handleAs : "text",
					load : function(response, args){
						if(response.indexOf('SC_UNAUTHORIZED') !== -1)
						{
							sessionOver = true;
							
						}	
//						console.debug("ajax call made to auto logout is sucess and return value of sessionalreadyover is: "+sessionOver);
					},
					customError : function(response, ioArgs) {				
						sessionOver = true;
						//console.debug("ajax call made to auto logout is failed.........");
					}
				});
				
				if(sessionOver){
					//console.debug("calling misys.showSessionOverDialog...");
					misys.showSessionOverDialog();
					misys.dialog.disconnect(durationDialog);
					durationDialog.hide();
				}else{
					
					//console.debug("calling _showMaxDurationOverDialog popup");
					_showMaxDurationOverDialog();
					misys.dialog.disconnect(durationDialog);
					durationDialog.hide();
				}
			}
			
		},
		
		//Timer for Idle Session Duration
		idleSessionTimer : function(idleTimer)
		{
//			console.debug("calling idleSessionTimer..."+idleTimer);
			if(dojo.byId("idleSessionTimeOutIndicator"))
			{ 
				//Counter
				if(idleTimer <= (misys._config.idleSessionTimeOutTime))
				{
					idleTimer = idleTimer+1;
					setTimeout("misys.idleSessionTimer("+idleTimer+")",1000);
				}
				//TimeOut
				else if(!misys._config.stopIdleSessionTimer)
				{
					idleTimer = 0;
					_showIdleSessionDialog();
				}
			}	
			
		},
		
		//Timer for Max Session Duration
		durationSessionTimer : function(durationTimer)
		{
//			console.debug("calling durationSessionTimer..."+durationTimer);
			if(dojo.byId("sessionMaxDurationIndicator"))
			{	
				var sessionTime = misys._config.presentTime - misys._config.loginTime;
				sessionTime = Math.floor(sessionTime/1000);
				var sessionMaxDurationDialogTimeAlert = misys._config.sessionMaxDurationTimeAlert;
				var remainingTime = sessionMaxDurationDialogTimeAlert - sessionTime;
				
				//Counter
				if(durationTimer <= (remainingTime))
				{
					durationTimer = durationTimer+1;
					setTimeout("misys.durationSessionTimer("+durationTimer+")",1000);
				}
				//TimeOut
				else 
				{
//					console.debug("Inside durationSessionTimer method and durationTimer is"+ durationTimer);
					durationTimer = 0;
					_showDurationSessionDialog();
					//make sure idle-dialog is closed if it is on open state
					misys._config.stopIdleSessionTimer = true;
					//misys.idleSessionTimer(0);
					var idleDialog = dijit.byId("idleSessionDialog");
					if(idleDialog){
						//just call hide
				
					idleDialog.hide();
					}
//					console.debug("Inside durationSessionTimer method end");
					
				}
			}
		}
	});
})(dojo, misys);

}

if(!dojo._hasResource["dojox.html.entities"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.html.entities"] = true;
dojo.provide("dojox.html.entities");

(function(){
	// dojox.html.entities.html [public] Array
	//		Entity characters for HTML, represented as an array of
	//		character code, entity name (minus & and ; wrapping.
	//		The function wrapper is to fix global leking with the build tools.
	
	var _applyEncodingMap = function(str, map){
		// summary:
		//		Private internal function for performing encoding of entity characters.
		// tags:
		//		private
	
		// Check to see if we have genned and cached a regexp for this map yet
		// If we have, use it, if not, gen it, cache, then use.
		var mapper, regexp;
		if(map._encCache &&
			map._encCache.regexp &&
			map._encCache.mapper &&
			map.length == map._encCache.length){
			mapper = map._encCache.mapper;
			regexp = map._encCache.regexp;
		}else{
			mapper = {};
			regexp = ["["];
			var i;
			for(i = 0; i < map.length; i++){
				mapper[map[i][0]] = "&" + map[i][1] + ";";
				regexp.push(map[i][0]);
			}
			regexp.push("]");
			regexp = new RegExp(regexp.join(""), "g");
			map._encCache = {
				mapper: mapper,
				regexp: regexp,
				length: map.length
			};
		}
		str = str.replace(regexp, function(c){
			return mapper[c];
		});
		return str;
	};
	
	var _applyDecodingMap = function(str, map){
		// summary:
		//		Private internal function for performing decoding of entity characters.
		// tags:
		//		private
		var mapper, regexp;
		if(map._decCache &&
			map._decCache.regexp &&
			map._decCache.mapper &&
			map.length == map._decCache.length){
			mapper = map._decCache.mapper;
			regexp = map._decCache.regexp;
		}else{
			mapper = {};
			regexp = ["("];
			var i;
			for(i = 0; i < map.length; i++){
				var e = "&" + map[i][1] + ";";
				if(i){regexp.push("|");}
				mapper[e] = map[i][0];
				regexp.push(e);
			}
			regexp.push(")");
			regexp = new RegExp(regexp.join(""), "g");
			map._decCache = {
				mapper: mapper,
				regexp: regexp,
				length: map.length
			};
		}
		str = str.replace(regexp, function(c){
			return mapper[c];
		});
		return str;
	};
	
	dojox.html.entities.html = [
		["\u0026","amp"], ["\u0022","quot"],["\u003C","lt"], ["\u003E","gt"],
		["\u00A0","nbsp"]
	];
	
	dojox.html.entities.map = [["\u00A0","nbsp"]];
	
	// dojox.html.entities.latin [public] Array
	//		Entity characters for Latin characters and similar, represented as an array of
	//		character code, entity name (minus & and ; wrapping.
	dojox.html.entities.latin = [
		["\u00A1","iexcl"],["\u00A2","cent"],["\u00A3","pound"],["\u20AC","euro"],
		["\u00A4","curren"],["\u00A5","yen"],["\u00A6","brvbar"],["\u00A7","sect"],
		["\u00A8","uml"],["\u00A9","copy"],["\u00AA","ordf"],["\u00AB","laquo"],
		["\u00AC","not"],["\u00AD","shy"],["\u00AE","reg"],["\u00AF","macr"],
		["\u00B0","deg"],["\u00B1","plusmn"],["\u00B2","sup2"],["\u00B3","sup3"],
		["\u00B4","acute"],["\u00B5","micro"],["\u00B6","para"],["\u00B7","middot"],
		["\u00B8","cedil"],["\u00B9","sup1"],["\u00BA","ordm"],["\u00BB","raquo"],
		["\u00BC","frac14"],["\u00BD","frac12"],["\u00BE","frac34"],["\u00BF","iquest"],
		["\u00C0","Agrave"],["\u00C1","Aacute"],["\u00C2","Acirc"],["\u00C3","Atilde"],
		["\u00C4","Auml"],["\u00C5","Aring"],["\u00C6","AElig"],["\u00C7","Ccedil"],
		["\u00C8","Egrave"],["\u00C9","Eacute"],["\u00CA","Ecirc"],["\u00CB","Euml"],
		["\u00CC","Igrave"],["\u00CD","Iacute"],["\u00CE","Icirc"],["\u00CF","Iuml"],
		["\u00D0","ETH"],["\u00D1","Ntilde"],["\u00D2","Ograve"],["\u00D3","Oacute"],
		["\u00D4","Ocirc"],["\u00D5","Otilde"],["\u00D6","Ouml"],["\u00D7","times"],
		["\u00D8","Oslash"],["\u00D9","Ugrave"],["\u00DA","Uacute"],["\u00DB","Ucirc"],
		["\u00DC","Uuml"],["\u00DD","Yacute"],["\u00DE","THORN"],["\u00DF","szlig"],
		["\u00E0","agrave"],["\u00E1","aacute"],["\u00E2","acirc"],["\u00E3","atilde"],
		["\u00E4","auml"],["\u00E5","aring"],["\u00E6","aelig"],["\u00E7","ccedil"],
		["\u00E8","egrave"],["\u00E9","eacute"],["\u00EA","ecirc"],["\u00EB","euml"],
		["\u00EC","igrave"],["\u00ED","iacute"],["\u00EE","icirc"],["\u00EF","iuml"],
		["\u00F0","eth"],["\u00F1","ntilde"],["\u00F2","ograve"],["\u00F3","oacute"],
		["\u00F4","ocirc"],["\u00F5","otilde"],["\u00F6","ouml"],["\u00F7","divide"],
		["\u00F8","oslash"],["\u00F9","ugrave"],["\u00FA","uacute"],["\u00FB","ucirc"],
		["\u00FC","uuml"],["\u00FD","yacute"],["\u00FE","thorn"],["\u00FF","yuml"],
		["\u0192","fnof"],["\u0391","Alpha"],["\u0392","Beta"],["\u0393","Gamma"],
		["\u0394","Delta"],["\u0395","Epsilon"],["\u0396","Zeta"],["\u0397","Eta"],
		["\u0398","Theta"], ["\u0399","Iota"],["\u039A","Kappa"],["\u039B","Lambda"],
		["\u039C","Mu"],["\u039D","Nu"],["\u039E","Xi"],["\u039F","Omicron"],
		["\u03A0","Pi"],["\u03A1","Rho"],["\u03A3","Sigma"],["\u03A4","Tau"],
		["\u03A5","Upsilon"],["\u03A6","Phi"],["\u03A7","Chi"],["\u03A8","Psi"],
		["\u03A9","Omega"],["\u03B1","alpha"],["\u03B2","beta"],["\u03B3","gamma"],
		["\u03B4","delta"],["\u03B5","epsilon"],["\u03B6","zeta"],["\u03B7","eta"],
		["\u03B8","theta"],["\u03B9","iota"],["\u03BA","kappa"],["\u03BB","lambda"],
		["\u03BC","mu"],["\u03BD","nu"],["\u03BE","xi"],["\u03BF","omicron"],
		["\u03C0","pi"],["\u03C1","rho"],["\u03C2","sigmaf"],["\u03C3","sigma"],
		["\u03C4","tau"],["\u03C5","upsilon"],["\u03C6","phi"],["\u03C7","chi"],
		["\u03C8","psi"],["\u03C9","omega"],["\u03D1","thetasym"],["\u03D2","upsih"],
		["\u03D6","piv"],["\u2022","bull"],["\u2026","hellip"],["\u2032","prime"],
		["\u2033","Prime"],["\u203E","oline"],["\u2044","frasl"],["\u2118","weierp"],
		["\u2111","image"],["\u211C","real"],["\u2122","trade"],["\u2135","alefsym"],
		["\u2190","larr"],["\u2191","uarr"],["\u2192","rarr"],["\u2193","darr"],
		["\u2194","harr"],["\u21B5","crarr"],["\u21D0","lArr"],["\u21D1","uArr"],
		["\u21D2","rArr"],["\u21D3","dArr"],["\u21D4","hArr"],["\u2200","forall"],
		["\u2202","part"],["\u2203","exist"],["\u2205","empty"],["\u2207","nabla"],
		["\u2208","isin"],["\u2209","notin"],["\u220B","ni"],["\u220F","prod"],
		["\u2211","sum"],["\u2212","minus"],["\u2217","lowast"],["\u221A","radic"],
		["\u221D","prop"],["\u221E","infin"],["\u2220","ang"],["\u2227","and"],
		["\u2228","or"],["\u2229","cap"],["\u222A","cup"],["\u222B","int"],
		["\u2234","there4"],["\u223C","sim"],["\u2245","cong"],["\u2248","asymp"],
		["\u2260","ne"],["\u2261","equiv"],["\u2264","le"],["\u2265","ge"],
		["\u2282","sub"],["\u2283","sup"],["\u2284","nsub"],["\u2286","sube"],
		["\u2287","supe"],["\u2295","oplus"],["\u2297","otimes"],["\u22A5","perp"],
		["\u22C5","sdot"],["\u2308","lceil"],["\u2309","rceil"],["\u230A","lfloor"],
		["\u230B","rfloor"],["\u2329","lang"],["\u232A","rang"],["\u25CA","loz"],
		["\u2660","spades"],["\u2663","clubs"],["\u2665","hearts"],["\u2666","diams"],
		["\u0152","Elig"],["\u0153","oelig"],["\u0160","Scaron"],["\u0161","scaron"],
		["\u0178","Yuml"],["\u02C6","circ"],["\u02DC","tilde"],["\u2002","ensp"],
		["\u2003","emsp"],["\u2009","thinsp"],["\u200C","zwnj"],["\u200D","zwj"],
		["\u200E","lrm"],["\u200F","rlm"],["\u2013","ndash"],["\u2014","mdash"],
		["\u2018","lsquo"],["\u2019","rsquo"],["\u201A","sbquo"],["\u201C","ldquo"],
		["\u201D","rdquo"],["\u201E","bdquo"],["\u2020","dagger"],["\u2021","Dagger"],
		["\u2030","permil"],["\u2039","lsaquo"],["\u203A","rsaquo"]
	];
	
	dojox.html.entities.encode = function(str/*string*/, m /*array?*/){
		// summary:
		//		Function to obtain an entity encoding for a specified character
		// str:
		//		The string to process for possible entity encoding.
		// m:
		//		An optional list of character to entity name mappings (array of
		//		arrays).  If not provided, it uses the and Latin entities as the
		//		set to map and escape.
		// tags:
		//		public
		if(str){
			if(!m){
				// Apply the basic mappings.  HTML should always come first when decoding
				// as well.
				str = _applyEncodingMap(str, dojox.html.entities.html);
				str = _applyEncodingMap(str, dojox.html.entities.latin);
	
			}else{
				str = _applyEncodingMap(str, m);
			}
		}
		return str;
	};
	
	dojox.html.entities.decode = function(str/*string*/, m /*array?*/){
		// summary:
		//		Function to obtain an entity encoding for a specified character
		// str:
		//		The string to process for possible entity encoding to decode.
		// m:
		//		An optional list of character to entity name mappings (array of
		//		arrays).  If not provided, it uses the HTML and Latin entities as the
		//		set to map and decode.
		// tags:
		//		public
		if(str){
			if(!m){
				// Apply the basic mappings.  HTML should always come first when decoding
				// as well.
				str = _applyDecodingMap(str, dojox.html.entities.html);
				str = _applyDecodingMap(str, dojox.html.entities.latin);
	
			}else{
				str = _applyDecodingMap(str, m);
			}
		}
		return str;
	};
})();

}

if(!dojo._hasResource["dojox.fx._core"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.fx._core"] = true;
dojo.provide("dojox.fx._core");

dojox.fx._Line = function(start, end){
	// summary: a custom _Line to accomodate multi-dimensional values
	//
	// description:
	//	a normal dojo._Line is the curve, and does Line(start,end)
	//	for propertyAnimation. as we make more complicatied animations, we realize
	//	some properties can have 2, or 4 values relevant (x,y) or (t,l,r,b) for example
	//
	// 	this function provides support for those Lines, and is ported directly from 0.4
	//	this is a lot of extra code for something so seldom used, so we'll put it here as
	//	and optional core addition. you can create a new line, and use it during onAnimate
	//	as you see fit.
	//
	// start: Integer|Array
	//	An Integer (or an Array of integers) to use as a starting point
	// end: Integer|Array
	//	An Integer (or an Array of integers) to use as an ending point
	//
	// example: see dojox.fx.smoothScroll
	//
	// example:
	// |	// this is 10 .. 100 and 50 .. 500
	// |	var curve = new dojox.fx._Line([10,50],[100,500]);
	// |	// dojo.Animation.onAnimate is called at every step of the animation
	// |	// to define current values. this _Line returns an array
	// | 	// at each step. arguments[0] and [1] in this example.
	//
	this.start = start;
	this.end = end;
	
	var isArray = dojo.isArray(start),
		d = (isArray ? [] : end - start);
	
	if(isArray){
		// multi-dimensional branch
		dojo.forEach(this.start, function(s, i){
			d[i] = this.end[i] - s;
		}, this);
		
		this.getValue = function(/*float*/ n){
			var res = [];
			dojo.forEach(this.start, function(s, i){
				res[i] = (d[i] * n) + s;
			}, this);
			return res; // Array
		}
	}else{
		// single value branch, document here for both branches:
		this.getValue = function(/*float*/ n){
			// summary: Returns the point on the line, or an array of points
			// n: a floating point number greater than 0 and less than 1
			// returns: Mixed
			return (d * n) + this.start; // Decimal
		}
	}
};

}

if(!dojo._hasResource["dojox.fx.scroll"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.fx.scroll"] = true;
dojo.provide("dojox.fx.scroll");
dojo.experimental("dojox.fx.scroll");



dojox.fx.smoothScroll = function(/* Object */args){
	// summary: Returns an animation that will smooth-scroll to a node
	// description: This implementation support either horizontal or vertical scroll, as well as
	// both. In addition, element in iframe can be scrolled to correctly.
	// offset: {x: int, y: int} this will be added to the target position
	// duration: Duration of the animation in milliseconds.
	// win: a node or window object to scroll

	if(!args.target){ args.target = dojo.position(args.node); }

	var isWindow = dojo[(dojo.isIE ? "isObject" : "isFunction")](args["win"].scrollTo),
		delta = { x: args.target.x, y: args.target.y }
	;
	if(!isWindow){
		var winPos = dojo.position(args.win);
		delta.x -= winPos.x;
		delta.y -= winPos.y;
	}
	var _anim = (isWindow) ?
		(function(val){
			args.win.scrollTo(val[0],val[1]);
		}) :
		(function(val){
			args.win.scrollLeft = val[0];
			args.win.scrollTop = val[1];
		});
	var anim = new dojo.Animation(dojo.mixin({
		beforeBegin: function(){
			if(this.curve){ delete this.curve; }
			var current = isWindow ? dojo._docScroll() : {x: args.win.scrollLeft, y: args.win.scrollTop};
			anim.curve = new dojox.fx._Line([current.x,current.y],[current.x + delta.x, current.y + delta.y]);
		},
		onAnimate: _anim
	},args));
	return anim; // dojo.Animation
};

}

if(!dojo._hasResource["dojo.cookie"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.cookie"] = true;
dojo.provide("dojo.cookie");



/*=====
dojo.__cookieProps = function(){
	//	expires: Date|String|Number?
	//		If a number, the number of days from today at which the cookie
	//		will expire. If a date, the date past which the cookie will expire.
	//		If expires is in the past, the cookie will be deleted.
	//		If expires is omitted or is 0, the cookie will expire when the browser closes. << FIXME: 0 seems to disappear right away? FF3.
	//	path: String?
	//		The path to use for the cookie.
	//	domain: String?
	//		The domain to use for the cookie.
	//	secure: Boolean?
	//		Whether to only send the cookie on secure connections
	this.expires = expires;
	this.path = path;
	this.domain = domain;
	this.secure = secure;
}
=====*/


dojo.cookie = function(/*String*/name, /*String?*/value, /*dojo.__cookieProps?*/props){
	//	summary:
	//		Get or set a cookie.
	//	description:
	// 		If one argument is passed, returns the value of the cookie
	// 		For two or more arguments, acts as a setter.
	//	name:
	//		Name of the cookie
	//	value:
	//		Value for the cookie
	//	props:
	//		Properties for the cookie
	//	example:
	//		set a cookie with the JSON-serialized contents of an object which
	//		will expire 5 days from now:
	//	|	dojo.cookie("configObj", dojo.toJson(config), { expires: 5 });
	//
	//	example:
	//		de-serialize a cookie back into a JavaScript object:
	//	|	var config = dojo.fromJson(dojo.cookie("configObj"));
	//
	//	example:
	//		delete a cookie:
	//	|	dojo.cookie("configObj", null, {expires: -1});
	var c = document.cookie;
	if(arguments.length == 1){
		var matches = c.match(new RegExp("(?:^|; )" + dojo.regexp.escapeString(name) + "=([^;]*)"));
		return matches ? decodeURIComponent(matches[1]) : undefined; // String or undefined
	}else{
		props = props || {};
// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
		var exp = props.expires;
		if(typeof exp == "number"){
			var d = new Date();
			d.setTime(d.getTime() + exp*24*60*60*1000);
			exp = props.expires = d;
		}
		if(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }

		value = encodeURIComponent(value);
		var updatedCookie = name + "=" + value, propName;
		for(propName in props){
			updatedCookie += "; " + propName;
			var propValue = props[propName];
			if(propValue !== true){ updatedCookie += "=" + propValue; }
		}
		document.cookie = updatedCookie;
	}
};

dojo.cookie.isSupported = function(){
	//	summary:
	//		Use to determine if the current browser supports cookies or not.
	//
	//		Returns true if user allows cookies.
	//		Returns false if user doesn't allow cookies.

	if(!("cookieEnabled" in navigator)){
		this("__djCookieTest__", "CookiesAllowed");
		navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
		if(navigator.cookieEnabled){
			this("__djCookieTest__", "", {expires: -1});
		}
	}
	return navigator.cookieEnabled;
};

}

if(!dojo._hasResource["dijit.layout.StackController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.StackController"] = true;
dojo.provide("dijit.layout.StackController");







dojo.declare(
		"dijit.layout.StackController",
		[dijit._Widget, dijit._Templated, dijit._Container],
		{
			// summary:
			//		Set of buttons to select a page in a page list.
			// description:
			//		Monitors the specified StackContainer, and whenever a page is
			//		added, deleted, or selected, updates itself accordingly.

			templateString: "<span role='tablist' dojoAttachEvent='onkeypress' class='dijitStackController'></span>",

			// containerId: [const] String
			//		The id of the page container that I point to
			containerId: "",

			// buttonWidget: [const] String
			//		The name of the button widget to create to correspond to each page
			buttonWidget: "dijit.layout._StackButton",

			constructor: function(){
				this.pane2button = {};		// mapping from pane id to buttons
				this.pane2connects = {};	// mapping from pane id to this.connect() handles
				this.pane2watches = {};		// mapping from pane id to watch() handles
			},

			buildRendering: function(){
				this.inherited(arguments);
				dijit.setWaiRole(this.domNode, "tablist");	// TODO: unneeded?   it's in template above.
			},

			postCreate: function(){
				this.inherited(arguments);

				// Listen to notifications from StackContainer
				this.subscribe(this.containerId+"-startup", "onStartup");
				this.subscribe(this.containerId+"-addChild", "onAddChild");
				this.subscribe(this.containerId+"-removeChild", "onRemoveChild");
				this.subscribe(this.containerId+"-selectChild", "onSelectChild");
				this.subscribe(this.containerId+"-containerKeyPress", "onContainerKeyPress");
			},

			onStartup: function(/*Object*/ info){
				// summary:
				//		Called after StackContainer has finished initializing
				// tags:
				//		private
				dojo.forEach(info.children, this.onAddChild, this);
				if(info.selected){
					// Show button corresponding to selected pane (unless selected
					// is null because there are no panes)
					this.onSelectChild(info.selected);
				}
			},

			destroy: function(){
				for(var pane in this.pane2button){
					this.onRemoveChild(dijit.byId(pane));
				}
				this.inherited(arguments);
			},

			onAddChild: function(/*dijit._Widget*/ page, /*Integer?*/ insertIndex){
				// summary:
				//		Called whenever a page is added to the container.
				//		Create button corresponding to the page.
				// tags:
				//		private

				// create an instance of the button widget
				var cls = dojo.getObject(this.buttonWidget);
				var button = new cls({
					id: this.id + "_" + page.id,
					label: page.title,
					dir: page.dir,
					lang: page.lang,
					showLabel: page.showTitle,
					iconClass: page.iconClass,
					closeButton: page.closable,
					title: page.tooltip
				});
				dijit.setWaiState(button.focusNode,"selected", "false");


				// map from page attribute to corresponding tab button attribute
				var pageAttrList = ["title", "showTitle", "iconClass", "closable", "tooltip"],
					buttonAttrList = ["label", "showLabel", "iconClass", "closeButton", "title"];

				// watch() so events like page title changes are reflected in tab button
				this.pane2watches[page.id] = dojo.map(pageAttrList, function(pageAttr, idx){
					return page.watch(pageAttr, function(name, oldVal, newVal){
						button.set(buttonAttrList[idx], newVal);
					});
				});
					
				// connections so that clicking a tab button selects the corresponding page
				this.pane2connects[page.id] = [
					this.connect(button, 'onClick', dojo.hitch(this,"onButtonClick", page)),
					this.connect(button, 'onClickCloseButton', dojo.hitch(this,"onCloseButtonClick", page))
				];

				this.addChild(button, insertIndex);
				this.pane2button[page.id] = button;
				page.controlButton = button;	// this value might be overwritten if two tabs point to same container
				if(!this._currentChild){ // put the first child into the tab order
					button.focusNode.setAttribute("tabIndex", "0");
					dijit.setWaiState(button.focusNode, "selected", "true");
					this._currentChild = page;
				}
				// make sure all tabs have the same length
				if(!this.isLeftToRight() && dojo.isIE && this._rectifyRtlTabList){
					this._rectifyRtlTabList();
				}
			},

			onRemoveChild: function(/*dijit._Widget*/ page){
				// summary:
				//		Called whenever a page is removed from the container.
				//		Remove the button corresponding to the page.
				// tags:
				//		private

				if(this._currentChild === page){ this._currentChild = null; }

				// disconnect/unwatch connections/watches related to page being removed
				dojo.forEach(this.pane2connects[page.id], dojo.hitch(this, "disconnect"));
				delete this.pane2connects[page.id];
				dojo.forEach(this.pane2watches[page.id], function(w){ w.unwatch(); });
				delete this.pane2watches[page.id];

				var button = this.pane2button[page.id];
				if(button){
					this.removeChild(button);
					delete this.pane2button[page.id];
					button.destroy();
				}
				delete page.controlButton;
			},

			onSelectChild: function(/*dijit._Widget*/ page){
				// summary:
				//		Called when a page has been selected in the StackContainer, either by me or by another StackController
				// tags:
				//		private

				if(!page){ return; }

				if(this._currentChild){
					var oldButton=this.pane2button[this._currentChild.id];
					oldButton.set('checked', false);
					dijit.setWaiState(oldButton.focusNode, "selected", "false");
					oldButton.focusNode.setAttribute("tabIndex", "-1");
				}

				var newButton=this.pane2button[page.id];
				newButton.set('checked', true);
				dijit.setWaiState(newButton.focusNode, "selected", "true");
				this._currentChild = page;
				newButton.focusNode.setAttribute("tabIndex", "0");
				var container = dijit.byId(this.containerId);
				dijit.setWaiState(container.containerNode, "labelledby", newButton.id);
			},

			onButtonClick: function(/*dijit._Widget*/ page){
				// summary:
				//		Called whenever one of my child buttons is pressed in an attempt to select a page
				// tags:
				//		private

				var container = dijit.byId(this.containerId);
				container.selectChild(page);
			},

			onCloseButtonClick: function(/*dijit._Widget*/ page){
				// summary:
				//		Called whenever one of my child buttons [X] is pressed in an attempt to close a page
				// tags:
				//		private

				var container = dijit.byId(this.containerId);
				container.closeChild(page);
				if(this._currentChild){
					var b = this.pane2button[this._currentChild.id];
					if(b){
						dijit.focus(b.focusNode || b.domNode);
					}
				}
			},

			// TODO: this is a bit redundant with forward, back api in StackContainer
			adjacent: function(/*Boolean*/ forward){
				// summary:
				//		Helper for onkeypress to find next/previous button
				// tags:
				//		private

				if(!this.isLeftToRight() && (!this.tabPosition || /top|bottom/.test(this.tabPosition))){ forward = !forward; }
				// find currently focused button in children array
				var children = this.getChildren();
				var current = dojo.indexOf(children, this.pane2button[this._currentChild.id]);
				// pick next button to focus on
				var offset = forward ? 1 : children.length - 1;
				return children[ (current + offset) % children.length ]; // dijit._Widget
			},

			onkeypress: function(/*Event*/ e){
				// summary:
				//		Handle keystrokes on the page list, for advancing to next/previous button
				//		and closing the current page if the page is closable.
				// tags:
				//		private

				if(this.disabled || e.altKey ){ return; }
				var forward = null;
				if(e.ctrlKey || !e._djpage){
					var k = dojo.keys;
					switch(e.charOrCode){
						case k.LEFT_ARROW:
						case k.UP_ARROW:
							if(!e._djpage){ forward = false; }
							break;
						case k.PAGE_UP:
							if(e.ctrlKey){ forward = false; }
							break;
						case k.RIGHT_ARROW:
						case k.DOWN_ARROW:
							if(!e._djpage){ forward = true; }
							break;
						case k.PAGE_DOWN:
							if(e.ctrlKey){ forward = true; }
							break;
						case k.HOME:
						case k.END:
							var children = this.getChildren();
							if(children && children.length){
								children[e.charOrCode == k.HOME ? 0 : children.length-1].onClick();
							}
							dojo.stopEvent(e);
							break;
						case k.DELETE:
							if(this._currentChild.closable){
								this.onCloseButtonClick(this._currentChild);
							}
							dojo.stopEvent(e);
							break;
						default:
							if(e.ctrlKey){
								if(e.charOrCode === k.TAB){
									this.adjacent(!e.shiftKey).onClick();
									dojo.stopEvent(e);
								}else if(e.charOrCode == "w"){
									if(this._currentChild.closable){
										this.onCloseButtonClick(this._currentChild);
									}
									dojo.stopEvent(e); // avoid browser tab closing.
								}
							}
					}
					// handle next/previous page navigation (left/right arrow, etc.)
					if(forward !== null){
						this.adjacent(forward).onClick();
						dojo.stopEvent(e);
					}
				}
			},

			onContainerKeyPress: function(/*Object*/ info){
				// summary:
				//		Called when there was a keypress on the container
				// tags:
				//		private
				info.e._djpage = info.page;
				this.onkeypress(info.e);
			}
	});


dojo.declare("dijit.layout._StackButton",
		dijit.form.ToggleButton,
		{
		// summary:
		//		Internal widget used by StackContainer.
		// description:
		//		The button-like or tab-like object you click to select or delete a page
		// tags:
		//		private

		// Override _FormWidget.tabIndex.
		// StackContainer buttons are not in the tab order by default.
		// Probably we should be calling this.startupKeyNavChildren() instead.
		tabIndex: "-1",

		buildRendering: function(/*Event*/ evt){
			this.inherited(arguments);
			dijit.setWaiRole((this.focusNode || this.domNode), "tab");
		},

		onClick: function(/*Event*/ evt){
			// summary:
			//		This is for TabContainer where the tabs are <span> rather than button,
			//		so need to set focus explicitly (on some browsers)
			//		Note that you shouldn't override this method, but you can connect to it.
			dijit.focus(this.focusNode);

			// ... now let StackController catch the event and tell me what to do
		},

		onClickCloseButton: function(/*Event*/ evt){
			// summary:
			//		StackContainer connects to this function; if your widget contains a close button
			//		then clicking it should call this function.
			//		Note that you shouldn't override this method, but you can connect to it.
			evt.stopPropagation();
		}
	});

}

if(!dojo._hasResource["dijit.layout.StackContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.StackContainer"] = true;
dojo.provide("dijit.layout.StackContainer");







dojo.declare(
	"dijit.layout.StackContainer",
	dijit.layout._LayoutWidget,
	{
	// summary:
	//		A container that has multiple children, but shows only
	//		one child at a time
	//
	// description:
	//		A container for widgets (ContentPanes, for example) That displays
	//		only one Widget at a time.
	//
	//		Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	//
	//		Can be base class for container, Wizard, Show, etc.

	// doLayout: Boolean
	//		If true, change the size of my currently displayed child to match my size
	doLayout: true,

	// persist: Boolean
	//		Remembers the selected child across sessions
	persist: false,

	baseClass: "dijitStackContainer",

/*=====
	// selectedChildWidget: [readonly] dijit._Widget
	//		References the currently selected child widget, if any.
	//		Adjust selected child with selectChild() method.
	selectedChildWidget: null,
=====*/

	buildRendering: function(){
		this.inherited(arguments);
		dojo.addClass(this.domNode, "dijitLayoutContainer");
		dijit.setWaiRole(this.containerNode, "tabpanel");
	},

	postCreate: function(){
		this.inherited(arguments);
		this.connect(this.domNode, "onkeypress", this._onKeyPress);
	},

	startup: function(){
		if(this._started){ return; }

		var children = this.getChildren();

		// Setup each page panel to be initially hidden
		dojo.forEach(children, this._setupChild, this);

		// Figure out which child to initially display, defaulting to first one
		if(this.persist){
			this.selectedChildWidget = dijit.byId(dojo.cookie(this.id + "_selectedChild"));
		}else{
			dojo.some(children, function(child){
				if(child.selected){
					this.selectedChildWidget = child;
				}
				return child.selected;
			}, this);
		}
		var selected = this.selectedChildWidget;
		if(!selected && children[0]){
			selected = this.selectedChildWidget = children[0];
			selected.selected = true;
		}

		// Publish information about myself so any StackControllers can initialize.
		// This needs to happen before this.inherited(arguments) so that for
		// TabContainer, this._contentBox doesn't include the space for the tab labels.
		dojo.publish(this.id+"-startup", [{children: children, selected: selected}]);

		// Startup each child widget, and do initial layout like setting this._contentBox,
		// then calls this.resize() which does the initial sizing on the selected child.
		this.inherited(arguments);
	},

	resize: function(){
		// Resize is called when we are first made visible (it's called from startup()
		// if we are initially visible).   If this is the first time we've been made
		// visible then show our first child.
		var selected = this.selectedChildWidget;
		if(selected && !this._hasBeenShown){
			this._hasBeenShown = true;
			this._showChild(selected);
		}
		this.inherited(arguments);
	},

	_setupChild: function(/*dijit._Widget*/ child){
		// Overrides _LayoutWidget._setupChild()

		this.inherited(arguments);

		dojo.replaceClass(child.domNode, "dijitHidden", "dijitVisible");

		// remove the title attribute so it doesn't show up when i hover
		// over a node
		child.domNode.title = "";
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		// Overrides _Container.addChild() to do layout and publish events

		this.inherited(arguments);

		if(this._started){
			dojo.publish(this.id+"-addChild", [child, insertIndex]);

			// in case the tab titles have overflowed from one line to two lines
			// (or, if this if first child, from zero lines to one line)
			// TODO: w/ScrollingTabController this is no longer necessary, although
			// ScrollTabController.resize() does need to get called to show/hide
			// the navigation buttons as appropriate, but that's handled in ScrollingTabController.onAddChild()
			this.layout();

			// if this is the first child, then select it
			if(!this.selectedChildWidget){
				this.selectChild(child);
			}
		}
	},

	removeChild: function(/*dijit._Widget*/ page){
		// Overrides _Container.removeChild() to do layout and publish events

		this.inherited(arguments);

		if(this._started){
			// this will notify any tablists to remove a button; do this first because it may affect sizing
			dojo.publish(this.id + "-removeChild", [page]);
		}

		// If we are being destroyed than don't run the code below (to select another page), because we are deleting
		// every page one by one
		if(this._beingDestroyed){ return; }

		// Select new page to display, also updating TabController to show the respective tab.
		// Do this before layout call because it can affect the height of the TabController.
		if(this.selectedChildWidget === page){
			this.selectedChildWidget = undefined;
			if(this._started){
				var children = this.getChildren();
				if(children.length){
					this.selectChild(children[0]);
				}
			}
		}

		if(this._started){
			// In case the tab titles now take up one line instead of two lines
			// (note though that ScrollingTabController never overflows to multiple lines),
			// or the height has changed slightly because of addition/removal of tab which close icon
			this.layout();
		}
	},

	selectChild: function(/*dijit._Widget|String*/ page, /*Boolean*/ animate){
		// summary:
		//		Show the given widget (which must be one of my children)
		// page:
		//		Reference to child widget or id of child widget

		page = dijit.byId(page);

		if(this.selectedChildWidget != page){
			// Deselect old page and select new one
			var d = this._transition(page, this.selectedChildWidget, animate);
			this._set("selectedChildWidget", page);
			dojo.publish(this.id+"-selectChild", [page]);

			if(this.persist){
				dojo.cookie(this.id + "_selectedChild", this.selectedChildWidget.id);
			}
		}

		return d;		// If child has an href, promise that fires when the child's href finishes loading
	},

	_transition: function(/*dijit._Widget*/ newWidget, /*dijit._Widget*/ oldWidget, /*Boolean*/ animate){
		// summary:
		//		Hide the old widget and display the new widget.
		//		Subclasses should override this.
		// tags:
		//		protected extension
		if(oldWidget){
			this._hideChild(oldWidget);
		}
		var d = this._showChild(newWidget);

		// Size the new widget, in case this is the first time it's being shown,
		// or I have been resized since the last time it was shown.
		// Note that page must be visible for resizing to work.
		if(newWidget.resize){
			if(this.doLayout){
				newWidget.resize(this._containerContentBox || this._contentBox);
			}else{
				// the child should pick it's own size but we still need to call resize()
				// (with no arguments) to let the widget lay itself out
				newWidget.resize();
			}
		}

		return d;	// If child has an href, promise that fires when the child's href finishes loading
	},

	_adjacent: function(/*Boolean*/ forward){
		// summary:
		//		Gets the next/previous child widget in this container from the current selection.
		var children = this.getChildren();
		var index = dojo.indexOf(children, this.selectedChildWidget);
		index += forward ? 1 : children.length - 1;
		return children[ index % children.length ]; // dijit._Widget
	},

	forward: function(){
		// summary:
		//		Advance to next page.
		return this.selectChild(this._adjacent(true), true);
	},

	back: function(){
		// summary:
		//		Go back to previous page.
		return this.selectChild(this._adjacent(false), true);
	},

	_onKeyPress: function(e){
		dojo.publish(this.id+"-containerKeyPress", [{ e: e, page: this}]);
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		if(this.doLayout && this.selectedChildWidget && this.selectedChildWidget.resize){
			this.selectedChildWidget.resize(this._containerContentBox || this._contentBox);
		}
	},

	_showChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Show the specified child by changing it's CSS, and call _onShow()/onShow() so
		//		it can do any updates it needs regarding loading href's etc.
		// returns:
		//		Promise that fires when page has finished showing, or true if there's no href
		var children = this.getChildren();
		page.isFirstChild = (page == children[0]);
		page.isLastChild = (page == children[children.length-1]);
		page._set("selected", true);

		dojo.replaceClass(page.domNode, "dijitVisible", "dijitHidden");

		return page._onShow() || true;
	},

	_hideChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Hide the specified child by changing it's CSS, and call _onHide() so
		//		it's notified.
		page._set("selected", false);
		dojo.replaceClass(page.domNode, "dijitHidden", "dijitVisible");

		page.onHide();
	},

	closeChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Callback when user clicks the [X] to remove a page.
		//		If onClose() returns true then remove and destroy the child.
		// tags:
		//		private
		var remove = page.onClose(this, page);
		if(remove){
			this.removeChild(page);
			// makes sure we can clean up executeScripts in ContentPane onUnLoad
			page.destroyRecursive();
		}
	},

	destroyDescendants: function(/*Boolean*/ preserveDom){
		dojo.forEach(this.getChildren(), function(child){
			this.removeChild(child);
			child.destroyRecursive(preserveDom);
		}, this);
	}
});

// For back-compat, remove for 2.0


// These arguments can be specified for the children of a StackContainer.
// Since any widget can be specified as a StackContainer child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
dojo.extend(dijit._Widget, {
	// selected: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		Specifies that this widget should be the initially displayed pane.
	//		Note: to change the selected child use `dijit.layout.StackContainer.selectChild`
	selected: false,

	// closable: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		True if user can close (destroy) this child, such as (for example) clicking the X on the tab.
	closable: false,

	// iconClass: String
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		CSS Class specifying icon to use in label associated with this pane.
	iconClass: "",

	// showTitle: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		When true, display title of this widget as tab label etc., rather than just using
	//		icon specified in iconClass
	showTitle: true
});

}

if(!dojo._hasResource["dijit.layout._TabContainerBase"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout._TabContainerBase"] = true;
dojo.provide("dijit.layout._TabContainerBase");




dojo.declare("dijit.layout._TabContainerBase",
	[dijit.layout.StackContainer, dijit._Templated],
	{
	// summary:
	//		Abstract base class for TabContainer.   Must define _makeController() to instantiate
	//		and return the widget that displays the tab labels
	// description:
	//		A TabContainer is a container that has multiple panes, but shows only
	//		one pane at a time.  There are a set of tabs corresponding to each pane,
	//		where each tab has the name (aka title) of the pane, and optionally a close button.

	// tabPosition: String
	//		Defines where tabs go relative to tab content.
	//		"top", "bottom", "left-h", "right-h"
	tabPosition: "top",

	baseClass: "dijitTabContainer",

	// tabStrip: [const] Boolean
	//		Defines whether the tablist gets an extra class for layouting, putting a border/shading
	//		around the set of tabs.   Not supported by claro theme.
	tabStrip: false,

	// nested: [const] Boolean
	//		If true, use styling for a TabContainer nested inside another TabContainer.
	//		For tundra etc., makes tabs look like links, and hides the outer
	//		border since the outer TabContainer already has a border.
	nested: false,

	templateString: dojo.cache("dijit.layout", "templates/TabContainer.html", "<div class=\"dijitTabContainer\">\n\t<div class=\"dijitTabListWrapper\" dojoAttachPoint=\"tablistNode\"></div>\n\t<div dojoAttachPoint=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container\" dojoAttachPoint=\"containerNode\"></div>\n</div>\n"),

	postMixInProperties: function(){
		// set class name according to tab position, ex: dijitTabContainerTop
		this.baseClass += this.tabPosition.charAt(0).toUpperCase() + this.tabPosition.substr(1).replace(/-.*/, "");

		this.srcNodeRef && dojo.style(this.srcNodeRef, "visibility", "hidden");

		this.inherited(arguments);
	},

	buildRendering: function(){
		this.inherited(arguments);

		// Create the tab list that will have a tab (a.k.a. tab button) for each tab panel
		this.tablist = this._makeController(this.tablistNode);

		if(!this.doLayout){ dojo.addClass(this.domNode, "dijitTabContainerNoLayout"); }

		if(this.nested){
			/* workaround IE's lack of support for "a > b" selectors by
			 * tagging each node in the template.
			 */
			dojo.addClass(this.domNode, "dijitTabContainerNested");
			dojo.addClass(this.tablist.containerNode, "dijitTabContainerTabListNested");
			dojo.addClass(this.tablistSpacer, "dijitTabContainerSpacerNested");
			dojo.addClass(this.containerNode, "dijitTabPaneWrapperNested");
		}else{
			dojo.addClass(this.domNode, "tabStrip-" + (this.tabStrip ? "enabled" : "disabled"));
		}
	},

	_setupChild: function(/*dijit._Widget*/ tab){
		// Overrides StackContainer._setupChild().
		dojo.addClass(tab.domNode, "dijitTabPane");
		this.inherited(arguments);
	},

	startup: function(){
		if(this._started){ return; }

		// wire up the tablist and its tabs
		this.tablist.startup();

		this.inherited(arguments);
	},

	layout: function(){
		// Overrides StackContainer.layout().
		// Configure the content pane to take up all the space except for where the tabs are

		if(!this._contentBox || typeof(this._contentBox.l) == "undefined"){return;}

		var sc = this.selectedChildWidget;

		if(this.doLayout){
			// position and size the titles and the container node
			var titleAlign = this.tabPosition.replace(/-h/, "");
			this.tablist.layoutAlign = titleAlign;
			var children = [this.tablist, {
				domNode: this.tablistSpacer,
				layoutAlign: titleAlign
			}, {
				domNode: this.containerNode,
				layoutAlign: "client"
			}];
			dijit.layout.layoutChildren(this.domNode, this._contentBox, children);

			// Compute size to make each of my children.
			// children[2] is the margin-box size of this.containerNode, set by layoutChildren() call above
			this._containerContentBox = dijit.layout.marginBox2contentBox(this.containerNode, children[2]);

			if(sc && sc.resize){
				sc.resize(this._containerContentBox);
			}
		}else{
			// just layout the tab controller, so it can position left/right buttons etc.
			if(this.tablist.resize){
				//make the tabs zero width so that they don't interfere with width calc, then reset
				var s = this.tablist.domNode.style;
				s.width="0";
				var width = dojo.contentBox(this.domNode).w;
				s.width="";
				this.tablist.resize({w: width});
			}

			// and call resize() on the selected pane just to tell it that it's been made visible
			if(sc && sc.resize){
				sc.resize();
			}
		}
	},

	destroy: function(){
		if(this.tablist){
			this.tablist.destroy();
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["dijit.layout.TabController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.TabController"] = true;
dojo.provide("dijit.layout.TabController");






// Menu is used for an accessible close button, would be nice to have a lighter-weight solution


dojo.declare("dijit.layout.TabController",
	dijit.layout.StackController,
{
	// summary:
	// 		Set of tabs (the things with titles and a close button, that you click to show a tab panel).
	//		Used internally by `dijit.layout.TabContainer`.
	// description:
	//		Lets the user select the currently shown pane in a TabContainer or StackContainer.
	//		TabController also monitors the TabContainer, and whenever a pane is
	//		added or deleted updates itself accordingly.
	// tags:
	//		private

	templateString: "<div role='tablist' dojoAttachEvent='onkeypress:onkeypress'></div>",

	// tabPosition: String
	//		Defines where tabs go relative to the content.
	//		"top", "bottom", "left-h", "right-h"
	tabPosition: "top",

	// buttonWidget: String
	//		The name of the tab widget to create to correspond to each page
	buttonWidget: "dijit.layout._TabButton",

	_rectifyRtlTabList: function(){
		// summary:
		//		For left/right TabContainer when page is RTL mode, rectify the width of all tabs to be equal, otherwise the tab widths are different in IE

		if(0 >= this.tabPosition.indexOf('-h')){ return; }
		if(!this.pane2button){ return; }

		var maxWidth = 0;
		for(var pane in this.pane2button){
			var ow = this.pane2button[pane].innerDiv.scrollWidth;
			maxWidth = Math.max(maxWidth, ow);
		}
		//unify the length of all the tabs
		for(pane in this.pane2button){
			this.pane2button[pane].innerDiv.style.width = maxWidth + 'px';
		}
	}
});

dojo.declare("dijit.layout._TabButton",
	dijit.layout._StackButton,
	{
	// summary:
	//		A tab (the thing you click to select a pane).
	// description:
	//		Contains the title of the pane, and optionally a close-button to destroy the pane.
	//		This is an internal widget and should not be instantiated directly.
	// tags:
	//		private

	// baseClass: String
	//		The CSS class applied to the domNode.
	baseClass: "dijitTab",

	// Apply dijitTabCloseButtonHover when close button is hovered
	cssStateNodes: {
		closeNode: "dijitTabCloseButton"
	},

	templateString: dojo.cache("dijit.layout", "templates/_TabButton.html", "<div role=\"presentation\" dojoAttachPoint=\"titleNode\" dojoAttachEvent='onclick:onClick'>\n    <div role=\"presentation\" class='dijitTabInnerDiv' dojoAttachPoint='innerDiv'>\n        <div role=\"presentation\" class='dijitTabContent' dojoAttachPoint='tabContent'>\n        \t<div role=\"presentation\" dojoAttachPoint='focusNode'>\n\t\t        <img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitTabButtonIcon\" dojoAttachPoint='iconNode' />\n\t\t        <span dojoAttachPoint='containerNode' class='tabLabel'></span>\n\t\t        <span class=\"dijitInline dijitTabCloseButton dijitTabCloseIcon\" dojoAttachPoint='closeNode'\n\t\t        \t\tdojoAttachEvent='onclick: onClickCloseButton' role=\"presentation\">\n\t\t            <span dojoAttachPoint='closeText' class='dijitTabCloseText'>[x]</span\n\t\t        ></span>\n\t\t\t</div>\n        </div>\n    </div>\n</div>\n"),

	// Override _FormWidget.scrollOnFocus.
	// Don't scroll the whole tab container into view when the button is focused.
	scrollOnFocus: false,

	buildRendering: function(){
		this.inherited(arguments);

		dojo.setSelectable(this.containerNode, false);
	},

	startup: function(){
		this.inherited(arguments);
		var n = this.domNode;

		// Required to give IE6 a kick, as it initially hides the
		// tabs until they are focused on.
		setTimeout(function(){
			n.className = n.className;
		}, 1);
	},

	_setCloseButtonAttr: function(/*Boolean*/ disp){
		// summary:
		//		Hide/show close button
		this._set("closeButton", disp);
		dojo.toggleClass(this.innerDiv, "dijitClosable", disp);
		this.closeNode.style.display = disp ? "" : "none";
		if(disp){
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			if(this.closeNode){
				dojo.attr(this.closeNode,"title", _nlsResources.itemClose);
			}
			// add context menu onto title button
			var _nlsResources = dojo.i18n.getLocalization("dijit", "common");
			this._closeMenu = new dijit.Menu({
				id: this.id+"_Menu",
				dir: this.dir,
				lang: this.lang,
				targetNodeIds: [this.domNode]
			});

			this._closeMenu.addChild(new dijit.MenuItem({
				label: _nlsResources.itemClose,
				dir: this.dir,
				lang: this.lang,
				onClick: dojo.hitch(this, "onClickCloseButton")
			}));
		}else{
			if(this._closeMenu){
				this._closeMenu.destroyRecursive();
				delete this._closeMenu;
			}
		}
	},
	_setLabelAttr: function(/*String*/ content){
		// summary:
		//		Hook for set('label', ...) to work.
		// description:
		//		takes an HTML string.
		//		Inherited ToggleButton implementation will Set the label (text) of the button;
		//		Need to set the alt attribute of icon on tab buttons if no label displayed
		this.inherited(arguments);
		if(this.showLabel == false && !this.params.title){
			this.iconNode.alt = dojo.trim(this.containerNode.innerText || this.containerNode.textContent || '');
		}
	},

	destroy: function(){
		if(this._closeMenu){
			this._closeMenu.destroyRecursive();
			delete this._closeMenu;
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["dijit.layout.ScrollingTabController"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.ScrollingTabController"] = true;
dojo.provide("dijit.layout.ScrollingTabController");






dojo.declare("dijit.layout.ScrollingTabController",
	dijit.layout.TabController,
	{
	// summary:
	//		Set of tabs with left/right arrow keys and a menu to switch between tabs not
	//		all fitting on a single row.
	//		Works only for horizontal tabs (either above or below the content, not to the left
	//		or right).
	// tags:
	//		private

	templateString: dojo.cache("dijit.layout", "templates/ScrollingTabController.html", "<div class=\"dijitTabListContainer-${tabPosition}\" style=\"visibility:hidden\">\n\t<div dojoType=\"dijit.layout._ScrollingTabControllerMenuButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_menuBtn\" containerId=\"${containerId}\" iconClass=\"dijitTabStripMenuIcon\"\n\t\t\tdropDownPosition=\"below-alt, above-alt\"\n\t\t\tdojoAttachPoint=\"_menuBtn\" showLabel=\"false\">&#9660;</div>\n\t<div dojoType=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_leftBtn\" iconClass=\"dijitTabStripSlideLeftIcon\"\n\t\t\tdojoAttachPoint=\"_leftBtn\" dojoAttachEvent=\"onClick: doSlideLeft\" showLabel=\"false\">&#9664;</div>\n\t<div dojoType=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_rightBtn\" iconClass=\"dijitTabStripSlideRightIcon\"\n\t\t\tdojoAttachPoint=\"_rightBtn\" dojoAttachEvent=\"onClick: doSlideRight\" showLabel=\"false\">&#9654;</div>\n\t<div class='dijitTabListWrapper' dojoAttachPoint='tablistWrapper'>\n\t\t<div role='tablist' dojoAttachEvent='onkeypress:onkeypress'\n\t\t\t\tdojoAttachPoint='containerNode' class='nowrapTabStrip'></div>\n\t</div>\n</div>\n"),

	// useMenu: [const] Boolean
	//		True if a menu should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useMenu: true,

	// useSlider: [const] Boolean
	//		True if a slider should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useSlider: true,

	// tabStripClass: [const] String
	//		The css class to apply to the tab strip, if it is visible.
	tabStripClass: "",

	widgetsInTemplate: true,

	// _minScroll: Number
	//		The distance in pixels from the edge of the tab strip which,
	//		if a scroll animation is less than, forces the scroll to
	//		go all the way to the left/right.
	_minScroll: 5,

	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		"class": "containerNode"
	}),

	buildRendering: function(){
		this.inherited(arguments);
		var n = this.domNode;

		this.scrollNode = this.tablistWrapper;
		this._initButtons();

		if(!this.tabStripClass){
			this.tabStripClass = "dijitTabContainer" +
				this.tabPosition.charAt(0).toUpperCase() +
				this.tabPosition.substr(1).replace(/-.*/, "") +
				"None";
			dojo.addClass(n, "tabStrip-disabled")
		}

		dojo.addClass(this.tablistWrapper, this.tabStripClass);
	},

	onStartup: function(){
		this.inherited(arguments);

		// Do not show the TabController until the related
		// StackController has added it's children.  This gives
		// a less visually jumpy instantiation.
		dojo.style(this.domNode, "visibility", "visible");
		this._postStartup = true;
	},

	onAddChild: function(page, insertIndex){
		this.inherited(arguments);

		// changes to the tab button label or iconClass will have changed the width of the
		// buttons, so do a resize
		dojo.forEach(["label", "iconClass"], function(attr){
			this.pane2watches[page.id].push(
				this.pane2button[page.id].watch(attr, dojo.hitch(this, function(name, oldValue, newValue){
					if(this._postStartup && this._dim){
						this.resize(this._dim);
					}
				}))
			);
		}, this);

		// Increment the width of the wrapper when a tab is added
		// This makes sure that the buttons never wrap.
		// The value 200 is chosen as it should be bigger than most
		// Tab button widths.
		dojo.style(this.containerNode, "width",
			(dojo.style(this.containerNode, "width") + 200) + "px");
	},

	onRemoveChild: function(page, insertIndex){
		// null out _selectedTab because we are about to delete that dom node
		var button = this.pane2button[page.id];
		if(this._selectedTab === button.domNode){
			this._selectedTab = null;
		}

		this.inherited(arguments);
	},

	_initButtons: function(){
		// summary:
		//		Creates the buttons used to scroll to view tabs that
		//		may not be visible if the TabContainer is too narrow.

		// Make a list of the buttons to display when the tab labels become
		// wider than the TabContainer, and hide the other buttons.
		// Also gets the total width of the displayed buttons.
		this._btnWidth = 0;
		this._buttons = dojo.query("> .tabStripButton", this.domNode).filter(function(btn){
			if((this.useMenu && btn == this._menuBtn.domNode) ||
				(this.useSlider && (btn == this._rightBtn.domNode || btn == this._leftBtn.domNode))){
				this._btnWidth += dojo._getMarginSize(btn).w;
				return true;
			}else{
				dojo.style(btn, "display", "none");
				return false;
			}
		}, this);
	},

	_getTabsWidth: function(){
		var children = this.getChildren();
		if(children.length){
			var leftTab = children[this.isLeftToRight() ? 0 : children.length - 1].domNode,
				rightTab = children[this.isLeftToRight() ? children.length - 1 : 0].domNode;
			return rightTab.offsetLeft + dojo.style(rightTab, "width") - leftTab.offsetLeft;
		}else{
			return 0;
		}
	},

	_enableBtn: function(width){
		// summary:
		//		Determines if the tabs are wider than the width of the TabContainer, and
		//		thus that we need to display left/right/menu navigation buttons.
		var tabsWidth = this._getTabsWidth();
		width = width || dojo.style(this.scrollNode, "width");
		return tabsWidth > 0 && width < tabsWidth;
	},

	resize: function(dim){
		// summary:
		//		Hides or displays the buttons used to scroll the tab list and launch the menu
		//		that selects tabs.

		if(this.domNode.offsetWidth == 0){
			return;
		}

		// Save the dimensions to be used when a child is renamed.
		this._dim = dim;

		// Set my height to be my natural height (tall enough for one row of tab labels),
		// and my content-box width based on margin-box width specified in dim parameter.
		// But first reset scrollNode.height in case it was set by layoutChildren() call
		// in a previous run of this method.
		this.scrollNode.style.height = "auto";
		this._contentBox = dijit.layout.marginBox2contentBox(this.domNode, {h: 0, w: dim.w});
		this._contentBox.h = this.scrollNode.offsetHeight;
		dojo.contentBox(this.domNode, this._contentBox);

		// Show/hide the left/right/menu navigation buttons depending on whether or not they
		// are needed.
		var enable = this._enableBtn(this._contentBox.w);
		this._buttons.style("display", enable ? "" : "none");

		// Position and size the navigation buttons and the tablist
		this._leftBtn.layoutAlign = "left";
		this._rightBtn.layoutAlign = "right";
		this._menuBtn.layoutAlign = this.isLeftToRight() ? "right" : "left";
		dijit.layout.layoutChildren(this.domNode, this._contentBox,
			[this._menuBtn, this._leftBtn, this._rightBtn, {domNode: this.scrollNode, layoutAlign: "client"}]);

		// set proper scroll so that selected tab is visible
		if(this._selectedTab){
			if(this._anim && this._anim.status() == "playing"){
				this._anim.stop();
			}
			var w = this.scrollNode,
				sl = this._convertToScrollLeft(this._getScrollForSelectedTab());
			w.scrollLeft = sl;
		}

		// Enable/disabled left right buttons depending on whether or not user can scroll to left or right
		this._setButtonClass(this._getScroll());
		
		this._postResize = true;

		// Return my size so layoutChildren() can use it.
		// Also avoids IE9 layout glitch on browser resize when scroll buttons present
		return {h: this._contentBox.h, w: dim.w};
	},

	_getScroll: function(){
		// summary:
		//		Returns the current scroll of the tabs where 0 means
		//		"scrolled all the way to the left" and some positive number, based on #
		//		of pixels of possible scroll (ex: 1000) means "scrolled all the way to the right"
		var sl = (this.isLeftToRight() || dojo.isIE < 8 || (dojo.isIE && dojo.isQuirks) || dojo.isWebKit) ? this.scrollNode.scrollLeft :
				dojo.style(this.containerNode, "width") - dojo.style(this.scrollNode, "width")
					 + (dojo.isIE == 8 ? -1 : 1) * this.scrollNode.scrollLeft;
		return sl;
	},

	_convertToScrollLeft: function(val){
		// summary:
		//		Given a scroll value where 0 means "scrolled all the way to the left"
		//		and some positive number, based on # of pixels of possible scroll (ex: 1000)
		//		means "scrolled all the way to the right", return value to set this.scrollNode.scrollLeft
		//		to achieve that scroll.
		//
		//		This method is to adjust for RTL funniness in various browsers and versions.
		if(this.isLeftToRight() || dojo.isIE < 8 || (dojo.isIE && dojo.isQuirks) || dojo.isWebKit){
			return val;
		}else{
			var maxScroll = dojo.style(this.containerNode, "width") - dojo.style(this.scrollNode, "width");
			return (dojo.isIE == 8 ? -1 : 1) * (val - maxScroll);
		}
	},

	onSelectChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Smoothly scrolls to a tab when it is selected.

		var tab = this.pane2button[page.id];
		if(!tab || !page){return;}

		// Scroll to the selected tab, except on startup, when scrolling is handled in resize()
		var node = tab.domNode;
		if(this._postResize && node != this._selectedTab){
			this._selectedTab = node;

			var sl = this._getScroll();

			if(sl > node.offsetLeft ||
					sl + dojo.style(this.scrollNode, "width") <
					node.offsetLeft + dojo.style(node, "width")){
				this.createSmoothScroll().play();
			}
		}

		this.inherited(arguments);
	},

	_getScrollBounds: function(){
		// summary:
		//		Returns the minimum and maximum scroll setting to show the leftmost and rightmost
		//		tabs (respectively)
		var children = this.getChildren(),
			scrollNodeWidth = dojo.style(this.scrollNode, "width"),		// about 500px
			containerWidth = dojo.style(this.containerNode, "width"),	// 50,000px
			maxPossibleScroll = containerWidth - scrollNodeWidth,	// scrolling until right edge of containerNode visible
			tabsWidth = this._getTabsWidth();

		if(children.length && tabsWidth > scrollNodeWidth){
			// Scrolling should happen
			return {
				min: this.isLeftToRight() ? 0 : children[children.length-1].domNode.offsetLeft,
				max: this.isLeftToRight() ?
					(children[children.length-1].domNode.offsetLeft + dojo.style(children[children.length-1].domNode, "width")) - scrollNodeWidth :
					maxPossibleScroll
			};
		}else{
			// No scrolling needed, all tabs visible, we stay either scrolled to far left or far right (depending on dir)
			var onlyScrollPosition = this.isLeftToRight() ? 0 : maxPossibleScroll;
			return {
				min: onlyScrollPosition,
				max: onlyScrollPosition
			};
		}
	},

	_getScrollForSelectedTab: function(){
		// summary:
		//		Returns the scroll value setting so that the selected tab
		//		will appear in the center
		var w = this.scrollNode,
			n = this._selectedTab,
			scrollNodeWidth = dojo.style(this.scrollNode, "width"),
			scrollBounds = this._getScrollBounds();

		// TODO: scroll minimal amount (to either right or left) so that
		// selected tab is fully visible, and just return if it's already visible?
		var pos = (n.offsetLeft + dojo.style(n, "width")/2) - scrollNodeWidth/2;
		pos = Math.min(Math.max(pos, scrollBounds.min), scrollBounds.max);

		// TODO:
		// If scrolling close to the left side or right side, scroll
		// all the way to the left or right.  See this._minScroll.
		// (But need to make sure that doesn't scroll the tab out of view...)
		return pos;
	},

	createSmoothScroll: function(x){
		// summary:
		//		Creates a dojo._Animation object that smoothly scrolls the tab list
		//		either to a fixed horizontal pixel value, or to the selected tab.
		// description:
		//		If an number argument is passed to the function, that horizontal
		//		pixel position is scrolled to.  Otherwise the currently selected
		//		tab is scrolled to.
		// x: Integer?
		//		An optional pixel value to scroll to, indicating distance from left.

		// Calculate position to scroll to
		if(arguments.length > 0){
			// position specified by caller, just make sure it's within bounds
			var scrollBounds = this._getScrollBounds();
			x = Math.min(Math.max(x, scrollBounds.min), scrollBounds.max);
		}else{
			// scroll to center the current tab
			x = this._getScrollForSelectedTab();
		}

		if(this._anim && this._anim.status() == "playing"){
			this._anim.stop();
		}

		var self = this,
			w = this.scrollNode,
			anim = new dojo._Animation({
				beforeBegin: function(){
					if(this.curve){ delete this.curve; }
					var oldS = w.scrollLeft,
						newS = self._convertToScrollLeft(x);
					anim.curve = new dojo._Line(oldS, newS);
				},
				onAnimate: function(val){
					w.scrollLeft = val;
				}
			});
		this._anim = anim;

		// Disable/enable left/right buttons according to new scroll position
		this._setButtonClass(x);

		return anim; // dojo._Animation
	},

	_getBtnNode: function(/*Event*/ e){
		// summary:
		//		Gets a button DOM node from a mouse click event.
		// e:
		//		The mouse click event.
		var n = e.target;
		while(n && !dojo.hasClass(n, "tabStripButton")){
			n = n.parentNode;
		}
		return n;
	},

	doSlideRight: function(/*Event*/ e){
		// summary:
		//		Scrolls the menu to the right.
		// e:
		//		The mouse click event.
		this.doSlide(1, this._getBtnNode(e));
	},

	doSlideLeft: function(/*Event*/ e){
		// summary:
		//		Scrolls the menu to the left.
		// e:
		//		The mouse click event.
		this.doSlide(-1,this._getBtnNode(e));
	},

	doSlide: function(/*Number*/ direction, /*DomNode*/ node){
		// summary:
		//		Scrolls the tab list to the left or right by 75% of the widget width.
		// direction:
		//		If the direction is 1, the widget scrolls to the right, if it is
		//		-1, it scrolls to the left.

		if(node && dojo.hasClass(node, "dijitTabDisabled")){return;}

		var sWidth = dojo.style(this.scrollNode, "width");
		var d = (sWidth * 0.75) * direction;

		var to = this._getScroll() + d;

		this._setButtonClass(to);

		this.createSmoothScroll(to).play();
	},

	_setButtonClass: function(/*Number*/ scroll){
		// summary:
		//		Disables the left scroll button if the tabs are scrolled all the way to the left,
		//		or the right scroll button in the opposite case.
		// scroll: Integer
		//		amount of horizontal scroll

		var scrollBounds = this._getScrollBounds();
		this._leftBtn.set("disabled", scroll <= scrollBounds.min);
		this._rightBtn.set("disabled", scroll >= scrollBounds.max);
	}
});


dojo.declare("dijit.layout._ScrollingTabControllerButtonMixin", null, {
	baseClass: "dijitTab tabStripButton",

	templateString: dojo.cache("dijit.layout", "templates/_ScrollingTabControllerButton.html", "<div dojoAttachEvent=\"onclick:_onButtonClick\">\n\t<div role=\"presentation\" class=\"dijitTabInnerDiv\" dojoattachpoint=\"innerDiv,focusNode\">\n\t\t<div role=\"presentation\" class=\"dijitTabContent dijitButtonContents\" dojoattachpoint=\"tabContent\">\n\t\t\t<img role=\"presentation\" alt=\"\" src=\"${_blankGif}\" class=\"dijitTabStripIcon\" dojoAttachPoint=\"iconNode\"/>\n\t\t\t<span dojoAttachPoint=\"containerNode,titleNode\" class=\"dijitButtonText\"></span>\n\t\t</div>\n\t</div>\n</div>\n"),

		// Override inherited tabIndex: 0 from dijit.form.Button, because user shouldn't be
		// able to tab to the left/right/menu buttons
	tabIndex: "",

	// Similarly, override FormWidget.isFocusable() because clicking a button shouldn't focus it
	// either (this override avoids focus() call in FormWidget.js)
	isFocusable: function(){ return false; }
});

dojo.declare("dijit.layout._ScrollingTabControllerButton",
	[dijit.form.Button, dijit.layout._ScrollingTabControllerButtonMixin]);

dojo.declare(
	"dijit.layout._ScrollingTabControllerMenuButton",
	[dijit.form.Button, dijit._HasDropDown, dijit.layout._ScrollingTabControllerButtonMixin],
{
	// id of the TabContainer itself
	containerId: "",

	// -1 so user can't tab into the button, but so that button can still be focused programatically.
	// Because need to move focus to the button (or somewhere) before the menu is hidden or IE6 will crash.
	tabIndex: "-1",

	isLoaded: function(){
		// recreate menu every time, in case the TabContainer's list of children (or their icons/labels) have changed
		return false;
	},

	loadDropDown: function(callback){
		this.dropDown = new dijit.Menu({
			id: this.containerId + "_menu",
			dir: this.dir,
			lang: this.lang
		});
		var container = dijit.byId(this.containerId);
		dojo.forEach(container.getChildren(), function(page){
			var menuItem = new dijit.MenuItem({
				id: page.id + "_stcMi",
				label: page.title,
				iconClass: page.iconClass,
				dir: page.dir,
				lang: page.lang,
				onClick: function(){
					container.selectChild(page);
				}
			});
			this.dropDown.addChild(menuItem);
		}, this);
		callback();
	},

	closeDropDown: function(/*Boolean*/ focus){
		this.inherited(arguments);
		if(this.dropDown){
			this.dropDown.destroyRecursive();
			delete this.dropDown;
		}
	}
});

}

if(!dojo._hasResource["dijit.layout.TabContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.layout.TabContainer"] = true;
dojo.provide("dijit.layout.TabContainer");





dojo.declare("dijit.layout.TabContainer",
	dijit.layout._TabContainerBase,
	{
		// summary:
		//		A Container with tabs to select each child (only one of which is displayed at a time).
		// description:
		//		A TabContainer is a container that has multiple panes, but shows only
		//		one pane at a time.  There are a set of tabs corresponding to each pane,
		//		where each tab has the name (aka title) of the pane, and optionally a close button.

		// useMenu: [const] Boolean
		//		True if a menu should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useMenu: true,

		// useSlider: [const] Boolean
		//		True if a slider should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useSlider: true,

		// controllerWidget: String
		//		An optional parameter to override the widget used to display the tab labels
		controllerWidget: "",

		_makeController: function(/*DomNode*/ srcNode){
			// summary:
			//		Instantiate tablist controller widget and return reference to it.
			//		Callback from _TabContainerBase.postCreate().
			// tags:
			//		protected extension

			var cls = this.baseClass + "-tabs" + (this.doLayout ? "" : " dijitTabNoLayout"),
				TabController = dojo.getObject(this.controllerWidget);

			return new TabController({
				id: this.id + "_tablist",
				dir: this.dir,
				lang: this.lang,
				tabPosition: this.tabPosition,
				doLayout: this.doLayout,
				containerId: this.id,
				"class": cls,
				nested: this.nested,
				useMenu: this.useMenu,
				useSlider: this.useSlider,
				tabStripClass: this.tabStrip ? this.baseClass + (this.tabStrip ? "":"No") + "Strip": null
			}, srcNode);
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			// Scrolling controller only works for horizontal non-nested tabs
			if(!this.controllerWidget){
				this.controllerWidget = (this.tabPosition == "top" || this.tabPosition == "bottom") && !this.nested ?
							"dijit.layout.ScrollingTabController" : "dijit.layout.TabController";
			}
		}
});

}

if(!dojo._hasResource["dijit.form.SimpleTextarea"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.SimpleTextarea"] = true;
dojo.provide("dijit.form.SimpleTextarea");



dojo.declare("dijit.form.SimpleTextarea",
	dijit.form.TextBox,
	{
	// summary:
	//		A simple textarea that degrades, and responds to
	// 		minimal LayoutContainer usage, and works with dijit.form.Form.
	//		Doesn't automatically size according to input, like Textarea.
	//
	// example:
	//	|	<textarea dojoType="dijit.form.SimpleTextarea" name="foo" value="bar" rows=30 cols=40></textarea>
	//
	// example:
	//	|	new dijit.form.SimpleTextarea({ rows:20, cols:30 }, "foo");

	baseClass: "dijitTextBox dijitTextArea",

	attributeMap: dojo.delegate(dijit.form._FormValueWidget.prototype.attributeMap, {
		rows:"textbox", cols: "textbox"
	}),

	// rows: Number
	//		The number of rows of text.
	rows: "3",

	// rows: Number
	//		The number of characters per line.
	cols: "20",

	templateString: "<textarea ${!nameAttrSetting} dojoAttachPoint='focusNode,containerNode,textbox' autocomplete='off'></textarea>",

	postMixInProperties: function(){
		// Copy value from srcNodeRef, unless user specified a value explicitly (or there is no srcNodeRef)
		// TODO: parser will handle this in 2.0
		if(!this.value && this.srcNodeRef){
			this.value = this.srcNodeRef.value;
		}
		this.inherited(arguments);
	},

	buildRendering: function(){
		this.inherited(arguments);
		if(dojo.isIE && this.cols){ // attribute selectors is not supported in IE6
			dojo.addClass(this.textbox, "dijitTextAreaCols");
		}
	},

	filter: function(/*String*/ value){
		// Override TextBox.filter to deal with newlines... specifically (IIRC) this is for IE which writes newlines
		// as \r\n instead of just \n
		if(value){
			value = value.replace(/\r/g,"");
		}
		return this.inherited(arguments);
	},

	_previousValue: "",
	_onInput: function(/*Event?*/ e){
		// Override TextBox._onInput() to enforce maxLength restriction
		if(this.maxLength){
			var maxLength = parseInt(this.maxLength);
			var value = this.textbox.value.replace(/\r/g,'');
			var overflow = value.length - maxLength;
			if(overflow > 0){
				if(e){ dojo.stopEvent(e); }
				var textarea = this.textbox;
				if(textarea.selectionStart){
					var pos = textarea.selectionStart;
					var cr = 0;
					if(dojo.isOpera){
						cr = (this.textbox.value.substring(0,pos).match(/\r/g) || []).length;
					}
					this.textbox.value = value.substring(0,pos-overflow-cr)+value.substring(pos-cr);
					textarea.setSelectionRange(pos-overflow, pos-overflow);
				}else if(dojo.doc.selection){ //IE
					textarea.focus();
					var range = dojo.doc.selection.createRange();
					// delete overflow characters
					range.moveStart("character", -overflow);
					range.text = '';
					// show cursor
					range.select();
				}
			}
			this._previousValue = this.textbox.value;
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["misys.form.SimpleTextarea"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.form.SimpleTextarea"] = true;
dojo.provide("misys.form.SimpleTextarea");
dojo.experimental("misys.form.SimpleTextarea");




// our declared class
dojo.declare(
		"misys.form.SimpleTextarea",
        // we inherit from this class, which in turn mixes
        // in _Templated and _Layout
        [dijit.form.ValidationTextBox, dijit.form.SimpleTextarea],
        // class properties:
        {
            // Used for custom formatting
        	maxSize: 
        		this.maxSize,
        		
        	blnNewRow: false,
        		
        	rowCount: 0,
        	
        	postCreate: function() {
                this.inherited(arguments);
            },
            
            regExp: "(.|\\s)*",
            
            validate: function() {
            	if (arguments.length === 0) {
            		return this.validate(false);
            	}
            	return this.inherited(arguments);
            },
            
            isValid:  function(/*Boolean*/ isFocused){
            	this.invalidMessage = this.messages.invalidMessage;
            	if(!this.validator(this.textbox.value, this.constraints)){
            		return false;
            	}
            	
            	// Validate only when the field is onfocussed, or focussed but in error
            	var fieldIsValid = (this.state === 'Error') ? false : true;
            	if(false === isFocused || (true === isFocused && !fieldIsValid)){
            		fieldIsValid = true;
	            	// If the column counter is null, it means that the carriage returned
	            	// has been added. In such a case, we test if the current number of
	            	// rows is exceeding the maximum allowed:
	            	if(this.blnNewRow){
	            		if(this.rowCount >= this.maxSize){
	            			this.invalidMessage = misys.getLocalization('textareaLinesError', [this.maxSize, this.rowCount+1]);
	            			fieldIsValid = false;
	            		} 
	            	}
	            	// Test if the size of the result string is exceeding the maximum (include
	            	// the eventual linefeed to determine the maximum)
	            	var limit = (this.maxSize * this.cols) + this.maxSize;
	            	if(this.value.length > limit){
	            		this.invalidMessage =  misys.getLocalization('invalidFieldSizeError', [limit-1, this.value.length]);
	            		fieldIsValid = false;
	            	} 
            	}
            	
            	return fieldIsValid;
            },

            onBlur: function(element){
            	var el = (element == undefined) ? this : element;         	
				// Custom formatting
				if(el.value !== "") {
					var strResult = "";
					var intCountCol = 0;
					var intPosLastSpace = -1;
					var strInput = el.get('value');
					var rowCount = 0;
					var rowCountFix = 0;
					var blnNewRow = false;
					var cols = el.cols;
					var maxSize = el.maxSize;
					
					//to handle blnNewRow when the maxlines has been exceeded
					var newRowFlag = false;
					//To handle the deletion of extra line from textarea.
					var delExtraLines = misys.getLocalization('g_delExtraLinesTextarea');
					
					// We remove any trailing carriage return line feed at then end of the text
					// respectively for IE and Mozilla/Netscape
					strInput = strInput.replace(/(\r\n)+$/, "");
					strInput = strInput.replace(/(\n)+$/, "");
					
				    for (k=0; k<strInput.length; k++)
				    {
				    	strCurrentChar = strInput.charAt(k);
					
						// If the character is a carriage return or newline, we copy it
						// and reset the line counter
						if((strCurrentChar == "\r") || (strCurrentChar == "\n")){
							strResult += "\n";
							intCountCol = 0;
							rowCount++;
							blnNewRow = true;

							// Reset the position of the last space
							intPosLastSpace = -1;

							// If the character is a carriage return (IE), it will be followed
							// by a linefeed and hence we let the counter k jump by one
							if(strCurrentChar == "\r"){
								k++;
							}
						}
						
						// If the counter is equal to the maximum number of characters per line,
						// we retrieve the position of the previous blank space and add a
						// carriage return right after it. We insert a carriage return before the 
						// character and reset the counter:
						else if(intCountCol == cols){
							// If no space has so far been encountered we simply add a carriage
							// return here
							if(intPosLastSpace == -1){
								strResult += "\n";
								intCountCol = 1;
							} else{
								strResult = strResult.slice(0, strResult.length - (k - intPosLastSpace) + 1) + "\n" +
										strResult.slice(strResult.length - (k - intPosLastSpace) + 1);
								intCountCol = k - intPosLastSpace;
							}
							strResult += strCurrentChar;
							rowCount++;
							blnNewRow = true;
							// Reset the position of the last space
							intPosLastSpace = -1;
						} else{
							// Otherwise we simply copy the character and increment the counter:
							strResult += strCurrentChar;
							intCountCol++;
							blnNewRow = false;
						}

						// If the current character is a space, we store its position
						if(strCurrentChar == " "){
							intPosLastSpace = k;
						}
						
						//Fixed : blnNewRow has a scope within the for loop
						//when the current character is on the same line, blrNewRow is false
						//so when we pass blrNewRow to this.blnNewRow it doesnt validate for max no of lines
						//hence set a new flag into this.blnNewRow to indicate maxlines being exceeded 
						if(blnNewRow)
						{
							if(rowCount >= maxSize)
							{
								newRowFlag = true;
								el.set('blnNewRow', newRowFlag);
								el.set('rowCount', rowCount);
								if(delExtraLines === 'true')
								{
									el.set('value',strResult);
								}
								el.validate(false);
								//return;
	            			}
						}
				    }
					
				    if(el.maxLength != "" && el.maxLength > 0)
				    {
					    if(strResult.length > el.maxLength)
				    	{
					    	strResult = strResult.substring(0, el.maxLength);
				    	}
				    }
				    
					// Set attributes and update value
					el.set('blnNewRow', newRowFlag);
					el.set('rowCount', rowCount);
					el.set('value',strResult);
				}
				else
					{
						var newRowCount = 0;
						el.set('rowCount', newRowCount);
					}
				
				
				// Validate
				el.validate(false);
			}
        }
);

}

if(!dojo._hasResource["dijit.form.MultiSelect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.form.MultiSelect"] = true;
dojo.provide("dijit.form.MultiSelect");



dojo.declare("dijit.form.MultiSelect", dijit.form._FormValueWidget, {
	// summary:
	//		Widget version of a <select multiple=true> element,
	//		for selecting multiple options.

	// size: Number
	//		Number of elements to display on a page
	//		NOTE: may be removed in version 2.0, since elements may have variable height;
	//		set the size via style="..." or CSS class names instead.
	size: 7,

	templateString: "<select multiple='true' ${!nameAttrSetting} dojoAttachPoint='containerNode,focusNode' dojoAttachEvent='onchange: _onChange'></select>",

	attributeMap: dojo.delegate(dijit.form._FormWidget.prototype.attributeMap, {
		size: "focusNode"
	}),

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time

		// TODO: once we inherit from FormValueWidget this won't be needed
		this._hasBeenBlurred = false;
		this._setValueAttr(this._resetValue, true);
	},

	addSelected: function(/*dijit.form.MultiSelect*/ select){
		// summary:
		//		Move the selected nodes of a passed Select widget
		//		instance to this Select widget.
		//
		// example:
		// |	// move all the selected values from "bar" to "foo"
		// | 	dijit.byId("foo").addSelected(dijit.byId("bar"));

		select.getSelected().forEach(function(n){
			this.containerNode.appendChild(n);
			// scroll to bottom to see item
			// cannot use scrollIntoView since <option> tags don't support all attributes
			// does not work on IE due to a bug where <select> always shows scrollTop = 0
			this.domNode.scrollTop = this.domNode.offsetHeight; // overshoot will be ignored
			// scrolling the source select is trickier esp. on safari who forgets to change the scrollbar size
			var oldscroll = select.domNode.scrollTop;
			select.domNode.scrollTop = 0;
			select.domNode.scrollTop = oldscroll;
		},this);
	},

	getSelected: function(){
		// summary:
		//		Access the NodeList of the selected options directly
		return dojo.query("option",this.containerNode).filter(function(n){
			return n.selected; // Boolean
		}); // dojo.NodeList
	},

	_getValueAttr: function(){
		// summary:
		//		Hook so get('value') works.
		// description:
		//		Returns an array of the selected options' values.
		return this.getSelected().map(function(n){
			return n.value;
		});
	},

	multiple: true, // for Form

	_setValueAttr: function(/*Array*/ values){
		// summary:
		//		Hook so set('value', values) works.
		// description:
		//		Set the value(s) of this Select based on passed values
		dojo.query("option",this.containerNode).forEach(function(n){
			n.selected = (dojo.indexOf(values,n.value) != -1);
		});
	},

	invertSelection: function(onChange){
		// summary:
		//		Invert the selection
		// onChange: Boolean
		//		If null, onChange is not fired.
		dojo.query("option",this.containerNode).forEach(function(n){
			n.selected = !n.selected;
		});
		this._handleOnChange(this.get('value'), onChange == true);
	},

	_onChange: function(/*Event*/ e){
		this._handleOnChange(this.get('value'), true);
	},

	// for layout widgets:
	resize: function(/*Object*/ size){
		if(size){
			dojo.marginBox(this.domNode, size);
		}
	},

	postCreate: function(){
		this._onChange();
	}
});

}

if(!dojo._hasResource["misys.binding.AsyncMessage"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.binding.AsyncMessage"] = true;
/**
 * Timer to periodically check for any asynchronous transaction message
 * DEMO for Unsaved Data Alert
 */
dojo.provide("misys.binding.AsyncMessage");


(function(/*Dojo*/ d, /*Misys*/m){
	
	 // ECMA5 Strict Mode
	
	// Private Methods
	//Dialog for After Max duration over Session
	function _showAsyncMessageDialog(/*XHRResponse*/ response){
		
		var asyncMsgDialog = dijit.byId("asyncSaveDialog");
		var asyncMsgDialogButtons = dojo.byId('asyncSaveDialogButtons');
		var asyncMsgButton = dijit.byId('OkAsyncButton').domNode;
		var asyncMsgDialogContent = dojo.byId('asyncSaveDialogContent');
		var asyncMsgWidgetContainer = dijit.byId('asyncSaveDialog').domNode;
		var asyncMsg = dojo.byId('asyncSaveDialogMsg');

		dojo.style(asyncMsgDialogButtons, 'display', 'block');
		dojo.style(asyncMsgDialogContent, 'display', 'block');
		dojo.style(asyncMsgButton, 'display', 'inline-block');
		dojo.style(asyncMsgWidgetContainer, 'display', 'inline-block');
		dojo.style(asyncMsg, 'display', 'inline-block');
		asyncMsgDialog.set('title', misys.getLocalization('asyncMessage'));
		asyncMsg.innerHTML = response.asyncMessage;
		
		// Disable window closing by using the escape key
		misys.dialog.connect(asyncMsgDialog, 'onKeyPress', function(evt) {
			if (evt.keyCode == dojo.keys.ESCAPE) {
				dojo.stopEvent(evt);
			}
		});
			
		misys.dialog.connect(dijit.byId('OkAsyncButton'), 'onMouseUp', function(){
			misys.dialog.disconnect(asyncMsgDialog);
			asyncMsgDialog.hide();
		}, asyncMsgDialog.id);
		
		misys.dialog.connect(asyncMsgDialog, 'onHide', function() {
				misys.dialog.disconnect(asyncMsgDialog);
		});
		
		asyncMsgDialog.show();
	}
	
	//Public Methods
	d.mixin(m, {
		checkAsyncMessage : function(/*Number*/ counter){
			misys.xhrGet( {
				url : misys.getServletURL("/screen/AjaxScreen/action/PingAction"),
				sync : true,
				handleAs : "json",
				load : function(response, args){
					if(response.asyncMessage)
					{
						console.debug("Message found!");
						_showAsyncMessageDialog(response);
					}	
					else
					{
						counter++;
						setTimeout("misys.checkAsyncMessage("+counter+")", m._config.asyncMessageFreq || 5000);
					}	
				},
				error : function(error) {				
					console.debug("Some error:",error);
				}
			});
		}
	});
})(dojo, misys);	

}

if(!dojo._hasResource["dojox.lang.aspect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.lang.aspect"] = true;
dojo.provide("dojox.lang.aspect");

(function(){
	var d = dojo, aop = dojox.lang.aspect, ap = Array.prototype,
		contextStack = [], context;
		
	// this class implements a topic-based double-linked list
	var Advice = function(){
		this.next_before = this.prev_before =
		this.next_around = this.prev_around =
		this.next_afterReturning = this.prev_afterReturning =
		this.next_afterThrowing = this.prev_afterThrowing =
			this;
		this.counter = 0;
	};
	d.extend(Advice, {
		add: function(advice){
			var dyn = d.isFunction(advice),
				node = {advice: advice, dynamic: dyn};
			this._add(node, "before", "", dyn, advice);
			this._add(node, "around", "", dyn, advice);
			this._add(node, "after", "Returning", dyn, advice);
			this._add(node, "after", "Throwing", dyn, advice);
			++this.counter;
			return node;
		},
		_add: function(node, topic, subtopic, dyn, advice){
			var full = topic + subtopic;
			if(dyn || advice[topic] || (subtopic && advice[full])){
				var next = "next_" + full, prev = "prev_" + full;
				(node[prev] = this[prev])[next] = node;
				(node[next] = this)[prev] = node;
			}
		},
		remove: function(node){
			this._remove(node, "before");
			this._remove(node, "around");
			this._remove(node, "afterReturning");
			this._remove(node, "afterThrowing");
			--this.counter;
		},
		_remove: function(node, topic){
			var next = "next_" + topic, prev = "prev_" + topic;
			if(node[next]){
				node[next][prev] = node[prev];
				node[prev][next] = node[next];
			}
		},
		isEmpty: function(){
			return !this.counter;
		}
	});

	var getDispatcher = function(){
	
		return function(){
			
			var self = arguments.callee,	// the join point
				advices = self.advices,		// list of advices for this joinpoint
				ret, i, a, e, t;

			// push context
			if(context){ contextStack.push(context); }
			context = {
				instance: this,					// object instance
				joinPoint: self,				// join point
				depth: contextStack.length,		// current level of depth starting from 0
				around: advices.prev_around,	// pointer to the current around advice
				dynAdvices: [],					// array of dynamic advices if any
				dynIndex: 0						// index of a dynamic advice
			};

			try{
				// process before events
				for(i = advices.prev_before; i != advices; i = i.prev_before){
					if(i.dynamic){
						// instantiate a dynamic advice
						context.dynAdvices.push(a = new i.advice(context));
						if(t = a.before){ // intentional assignment
							t.apply(a, arguments);
						}
					}else{
						t = i.advice;
						t.before.apply(t, arguments);
					}
				}

				// process around and after events
				try{
					// call the around advice or the original method
					ret = (advices.prev_around == advices ? self.target : aop.proceed).apply(this, arguments);
				}catch(e){
					// process after throwing and after events
					context.dynIndex = context.dynAdvices.length;
					for(i = advices.next_afterThrowing; i != advices; i = i.next_afterThrowing){
						a = i.dynamic ? context.dynAdvices[--context.dynIndex] : i.advice;
						if(t = a.afterThrowing){ // intentional assignment
							t.call(a, e);
						}
						if(t = a.after){ // intentional assignment
							t.call(a);
						}
					}
					// continue the exception processing
					throw e;
				}
				// process after returning and after events
				context.dynIndex = context.dynAdvices.length;
				for(i = advices.next_afterReturning; i != advices; i = i.next_afterReturning){
					a = i.dynamic ? context.dynAdvices[--context.dynIndex] : i.advice;
					if(t = a.afterReturning){ // intentional assignment
						t.call(a, ret);
					}
					if(t = a.after){ // intentional assignment
						t.call(a);
					}
				}
				// process dojo.connect() listeners
				var ls = self._listeners;
				for(i in ls){
					if(!(i in ap)){
						ls[i].apply(this, arguments);
					}
				}
			}finally{
				// destroy dynamic advices
				for(i = 0; i < context.dynAdvices.length; ++i){
					a = context.dynAdvices[i];
					if(a.destroy){
						a.destroy();
					}
				}
				// pop context
				context = contextStack.length ? contextStack.pop() : null;
			}
			
			return ret;
		};
	};

	aop.advise = function(/*Object*/ obj,
						/*String|RegExp|Array*/ method,
						/*Object|Function|Array*/ advice
						){
		// summary:
		//		Attach AOP-style advices to a method.
		//
		// description:
		//		Attaches AOP-style advices to a method. Can attach several
		//		advices at once and operate on several methods of an object.
		//		The latter is achieved when a RegExp is specified as
		//		a method name, or an array of strings and regular expressions
		//		is used. In this case all functional methods that
		//		satisfy the RegExp condition are processed. This function
		//		returns a handle, which can be used to unadvise, or null,
		//		if advising has failed.
		//
		//		This function is a convenience wrapper for
		//		dojox.lang.aspect.adviseRaw().
		//
		// obj:
		//		A source object for the advised function. Cannot be a DOM node.
		//		If this object is a constructor, its prototype is advised.
		//
		// method:
		//		A string name of the function in obj. In case of RegExp all
		//		methods of obj matching the regular expression are advised.
		//
		// advice:
		//		An object, which defines advises, or a function, which
		//		returns such object, or an array of previous items.
		//		The advice object can define following member functions:
		//		before, around, afterReturning, afterThrowing, after.
		//		If the function is supplied, it is called with a context
		//		object once per call to create a temporary advice object, which
		//		is destroyed after the processing. The temporary advice object
		//		can implement a destroy() method, if it wants to be called when
		//		not needed.
		
		if(typeof obj != "object"){
			obj = obj.prototype;
		}

		var methods = [];
		if(!(method instanceof Array)){
			method = [method];
		}
		
		// identify advised methods
		for(var j = 0; j < method.length; ++j){
			var t = method[j];
			if(t instanceof RegExp){
				for(var i in obj){
					if(d.isFunction(obj[i]) && t.test(i)){
						methods.push(i);
					}
				}
			}else{
				if(d.isFunction(obj[t])){
					methods.push(t);
				}
			}
		}

		if(!d.isArray(advice)){ advice = [advice]; }

		return aop.adviseRaw(obj, methods, advice);	// Object
	};
	
	aop.adviseRaw = function(/*Object*/ obj,
						/*Array*/ methods,
						/*Array*/ advices
						){
		// summary:
		//		Attach AOP-style advices to methods.
		//
		// description:
		//		Attaches AOP-style advices to object's methods. Can attach several
		//		advices at once and operate on several methods of the object.
		//		The latter is achieved when a RegExp is specified as
		//		a method name. In this case all functional methods that
		//		satisfy the RegExp condition are processed. This function
		//		returns a handle, which can be used to unadvise, or null,
		//		if advising has failed.
		//
		// obj:
		//		A source object for the advised function.
		//		Cannot be a DOM node.
		//
		// methods:
		//		An array of method names (strings) to be advised.
		//
		// advices:
		//		An array of advices represented by objects or functions that
		//		return such objects on demand during the event processing.
		//		The advice object can define following member functions:
		//		before, around, afterReturning, afterThrowing, after.
		//		If the function is supplied, it is called with a context
		//		object once per call to create a temporary advice object, which
		//		is destroyed after the processing. The temporary advice object
		//		can implement a destroy() method, if it wants to be called when
		//		not needed.

		if(!methods.length || !advices.length){ return null; }
		
		// attach advices
		var m = {}, al = advices.length;
		for(var i = methods.length - 1; i >= 0; --i){
			var name = methods[i], o = obj[name], ao = new Array(al), t = o.advices;
			// create a stub, if needed
			if(!t){
				var x = obj[name] = getDispatcher();
				x.target = o.target || o;
				x.targetName = name;
				x._listeners = o._listeners || [];
				x.advices = new Advice;
				t = x.advices;
			}
			// attach advices
			for(var j = 0; j < al; ++j){
				ao[j] = t.add(advices[j]);
			}
			m[name] = ao;
		}
		
		return [obj, m];	// Object
	};

	aop.unadvise = function(/*Object*/ handle){
		// summary:
		//		Detach previously attached AOP-style advices.
		//
		// handle:
		//		The object returned by dojox.lang.aspect.advise().
		
		if(!handle){ return; }
		var obj = handle[0], methods = handle[1];
		for(var name in methods){
			var o = obj[name], t = o.advices, ao = methods[name];
			for(var i = ao.length - 1; i >= 0; --i){
				t.remove(ao[i]);
			}
			if(t.isEmpty()){
				// check if we can remove all stubs
				var empty = true, ls = o._listeners;
				if(ls.length){
					for(i in ls){
						if(!(i in ap)){
							empty = false;
							break;
						}
					}
				}
				if(empty){
					// revert to the original method
					obj[name] = o.target;
				}else{
					// replace with the dojo.connect() stub
					var x = obj[name] = d._listener.getDispatcher();
					x.target = o.target;
					x._listeners = ls;
				}
			}
		}
	};
	
	aop.getContext = function(){
		// summary:
		//		Returns the context information for the advice in effect.
		
		return context;	// Object
	};
	
	aop.getContextStack = function(){
		// summary:
		//		Returns the context stack, which reflects executing advices
		//		up to this point. The array is ordered from oldest to newest.
		//		In order to get the active context use dojox.lang.aspect.getContext().
		
		return contextStack;	// Array
	};
	
	aop.proceed = function(){
		// summary:
		//		Call the original function (or the next level around advice) in an around advice code.
		//
		// description:
		//		Calls the original function (or the next level around advice).
		//		Accepts and passes on any number of arguments, and returns a value.
		//		This function is valid only in the content of around calls.
		
		var joinPoint = context.joinPoint, advices = joinPoint.advices;
		for(var c = context.around; c != advices; c = context.around){
			context.around = c.prev_around;	// advance the pointer
			if(c.dynamic){
				var a = context.dynAdvices[context.dynIndex++], t = a.around;
				if(t){
					return t.apply(a, arguments);
				}
			}else{
				return c.advice.around.apply(c.advice, arguments);
			}
		}
		return joinPoint.target.apply(context.instance, arguments);
	};
})();

/*
Aspect = {
	before: function(arguments){...},
	around: function(arguments){...returns value...},
	afterReturning: function(ret){...},
	afterThrowing: function(excp){...},
	after: function(){...}
};

Context = {
	instance:  ..., // the instance we operate on
	joinPoint: ...,	// Object (see below)
	depth:     ...	// current depth of the context stack
};

JoinPoint = {
	target:     ...,	// the original function being wrapped
	targetName: ...		// name of the method
};
*/

}

if(!dojo._hasResource["dojox.collections._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.collections._base"] = true;
dojo.provide("dojox.collections._base");

dojox.collections.DictionaryEntry=function(/* string */k, /* object */v){
	//	summary
	//	return an object of type dojox.collections.DictionaryEntry
	this.key=k;
	this.value=v;
	this.valueOf=function(){
		return this.value; 	//	object
	};
	this.toString=function(){
		return String(this.value);	//	string
	};
}

/*	Iterators
 *	The collections.Iterators (Iterator and DictionaryIterator) are built to
 *	work with the Collections included in this module.  However, they *can*
 *	be used with arrays and objects, respectively, should one choose to do so.
 */
dojox.collections.Iterator=function(/* array */arr){
	//	summary
	//	return an object of type dojox.collections.Iterator
	var a=arr;
	var position=0;
	this.element=a[position]||null;
	this.atEnd=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		return (position>=a.length);	//	bool
	};
	this.get=function(){
		//	summary
		//	Get the next member in the collection.
		if(this.atEnd()){
			return null;		//	object
		}
		this.element=a[position++];
		return this.element;	//	object
	};
	this.map=function(/* function */fn, /* object? */scope){
		//	summary
		//	Functional iteration with optional scope.
		return dojo.map(a, fn, scope);
	};
	this.reset=function(){
		//	summary
		//	reset the internal cursor.
		position=0;
		this.element=a[position];
	};
}

/*	Notes:
 *	The DictionaryIterator no longer supports a key and value property;
 *	the reality is that you can use this to iterate over a JS object
 *	being used as a hashtable.
 */
dojox.collections.DictionaryIterator=function(/* object */obj){
	//	summary
	//	return an object of type dojox.collections.DictionaryIterator
	var a=[];	//	Create an indexing array
	var testObject={};
	for(var p in obj){
		if(!testObject[p]){
			a.push(obj[p]);	//	fill it up
		}
	}
	var position=0;
	this.element=a[position]||null;
	this.atEnd=function(){
		//	summary
		//	Test to see if the internal cursor has reached the end of the internal collection.
		return (position>=a.length);	//	bool
	};
	this.get=function(){
		//	summary
		//	Get the next member in the collection.
		if(this.atEnd()){
			return null;		//	object
		}
		this.element=a[position++];
		return this.element;	//	object
	};
	this.map=function(/* function */fn, /* object? */scope){
		//	summary
		//	Functional iteration with optional scope.
		return dojo.map(a, fn, scope);
	};
	this.reset=function() {
		//	summary
		//	reset the internal cursor.
		position=0;
		this.element=a[position];
	};
};

}

if(!dojo._hasResource["dojox.collections.ArrayList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.collections.ArrayList"] = true;
dojo.provide("dojox.collections.ArrayList");


dojox.collections.ArrayList=function(/* array? */arr){
	//	summary
	//	Returns a new object of type dojox.collections.ArrayList
	var items=[];
	if(arr) items=items.concat(arr);
	this.count=items.length;
	this.add=function(/* object */obj){
		//	summary
		//	Add an element to the collection.
		items.push(obj);
		this.count=items.length;
	};
	this.addRange=function(/* array */a){
		//	summary
		//	Add a range of objects to the ArrayList
		if(a.getIterator){
			var e=a.getIterator();
			while(!e.atEnd()){
				this.add(e.get());
			}
			this.count=items.length;
		}else{
			for(var i=0; i<a.length; i++){
				items.push(a[i]);
			}
			this.count=items.length;
		}
	};
	this.clear=function(){
		//	summary
		//	Clear all elements out of the collection, and reset the count.
		items.splice(0, items.length);
		this.count=0;
	};
	this.clone=function(){
		//	summary
		//	Clone the array list
		return new dojox.collections.ArrayList(items);	//	dojox.collections.ArrayList
	};
	this.contains=function(/* object */obj){
		//	summary
		//	Check to see if the passed object is a member in the ArrayList
		for(var i=0; i < items.length; i++){
			if(items[i] == obj) {
				return true;	//	bool
			}
		}
		return false;	//	bool
	};
	this.forEach=function(/* function */ fn, /* object? */ scope){
		//	summary
		//	functional iterator, following the mozilla spec.
		dojo.forEach(items, fn, scope);
	};
	this.getIterator=function(){
		//	summary
		//	Get an Iterator for this object
		return new dojox.collections.Iterator(items);	//	dojox.collections.Iterator
	};
	this.indexOf=function(/* object */obj){
		//	summary
		//	Return the numeric index of the passed object; will return -1 if not found.
		for(var i=0; i < items.length; i++){
			if(items[i] == obj) {
				return i;	//	int
			}
		}
		return -1;	// int
	};
	this.insert=function(/* int */ i, /* object */ obj){
		//	summary
		//	Insert the passed object at index i
		items.splice(i,0,obj);
		this.count=items.length;
	};
	this.item=function(/* int */ i){
		//	summary
		//	return the element at index i
		return items[i];	//	object
	};
	this.remove=function(/* object */obj){
		//	summary
		//	Look for the passed object, and if found, remove it from the internal array.
		var i=this.indexOf(obj);
		if(i >=0) {
			items.splice(i,1);
		}
		this.count=items.length;
	};
	this.removeAt=function(/* int */ i){
		//	summary
		//	return an array with function applied to all elements
		items.splice(i,1);
		this.count=items.length;
	};
	this.reverse=function(){
		//	summary
		//	Reverse the internal array
		items.reverse();
	};
	this.sort=function(/* function? */ fn){
		//	summary
		//	sort the internal array
		if(fn){
			items.sort(fn);
		}else{
			items.sort();
		}
	};
	this.setByIndex=function(/* int */ i, /* object */ obj){
		//	summary
		//	Set an element in the array by the passed index.
		items[i]=obj;
		this.count=items.length;
	};
	this.toArray=function(){
		//	summary
		//	Return a new array with all of the items of the internal array concatenated.
		return [].concat(items);
	}
	this.toString=function(/* string */ delim){
		//	summary
		//	implementation of toString, follows [].toString();
		return items.join((delim||","));
	};
};

}

if(!dojo._hasResource["dojo.io.iframe"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.io.iframe"] = true;
dojo.provide("dojo.io.iframe");

dojo.getObject("io", true, dojo);

/*=====
dojo.declare("dojo.io.iframe.__ioArgs", dojo.__IoArgs, {
	constructor: function(){
		//	summary:
		//		All the properties described in the dojo.__ioArgs type, apply
		//		to this type. The following additional properties are allowed
		//		for dojo.io.iframe.send():
		//	method: String?
		//		The HTTP method to use. "GET" or "POST" are the only supported
		//		values.  It will try to read the value from the form node's
		//		method, then try this argument. If neither one exists, then it
		//		defaults to POST.
		//	handleAs: String?
		//		Specifies what format the result data should be given to the
		//		load/handle callback. Valid values are: text, html, xml, json,
		//		javascript. IMPORTANT: For all values EXCEPT html and xml, The
		//		server response should be an HTML file with a textarea element.
		//		The response data should be inside the textarea element. Using an
		//		HTML document the only reliable, cross-browser way this
		//		transport can know when the response has loaded. For the html
		//		handleAs value, just return a normal HTML document.  NOTE: xml
		//		is now supported with this transport (as of 1.1+); a known issue
		//		is if the XML document in question is malformed, Internet Explorer
		//		will throw an uncatchable error.
		//	content: Object?
		//		If "form" is one of the other args properties, then the content
		//		object properties become hidden form form elements. For
		//		instance, a content object of {name1 : "value1"} is converted
		//		to a hidden form element with a name of "name1" and a value of
		//		"value1". If there is not a "form" property, then the content
		//		object is converted into a name=value&name=value string, by
		//		using dojo.objectToQuery().
		this.method = method;
		this.handleAs = handleAs;
		this.content = content;
	}
});
=====*/

dojo.io.iframe = {
	// summary:
	//		Sends an Ajax I/O call using and Iframe (for instance, to upload files)
	
	create: function(/*String*/fname, /*String*/onloadstr, /*String?*/uri){
		//	summary:
		//		Creates a hidden iframe in the page. Used mostly for IO
		//		transports.  You do not need to call this to start a
		//		dojo.io.iframe request. Just call send().
		//	fname: String
		//		The name of the iframe. Used for the name attribute on the
		//		iframe.
		//	onloadstr: String
		//		A string of JavaScript that will be executed when the content
		//		in the iframe loads.
		//	uri: String
		//		The value of the src attribute on the iframe element. If a
		//		value is not given, then dojo/resources/blank.html will be
		//		used.
		if(window[fname]){ return window[fname]; }
		if(window.frames[fname]){ return window.frames[fname]; }
		var cframe = null;
		var turi = uri;
		if(!turi){
			if(dojo.config["useXDomain"] && !dojo.config["dojoBlankHtmlUrl"]){
				console.warn("dojo.io.iframe.create: When using cross-domain Dojo builds,"
					+ " please save dojo/resources/blank.html to your domain and set djConfig.dojoBlankHtmlUrl"
					+ " to the path on your domain to blank.html");
			}
			turi = (dojo.config["dojoBlankHtmlUrl"]||dojo.moduleUrl("dojo", "resources/blank.html"));
		}
		var cframe = dojo.place(
				'<iframe id="'+fname+'" name="'+fname+'" onload="'+onloadstr+
			'" style="position: absolute; left: 1px; top: 1px; height: 1px; width: 1px; visibility: hidden">',
		dojo.body());

		window[fname] = cframe;

		return cframe;
	},

	setSrc: function(/*DOMNode*/iframe, /*String*/src, /*Boolean*/replace){
		//summary:
		//		Sets the URL that is loaded in an IFrame. The replace parameter
		//		indicates whether location.replace() should be used when
		//		changing the location of the iframe.
		try{
			if(!replace){
				if(dojo.isWebKit){
					iframe.location = src;
				}else{
					frames[iframe.name].location = src;
				}
			}else{
				// Fun with DOM 0 incompatibilities!
				var idoc;
				if(dojo.isIE || dojo.isWebKit){
					idoc = iframe.contentWindow.document;
				}else{ //  if(d.isMozilla){
					idoc = iframe.contentWindow;
				}
	
				//For Safari (at least 2.0.3) and Opera, if the iframe
				//has just been created but it doesn't have content
				//yet, then iframe.document may be null. In that case,
				//use iframe.location and return.
				if(!idoc){
					iframe.location = src;
					return;
				}else{
					idoc.location.replace(src);
				}
			}
		}catch(e){
			console.log("dojo.io.iframe.setSrc: ", e);
		}
	},

	doc: function(/*DOMNode*/iframeNode){
		//summary: Returns the document object associated with the iframe DOM Node argument.
		var doc = iframeNode.contentDocument || // W3
			(
				(
					(iframeNode.name) && (iframeNode.document) &&
					(dojo.doc.getElementsByTagName("iframe")[iframeNode.name].contentWindow) &&
					(dojo.doc.getElementsByTagName("iframe")[iframeNode.name].contentWindow.document)
				)
			) ||  // IE
			(
				(iframeNode.name)&&(dojo.doc.frames[iframeNode.name])&&
				(dojo.doc.frames[iframeNode.name].document)
			) || null;
		return doc;
	},

	send: function(/*dojo.io.iframe.__ioArgs*/args){
		//summary:
		//		Function that sends the request to the server.
		//		This transport can only process one send() request at a time, so if send() is called
		//multiple times, it will queue up the calls and only process one at a time.
		if(!this["_frame"]){
			this._frame = this.create(this._iframeName, dojo._scopeName + ".io.iframe._iframeOnload();");
		}

		//Set up the deferred.
		var dfd = dojo._ioSetArgs(
			args,
			function(/*Deferred*/dfd){
				//summary: canceller function for dojo._ioSetArgs call.
				dfd.canceled = true;
				dfd.ioArgs._callNext();
			},
			function(/*Deferred*/dfd){
				//summary: okHandler function for dojo._ioSetArgs call.
				var value = null;
				try{
					var ioArgs = dfd.ioArgs;
					var dii = dojo.io.iframe;
					var ifd = dii.doc(dii._frame);
					var handleAs = ioArgs.handleAs;

					//Assign correct value based on handleAs value.
					value = ifd; //html
					if(handleAs != "html"){
						if(handleAs == "xml"){
							//	FF, Saf 3+ and Opera all seem to be fine with ifd being xml.  We have to
							//	do it manually for IE6-8.  Refs #6334.
							if(dojo.isIE < 9 || (dojo.isIE && dojo.isQuirks)){
								dojo.query("a", dii._frame.contentWindow.document.documentElement).orphan();
								var xmlText=(dii._frame.contentWindow.document).documentElement.innerText;
								xmlText=xmlText.replace(/>\s+</g, "><");
								xmlText=dojo.trim(xmlText);
								//Reusing some code in base dojo for handling XML content.  Simpler and keeps
								//Core from duplicating the effort needed to locate the XML Parser on IE.
								var fauxXhr = { responseText: xmlText };
								value = dojo._contentHandlers["xml"](fauxXhr); // DOMDocument
							}
						}else{
							value = ifd.getElementsByTagName("textarea")[0].value; //text
							if(handleAs == "json"){
								value = dojo.fromJson(value); //json
							}else if(handleAs == "javascript"){
								value = dojo.eval(value); //javascript
							}
						}
					}
				}catch(e){
					value = e;
				}finally{
					ioArgs._callNext();
				}
				return value;
			},
			function(/*Error*/error, /*Deferred*/dfd){
				//summary: errHandler function for dojo._ioSetArgs call.
				dfd.ioArgs._hasError = true;
				dfd.ioArgs._callNext();
				return error;
			}
		);

		//Set up a function that will fire the next iframe request. Make sure it only
		//happens once per deferred.
		dfd.ioArgs._callNext = function(){
			if(!this["_calledNext"]){
				this._calledNext = true;
				dojo.io.iframe._currentDfd = null;
				dojo.io.iframe._fireNextRequest();
			}
		};

		this._dfdQueue.push(dfd);
		this._fireNextRequest();
		
		//Add it the IO watch queue, to get things like timeout support.
		dojo._ioWatch(
			dfd,
			function(/*Deferred*/dfd){
				//validCheck
				return !dfd.ioArgs["_hasError"];
			},
			function(dfd){
				//ioCheck
				return (!!dfd.ioArgs["_finished"]);
			},
			function(dfd){
				//resHandle
				if(dfd.ioArgs._finished){
					dfd.callback(dfd);
				}else{
					dfd.errback(new Error("Invalid dojo.io.iframe request state"));
				}
			}
		);

		return dfd;
	},

	_currentDfd: null,
	_dfdQueue: [],
	_iframeName: dojo._scopeName + "IoIframe",

	_fireNextRequest: function(){
		//summary: Internal method used to fire the next request in the bind queue.
		try{
			if((this._currentDfd)||(this._dfdQueue.length == 0)){ return; }
			//Find next deferred, skip the canceled ones.
			do{
				var dfd = this._currentDfd = this._dfdQueue.shift();
			} while(dfd && dfd.canceled && this._dfdQueue.length);

			//If no more dfds, cancel.
			if(!dfd || dfd.canceled){
				this._currentDfd =  null;
				return;
			}

			var ioArgs = dfd.ioArgs;
			var args = ioArgs.args;

			ioArgs._contentToClean = [];
			var fn = dojo.byId(args["form"]);
			var content = args["content"] || {};
			if(fn){
				if(content){
					// if we have things in content, we need to add them to the form
					// before submission
					var pHandler = function(name, value) {
						dojo.create("input", {type: "hidden", name: name, value: value}, fn);
						ioArgs._contentToClean.push(name);
					};
					for(var x in content){
						var val = content[x];
						if(dojo.isArray(val) && val.length > 1){
							var i;
							for (i = 0; i < val.length; i++) {
								pHandler(x,val[i]);
							}
						}else{
							if(!fn[x]){
								pHandler(x,val);
							}else{
								fn[x].value = val;
							}
						}
					}
				}
				//IE requires going through getAttributeNode instead of just getAttribute in some form cases,
				//so use it for all.  See #2844
				var actnNode = fn.getAttributeNode("action");
				var mthdNode = fn.getAttributeNode("method");
				var trgtNode = fn.getAttributeNode("target");
				if(args["url"]){
					ioArgs._originalAction = actnNode ? actnNode.value : null;
					if(actnNode){
						actnNode.value = args.url;
					}else{
						fn.setAttribute("action",args.url);
					}
				}
				if(!mthdNode || !mthdNode.value){
					if(mthdNode){
						mthdNode.value= (args["method"]) ? args["method"] : "post";
					}else{
						fn.setAttribute("method", (args["method"]) ? args["method"] : "post");
					}
				}
				ioArgs._originalTarget = trgtNode ? trgtNode.value: null;
				if(trgtNode){
					trgtNode.value = this._iframeName;
				}else{
					fn.setAttribute("target", this._iframeName);
				}
				fn.target = this._iframeName;
				dojo._ioNotifyStart(dfd);
				fn.submit();
			}else{
				// otherwise we post a GET string by changing URL location for the
				// iframe
				var tmpUrl = args.url + (args.url.indexOf("?") > -1 ? "&" : "?") + ioArgs.query;
				dojo._ioNotifyStart(dfd);
				this.setSrc(this._frame, tmpUrl, true);
			}
		}catch(e){
			dfd.errback(e);
		}
	},

	_iframeOnload: function(){
		var dfd = this._currentDfd;
		if(!dfd){
			this._fireNextRequest();
			return;
		}

		var ioArgs = dfd.ioArgs;
		var args = ioArgs.args;
		var fNode = dojo.byId(args.form);
	
		if(fNode){
			// remove all the hidden content inputs
			var toClean = ioArgs._contentToClean;
			for(var i = 0; i < toClean.length; i++) {
				var key = toClean[i];
				//Need to cycle over all nodes since we may have added
				//an array value which means that more than one node could
				//have the same .name value.
				for(var j = 0; j < fNode.childNodes.length; j++){
					var chNode = fNode.childNodes[j];
					if(chNode.name == key){
						dojo.destroy(chNode);
						break;
					}
				}
			}

			// restore original action + target
			if(ioArgs["_originalAction"]){
				fNode.setAttribute("action", ioArgs._originalAction);
			}
			if(ioArgs["_originalTarget"]){
				fNode.setAttribute("target", ioArgs._originalTarget);
				fNode.target = ioArgs._originalTarget;
			}
		}

		ioArgs._finished = true;
	}
};

}

if(!dojo._hasResource['misys.client.common_client']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['misys.client.common_client'] = true;
dojo.provide('misys.client.common_client');
(function(/*Dojo*/d, /*Dijit*/dj, /*Misys*/m) {
'use strict'; // ECMA5 Strict Mode

// use 'commonclient' as binding 
})(dojo, dijit, misys);

}

if(!dojo._hasResource["misys.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.common"] = true;
var originalOperationValue="";
var consoleMSG ='widget invalid: ';
var attachmntFile="attachment-file";
var tabContainr=".tabcontainer";
var colbortionWindow='#collaborationWindow';
var ariaDescrib='aria-describedby';
var langMenu='#languagesMenu .dijitReset.dijitStretch.dijitButtonContents.dijitDownArrowButton';
var bookmrkMenu='#bookmarkMenu .dijitReset.dijitStretch.dijitButtonContents.dijitDownArrowButton';
var popuMenuItem=".dijitReset.dijitInline.dijitMenuItem.dijitMenuItemLabel.portalPopupMenuBarItem";
var h1portletTitle="h1.portlet-title";
var h2portletTitle="h2.portlet-title";
var homepagePortlet=".homepage .portlet";
var inlneBlock='inline-block';
var prductCode="&productcode=";
var refrnceId="&referenceid=";
var entitlementCod="&entitlementcode=";
var entitlementDescp="&entitlementdescription=";
var scrhCrieteria='#searchCriteria > div > p';
var GTPRootPotlet="#GTPRootPortlet > div.portlet-section-header.portlet-font > h1";
var reportingPopup ="/screen/ReportingPopup";
var footerHtml = 'footerHtml';

dojo.provide("misys.common");

















// Copyright (c) 2000-2011 Misys (http://www.misys.com),
// All Rights Reserved. 
//
// summary: 
//    Library of commonly-used security-sensitive JavaScript functions
//
// description:
//    JavaScript functions used across the application, for all secured
//    pages only. This file shouldn't be loaded in a non-secured 
//    session (that's what _base.js is for).
//
//	  This will always be loaded into the page for every authorised session
//    (consult DefaultGTPLayout.java for details) so there is no need to dojo.require this
//	  file.
//
//	  It contains functions that live under the following categories
//		1. Setup functions for page services (topic subscriptions, grids, etc.)
//		2. Common onLoad events for all secured pages. This startup is called for all
//         pages, even those without forms. Hence we include empty functions that
//		   are later defined in misys.forms.common
//      3. Anything needed to get a basic form working with MTP. The functions in 
//		   misys.common decorate such forms with the more complicated functionality
//		   required for product forms.
//
//	  Note that we assume throughout that misys._base has already been loaded (which is
//	  always the case, otherwise there's a problem)
//
//   version:   1.2
//   date:      24/03/2011
//   author:    Cormac Flynn

/**
 * <h4>Summary:</h4>
 *   Library of commonly-used security-sensitive JavaScript functions
 *   JavaScript functions that re  used across the application, for all secured
 *    pages. This file shouldn't be loaded in a non-secured
 *    session (that's what _base.js is for).
 *    This will always be loaded into the page for every authorised session
 *    (consult DefaultGTPLayout.java for details) so there is no need to dojo.require this
 *    file.
 *    
 *    <h4>Description:</h4> 
 *    It contains functions that live under the following categories
 *    1. Setup functions for page services (topic subscriptions, grids, etc.)
 *    2. Common onLoad events for all secured pages. This startup is called for all
 *    pages, even those without forms. Hence we include empty functions that
 *    are later defined in misys.forms.common
 *   3. Anything needed to get a basic form working with MTP. The functions in
 *    misys.common decorate such forms with the more complicated functionality
 *     required for product forms.
 *     
 *     Note that we assume throughout that misys._base has already been loaded (which is
 *     always the case, otherwise there's a problem)
 * @class common
 */

dojo.extend(dijit.Editor, {
	// summary:
	//	 Extend the dijit.Editor prototype to include a toXML method
	// <h4>Description:</h4> 
	//	 We need to escape the Editor content as it will form part of an XML string. Moreover, 
	//	 we wish to avoid logic in commonly used code below, that relied on testing 
	//   the value of declaredClass.
	/**
	 * <h4>Summary:</h4>
	 *  Extend the dijit.Editor prototype to include a toXML method
	 *  <h4>Description:</h4> 
	 *  We need to escape the Editor content as it will form part of an XML string.
	 *  @method toXML
	 * 
	 */
	toXML : function() {
		// Firefox4 inserts garbage into an empty editor, for some reason
		var value = this.get("value").replace("<br _moz_editor_bogus_node=\"TRUE\" />", "");
		value = dojo.trim(value);
		return value !== "" ? 
				"<![CDATA[" + dojo.trim(dojox.html.entities.encode(value,
						dojox.html.entities.html)) + "]]>" : "";
	}
});

dojo.extend(misys.form.SimpleTextarea, {
	// summary:
	//	 Extend the misys.form.SimpleTextarea prototype to include a toXML method
	// description:
	//	 We need to escape the misys.form.SimpleTextarea as it will form part of an XML string.  
	
	toXML : function() 
	{
		var value = this.get("value");
		value = dojo.trim(value);
		return value !== "" ? "<![CDATA[" + dojo.trim(value) + "]]>" : "";
		
	}
});

dojo.extend(dijit.form.MultiSelect, {
	// <h4>Summary:</h4>
	//	 Extend the dijit.form.MultiSelect _getValueAttr method so it returns all options
	// description:
	//	 By default, the a call to .get("value") on a MultiSelect will return only selected
	//	 options. In our use case, we want to return all options, selected or otherwise
	
	_getValueAttr: function(){
		return dojo.query("option", this.containerNode).map(function(n){
			return n.value;
		});
	}
});

function getErrorSection() {

	var counter = 0,counter1 = 0;
	var jsonArray = [];
	misys._config = misys._config || {};
		 dojo.query(".toplevel-header").forEach(function(parentTag){
	 		 var child;
	 		 var i;
	 		 var headerText;
	 		
				var childs = parentTag.childNodes;
				for (i = 0; i < childs.length; i++) { 
					child = childs[i];
						if(child.className === "toc-item")
						{
							headerText = child.firstChild.innerHTML;
						}
						else if(child.className === "fieldset-content")
						{
							var jsonWidgetArray = [];
							dojo.forEach(child.querySelectorAll('*'), function(div){
								console.debug(consoleMSG + div);
								var widget = dijit.byId(div.id);
								if(widget)
									{
										widget._hasBeenBlurred = true;
										var valid = widget.disabled || !widget.validate || widget.validate();
										if (!valid) { 
											console.debug(consoleMSG + widget); 
											var jsonWidgetObj = {"widget": widget };
											var widgetType = widget.declaredClass;
											
											jsonWidgetArray.push(jsonWidgetObj);
										}
									}
								});
						}
						if(headerText && jsonWidgetArray && jsonWidgetArray.length > 0)
						{
							var jsonObject = {"header": headerText, "widgetArray" : jsonWidgetArray , "child" : child};
							jsonArray.push(jsonObject);
						}
					}
		});
		/*dojo.mixin(misys._config, {				
			errorWidgetArray : jsonArray		       
		});*/
	if(jsonArray.length >0) {
		var div_elements = dojo.byId("errorContent");
		if(div_elements){
			div_elements.innerHTML = "";
			var tocRoot = dojo.create("ul");
			 dojo.forEach(jsonArray, function(errorMap) {
				errorMap.child.id = "mylink" + counter1++;
				var headerId = "mylink" + counter++;
				var li = dojo.create("li");
				var a = dojo.create("a", {
				href: "#" + headerId,
				id: "goto_" + headerId,
				innerHTML: errorMap.header
			}, li);
				dojo.place(li, tocRoot);
			    
			});
			dojo.empty(div_elements);
			dojo.style(dojo.byId("errorSection"),"display","block");
		dojo.place(tocRoot, div_elements);
		}
	}
	else
	{
	if(dojo.byId("errorSection"))
		{
		dojo.style(dojo.byId("errorSection"),"display","none");
		}
	}

}



dojo.extend(dijit.form.Form, {
	/**
	 * <h4>Summary:</h4>
	 * Returns if the form is valid - same as isValid - but
	 * provides a few additional (ui-specific) features.
	 * 1 - it will highlight any sub-widgets that are not
	 * valid
	 * 2 - it will call focus() on the first invalid
	 * sub-widget
	 * We override this standard function as it currently does not deal with
	 * fields that are in closed tabs. Moreover, we add a little smooth
	 * scrolling for browsers that can handle it.
	 * @method validate
	 */
	validate: function(){
		// summary:
		//		returns if the form is valid - same as isValid - but
		//		provides a few additional (ui-specific) features.
		//		1 - it will highlight any sub-widgets that are not
		//			valid
		//		2 - it will call focus() on the first invalid
		//			sub-widget

		// We override this standard function as it currently does not deal with
		// fields that are in closed tabs. Moreover, we add a little smooth
		// scrolling for browsers that can handle it.
		
		var didFocus = false;
	
		misys._config = misys._config || {};
		
		return dojo.every(dojo.map(this.getDescendants(), function(widget){
			// Need to set this so that "required" widgets get their
			// state set.
			widget._hasBeenBlurred = true;
			var valid = widget.disabled || !widget.validate || widget.validate();
			
			if (!valid) { 
				console.debug(consoleMSG + widget); 
			}
			
			if(!valid && !didFocus){
				// Set focus of the first non-valid widget
				
				// If the field is in a tabcontainer, select the correct tab
				if(widget.hasOwnProperty("parentTab")) {
					dijit.byId(widget.get("tabContainer")).selectChild(widget.get("parentTab"));
				}

				// Some validating elements are not focusable (GridMultipleItems, for example)
				// and so the .focus() method is not always available.
				var focusFnc = widget.focus || function(){};
				
				if(dojo.isIE <= 6 || misys._config.popupType) {
					dojo.window.scrollIntoView(widget.containerNode || widget.domNode);
					focusFnc();
				} else {
					dojox.fx.smoothScroll({
						node: widget.containerNode || widget.domNode, 
						win: window,
						onEnd: function() {
							focusFnc();
						}
					}).play();
				}

				didFocus = true;
			}
 			return valid;
 		}), function(item){ return item; });
	}
});

(function(/*Dojo*/ d, /*Dijit*/ dj, /*Misys*/ m) {

	 // ECMA5 Strict Mode
	
	// Private functions and variables
	
	var 
		// Selector for forms that we wish to be validated upon submission
		_formToValidateSelector = ".validate",
		
		// The ID of the form that is actually submitted to the server
		_realformID = "realform",
		
		// The ID of the container DIV that holds the hidden transaction
		// details on the bank side.
		_bankTransactionContainerID = "transactionDetails",
		
		// The ID of the file attachment widget
		_fileAttachmentsWidgetID = attachmntFile,
		
		_invoiceFileAttachmentsWidgetID = "attachment-fileinvoice",
		
		_purchaseorderFileAttachmentsWidgetID = "attachment-filepurchaseorder",
		
		_purchaseorderUploadFileAttachmentsWidgetID = "attachment-filepurchaseorderupload",
		
		// The ID of the file attachment table
		_fileAttachmentsTableID = "files_master_table",
		
		// The ID of the MT700 File attachment widget
		_mt700FileAttachmentsWidgetID = "attachment-fileOTHER",
	
		// A classname selector for fields that should be validated against the
		// SWIFT standard
		_SWIFTFieldSelector = ".swift",

		// The maximum number of textarea rows that is permitted under the
		// SWIFT standard
		_SWIFTMaxTextareaRows = 100,
		
		// The ID of a form in a popup dialog
		_popupFormId = "popup_fakeform1",
		
		// Selector for widgets which should listen to a topic
		_subscribeTopicSelector = ".subscribeTopic",
		
		// Attribute that holds as its value, the name of the topic
		_subscribeTopicAttr = "subscribe_topic",
		
		// Class to highlight the title of active tabs
		_nonEmptyTabClass = "tabChangeStyle",
		
		// Selector for tab containers
		_tabContainerSelector = tabContainr,
	
		// Selector for grids
		_gridClassSelector = ".dojoxGrid",

		// The id of the search form on list pages (it is always the same)
		_transactionSearchFormId = "TransactionSearchForm",
		
		// The id of the "export" button in list pages
		_exportListFieldId = "export_list",
		
		// The id of the "file" button in list pages
		_filenameFieldId = "filename",
		
		// The container DIV that holds the floating collaboration pane
		_collaborationWindowContainerId = "collaborationWindowContainer",

		// Classname selector for a page element that should be added to the Table of Contents (TOC)
		_tocItemSelector = ".toc-item",
		
		// The default timeout for tooltips
		_defaultTooltipTimeout = 5000, //ms
		
		// Selector for charts in the page
		_chartSelector = ".chartImg",
		
		// Default dimensions for a chart
		_defaultChartHeight = "400px",
		_defaultChartInDialogHeight = "600",
		_defaultChartInDialogWidth = "800",
		
		// utility vars for chart display
		_defaultResizeTimeout = 500,
		_resizeGridTimeoutHandle,
		_resizeChartTimeoutHandle,
		_chartDialog,
		_lastWidth;
	
/**
 * <h4>Summary:</h4>
 *  Submit the transaction.
 *  <h4>Description:</h4> 
 *  Note that this behaves slightly differently in debug mode - we generate the XML
 *  twice, the first time just for outputting to the console. So you can click submit
 *  to submit the transaction, dismiss the confirmation dialog and the XML will be in
 *  the console.
 *  
 *  Upon submit, the following validations are performed in the following order
 *  1. _validateForms (basic validation that all the fields have valid input)
 *  2. _validateSWIFTFields (If SWIFT validation was selected, we check that all
 *  fields with the class swift, have valid input)
 *  3. misys.doPreSubmitValidations (This method is overridden in the form binding,
 *  and performs form-specific validations, if there are any).
 *  As you can see we are passing type of event or submission in the method ,
 *  Depending upon the type different validation are happening.
 *  @param {String} type
 *   Type of the submission like "Save,Submit,System submit"
 *  @method _submit
 */
	function _submit( /*String*/ type) {
		//  summary:
	    //        Submit the transaction.
	    //  description:
		//        Note that this behaves slightly differently in debug mode - we generate the XML 
		//        twice, the first time just for outputting to the console. So you can click submit 
		//        to submit the transaction, dismiss the confirmation dialog and the XML will be in 
		//        the console.
		//
		//        Upon submit, the following validations are performed in the following order
		//        1. _validateForms (basic validation that all the fields have valid input)
	    //        2. _validateSWIFTFields (If SWIFT validation was selected, we check that all 
		//        fields with the class swift, have valid input)
	    //        3. misys.doPreSubmitValidations (This method is overridden in the form binding, 
		//           and performs form-specific validations, if there are any).
		var validations = [function(){return true;}],
		    operation = type,
		    progressMessage,
		    onErrorCallback,
		    errorMessage,
		    returnComments,
		    rejectComments,
		    freeFormatText,
		    freeFormatComments;

		switch(type){
		 case "VALIDATE":
			 validations.push(misys.validateSummitTransaction);
			 progressMessage = m.getLocalization("validatingTransactionMessage");
			break;
		 case "SAVE":
			 validations.push(_validateSWIFTFields,m.beforeSaveValidations);
			 if(m.client && m.client.beforeSaveValidations) {
				 validations.push(m.client.beforeSaveValidations);
			 }
			 errorMessage = m.getLocalization("mandatoryEntityMessage");
			 var productCode = dj.byId("product_code") ? dj.byId('product_code').get('value') : null;
			 // MPS-52317
			 // If the currency code is invalid, the form should be saved and the value should be cleared off
			 if(productCode !== null)
			 {
				 var productCurrencyCodeWidget = dj.byId(productCode.toLowerCase()+"_cur_code");
			 }	 
			 var productCurrencyCodeValue = productCurrencyCodeWidget ? productCurrencyCodeWidget.get("value") : "";
			 if(productCurrencyCodeWidget && productCurrencyCodeValue !== "" && productCurrencyCodeWidget.state === "Error")
			 {
				 productCurrencyCodeWidget.set("value", "");
			 }
			 
			 progressMessage = m.getLocalization("savingTransactionMessage");
			 onErrorCallback = function(){
				 dijit.byId("entity")?dijit.byId("entity").focus():null;
				// If the error was a SWIFT error
				 if(misys._config.swiftError && misys._config.swiftError.length !== 0) {
				         for(var i in misys._config.swiftError){
			                  var swiftErrorField = dijit.byId(m._config.swiftError[i]);
			                  swiftErrorField.set("state","Error");
			                  swiftErrorField._setStateClass();
			                  dj.setWaiState(swiftErrorField.focusNode, "invalid", "true");
			                }
			                  //Scroll to the first field which is in error.
		                 swiftErrorField = dijit.byId(m._config.swiftError[0]);
		                 // If the field is in a tabcontainer, select the correct tab 
		                  if(swiftErrorField.hasOwnProperty("parentTab")) {
		                  dj.byId(swiftErrorField.get("tabContainer")).selectChild(swiftErrorField.get("parentTab"));
		                  _validateTabs();
		                  }
		                  dojox.fx.smoothScroll({
	                         node: swiftErrorField.containerNode || swiftErrorField.domNode, 
	                         win: window
		                   }).play();
				  } 
			 };
			break;
		 case "ADD_BULK":
			 validations.push(_validateSWIFTFields, _validateForms, m.beforeSubmitValidations);
			 if(m.client && m.client.beforeSubmitValidations) {
				 validations.push(m.client.beforeSubmitValidations);
			 }
			 errorMessage = m.getLocalization("mandatoryFieldsToSubmitError");
			 progressMessage = m.getLocalization("validatingAndSubmittingMessage");
			 onErrorCallback = function(){
				 // Open hidden details, if present
				 if(d.byId(_bankTransactionContainerID)) {
					 m.toggleTransaction(true, false, function(){
						_validateForms(true);	
					 });
				 } else {
					 _validateForms(true);
				 }
				 
				// If the error was a SWIFT error
				 if(misys._config.swiftError && misys._config.swiftError.length !== 0) {
						for(var i in misys._config.swiftError){
							 var swiftErrorField = dijit.byId(m._config.swiftError[i]);
							 swiftErrorField.set("state","Error");
							 swiftErrorField._setStateClass();
							 dj.setWaiState(swiftErrorField.focusNode, "invalid", "true");
							 }
							 //Scroll to the first field which is in error.
							swiftErrorField = dijit.byId(m._config.swiftError[0]);
							 dojox.fx.smoothScroll({
									node: swiftErrorField.containerNode || swiftErrorField.domNode, 
									win: window
							  }).play();
						 } 
			 };
			 break; 
		 case "UPDATE_BULK":	 
			 validations.push(_validateSWIFTFields, _validateForms, m.beforeSubmitValidations);
			 // Hook for client specific beforeSubmit validations
			 if(m.client && m.client.beforeSubmitValidations) {
				 validations.push(m.client.beforeSubmitValidations);
			 }
			 errorMessage = m.getLocalization("mandatoryFieldsToSubmitError");
			 progressMessage = m.getLocalization("validatingAndSubmittingMessage");
			 onErrorCallback = function(){
				 // Open hidden details, if present
				 if(d.byId(_bankTransactionContainerID)) {
					 m.toggleTransaction(true, false, function(){
						_validateForms(true);	
					 });
				 } else {
					 _validateForms(true);
				 }
				 
				// If the error was a SWIFT error
				 if(misys._config.swiftError && misys._config.swiftError.length !== 0) {
						for(var i in misys._config.swiftError){
							 var swiftErrorField = dijit.byId(m._config.swiftError[i]);
							 swiftErrorField.set("state","Error");
							 swiftErrorField._setStateClass();
							 dj.setWaiState(swiftErrorField.focusNode, "invalid", "true");
							 }
							 //Scroll to the first field which is in error.
							swiftErrorField = dijit.byId(m._config.swiftError[0]);
							 dojox.fx.smoothScroll({
									node: swiftErrorField.containerNode || swiftErrorField.domNode, 
									win: window
							  }).play();
						 }  
			 };
			 break;
		 case "SYSTEM_SUBMIT":
			 operation = "SUBMIT";
			 validations.push(_validateForms, m.beforeSubmitValidations);
			 // Hook for client specific beforeSubmit validations
			 if(m.client && m.client.beforeSubmitValidations) {
				 validations.push(m.client.beforeSubmitValidations);
			 }
			 errorMessage = m.getLocalization("mandatoryFieldsToSubmitError");
			 progressMessage = m.getLocalization("validatingAndSubmittingMessage");
			 onErrorCallback = function(){
				 setTimeout(function(){_validateForms(true);}, dj.defaultDuration);
			 };
			break;
		 case "SUBMIT":
			 validations.push(_validateSWIFTFields, _validateForms, _validateFileAct, m.beforeSubmitValidations);
			 // Hook for client specific beforeSubmit validations
			 if(m.client && m.client.beforeSubmitValidations) {
				 validations.push(m.client.beforeSubmitValidations);
			 }
			 errorMessage = m.getLocalization("mandatoryFieldsToSubmitError");
			 progressMessage = m.getLocalization("validatingAndSubmittingMessage");
			 if(dj.byId("return_comments"))
			{	
				 dj.byId("return_comments").set("required",false);	
			}
			 getErrorSection();
			 onErrorCallback = function(){
				 
				 //form to be validated in every case
				 _validateForms(true);
	 
				// If the error was a SWIFT error
				 if(misys._config.swiftError && misys._config.swiftError.length !== 0) {
						for(var i in misys._config.swiftError){
							 var swiftErrorField = dijit.byId(m._config.swiftError[i]);
							 swiftErrorField.set("state","Error");
							 swiftErrorField._setStateClass();
							 dj.setWaiState(swiftErrorField.focusNode, "invalid", "true");
							 }
							 //Scroll to the first field which is in error.
							swiftErrorField = dijit.byId(m._config.swiftError[0]);
							 // If the field is in a tabcontainer, select the correct tab 
			                  if(swiftErrorField.hasOwnProperty("parentTab")) {
			                  dj.byId(swiftErrorField.get("tabContainer")).selectChild(swiftErrorField.get("parentTab"));
			                  _validateTabs();
			                  }			                  
			               // Open hidden details, if present, sending scroll function for swift validation as callback
			               //to avoid mix up of synchronous and asynchronous calls
			                  if(d.byId(_bankTransactionContainerID)){
			 					 m.toggleTransaction(true, false, function(){
			 						dojox.fx.smoothScroll({
										node: swiftErrorField.containerNode || swiftErrorField.domNode, 
										win: window
								  }).play();
			 					 }); 
			                  }
		 					 else {
		 						dojox.fx.smoothScroll({
									node: swiftErrorField.containerNode || swiftErrorField.domNode, 
									win: window
							  }).play();
		 					 }
						 } 
			 };
			break;
		 case "SAVE_TEMPLATE":
			 var templateId = dj.byId("template_id"),
			 templateIdVal = templateId.get("value");
			 if(templateIdVal.indexOf("<")!==-1) {
				 templateIdVal = templateIdVal.replaceAll("<", "&lt;");
			 }
			if (misys._config.isMultiBank)
			{
				var bkTypeField = dj.byId("bk_type");
				var bkTypeHiddenField = dj.byId("bk_type_hidden");
				var payrollTypeField = dj.byId("payroll_type");
				var payrollHiddenField = dj.byId("payroll_type_hidden");
				if (bkTypeField && bkTypeField.get("value") === "" && bkTypeHiddenField && bkTypeHiddenField.get("value") !== "")
				{
					bkTypeField.set("value", bkTypeHiddenField.get("value"));
				}
				if (payrollTypeField && payrollTypeField.get("value") === "" && payrollHiddenField && payrollHiddenField.get("value") !== "")
				{
					payrollTypeField.set("value", payrollHiddenField.get("value"));
				}
			}
			 progressMessage = m.getLocalization("savingTemplateMessage", 
					 				[templateIdVal]);
			 errorMessage = m.getLocalization("mandatoryTemplateFieldError");
			 validations.push(
				 function(){
					if(templateId.get("value") === "")  {
						errorMessage = m.getLocalization("mandatoryTemplateFieldError");
						return false;
					}
					/*else {
						var invalidCharacters = "\\'`",
						isValid = d.every(templateId.get("value"), function(theChar) {
							return (invalidCharacters.indexOf(theChar) < 0) ? true : false;
						});
						if(!isValid ) {
							errorMessage = m.getLocalization("focusOnErrorAlert");
							return false;
						}
					}*/
					return true;
				 }
			 );
			 onErrorCallback = function(){
				 templateId.focus();
			 };
			break;
		 case "SAVE_REPORT_TEMPLATE":
			 operation = "SAVE_TEMPLATE";
		     validations.push(_validateForms);
		     errorMessage = m.getLocalization("mandatoryFieldsToSubmitError");
			 progressMessage = m.getLocalization("validatingAndSubmittingMessage");
		     onErrorCallback = function(){
				setTimeout(function(){_validateForms(true);}, dj.defaultDuration);
			 };
			 break;
		 case "CANCEL":
			document.location.href = m.onCancelNavigation();
			return;
			break;
		case "CANCEL_BULK_TRANSACTION":					
			var bulkReferenceId = dj.byId("ref_id").get("value");
			var bulkCancelURL = ["/screen/BulkScreen?referenceid=", bulkReferenceId, "&mode=CANCEL"];
			window.location.href = misys.getServletURL(bulkCancelURL.join(""));
			return;
			break;				
		 case "CANCEL_BULK":
			var bulkRefId = dj.byId("bulk_ref_id").get("value");
			var bulkTnxId = dj.byId("bulk_tnx_id").get("value");
			var childRefId = dj.byId("ref_id").get("value");
			var childTnxId = dj.byId("tnx_id").get("value");
			var bulkDraftURL = ["/screen/BulkScreen?referenceid=", bulkRefId, "&tnxid=", bulkTnxId, "&childrefid=", childRefId, "&childtnxid=", childTnxId, "&tnxtype=01&mode=DRAFT"];
			window.location.href = misys.getServletURL(bulkDraftURL.join(""));
			return;
			break;
		 case "RETURN":
			 returnComments = dj.byId("return_comments");
			 if(returnComments && dojo.string.trim(returnComments.get("value")) === ""){
				 returnComments.set("value", "");
				 returnComments.set("required",true);
				 if(dj.byId("fakeform1"))
				 {
					 dj.byId("fakeform1").validate();
				 }
				 errorMessage = m.getLocalization("requiredToolTip");
				 returnComments.focus();
				 return;
			 }
			 else if(returnComments && dojo.string.trim(returnComments.get("value")) !== "" ){
				 returnComments.set("value", dojo.string.trim(returnComments.get("value")));
			 }
			 break;
		 case "REJECT":
			 operation = "REJECT";
			 if(dj.byId("reject_comments"))
				{	
				 rejectComments = dj.byId("reject_comments");
					 if(rejectComments && dojo.string.trim(rejectComments.get("value")) === ""){
						 rejectComments.set("required",true);
						 errorMessage = m.getLocalization("requiredToolTip");
						 rejectComments.focus();
						 return;
					 }
				}
			 if(dj.byId("free_format_text"))
			 {
				 	freeFormatText = dj.byId("free_format_text");
				 	if(freeFormatText && dojo.string.trim(freeFormatText.get("value")) === "")
				 	{
				 		 freeFormatText.set("required",true);
						 errorMessage = m.getLocalization("requiredToolTip");
						 freeFormatText.focus();
						 return;
					}
				 	
			 }
			
			 progressMessage = m.getLocalization("rejectingTransactionMessage");
			break;
		 case "RETURN_TRANSACTION":
			 operation = "RETURN_TRANSACTION";
			 progressMessage = m.getLocalization("returningTransactionMessage");
			 returnComments = dj.byId("return_comments");
			 if(returnComments){
				 if(returnComments && returnComments.get("value") === ""){				 
					 returnComments.set("required",true);
					 dj.byId("fakeform1").validate();
					 errorMessage = m.getLocalization("requiredToolTip");
					 returnComments.focus();
					 return;
				 }
				 else
					{
						 var checkReturn = dojo.string.trim(dj.byId("return_comments").get("value"));
						 if(checkReturn === "")
						 {
							 dj.byId("return_comments").set("value", checkReturn);
							 returnComments.set("required",true);
							 dj.byId("fakeform1").validate();
							 errorMessage = m.getLocalization("requiredToolTip");
							 returnComments.focus();
							 return;
						 }
					}	 
			 }
			break;
			
		 case "AUTO_FORWARD_SUBMIT":
			 operation = "AUTO_FORWARD_SUBMIT";
			 if(m.client && m.client.beforeSubmitValidations) {
				 validations.push(m.client.beforeSubmitValidations);
			 }
			 progressMessage = m.getLocalization("submitAutoForwardMsg");
			break;
		 case "LEGAL_TEXT_SUBMIT" :
			 operation = "SUBMIT";
			 if(m.client && m.client.beforeSubmitValidations) {
				 validations.push(m.client.beforeSubmitValidations);
			 }
			 progressMessage = m.getLocalization("validatingAndSubmittingMessage");
			break; 
		 case "DRAFT":
			 operation = "DRAFT";
			 validations.push(m.beforeSaveValidations);
			 if(m.client && m.client.beforeSaveValidations) {
				 validations.push(m.client.beforeSaveValidations);
			 }
			break;
		 case "MAKER_SUBMIT":
			 operation = "SUBMIT";
			 validations.push(_validateSWIFTFields, _validateForms, m.beforeSubmitValidations);
			 if(m.client && m.client.beforeSubmitValidations) {
				 validations.push(m.client.beforeSubmitValidations);
			 }
			 errorMessage = m.getLocalization("mandatoryFieldsToSubmitError");
			 progressMessage = m.getLocalization("validatingAndSubmittingMessage");
			 onErrorCallback = function(){
				 _validateForms(true);
	 	 	 	 if(misys._config.swiftError && misys._config.swiftError.length !== 0) {
	 	 	 for(var i in misys._config.swiftError){
	 	 	 var swiftErrorField = dijit.byId(m._config.swiftError[i]);
	 	 	 swiftErrorField.set("state","Error");
	 	 	swiftErrorField._setStateClass();
	 	 	dj.setWaiState(swiftErrorField.focusNode, "invalid", "true");
	 	 	}
	 	 	 //Scroll to the first field which is in error.
	 	 	swiftErrorField = dijit.byId(m._config.swiftError[0]);
	 	 	 dojox.fx.smoothScroll({
	 	 	node: swiftErrorField.containerNode || swiftErrorField.domNode, 
	 	 	win: window
	 	 	}).play();
	 	 	} 
	 };
			break;
		 case "RESUBMIT":
			 operation = "SUBMIT";
			 progressMessage = m.getLocalization("resubmitMessage");
			break;
		 case "MAKER_BENE_FILE_UPLOAD_SUBMIT":
			 operation = "SUBMIT";
			 validations.push(_validateSWIFTFields, _validateForms, m.beforeSubmitValidations);
			 if(m.client && m.client.beforeSubmitValidations) 
			 {
				 validations.push(m.client.beforeSubmitValidations);
			 }
			 errorMessage = m.getLocalization("mandatoryFieldsToSubmitError");
			 progressMessage = m.getLocalization("validatingAndSubmittingMessage");
			 onErrorCallback = function(){
				 _validateForms(true);
	 	 	 	 if(misys._config.swiftError && misys._config.swiftError.length !== 0) 
	 	 	 	 {
	 	 	 		 for(var i in misys._config.swiftError)
	 	 	 		 {
	 	 	 			 var swiftErrorField = dijit.byId(m._config.swiftError[i]);
	 	 	 			 swiftErrorField.set("state","Error");
	 	 	 			 swiftErrorField._setStateClass();
	 	 	 			 dj.setWaiState(swiftErrorField.focusNode, "invalid", "true");
	 	 	 		 }
		 	 	 //Scroll to the first field which is in error.
	 	 	 		 swiftErrorField = dijit.byId(m._config.swiftError[0]);
	 	 	 		 dojox.fx.smoothScroll({
	 	 	 			 node: swiftErrorField.containerNode || swiftErrorField.domNode, 
	 	 	 			 win: window
	 	 	 		 	}).play();
		 	 	} 
			};
			break;
		 case "MAKER_BENE_SUBMIT":
			 operation = "SUBMIT";
			 validations.push(_validateSWIFTFields, _validateForms, m.beforeSubmitValidations);
			 if(m.client && m.client.beforeSubmitValidations) 
			 {
				 validations.push(m.client.beforeSubmitValidations);
			 }
			 errorMessage = m.getLocalization("mandatoryFieldsToSubmitError");
			 progressMessage = m.getLocalization("validatingAndSubmittingMessage");
			 onErrorCallback = function(){
				 _validateForms(true);
	 	 	 	 if(misys._config.swiftError && misys._config.swiftError.length !== 0) 
	 	 	 	 {
	 	 	 		 for(var i in misys._config.swiftError)
	 	 	 		 {
	 	 	 			 var swiftErrorField = dijit.byId(m._config.swiftError[i]);
	 	 	 			 swiftErrorField.set("state","Error");
	 	 	 			 swiftErrorField._setStateClass();
	 	 	 			 dj.setWaiState(swiftErrorField.focusNode, "invalid", "true");
	 	 	 		 }
		 	 	 //Scroll to the first field which is in error.
	 	 	 		 swiftErrorField = dijit.byId(m._config.swiftError[0]);
	 	 	 		 dojox.fx.smoothScroll({
	 	 	 			 node: swiftErrorField.containerNode || swiftErrorField.domNode, 
	 	 	 			 win: window
	 	 	 		 	}).play();
		 	 	} 
			};
			break;
		default:
			break;
		}
		
		// Perform any validations and submit the form
		if(progressMessage && progressMessage !== ""){
			m.dialog.show("PROGRESS", progressMessage);
		}
		
		// If the transaction is rejected, then we don't need to trigger form validation
		// on submit (individual fields are still protected by inline validation)
		// Verify if this is what we want before uncommenting
		//No Validation required for Payment Request Screen because all are read only screen.The validation was happening in case of adding otherChargesType in TransportDataset

		if((d.every(validations, function(f){return f();})) || (dj.byId("tnxtype") && dj.byId("tnxtype").get("value")==="55")) {
			var realformOperation = dj.byId("realform_operation");
			if(realformOperation && realformOperation.get("value") === "") {
				realformOperation.set("value", operation);
			}
			else if(operation !== "" && (operation === "CHECKER_BENE_SUBMIT" || operation === "CHECKER_BENE_FILE_UPLOAD_SUBMIT"))
			{
				realformOperation.set("value", "APPROVE_FEATURES");
			}
			_synchronizeAttachments();
			
			if(type === "SAVE_TEMPLATE" && !_isUniqueTemplateId(dijit.byId("template_id"))) {
				m.dialog.show("CONFIRMATION", m.getLocalization("nonUniqueTemplateIDError"), "", 
					function() {
						if(m.isFormDirty && m.isFormDirty === true )
						{
							m.isFormDirty = false;
						}
						dj.byId("TransactionData").set("value", m.formToXML());
						dj.byId("realform").submit();
					}
				);
				return;
			}

			var trans = dj.byId("transaction_confirmation_details"); 
			if(trans && trans.get('value') === "Y" && (type === "SUBMIT" || type === "AUTO_FORWARD_SUBMIT")){
			     m.checkAndShowTnxConfirmationDetailsDialog();
				 
			} else if (type === "SUBMIT" || type === "MAKER_SUBMIT" || type === "LEGAL_TEXT_SUBMIT" || type === "AUTO_FORWARD_SUBMIT" || type === "APPROVE" || type === "REJECT" || type === "RETURN_TRANSACTION" || type === "REVERT" || type === "RETURN" || type === "DELETE"||type==="SYSTEM_SUBMIT" || type === "RESUBMIT" || type === "CHECKER_BENE_FILE_UPLOAD_SUBMIT" || type === "CHECKER_BENE_SUBMIT" || type === "MAKER_BENE_FILE_UPLOAD_SUBMIT" || type === "MAKER_BENE_SUBMIT"){
				m.performReauthentication();
			} else {
				if(m.isFormDirty && m.isFormDirty === true )
				{
					m.isFormDirty = false;
				}
				dj.byId("TransactionData").set("value", m.formToXML());
				dj.byId(_realformID).submit();
			}
		} else {
			var holidayCutOffEnabled = m._config.holidayCutOffEnabled;
			var legalTextEnabled = m._config.legalTextEnabled;
			if(holidayCutOffEnabled && holidayCutOffEnabled === true)
			{
				m._config.holidayCutOffEnabled = false;
				//Do Nothing here (Custom Dialog is shown in validation/common.js) 
			}
			else if(legalTextEnabled && legalTextEnabled == true){
				m._config.legalTextEnabled = false;
			}
			else
			{
				var globalOnSubmitError = m._config.onSubmitErrorMsg;
				errorMessage = (globalOnSubmitError && globalOnSubmitError !== "") ? 
						globalOnSubmitError : errorMessage;
				
				m._config.onSubmitErrorMsg = "";
				if(errorMessage && errorMessage !== "") {
					m.dialog.show("ERROR", errorMessage, "", onErrorCallback);
				}
			}
		}
	
	}
	/**
	 * <h4>Summary:</h4>
	 *  Asynchronous Click : Submit the transaction.
	 *  <h4>Description:</h4> 
	 *  This is Asynchronous call, called because of asynchronous navigation
	 *  @param {String} type
	 *   Type of the operation like "Submit,Save etc."
	 *  @method _submitAsync
	 * 
	 */
	function _submitAsync( /*String*/ type) {
		//  summary:
	    //        Asynchronous Click : Submit the transaction.
	    //  description:
		//        This is Asynchronous call, called because of asynchronous navigation
		//
		
		var validations = [function(){return true;}],
		    operation = type,
		    onErrorCallback,
		    errorMessage;

		validations.push(m.beforeSaveValidations);
		errorMessage = m.getLocalization("mandatoryEntityMessage");
		onErrorCallback = function(){dijit.byId("entity")?dijit.byId("entity").focus():null;};
		
		// Perform any validations and submit the form

		if(d.every(validations, function(f){return f();})) {
			var realformOperation = dj.byId("realform_operation");
			if(realformOperation.get("value") === "") {
				realformOperation.set("value", operation);
			}
			_synchronizeAttachments();
			
			errorMessage = "";
			
			dj.byId("TransactionData").set("value", m.formToXML());
		} else {
			var holidayCutOffEnabled = m._config.holidayCutOffEnabled;
			if(holidayCutOffEnabled && holidayCutOffEnabled === true)
			{
				m._config.holidayCutOffEnabled = false;
				//Do Nothing here (Custom Dialog is shown in validation/common.js) 
			}
			else
			{
				var globalOnSubmitError = m._config.onSubmitErrorMsg;
				errorMessage = (globalOnSubmitError && globalOnSubmitError !== "") ? 
						globalOnSubmitError : errorMessage;
				
				m._config.onSubmitErrorMsg = "";
				if(errorMessage && errorMessage !== "") {
					m.dialog.show("ERROR", errorMessage, "", onErrorCallback);
				}
			}
		}
		return errorMessage;
	}
	/**
	 * <h4>Summary:</h4>
	 * Submits a form in a popup
	 * @param {String} formId
	 *  Id of the form
	 * @param {Function} callback
	 *  Call back function
	 * @method _submitDialog
	 * 
	 */
	function _submitDialog( /*String*/ formId,
							/*Function*/ callback) {
		//  summary:
	    //           Submits a form in a popup
		
		m.dialog.show("PROGRESS", m.getLocalization("validatingAndSubmittingMessage"), 
						"", null, function(){
			setTimeout(function(){
				m.xhrPost({
				  form: formId,
				  load: function(data, ioArgs){
				  	     //Need to handle the response to show if transaction failed
					  	 var response = data.substring(data.indexOf("<div id='GTPRootPortlet' class='portlet'>"));
					  	 response = response.substring(response.indexOf("<div class='portlet-font portlet-section-body'><p>"));
					  	 response = response.substring(response.indexOf("<p>"),response.indexOf("</div>"));
					  	 dj.byId("alertDialog").hide();
						 m.dialog.clear(d.byId(m._config.popupType + "data"),
								 		dj.byId("contentPane"),
								 		callback,response);
				  },
				  // the AJAX submit breaks with the default contentType, I'm not sure why
				  contentType: ""
				 });
			}, 1000);
		});
	}
	/**
	 *  <h4>Summary:</h4>
	 *   Validates all forms with class "validate" in the page.
	 * 	<h4>Description:</h4> 
	 *  If doRealValidation is false, we call isValid, which returns the status of the
	 *  form without triggering the error state of all fields. If doRealValidation is
	 *  true, we perform the full validation. This is triggered when the "error" dialog
	 *  is dismissed.
	 *  
	 *   Note: We usually don't pass a value to the forms param; the function then
	 *   takes all forms with class 'form'.
	 *   @param {Boolean} doRealValidation
	 *   @method _validateForms
	 * 
	 */
	function _validateForms( /*Boolean*/ doRealValidation,
							 /*Array*/ forms) {
		//  summary:
	    //        Validates all forms with class "validate" in the page.
		//
		//  description:
		//        If doRealValidation is false, we call isValid, which returns the status of the 
		//        form without triggering the error state of all fields. If doRealValidation is 
		//        true, we perform the full validation. This is triggered when the "error" dialog 
		//        is dismissed.
		//
		//	      Note: We usually don't pass a value to the forms param; the function then
		//		  takes all forms with class 'form'.
		
		console.debug("[misys.common] Validating forms in the page ...");
		
		var 
			// Forms to validate. Reverse sort it so "fakeform0" is validated first
			formsToValidate = (forms || d.query(_formToValidateSelector)).reverse(),
			draftTerm = dj.byId("draft_term"),
		    result = true;
		
		if(draftTerm) {
			// This is a workaround, occasionally the draft_term field validate function is
			// not called, so we call it manually once, here
			draftTerm.validate();
		}
		
		d.forEach(formsToValidate, function(form) {
				console.debug("[misys.common] Validating form", form.id);
				var formObj = dj.byId(form.id);
				
				// TODO Workaround, GridMultipleItems are not hooking into the validation for
				// some reason. Despite their state being Error, the overall form state is 
				// empty. Calling _getState() explicitly seems to fix it.
				if(formObj._getState() !== ""|| formObj.state !== "") {
					if(doRealValidation) {
						formObj.validate();
					}
					result = false;
				}
			}
		);

		if(!result && doRealValidation) {
			_validateTabs();
		}
		
		console.debug("[misys.common] Validation result", result);
		
		return result;
	}
	/**
	 * This function is specially written for validating File Act scenarios
	 * If delivery channel is Fact and attachment is there at least one 
	 * attachment should be selected to go with the transaction.
	 * @method _validateFileAct
	 * @return {Boolean}
	 *  Returns true if at least one attachment is selected otherwise show an error message
	 */
	function _validateFileAct(){
		var fileAttachments = dj.byId(_fileAttachmentsWidgetID);
		var deliveryChannel = dj.byId("delivery_channel");
		var selected = false;
		
		if(deliveryChannel && (deliveryChannel.get('value') == 'FACT') && fileAttachments && fileAttachments.grid.selection && fileAttachments.fileActVisible){
			d.forEach(fileAttachments.grid.selection.getSelected(), function(node, index){
				if(node && node != null) {
					selected = true;
				}
			});
		}
		else
		{
			selected = true;
		}
		
		if(!selected)
		{
			m._config.onSubmitErrorMsg = m.getLocalization("selectAtleastOneFileForFileAct");
		}
		
		return selected;
	}
	/**
	 * <h4>Summary:</h4>
	 * Validates all fields with the swift class against the SWIFT standard.
	 * It shows an error message in case validation fails.
	 * @method _validateSWIFTFields
	 * @return {boolean}
	 *  True if field is valid otherwise false
	 * 
	 */
	function _validateSWIFTFields() {
		//  summary:
	    //        Validates all fields with the swift class against the SWIFT standard, 
		//        if we have to
		
		// TODO This needs to be refactored
		
		var advSendMode = dj.byId("adv_send_mode");
		var swiftCharError,swiftFieldError,swiftInvalidFirstCharError=false,swiftFieldErrorForTrade=false,swiftAdderessFieldError=false;
		var extendedErrorFields =false;
		var errorFields = false;
		//userType variable contains the company type value:
		//Values 03 or 06 represent a customer user,any other user represents a bank.
		var userType;
		if (document.getElementById("_userType"))
		{
			userType = document.getElementById("_userType").getAttribute('value');
		}
		misys._config = misys._config || {};
		misys._config.swiftRelatedSections = misys._config.swiftRelatedSections || [];
		dojo.mixin(misys._config, {				
		        swiftError : new Array()		       
       		});
		var isBank = false;
		var isClient = true;
		if(m._config.isBank)
			{
			 if(m._config.isBank === true)
				{
					isBank = true;
					isClient = false;
				}
			 }
		if((advSendMode && advSendMode.get("value") === "01") || m._config.forceSWIFTValidation)
		{
		  if(isClient || ((isBank && misys._config.productCode != 'SR') && (isBank && misys._config.productCode != 'EL')))
		  {
			var invalidFields = [];
			misys._config.swiftRelatedSections.forEach(function(swiftRelatedSection) {
				var nameField = dj.byId(swiftRelatedSection.concat("_name"));
				var addressField = dj.byId(swiftRelatedSection.concat("_address_line_4"));
				if(nameField) {
					if(!_isValidSWIFTFieldSizeErrorForTrade(nameField)){
						//m.showTooltip(m.getLocalization("invalidSWIFTFieldSizeErrorForTrade"), swiftRelatedSection.concat("_name"));
						invalidFields.push(nameField);
						swiftFieldErrorForTrade=true;
						}
					}
				if(addressField && addressField.get("value")!=="") {
					if(isClient || ((isBank && misys._config.productCode != 'SR') && (isBank && misys._config.productCode != 'EL')))
				    {
					//m.showTooltip(m.getLocalization("invalidSWIFTAddressFieldErrorForTrade"), swiftRelatedSection.concat("_address_line_4"));
					invalidFields.push(addressField);
					swiftAdderessFieldError=true;
					}
				}
			  }
			);

			d.query(_SWIFTFieldSelector).forEach(function(node){
				var field = dj.byId(node.getAttribute("widgetid"));
				var ProductCodeValue =  misys._config.productCode;
				var is798 = dj.byId("is798") ? dj.byId("is798").get("value") : "";
				m._config.is798 = is798;
				if((field && field.id != 'cust_ref_id') || (field && field.id == 'cust_ref_id' && misys._config.is798 == 'Y')) {
					field.onBlur(field);
					if(!_isValidSWIFTTextarea(field) && !(ProductCodeValue != 'LC' || ProductCodeValue != 'SI' || ProductCodeValue != 'EL' || ProductCodeValue != 'SR')) {
						m.showTooltip(m.getLocalization("invalidSWIFTFieldSizeError"), node);
						invalidFields.push(field);
						m.connect(field, "onBlur", function(){
							m.setFieldState(this, _isValidSWIFTTextarea(this));
						});
						swiftFieldError=true;
					} else if(!_hasValidSWIFTChars(field) && field.id != 'template_id'){
						invalidFields.push(field);
						m.connect(field, "onBlur", function(){
							m.setFieldState(this, _hasValidSWIFTChars(this));
						});
						swiftCharError=true;
					} else if(m._config.swift2018Enabled && _isExtendedSwiftCharAllowed(node) && !_hasInvalidSWIFTFirstChars(field)){
						invalidFields.push(field);
						m.connect(field, "onBlur", function(){
							m.setFieldState(this, _hasInvalidSWIFTFirstChars(this));
						});
						swiftInvalidFirstCharError=true;
					} else if (!(field.get('required') && (field.get("value") === "" || isNaN(field.get("value")) ))) {
						m.setFieldState(field, true);
					}
				}
			});
			if(invalidFields.length > 0) {
				d.forEach(invalidFields, function(field, index){
					console.debug("[misys.common] The field", field.id, "is in error");
					m.setFieldState(field, false);
					if(m._config.swift2018Enabled && _isExtendedSwiftCharAllowed(field)){
						extendedErrorFields =true;
					}
					else{
						errorFields =true;
					}
					field.invalidMessage = m.getLocalization("invalidSWIFTTransactionError");
					misys._config.swiftError[index] = field.get("id");
				});
			
			  if(swiftFieldError)	
			  {
				  _validateTabs();
		          m._config.onSubmitErrorMsg = m.getLocalization("invalidSWIFTFieldSizeError");
		          return false;
			  }
			  else if(swiftFieldErrorForTrade)	
			  {
				  _validateTabs();
		          m._config.onSubmitErrorMsg = m.getLocalization("invalidSWIFTFieldSizeErrorForTrade");
		          return false;
			  }
			  else if (swiftCharError)
			  {
			    _validateTabs();
			    var errorMsg=m.getLocalization("invalidSWIFTTransactionErrorMsg");
			    if( errorFields && !extendedErrorFields && userType){
			    	errorMsg=errorMsg +m.getLocalization("invalidSWIFTTransactionValidValues");
			    }
			    if( !errorFields && extendedErrorFields && userType){
			    	errorMsg=errorMsg+ m.getLocalization("invalidSWIFTTransactionValidValuesExt");
			    }
			    if( errorFields && extendedErrorFields && userType){
			    	if(userType == '03' || userType == '06'){
			    		errorMsg=errorMsg+ m.getLocalization("invalidSWIFTTransactionValidValuesWithExt");
			    	}else{
			    		errorMsg=errorMsg+ m.getLocalization("invalidSWIFTTransactionValidValuesWithExtBank");
			    	}		    	
			    }
			    m._config.onSubmitErrorMsg =errorMsg;
				return false;
			  }
			  else if(swiftAdderessFieldError)	
			  {
				  _validateTabs();
		          m._config.onSubmitErrorMsg = m.getLocalization("invalidSWIFTAddressFieldErrorForTrade");
		          return false;
			  }
			  else if(swiftInvalidFirstCharError)
			  {
				  _validateTabs();
				  m._config.onSubmitErrorMsg = m.getLocalization("invalidSWIFTFirstCharErrorMsg");
		          return false;
			  }
		   }
	    }
	  }
		return true;
	}
	
	/**
	 * <h4>Summary:</h4>
	 * Checks if a field size is valid with respect to the SWIFT standard
	 * <h4>Description:</h4> 
	 * Return false if the number of lines of existing text exceeds 35 characters.
	 */
	function _isValidSWIFTFieldSizeErrorForTrade( /*dijit._Widget || DomNode*/ node) {
		
		var field = dj.byId(node);
		
		if(field.get("value").length > 35){
			return false;
		}

		return true;
	}
	
	/**
	 * <h4>Summary:</h4>
	 * Checks if a textarea is valid with respect to the SWIFT standard
	 * <h4>Description:</h4> 
	 * Return false if the number of lines of existing text in a textarea object
	 *  exceeds 100.
	 * @param {dijit._widget || DomNode} node
	 *  Node to be validated against swift standard
	 * @method _isValidSWIFTTextarea
	 * @return {boolean}
	 *   True if valid otherwise false
	 */
	function _isValidSWIFTTextarea( /*dijit._Widget || DomNode*/ node) {
		//  summary:
		//        Checks if a textarea is valid with respect to the SWIFT standard
		//
		//  description:
	    //        Return false if the number of lines of existing text in a textarea object 
		//        exceeds 100.
		
		var textarea = dj.byId(node);
		
		if(/SimpleTextarea/.test(textarea.declaredClass)){
			var rowCount = 1,
			    value = textarea.get("value");
			
			return d.every(value, function(c){
				if(c === "\n") {
					return (++rowCount <= _SWIFTMaxTextareaRows);
				}
				return true;
			});
		}

		return true;
	}
	
	
	/**
	 * <h4>Summary:</h4>
	 * check if field is allowed extra characters by swift standards .
	 * @param {dijit._widget || DomNode} node
	 *  Node to be checked 
	 * @method _isExtendedSwiftCharAllowed
	 * @return {Boolean}
	 *  Returns true if field is allowed extra character
	 */
	function _isExtendedSwiftCharAllowed( /*dijit._Widget || DomNode*/ node) {
		//  summary:
	    //        Validates the characters of a field against the SWIFT standard.
		
		if(!m._config.swift2018Enabled){
			return false;
		}
		
		var widget = dj.byId("product_code");		
		var productCode="";
		if(widget)
		{
			productCode=widget.get("value");
		}

		var allowedLCFields=['narrative_documents_required','narrative_description_goods',
			'narrative_additional_instructions','narrative_full_details',
			'narrative_charges','narrative_special_beneficiary','narrative_special_recvbank',
			'narrative_sender_to_receiver','narrative_amend_charges_other','free_format_text','narrative_transfer_conditions','line_item_product_name'];	
		
		if((productCode === "LC" && new RegExp(allowedLCFields.join('|')).test(node.id)) ||
				(productCode === "EL" && new RegExp(allowedLCFields.join('|')).test(node.id)) ||
				(productCode === "SI" && new RegExp(allowedLCFields.join('|')).test(node.id)) ||
				(productCode === "SR" && new RegExp(allowedLCFields.join('|')).test(node.id)))
		{
			return true;
		}
		else
		{
			return false;
		}			
	}
	
	
	/**
	 * <h4>Summary:</h4>
	 * Validates the characters of a field against the SWIFT standard.
	 * @param {dijit._widget || DomNode} node
	 *  Node to be validated against swift standard
	 * @method _hasValidSWIFTChars
	 * @return {Boolean}
	 *  Returns true if field is valid otherwise false
	 */
	function _hasValidSWIFTChars( /*dijit._Widget || DomNode*/ node) {
		//  summary:
	    //        Validates the characters of a field against the SWIFT standard.
		
		var widget = dj.byId(node),
			value = widget.get("value");
		
		if(widget.datePackage && widget.datePackage === "dojo.date")
		 {
		   value=widget.get("displayedValue");
	     }
		
		if(value === null || value === ""){
			return true;
		}
		var isValid=true;
		try
		{
		var regexStr = dj.byId("swiftregexValue") ? dj.byId("swiftregexValue").get("value") : "";
		if(m._config.swift2018Enabled && _isExtendedSwiftCharAllowed(node)){
			regexStr = dj.byId("swiftregexzcharValue") ? dj.byId("swiftregexzcharValue").get("value") : "";
		}
		var swiftchar = value;
		var swiftregexp = new RegExp(regexStr);
			
		isValid=swiftregexp.test(swiftchar);
		}
		catch(err)
		{
			return isValid;
		}
		
		return isValid;
	}
	
	/**
	 * <h4>Summary:</h4>
	 * Validates first character of all new lines except first line.
	 * As per SWIFT standards - and : is not allowed as first char of lines except for the first line.
	 * @param {dijit._widget || DomNode} node
	 *  Node to be validated against swift standard
	 * @method _hasInvalidSWIFTFirstChars
	 * @return {Boolean}
	 *  Returns true if field is valid otherwise false
	 */
	function _hasInvalidSWIFTFirstChars( /*dijit._Widget || DomNode*/ node) {
		//  summary:
	    //        Validates first character of all new lines except first line against the SWIFT standard.
		
		var widget = dj.byId(node),
			value = widget.get("value");
		
		if(value === null || value === "")
		{
			return true;
		}
		if(value.indexOf("\n:") != -1|| value.indexOf("\n-") != -1)
		{
			return false;
		}		
		return true;
	}
	
	/**
	 *  <h4>Summary:</h4>
	 *   Normalizes the value of form fields to match the expected XML format.
	 *   <h4>Description:</h4> 
	 *   Rules specific to certain widgets should be kept to an absolute minimum here - if
	 *   its a custom widget, implement toXML instead, for complex behaviour. If its
	 *   a standard widget, think about subclassing or check the existing widget
	 *   formatting options to see if they can be used.
	 * 	 @param {Object} value
	 *    Value to be normalised
	 *   @param {String} declaredClass
	 *   @method _normalize
	 */
	function _normalize( /*Object*/ value, 
						 /*String*/ declaredClass) {
		// summary:
		//    normalizes the value of form fields to match the expected XML format.
		//
		// description:	
		//    Rules specific to certain widgets should be kept to an absolute minimum here - if
		//	  its a custom widget, implement toXML instead, for complex behaviour. If its
		//	  a standard widget, think about subclassing or check the existing widget
		//	  formatting options to see if they can be used.
		//
		//	  TODO Some of these can be moved into widget extensions, perhaps?
		
		if(d.isArray(value)) {
			// checkbox/radio
			if(/CheckBox/.test(declaredClass)) {
				if(value.length === 1 && value[0] === "on") {
					return "Y";
				}
				return "N";
			}
		}
		
		if(value === null || value === "" || ((value + "") === "NaN")) {
			return "";
		}

		// TODO Normalize date/time formats client/server, would rather send full standard date
		if(/Date/.test(declaredClass)) {
			return d.date.locale.format(value, {
				selector :'date',
				datePattern : misys.getLocalization('g_strGlobalDateFormat')
			});
		}
		if(/Time/.test(declaredClass)) {
			return d.date.locale.format(value, {
				datePattern: "dd/MM/yyyy", 
				timePattern: "HH:mm:ss"
			});
		}
		return dojo.isString(value) ? 
				dojox.html.entities.encode(value, dojox.html.entities.html) : value;
	}
/**
 * <h4>Summary:</h4>
 * Check which attachments have been added or deleted.
 * @method _synchronizeAttachments
 */
	function _synchronizeAttachments(){
	    //  summary:
	    //        Check which attachments have been added or deleted.
		
		console.debug("[misys.common] Checking for lost attachments ...");
		var attIdsField = dj.byId("attIds");
		var fileActIdsField = dj.byId("fileActIds");
		if(attIdsField) {
			var attIds = [];
			var fileActIds = [];
			if(d.query("table[id^=" + _fileAttachmentsTableID + "]").length > 0) {
				d.query(
					"table[id^=" + _fileAttachmentsTableID + 
					   "] tr[id^='file_row_']]").forEach(function(node, i){
					var nodeId = node.id;
					if(i !== 0) {
						attIds.push("|");
					}
					attIds.push(nodeId.substring(nodeId.indexOf("row_") + 4, nodeId.length));
				});
			} else {
				var grids = [dj.byId(_fileAttachmentsWidgetID),
				             dj.byId(_mt700FileAttachmentsWidgetID),dj.byId(_invoiceFileAttachmentsWidgetID),dj.byId(_purchaseorderFileAttachmentsWidgetID),dj.byId(_purchaseorderUploadFileAttachmentsWidgetID)];	
				var firstInserted = false;
				d.forEach(grids, function(gridContainer){
					if(gridContainer &&  gridContainer.grid) {
						var arr = gridContainer.grid.store._arrayOfAllItems;
						d.forEach(arr, function(attachment, i){
							if(attachment && attachment != null) {
								if (firstInserted) {
									attIds.push("|");
								}
								else
								{
									firstInserted = true;
								}
								attIds.push(attachment.attachment_id);
							}
						});
					}
				});
				
				var fileAttachments = dj.byId(_fileAttachmentsWidgetID);
				if(fileActIdsField && fileAttachments && fileAttachments.grid && fileAttachments.grid.selection){
					firstInserted = false;
					d.forEach(fileAttachments.grid.selection.getSelected(), function(node, index){
						if(node && node != null) {
							if (firstInserted) {
								fileActIds.push("|");
							}
							else
							{
								firstInserted = true;
							}
							fileActIds.push(node.attachment_id);
						}
					});
					fileActIdsField.set("value", fileActIds.join(""));
				}
			}

			attIdsField.set("value", attIds.join(""));
	    }
	}
/**
 * <h4>Summary:</h4>
 * Update a tab's title if it contains a field in error.
 * Query for all the nodes with passed context and css as _tabContainerSelector.
 * Get tab of the tab container check for its state ,if it is error update the tab.
 * @param {dijit._Widget} context
 *  Query for this context passed and get all the elements.
 * @method _validateTabs
 */
	function _validateTabs( /*dijit._Widget*/ context) {
		// summary: 
		//    Update a tab's title if it contains a field in error 
		
		// TODO Should probably be done with some sort of listener instead
		
		d.query(_tabContainerSelector, context).forEach(function(tabContainerNode){
				var tabContainer = dj.byId(tabContainerNode.getAttribute("widgetid"));
				if(tabContainer) {
					d.forEach(tabContainer.getChildren(), function(tab){
						d.some(tab.getChildren(), function(node) {
							if(node.get("state") === "Error") {
								m.connect(node, "onChange", function(){
									_updateTab(tab, node);
								});
								node.onChange();
								return true;
							}
							return false;
						});
					});
				}
		 });
	}
	/**
	 * <h4>Summary:</h4>
	 * Updates the title of a tab to indicate if it contains required fields, or
	 * fields in error
	 * <h4>Description:</h4> 
	 * The tab title is updated in the following cases
	 * 1. If the tab contains at least one field that is required, the title
	 * is preceded by the value of misys._config.requiredFieldPrefix (or '*')
	 * 2. If the tab contains at least one field that has a value, the title
	 *  is given the class nonEmptyTabContainer (which usually bolds the field)
	 * 3. If at least one field is in error, the tab title is preceded by the
	 *  error icon
	 *  @param {dijit._Widget} tab
	 *  @param {dijit._widget || JSON} tabState
	 *    as {"isRequired" : true, "isNonEmpty" : true, "isInError" : true}
	 *  @method _updateTab
	 */
	function _updateTab( /*dijit._Widget*/ tab,
            			 /*dijit._Widget || JSON*/ tabState) {
		//	summary:
		//		Updates the title of a tab to indicate if it contains required fields, or
		//		fields in error
		//		
		//	description:
		//		The tab title is updated in the following cases
		//			1. If the tab contains at least one field that is required, the title
		//			   is preceded by the value of misys._config.requiredFieldPrefix (or '*')
		//			2. If the tab contains at least one field that has a value, the title 
		//			   is given the class nonEmptyTabContainer (which usually bolds the field)
		//			3. If at least one field is in error, the tab title is preceded by the
		//			   error icon
		//
		//		The second parameter can be either JSON or a Dijit. 
		//
		//		When it is JSON, it should be structured as follows
		//
		//		{
		//		 "isRequired" : true,
		//		 "isNonEmpty" : true,
		//		 "isInError" : true
		//		}
		//
		//		(in cases where all three are true, obviously it changes depending on the field)
		//
		//	    In the case of a Dijit, the same JSON structure is formed from the Dijits state.
		
		var errorIcon = d.create("img", {
	    		"class" : "errorIcon",
	    		src: m.getContextualURL(m._config.imagesSrc + m._config.imageStore.warningIcon),
	    		alt: m.getLocalization("tabErrorWarning"),
	    		title: m.getLocalization("tabErrorWarning")
	    	}),
	    	requiredPrefix = m._config.requiredFieldPrefix || "*",
	    	title = tab.get("title"),
	    	container,
	    	state;

		// Establish the state of the tab
		if(tabState.declaredClass) {
			var value = tabState.get("value");
			state = {
					"isRequired" : tabState.get("required"),
					"isNonEmpty" : value !== null && value !== "",
					"isInError" : tabState.get("state") === "Error"
			};
		} else {
			state = tabState;
		}

		// Is node required? 
		if(state.isRequired && (title.indexOf(requiredPrefix) === -1)) {
			requiredPrefix += " ";
			title = requiredPrefix + title;
		}
		
		// Is node in error?
		// Note: this is the only update that is reversible
		if(state.isInError && title.indexOf("<img") === -1) {
			container = d.create("div");
			container.innerHTML = title;
			if (!(dojo.isIE && dojo.isIE === 6)){
				d.place(errorIcon, container);
			}
			title = container.innerHTML;
		}
		if(!state.isInError && title.indexOf("<img") !== -1) {
			title = title.substr(0, title.indexOf("<img"));
		}

		// Does node have a value?
		if(state.isNonEmpty && title.indexOf(_nonEmptyTabClass) === -1) {
			container = d.create("div");
			d.create("span", {
				"class" : _nonEmptyTabClass,
				innerHTML : title
			}, container);
			title = container.innerHTML;
		}
			
		if(title !== tab.get("title")) {
			tab.set("title", title);
		}
	}
	/**
	 * <h4>Summary:</h4>
	 * Bind event handlers to tab containers
	 * <h4>Description:</h4> 
	 * Change the tab title to include an asterisk, indicating that required fields are
	 * present. Moreover, bold the title when a child field fires an onBlur
	 * @method {dijit._Widget} context
	 * @method _bindTabs
	 */
	function _bindTabs( /*dijit._Widget*/ context) {
		//  summary:
	    //    Bind event handlers to tab containers 
		//  description:
		//    Change the tab title to include an asterisk, indicating that required fields are 
		//    present. Moreover, bold the title when a child field fires an onBlur
		
		var tabHasRequired = false,
		    tabHasNonEmpty = false,
		    tabHasInError = false,
		    parentTabId,
		    tabContainerId;

	      d.query(_tabContainerSelector, context).forEach(function(tabContainerNode){
				var tabContainer = dj.byId(tabContainerNode.getAttribute("widgetid"));
				if(tabContainer) {
					tabContainerId = tabContainer.get("id");
					d.forEach(tabContainer.getChildren(), function(tab){
						tabHasRequired = false;
						tabHasNonEmpty = false;
						tabHasInError = false;
						parentTabId = tab.get("id");
						d.forEach(tab.getChildren(), function(node){
							var value = node.get("value");
							
							// At least one field is required (on page load)
							if(!tabHasRequired && node.get("required")) {
								tabHasRequired = true;
							}
							
							// At least one field is non-empty
							// Note: We can't just check that "value" has any value as
							// its value could be zero which is "falsy" in JavaScript
							if(!tabHasNonEmpty && (value !== null && value !== "")) {
								tabHasNonEmpty = true;
							}
							
							// At least one field is non-empty
							if(!tabHasInError && node.get("state") === "Error") {
								tabHasInError = true;
							}
							
							// Highlight the tab if the value of this field is changed
							m.connect(node, "onChange", function() {
								_updateTab(tab, {
									"isRequired" : node.get("required"),
									"isNonEmpty" : node.get("value") !== null && 
														node.get("value") !== "",
									// Error icon is only shown on form submit and on page load
									"isInError" : false	
 								});
							});
							
							// Set the parent tab ID as an attribute on the child, so we
							// know which tab to open during the form validation
							node.set("parentTab", parentTabId);
							node.set("tabContainer", tabContainerId);
						});

						// Set the tab title the first time the page loads
						_updateTab(tab, {
							"isRequired" : tabHasRequired,
							"isNonEmpty" : tabHasNonEmpty,
							"isInError" : tabHasInError
						});
					});
				}
		  });
	}
	/**
	 * <h4>Summary:</h4>
	 * Subscribes elements with class _subscribeTopicSelector to
	 *  topic on attr _subscribeTopicAttr
	 *  @method _setupTopicSubscriptions
	 */
	function _setupTopicSubscriptions() {
		// summary:
		//        Subscribes elements with class _subscribeTopicSelector to
		//        topic on attr _subscribeTopicAttr
		
		var widget,
			topics;
		
		d.query(_subscribeTopicSelector).forEach(function(listener){
			 widget = dj.byId(dojo.attr(listener, "widgetid")) || 
			 				dj.byId(dojo.attr(listener, "id"));
			 if (widget) {
				 topics = widget.get(_subscribeTopicAttr);
				 if(topics) {
					 d.forEach(topics.split(" "), function(topic){
						 console.debug(
								 "[misys.common] Subscribe element", listener.id,  
								 "to topic", topic);
						 d.subscribe(topic, widget, function(event){
							 if (this.handleTopicEvent) {
								 this.handleTopicEvent(event, topic);
							 }
						 });
					 });
				 }
			 }
		});
	}
	/**
	 * <h4>Summary:</h4>
	 * If there is a search form in the page (e.g. for pages that list
	 *  transactions in a grid), then setUp the search.
	 *  @method _setupSearchFields
	 */
	function _setupSearchFields() {
		// summary:
		//       If there is a search form in the page (e.g. for pages that list 
		//       transactions in a grid), then 

		if(d.byId(_transactionSearchFormId)) {
			m.connect(_transactionSearchFormId, "onSubmit",  function(/*Event*/ e){
				var strCurrentFormat = dj.byId(_exportListFieldId) ? 
						                 dj.byId(_exportListFieldId).get("value") : "screen";
				if (e && strCurrentFormat === "screen") {
					e.preventDefault();
				}
				
				d.forEach(dj.byId('TransactionSearchForm').getDescendants(), function(fld){
					if(fld.state === 'Incomplete' && fld.required === true)
					{	
						fld._hasBeenBlurred =true; 
						fld.validate(false); 
					}
				});
				
				if(this.isValid()) {
					if (strCurrentFormat !== "screen") {
						if(strCurrentFormat === "pdf"){
							dj.byId(_filenameFieldId).set("value", "AccountStatement."+strCurrentFormat);
						}
						else {
							dj.byId(_filenameFieldId).set("value", "inquiry."+strCurrentFormat);							
						}
						return true;
					} else {
						m.grid.reloadForSearchTerms();
						m.reloadChartImg();
						return false;
					}
				}
				else { 
					if(dojo.byId('hugeDiv')) {
						dojo.byId('hugeDiv').style.display='none'; // hiding the results if form is in error state
					}
					return true;
				}
			});
		}
	}
	/**
	 * <h4>Summary:</h4>
	 *   Refreshes any grids in the page, which should be given the class "grid".
	 *  <h4>Description:</h4> 
	 *   Sometimes grid column sizes are not correctly sized upon page load, so this
	 *   methods calls the grid resize method to ensure the sizes are properly set.
	 *   @method _setupGrids
	 */
	function _setupGrids() {
		//  summary:
	    //        Refreshes any grids in the page, which should be given the class "grid".
		//  description:
		//        Sometimes grid column sizes are not correctly sized upon page load, so this
		//        methods calls the grid resize method to ensure the sizes are properly set.
		
		// All grids beneath isVisible will be shown
		d.query(_gridClassSelector).forEach(function(/*DomNode*/ grid){
				console.debug("[misys.common] Calling resize for grid", grid.id);
				var selectedItem;
				// Test if it is the datagrid of a graph to collapse it
				var gridObj = dj.byId(grid.id);
				if(gridObj) {
					if(d.hasClass(grid, "ischarted")) {
						m.grid.toggleAllGroups(gridObj, false);
					}
					if(!window.isTopElementToBeFocussed) {
						gridObj.resize();
                    }
					}
		});
	}

/**
 * <h4>Summary:</h4>
 *   Instantiate the collaboration floating pane, if present.
 * @method _setupCollaboration
 */
	function _setupCollaboration() {
		// summary:
		//       Instantiate the collaboration floating pane, if present

		var collaborationWindowContainer = d.byId(_collaborationWindowContainerId),
			collaborationWindow;
			
		if(collaborationWindowContainer) {
			console.debug("[misys.common] Showing Collaboration window ...");
			d.parser.parse(collaborationWindowContainer);
			// Place the window at the <body> tag, otherwise it will appear 
			// beneath other elements
			collaborationWindow = dj.byId("collaborationWindow");
			collaborationWindow.placeAt(dojo.body());
			if((!d.isIE || d.isIE > 7) && collaborationWindow.show) {
				d.style(collaborationWindow.domNode, "opacity", 0);
				collaborationWindow.show();
			} else {
				// Sometimes the collaboration window is a TitlePane & has no show method.
				//	It's been implemented like that, for some reason, when you save a transaction. 
				d.style(collaborationWindow.domNode, "opacity", 1);
			}
		}
	}
	/**
	 *   <h4>Summary:</h4>
	 *   When a field is in error, trap the user's focus until the field is corrected
	 *   <h4>Description:</h4> 
	 *   Add field focus on error action, to all writeable text fields in the page with an
	 *   id attribute, with the exception of those with the class 'nofocusonerror'.
	 *   If you wish to disable this 'feature' entirely for a particular page, set the flag
	 *   misys._config.disableFocusTrap to true
	 *   @method _focusFieldsOnError
	 *    
	 */
	function _focusFieldsOnError(){
		//	summary:
		//		  When a field is in error, trap the user's focus until the field is corrected
		//  description:
	    //        Add field focus on error action, to all writeable text fields in the page with an 
		//        id attribute, with the exception of those with the class 'nofocusonerror'.
		//
		//		  If you wish to disable this 'feature' entirely for a particular page, set the flag
		//		  misys._config.disableFocusTrap to true
		
		var validationBoxRegex = /ValidationTextBox/;
		
		if(!m._config.disableFocusTrap) {
			d.query(".widgetContainer *[id].dijitTextBox:not(.dijitReadOnly):not(.nofocusonerror)").
					forEach(function(field){
				var widget = dj.byId(field.getAttribute("widgetid"));
				if(validationBoxRegex.test(widget.get("declaredClass")) && !widget.focusonerror) {
					/*jsl:pass*/
				} else {
					m.connect(widget, "onBlur", _trapFocus);
				}
			});
		}
	}
	/**
	 * <h4>Summary:</h4>
	 *  Keeps the focus in the field if it is in error
	 * <h4>Description:</h4> 
	 * Keeps the focus in the field if it is in error, for any reason other than
	 * having no value.
	 * The guard checking for empty, NaN and null is to handle the various behaviours of
	 * required text, number and date fields when you enter and leave the field without
	 * entering a value ie.
	 * 
	 *  - A required text field will have an empty value;
	 *  - A number field will have NaN (as opposed to undefined if a non-number is entered);
	 *  - A date field will have null (as opposed to undefined if an invalid date is entered).
	 *  @method _trapFocus
	 */
	function _trapFocus(){
		//  summary:
	    //        Keeps the focus in the field if it is in error
		//  description: 
		//        Keeps the focus in the field if it is in error, for any reason other than
	    //        having no value.
	    // 
	    //        The guard checking for empty, NaN and null is to handle the various behaviours of
	    //        required text, number and date fields when you enter and leave the field without 
	    //        entering a value ie.
	    // 
	    //        - A required text field will have an empty value;
	    //        - A number field will have NaN (as opposed to undefined if a non-number is entered);
	    //        - A date field will have null (as opposed to undefined if an invalid date is entered).

		var value = this.get("value") + "";
		
		// What follows is the really complicated if/else statement that makes this work across all widget
		// types for all values, and neither traps the user in most cases where they enter spaces nor
		// allows them to get stuck in a focus loop

		if(this.state === "Error" && 
				(!m._config.fieldInError || m._config.fieldInError === this.id) &&
				((typeof value === "undefined") ||
				(value !== "" && value !== "null" && value !== "NaN") ||
				(/Select/.test(this.declaredClass) &&
				this.get("displayedValue") !== "" && !this.item))) {
			m._config.fieldInError = this.id;
			var that = this;
			m.dialog.show("ERROR", m.getLocalization("focusOnErrorAlert"), "", function(){
				that.focus();
			});
		} else {
			if(misys._config.fieldInError === this.id) {
				delete misys._config.fieldInError;
			}
		}
	}
	/**
	 * <h4>Summary:</h4>
	 * This fuction is for resizing the charts in FBCC
	 * @param {Array} charts
	 *  Array of chart widgets to be resized
	 * @param {Boolean} init
	 *  If true, initial width and height is positioned
	 * @method _resizeCharts
	 */
	function _resizeCharts( /*Array*/ charts, 
			  		  		/*Boolean*/ init) {
		// summary:
		//
	
		console.debug("[misys.common] Resizing charts");
		charts.forEach(function(chart){
			var width = chart.parentNode.offsetWidth;
			if(width !== 0) {
				_lastWidth = width;	
			}
			
			if(init) {
				d.attr(chart, "width", _lastWidth);
				d.attr(chart, "height", _defaultChartHeight);
			} else {
				d.attr(chart, "src", d.attr(chart, "alt") + "&chartwidth=" + _lastWidth);
			}
		});
	}
	
	/**
	 * <h4>Summary:</h4>
	 * This fuction is for replacing params in a string URL
	 * @param {String} URL
	 *  URL
	 * @param {String} key
	 *  param key
	 * @param {String} value
	 *  param value
	 * @method _setParamsToURLString
	 */
	function _setParamsToURLString( /*String*/ url, /*String*/ key, /*String*/ value) {
		
		key = encodeURI(key); 
		value = encodeURI(value);
		var finalURL;

        if (url.indexOf('?') === -1) {
        	finalURL = url + '?' + key + '=' + value;
        }
        else {
        	var splitURL = url.split('?')[0];
        	var splitParams = url.split('?')[1].split("&");
        	
            var i = splitParams.length; 
            var x; 
            while (i--) {
                x = splitParams[i].split('=');

                if (x[0] == key) {
                    x[1] = value;
                    splitParams[i] = x.join('=');
                    break;
                }
            }

            if (i < 0) { 
            	splitParams[splitParams.length] = [key, value].join('='); 
            }

            //this will reload the page, it's likely better to store this until finished
            finalURL = splitURL + '?' + splitParams.join('&');
        }
	
		return finalURL;
	}
	
/**
 * <h4>Summary:</h4>
 * This function is for resizing grids in FBCC
 * Inside this we are calling resize() and update() method.
 * @param {Array} grids
 *  Grids to be resized
 * @method _resizeGrids
 */
	function _resizeGrids( /* Array */ grids) {
		// summary:
		//
		
		console.debug("[misys.common] Resizing grids");
		grids.forEach(function(gridNode){
			var grid = dj.byId(gridNode.id);
			if(grid) {
				if(!window.isTopElementToBeFocussed || !window.isToPreventTableHeaderFocusAlways) {
					grid.resize();
				}
				grid.update();
			}
		});
	}
	/**
	 * <h4>Summary:</h4>
	 * Opens a new popup window
	 * <h4>Description:</h4> 
	 * We distinguish between Dialogs, which are in-page overlays (see misys.dialog.*) and
	 * popups, which are simply new windows (see misys.popup.*);
	 * Note: Don't change the popup window name without also changing the SELENIUM
	 * test; name is used to select the window
	 * @param {String} url
	 * @param {String} name
	 *  Name of the window
	 * @param {String} props
	 *  Properties for the window
	 * @method _openPopup
	 */
	function _openPopup( /*String*/ url,
						 /*String*/ name,
						 /*String*/ props) {
		// summary:
		//	Opens a new popup window
		//
		// description:
		//		We distinguish between Dialogs, which are in-page overlays (see misys.dialog.*) and
		//		popups, which are simply new windows (see misys.popup.*);
		//
		//		Note: Don't change the popup window name without also changing the SELENIUM
		// 		test; name is used to select the window
		
		var windowName = name || misys.getLocalization("transactionPopupWindowTitle"),
		    windowProps = props || "width=800,height=500,resizable=yes,scrollbars=yes",
		    popupWindow = d.global.open(url, windowName, windowProps);
		
		console.debug("[misys.common] Opening a standard popup with name", windowName, "at URL", url);
		if(!popupWindow.opener){
			popupWindow.opener = self;
		}

		popupWindow.focus();
	}
	
	// TODO Should this be a validation?
	/**
	 *  <h4>Summary:</h4>
	 *  Check if the template ID is unique across all products, with an AJAX call.
	 *  @param {dijit._Widget || DomeNode} node 
	 *  Id of the template or the node itself
	 *  @method _isUniqueTemplateId
	 */
	function _isUniqueTemplateId( /*dijit._Widget || DomNode*/ node) {
		//  summary:
	    //        Check if the template ID is unique across all products, with an AJAX call.
		
		var widget = dj.byId(node),
			value = widget.get("value"),
		    unique = true;
		
		var subProductCodeValue;
		if(dj.byId("sub_product_code"))
		{
			subProductCodeValue = dj.byId("sub_product_code").get("value");
		}else
		{
			subProductCodeValue = "*";
		}
		
		if(value !== "") {
			console.debug(
					"[misys.common] Checking that the Template ID is unique across products");
			m.xhrPost( {
				url : m.getServletURL("/screen/AjaxScreen/action/ValidateTemplateId"),
				handleAs : "text",
				content: {
					productcode 	: m._config.productCode,
					templateid 		: value,
					companyid 		: dj.byId("company_id").get("value"),
					subproductcode 	: subProductCodeValue
				},
				sync : true,
				load : function(response, ioArgs) {
					unique = (response.toLowerCase() === "true");
				},
				customError : function(response, ioArgs) {
					console.error("[misys.common] _isUniqueTemplateId error", response, ioArgs);
					unique = false;
				}
			});
			console.debug("[misys.common] _isUniqueTemplateId, response", unique);
		}
		
		return unique;
	}
	/**
	 * <h4>Summary:</h4>
	 * Binds events to commonly found page buttons.
	 * In this method we are covering all the buttons cancelButton,systemSaveButton etc
	 * For each type of button attach a different event.
	 * @method _bindButtons
	 */
	function _bindButtons() {
		// Summary:
		//		Bind events to commonly found page buttons
		
		if(d.query(".cancelButton").length > 0 || d.query(".cancelBkButton").length > 0) {
			console.debug("[misys.common] Connecting button event handlers ...");
			d.query(".saveButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("SAVE");
				});
			});
			d.query(".systemSaveButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("SYSTEM_SUBMIT");
				});
			});
			d.query(".saveTemplateButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("SAVE_TEMPLATE");
				});
			});
			d.query(".submitButton").forEach(function(btn) {

				var trans = dj.byId("transaction_confirmation_details");
				
				var callback = function(){
					if(m.commonclient && m.commonclient.submit) 
					{
						m.commonclient.submit("SUBMIT");
					}
					else
					{
						m.submit("SUBMIT");
					}
				}; 
				
				if(trans && trans.get('value') === "Y") 
				{	
					callback = function(){
						window.onbeforeunload = null;
						m.beforeSubmit();
						_submit("SUBMIT");
					};
				}
				
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", callback);
			});
			d.query(".validateButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("VALIDATE");
				});
			});
			d.query(".forwardButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("FORWARD");
				});
			});
			d.query(".rejectButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("REJECT");
				});
			});
			d.query(".returnTransactionButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("RETURN_TRANSACTION");
				});
			});
			d.query(".cancelButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("CANCEL");
				});
			});
			d.query(".cancelBkButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					// bulk needs its own cancel
					m.submit("CANCEL_BULK_TRANSACTION");
				});
			});
			d.query(".helpButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("HELP");
				});
			});
			d.query(".resubmitButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("RESUBMIT");
				});
			});
			d.query(".submitBulkButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					// bulk needs its own submit
					m.submit("SUBMITBULK");
				});
			});
			
			
		}
		// Bulk buttons if available
		if(d.query(".cancelBulkButton").length > 0) 
		{
			// Set the action to the bulk screen
			dj.byId("realform").set("action", m.getServletURL("/screen/BulkScreen"));
			
			d.query(".addBulkButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("ADD_BULK");
				});
			});
			d.query(".updateBulkButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("UPDATE_BULK");
				});
			});
			d.query(".saveTemplateBulkButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("SAVE_TEMPLATE_BULK");
				});
			});
			d.query(".cancelBulkButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("CANCEL_BULK");
				});
			});
			d.query(".helpButton").forEach(function(btn) {
				m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
					m.submit("HELP");
				});
			});
		}

		// Setup the table of contents
		// Delegate TOC events to the container node
		/**
		 * Delegate TOC events to the container node
		 */
		d.query("#toc").delegate("a", "onclick", function(evt){
			
			// Toggle the table of contents 
			if(this.id === "toggleTocLink") {
				m.toggleTOC();
				return;
			}
			
			if(this.id && this.id.indexOf("_") !== -1) {
				var headerId = this.id.substr(this.id.indexOf("_") + 1),
				target = d.byId(headerId),
				transactionDetails = d.byId("transactionDetails"),
				fnc = function() {
					if(d.isIE <= 6) {
						d.window.scrollIntoView(target);
					} else {
						dojox.fx.smoothScroll({
							node: target, 
							win: window
						}).play();
					}
				};
				
				if(transactionDetails && 
					d.isDescendant(target, transactionDetails) &&
						(d.style(transactionDetails, "display") === "none" || 
						 d.style(transactionDetails, "position") === "absolute")) {
					m.toggleTransaction(true, false, fnc);
				} else {
					fnc();
				}
			}
		});
		/**
		 * Delegate ErrorSection events to the container node
		 */
		d.query("#errorSection").delegate("a", "onclick", function(evt){
			
			// Toggle the table of contents 
			if(this.id === "errorLink") {
				m.toggleErrorSection();
				return;
			}
		});
		// Setup bank toggle links
		if (dj.byId("editTransactionDetails"))
		{
			m.connect("editTransactionDetails", "onclick", function(){
				m.toggleTransaction(true, true);
			});
		}
		if (dj.byId("hideTransactionDetails"))
		{
			m.connect("hideTransactionDetails", "onclick", function(){
				m.toggleTransaction(false);
			});
		}
	}
	/**
	 * <h4>Summary:</h4>
	 * 	Attach event handlers to the popup dialog buttons.
	 * This method is covering buttons wih css classes as .saveButton,cancelPopupbutton,.helpPopupButton etc
	 * Find all the nodes with these classes and attach events to them.
	 * @method _bindPopupButtons
	 * 
	 */
	function _bindPopupButtons() {
		// summary:
		//		Attach event handlers to the popup dialog buttons
		
		console.debug("[misys.common] Binding popup button event handlers ...");
		d.query(".savePopupButton").forEach(function(btn) {
			m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
				m.dialog.submit("SUBMIT");
			});
		});
		d.query(".cancelPopupButton").forEach(function(btn) {
			m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
				m.dialog.submit("CANCEL");
			});
		});
		d.query(".helpPopupButton").forEach(function(btn) {
			m.connect(dj.byId(d.attr(btn, "widgetid")), "onClick", function(){
				m.dialog.submit("HELP");
			});
		});
	}	
	
	/**
	 * <h4>Summary:</h4>
	 * Set up listeners. 
	 * <h4>Description:</h4> 
	 * Please refer inline comments below For each method
	 * listed in m.excludedMethods array, remove the window.onbeforeunload
	 * listener before method invocation.
	 * <b>IMPORTANT:</b> Since the window.onbeforeunload is removed and not reinstated,
	 * care should be taken to decide which methods are to be included in the
	 * m.excludedMethods array. Ideally, only those methods should be included
	 * which are bound to navigate to another page, but where an alert is not
	 * needed. For example - clicking on any system buttons like Save, Submit,
	 * Save Template etc, OR transaction navigations like adding Transaction in
	 * case of Bulk
	 * 
	 * @method _setListeners
	 */
	function _setListeners(){
		// Define the browser level unload listener window.onbeforeunload
		if(m.unloadListener)
		{
			window.onbeforeunload = m.unloadListener;
		}
		
		// For each method listed in m.excludedMethods array, remove the window.onbeforeunload listener before method invocation.
		// IMPORTANT: Since the window.onbeforeunload is removed and not reinstated, care should be taken to
		// decide which methods are to be included in the m.excludedMethods array. Ideally, only those
		// methods should be included which are bound to navigate to another page, but where an alert
		// is not needed. For example - clicking on any system buttons like Save, Submit, Save Template etc, 
		// OR transaction navigations like Add Transaction in case of Bulk
		dojo.forEach(m.excludedMethods, function(item, idx){
			dojox.lang.aspect.advise(item.object, item.method, {
				before: function(){
					m.isSystemButtonClicked = true;
					window.onbeforeunload = null;
				}
			});
		});
		
		//Making Form dirty on adding new or deleting the existing attachment from the Grid Store, 
		if(dijit.byId(attachmntFile))
		{
			dojox.lang.aspect.advise(dijit.byId(attachmntFile).grid.store, ["onSet", "onNew", "onDelete"],{
				after: function(){
					m.isFormDirty = true;
				}
			});
		}
		
		// This is actually a hack to work around an IE behavior: in IE, if the displayed dialog contains links 
		// with passback, the browser alert gets displayed. To avoid this, the window.onbeforeunload listener 
		// is temporarily removed before showing a dialog, and LATER REINSTATED when the dialog is closed,
		// based on conditions. Please refer related changes in misys/_base.js for method dialog.show
		dojox.lang.aspect.advise(m.dialog, "show", {
			before: function(){
				console.debug("Removing window.onbeforeunload for dialog");
				window.onbeforeunload = null;
			}
		});
		
		// Addons - handled as a special scenario. Mark the form dirty if the addons table is modified
		dojox.lang.aspect.advise(m, ["addTransactionAddon", "deleteTransactionAddon", "editTransactionAddon"], {
			after: function(){
				console.debug("Marking form dirty after addons change");
				m.isFormDirty = true;
			}
		});
		
		// Set up onChange listeners for all dojo widgets contained in the transaction forms
		d.query("#fakeform0, #fakeform1").forEach(function(node) {
			console.debug("[misys.common] Setting change listeners for all children of", node.id);
			var form = dj.byId(node.id);
		
			d.forEach(form.getDescendants(), function(child){
				m.connect(child, "onChange", m.markFormDirty);
			});
	
		});
		
		// Remove the window.onbeforeunload listener temporarily if any hyperlink contained in the
		// transaction form is clicked. NOTE that we (almost) immediately reinstate the window.onbeforeunload
		// listener by using setTimeout
		d.query("#fakeform0 a, #fakeform1 a, #fakeform0 img[onclick], #fakeform1 img[onclick]").forEach(function(node) {
			dojox.lang.aspect.advise(node, "onclick", {
				before: function(){
					console.debug("Removing onbeforeunload for link " + node);
					m.isSystemButtonClicked = true;
					window.onbeforeunload = null;
					setTimeout(function(){
						window.onbeforeunload = m.unloadListener;
					}, 50);
				}
			});
		});
		
		// Remove the window.onbeforeunload listener temporarily if icon for downloading an existing file is clicked.
		// NOTE that we (almost) immediately reinstate the window.onbeforeunload listener by using setTimeout
		dojox.lang.aspect.advise(misys, "downloadFile", {
			before: function(){
				console.debug("Removing onbeforeunload for file download");
				m.isSystemButtonClicked = true;
				window.onbeforeunload = null;
				setTimeout(function(){
					window.onbeforeunload = m.unloadListener;
				}, 50);
			}
		});
		
		// Set up onClick listeners for all hyperlinks outside the transaction forms
		dojo.query(".header a, .footer a, .portalMenuItem *").forEach(function(node, idx){ 
			m.connect(node, "onClick", function(/*Event*/ event){
				if(m.isPopupRequired())					
				{	
					var evt = event;
					var targetUrl = _getTargetUrl(evt);
					if(targetUrl !== "")
					{
						dojo.stopEvent(evt);
						m.showUnsavedDataDialog();
					}
					
					var handle = dojo.connect(m, "setUnsavedDataOption", function(){
						if(m.unsavedDataOption !== 'notset')
						{
							var errorMsg = "";
							if(m.unsavedDataOption === 'save')
							{
							//	errorMsg = _submitAsync("SAVE");
								m.saveAsync(targetUrl);
							}
							else if(targetUrl !== "" && errorMsg === "" && m.unsavedDataOption === 'nosave')
							{
								location.href = targetUrl;
							}
						}	
						dojo.disconnect(handle);
					});
				}
			});				
		});
		
		// Set up listeners for events on the left navigation tree
		var navBar = dj.byId("menu_tree");
		if(navBar)
		{
			// Set up onClick listeners for the navigation tree. However, NOTE that only those menu leaf
			// items are affected which are visible upon initial page load.
			// NOTE that the onClick event is triggered only when a leaf element is clicked
			
			// Set up onClick listeners for all child (leaf) elements, whenever a menu node is expanded.
			// This method complements the onClick listener defined immediately above, by listening to
			// menu items as and when they become visible
			d.connect(navBar, "onOpen", function(item, node, event){
				console.log("Item expanded");
				d.forEach(dojo.query("#"+node.id+" span.dijitTreeLabel"), function(child, idx){
					m.connect(child, "onClick", function(/*Event*/ event){
						if(m.isPopupRequired())					
						{	
							var evt = event;
							var targetUrl = _getTargetUrl(evt);
							if(targetUrl !== "")
							{
								dojo.stopEvent(evt);
								m.showUnsavedDataDialog();
							}
							
							var handle = dojo.connect(m, "setUnsavedDataOption", function(){
								if(m.unsavedDataOption !== 'notset')
								{
									var errorMsg = "";
									if(m.unsavedDataOption === 'save')
									{
									//	errorMsg = _submitAsync("SAVE");
										m.saveAsync(targetUrl);
									}
									else if(targetUrl !== "" && errorMsg === "" && m.unsavedDataOption === 'nosave')
									{
										location.href = targetUrl;
									}
								}	
								dojo.disconnect(handle);
							});
						}
					});
				});
			});
		}
		
		console.debug("[misys.common] Successfully completed setting change listeners");
	}
	// This method fetches the target url whenever a navigation event is triggered
	/**
	 * <h4>Summary:</h4>
	 * This method fetches the target url whenever a navigation event is triggered
	 * @param {Event} evt
	 *  Event from which we can get the target url
	 * @method _getTargetUrl
	 * @return targetURL
	 */
	function _getTargetUrl(/*Event*/ evt){
		var evtTarget = evt.target;
		var targetUrl = "";
		if(evtTarget.nodeName === "IMG" && evtTarget.parentNode.nodeName === "A")
		{
			
			if(evtTarget.parentNode.href)
			{
				targetUrl = evtTarget.parentNode.href;
			}
		}
		else if(evtTarget.href)
			{
			targetUrl = evtTarget.href;
			}
		else if(dojo.hasClass(evtTarget, "dijitTreeLabel"))
		{
			var navBar = dijit.byId("menu_tree");
			var selectedItemPath = navBar.attr('path');
			var selectedMenu = dojo.filter(selectedItemPath, function(pathEntry){
				return pathEntry.hasOwnProperty("url");
			});
			if(selectedMenu.length === 1 && selectedMenu[0].url)
			{
				targetUrl = selectedMenu[0].url;
			}
		}
		return targetUrl;
	}
	/**
	 * <h4>Summary:</h4>
	 * This function returns the screen name
	 * @method _getScreenName
	 */
	function _getScreenName(){
		var screen = "";
		var path = misys._config.homeUrl;
		if(misys._config.homeUrl.indexOf("?") != -1)
		{
			path = misys._config.homeUrl.split("?")[0];
		}
		screen = path.substr(path.lastIndexOf("/")+1);
		return screen;
	}
	
	/**
	 * <h4>Summary:</h4>
	 * This function returns the xml for re authentication by product. If result is FULL then formToXML is called to send complete xml.
	 * @method _getScreenName
	 */
	function _getReAuthXml(productCode){
		
		var productsForReauth = ["LC", "BG", "EC", "EL", "IC", "BR", "TF", "SG", "SI", "SR", "IR", "FT", "BK", "SE", "LN", "TD", "LI"];
		
		if(productsForReauth.indexOf(productCode) !== -1)
		{
			if(productCode === 'FT' || productCode === 'BK') {
				return m.formToXML({ignoreDisabled : true});
			}
			return m.formToXML();
		}
		else 
		{
			return "";
		}
	}
	
	
	//
	// Public functions follow
	//
	d.mixin(m, {
		/**
		 * <h4>Summary:</h4>
		 * This fuction performs reauthentication process 
		 * If reauthentication is enabled get parameters for the reauthentication, show reauth dialog.
		 * Throws an error if init paramters are not there for the reauthentication.
		 * @method performReauthentication
		 */
		performReauthentication : function () {		

			var reauth = dj.byId("reauth_perform");
			if(reauth && reauth.get("value") === "Y")
			{
				var paramsReAuth = {};
				 if(d.isFunction(m._config.initReAuthParams)) {
					 paramsReAuth =  m._config.initReAuthParams();
					 m.checkAndShowReAuthDialog(paramsReAuth);
				 }else{
					 console.debug("Doesnt find the function initReAuthParams for ReAuthentication");
					 m.setContentInReAuthDialog("ERROR", "");
					 dj.byId("reauth_dialog").show();
				 }
			} else {
				if(m.isFormDirty && m.isFormDirty === true )
				{
					m.isFormDirty = false;
				}
				dj.byId("TransactionData").set("value", m.formToXML());
				dj.byId(_realformID).submit();
			}
		},
		
		submitCommon : function(type){
			_submit(type);
		},
		
		validateFormsCommon : function()
		{
			return _validateForms(true);
		},
		
		openPopupCommon : function ( url, name, props) {
			_openPopup(/*String*/ url,
				 /*String*/ name,
				 /*String*/ props);
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function sets the reauthentication content that came
		 * from server on ajax call into the diolog
		 * @param {HTML} response
		 *  If response equals to '01' the there is no need for reauthentication.
		 *  If response equals to 'ERROR' then destroy all the widgets and show error dialog.
		 * 	Otherwise do perform reauthentication.
		 * @param {Collection} ioArgs
		 * @method setContentInReAuthDialog 
		 */
		setContentInReAuthDialog : function ( /* html */ response, /* Collection */ ioArgs) {		
			
			// Summary This function sets the reauthentication content that came
			// from server on ajax call into the diolog
			var widgets;
			switch(response)
			{
				case '01':
					// incase reauth not needed
					// no need of reauth dialog
					if(d.isFunction(m._config.nonReauthSubmit))
					{   
					    m._config.nonReauthSubmit();
					}
					else
					{
						if(dj.byId("TransactionData"))
						{
							dj.byId("TransactionData").set("value", m.formToXML());
						}
						dj.byId(_realformID).submit();
					}
					break;
				
				case 'ERROR':
				   // incase error in getting reauth type
					if(d.byId('reauth_dialog_content'))
				    { 
				    // Destroy all previous widgets and containers
				     widgets = dj.findWidgets(d.byId("reauth_dialog_content"));
				     d.forEach(widgets, function(w) {
				         w.destroyRecursive(false);
				     });
				     
				     // Destroy all the Children
				     d.empty("reauth_dialog_content");
				    
				    }
					d.byId("reauth_dialog_content").innerHTML = m.getLocalization("technicalErrorReauth");	
					d.parser.parse("reauth_dialog_content");
					dj.byId("reauth_password").set("required", false);
					m.animate('wipeOut', d.byId("reauth_otp_response_sb"));
					m.toggleClassInlineBlock("reauth_sb", false);
					break;
				case 'EXCHANGE_RATE_ERROR':
					if(d.byId('reauth_dialog_content'))
				    { 
				    // Destroy all previous widgets and containers
				     widgets = dj.findWidgets(d.byId("reauth_dialog_content"));
				     d.forEach(widgets, function(w) {
				         w.destroyRecursive(false);
				     });
				     
				     // Destroy all the Children
				     d.empty("reauth_dialog_content");
				    
				    }
					d.byId("reauth_dialog_content").innerHTML = m.getLocalization("technicalErrorExchangeRate");	
					d.parser.parse("reauth_dialog_content");
					dj.byId("reauth_password").set("required", false);
					m.animate('wipeOut', d.byId("reauth_otp_response_sb"));
					m.toggleClassInlineBlock("reauth_dialog_password", false);
					m.toggleClassInlineBlock("reauth_sb", false);
					break;
				default:				
					// incase reauth needed and got the reauth type
					if(d.byId('reauth_dialog_content'))
				    { 
					    // Destroy all previous widgets and containers
					     widgets = dj.findWidgets(dojo.byId("reauth_dialog_content"));
					     d.forEach(widgets, function(w) {
					         w.destroyRecursive(false);
					     });
					     // Destroy all the Children
					     d.empty("reauth_dialog_content");
				     }
				
					
					d.byId("reauth_dialog_content").innerHTML = response;								
					d.parser.parse("reauth_dialog_content");	
					m.toggleClassInlineBlock("reauth_sb", true);
					
					
					break;
			}
		},
		/**
		 * <h4>Summary:</h4>
		 *  This function is to make a Ajax call to find out whether re-auth is needed.
		 *  If needed it builds the re-auth pop up screen.
		 *  @param {Collection} paramsReAuth
		 *   Parameters for performing reauthenication
		 *  @method checkAndShowReAuthDialog
		 */
		checkAndShowReAuthDialog : function ( /* Collection */ paramsReAuth) {		

			// Summary: This function is to make a Ajax call to find out whether re-auth is needed 
			//          if needed it builds the re-auth pop up screen
			
			if(misys.commonclient && misys.commonclient.checkAndShowReAuthDialog)
			{
				misys.commonclient.checkAndShowReAuthDialog(paramsReAuth);
				return;
			}
			console.debug('[FormEvents] Checking for reAuth requirement');
		/*	var xml 		= [],
			xmlArray	= paramsReAuth.xml;
			if(xmlArray) {
	
				if(m._config.xmlTagName) {
						xml = ["<", m._config.xmlTagName, ">"];
				}
				xmlArray.forEach(function(field){
					if(dj.byId(field)) {
						var widget = dj.byId(field);
						xml.push("<"+field+">"+widget.get("value")+"</"+field+">");
					}
				});
				
				if(m._config.xmlTagName) {
					xml.push("</", m._config.xmlTagName, ">");
				}
			}*/
			m.xhrPost({
			url : m.getServletURL("/screen/AjaxScreen/action/ReAuthenticationAjax"),
			handleAs : "text",
			sync : true,
			preventCache: true,
			content : {
				productCode : paramsReAuth.productCode,
				subProductCode : paramsReAuth.subProductCode,
				transactionTypeCode : paramsReAuth.transactionTypeCode,
				subTransactionTypeCode : (paramsReAuth.subTransactionTypeCode) ? paramsReAuth.subTransactionTypeCode : '',
				entity : (paramsReAuth.entity) ? paramsReAuth.entity : '',
				currency : (paramsReAuth.currency) ? paramsReAuth.currency : '',
				amount : (paramsReAuth.amount) ? paramsReAuth.amount : '',
				tnxAmt : (paramsReAuth.tnxAmt) ? paramsReAuth.tnxAmt : '',
				bank_abbv_name : (paramsReAuth.bankAbbvName) ? paramsReAuth.bankAbbvName : '',
				xml : _getReAuthXml(paramsReAuth.productCode),
				mode : dj.byId("mode") ? dj.byId("mode").get("value") : '',
				operation : dj.byId("realform_operation") ? dj.byId("realform_operation").get("value") : "",
				option : paramsReAuth.option ? paramsReAuth.option : ""
			},		
			load : function(response, ioArgs)
			{   
				    if(!(response.indexOf('SC_UNAUTHORIZED') === -1))
				    {
				    	misys.showSessionOverDialog();
				    }
				    else
				    {
						m.setContentInReAuthDialog(response, ioArgs);
						if (""+response+"" != '01')
						{
							dj.byId("reauth_dialog").show(); 
						}
				    }
			},
			customError : function(response, ioArgs)
			{
				console.debug("Error in ReAuthenticationAjax Call");
				console.error(response);
				m.setContentInReAuthDialog("ERROR", ioArgs);
				dj.byId("reauth_dialog").show();
			}

			});
		
		},
		
		getQueryParameterByName: function(name, url) {
		    name = name.replace(/[\[\]]/g, '\\$&');
		    var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
		        results = regex.exec(url);
		    if (!results) {
		    	return null;
		    }
		    if (!results[2]) {
		    	return '';
		    }
		    return decodeURIComponent(results[2].replace(/\+/g, ' '));
		},		
		
		isAngularProductUrl : function (productCode, subProductCode) {
		    if (!subProductCode || subProductCode === 'null' || subProductCode === '') {
		    	var ret = misys._config.angularProducts && misys._config.angularProducts.indexOf(productCode) > -1;
		    	var restrictedAngularScreens = misys._config.restrictedangularscreen.replace(/[\[\]']+/g,'').split(', ');
		    	var isAngularScreenRestricted = false;
		    	for(var i=0;i<restrictedAngularScreens.length;i++) {
		    		if(window.location.href.indexOf(restrictedAngularScreens[i]) > -1){
		    			isAngularScreenRestricted = true;
		    		}
		    	}
		    	if(ret && productCode && productCode !== '' && misys._config.restrictedangularproductcode.indexOf(productCode) > -1 && ((isAngularScreenRestricted) || (window.location.href.indexOf('MessageCenterScreen') > -1) || (window.location.href.indexOf('classicUXHome') > -1))) {
		    		ret= false; 
		    	}
		      return ret; 
		    } else {
		      return misys._config.angularSubProducts && misys._config.angularProducts && misys._config.angularProducts.indexOf(productCode) > -1 && m.isSubProductCodeValidForAngularUrl(misys._config.angularSubProducts,subProductCode);
		    }
		},
		
		isSubProductCodeValidForAngularUrl: function contains(subProductsList, subProductCode) {
			var subProductsListString = subProductsList.replace("[","").replace("]","");
			var validSubproductList = subProductsListString.split(", ");
			if(validSubproductList.includes(subProductCode)){
    	         return true;
    	    }
			return false;
    	},
    	
		  
		/**
		 * <h4>Summary:</h4> :
		 * This function sets the content of Transaction confirmation dialog.
		 * @param {HTML} response
		 * @param {Collection} ioArgs
		 * @method setTnxConfirmationDetailsInDialog
		 */
		setTnxConfirmationDetailsInDialog : function ( /* html */ response, /* Collection */ ioArgs) {		
			
			//Set the dialog content
			switch(response)
			{
				case 'ERROR':
	
					console.debug('Error while getting transaction confirmation details');
					m.dialog.show("ERROR",  m.getLocalization("technicalErrorTnxConfirmationDetails"));
					break;
																		
				default:				
					console.debug('Content received from server for confirmation details', response);
					var onOkCallback = function(){
						console.debug("Confirmation details accepted");
						m.performReauthentication();
					};
	
					var onCanceCallback = function(){
						console.debug("Confirmation details cancelled");
						var realformOperation = dj.byId("realform_operation");
						realformOperation.set("value","");
						m.dialog.hide();
					};
	
					m.dialog.show("CONFIRMATION", response, "", null, null, "", onOkCallback, onCanceCallback, null);
					break;
			}
		},
		/**
		 * <h4>Summary:</h4>
		 *  This function is to make a Ajax call to check and display the details of a confirmation of transaction.
		 *  @method checkAndShowReAuthDialog
		 */
		checkAndShowTnxConfirmationDetailsDialog : function () {		

			console.debug('[FormEvents] Checking for transactionConfirmationDetails requirement');
			
			m.xhrPost({
			url : m.getServletURL("/screen/AjaxScreen/action/TransactionConfirmationDetailsAction"),
			handleAs : "text",
			sync : true,
			preventCache: true,
			content : {
				transactionData : m.formToXML()
			},		
			load : function(response, ioArgs)
			{   
				    if(!(response.indexOf('SC_UNAUTHORIZED') === -1))
				    {
				    	misys.showSessionOverDialog();
				    }
				    else
				    {
						m.setTnxConfirmationDetailsInDialog(response, ioArgs);
				    }
			},
			customError : function(response, ioArgs)
			{
				console.debug("Error in TransactionConfirmationDetailsAction Call");
				console.error(response);
				m.setTnxConfirmationDetailsInDialog("ERROR", ioArgs);
			}

			});
		
		},
		/**
		 * With angular menu enabled, the top colmask height needs to be reset based on the top angular menu height. 
		 */		
		angularMenuReSize: function () {
			var height1 = document.querySelector(".ui-menubar-root-list").offsetHeight;
			var dojoContent = document.querySelector(".colmask");
			if(dojoContent && dojoContent !== "undefined") {
				if(height1 >= 42) { 
					dojoContent.style.top = "80px"; 
				}
			}	
		},
		
		/**
		 * Sets the focus to the top element as configured
		 * And also sets the skip to links appropriate to the configuration
		 * Input reset flag will notify whether to reset the flags or not 
		 */		
		_setupFocus: function(resetFlag) {
			m.hideCollabWindow();
			if(resetFlag) {
				m.setAccessibilityFlags();
			}
			
			if(window.isTopElementToBeFocussed) { 
				m.focusTopElement();
			}
			
			if(window.isTopElementToBeFocussed && resetFlag) { 
				setTimeout(function(){
					window.isTopElementToBeFocussed = false; 
				 }, window.topElementFocusTimeout);
			}
		},
		
		/**
		 * Hides the collabaration window and TOC window for accessibility. 
		 */			
		hideCollabWindow: function() {
			if(!window.isFloatingFormSummaryMenuEnabled) { 
				if(dojo.query(colbortionWindow) && dojo.query(colbortionWindow)[0] != undefined) {
					dojo.style(dojo.query(colbortionWindow)[0],'display','none');
				}
				
				if(dojo.query('#toc') && dojo.query('#toc')[0] != undefined) {
					dojo.style(dojo.query('#toc')[0],'display','none');
				}
			}
		},		
		
		/**
		 * Sets the link for the skiptocontent link for accessibility. 
		 */		
		skipToMenuLink: function() { 
			// portalMenuBar
			if(!dojo.byId('portalMenuBar')) {
				dojo.style(dojo.byId('skipToMenu'), "display", "none");
			} else { 
				dojo.style(dojo.byId('skipToMenu'), "display", "inline");					
			}
		},
		
				
		/**
		 * Sets the link for the skiptocontent link for accessibility. 
		 */
		skipToContentLink: function() { 
			if(!dojo.byId('GTPRootPortlet')) {
				var firstHeading = dojo.query(".portlet-title")[0];
				var idToSet = dojo.attr(firstHeading, "id"); 
				if(idToSet) {
					dojo.attr( dojo.byId('skipToContent'), 'href', "#"+idToSet);
					dojo.style(dojo.byId('skipToContent'), "display", "block");
				} else { 
					dojo.style(dojo.byId('skipToContent'), "display", "none");					
				}
			}
		},

		/**
		 * Sets the accessibility related flags like aria-describedby/aria-labelledby etc  
		 */
		setAccessibilityFlags : function() {
			
			//Remove the for attribute for a label if the for is empty 
			dojo.query('label').forEach(function(labelDiv) {
				try {
					if(dojo.hasAttr(labelDiv,'for') && dojo.attr(labelDiv,'for') === '') {
						dojo.removeAttr(labelDiv,'for');
					}
				}catch(exe) {
					//ignore the exception 
				}
			}); 
			
			
			//For all the buttons link it to the main heading 
			var buttonIds = ['validateButton','validateButton2','saveButton','saveButton2','submitButton','submitButton2','forwardButton','forwardButton2','rejectButton','rejectButton2','returnTransactionButton','returnTransactionButton2','templateButton','templateButton2','menuCancelButton','cancelButton2','helpButton','helpButton2','previewButton','previewButton2','submitBulkButton','submitBulkButton2','addBulkButton','addBulkButton2','updateBulkButton','updateBulkButton2','templateBulkButton','templateBulkButton2','cancelBulkButton','cancelBulkButton2','helpButton','helpButton2','uploadFormButton','uploadFormButton2','resubmitButton','resubmitButton2','sySubmitButton'];
			dojo.forEach(buttonIds, function(entry, i){
				if(dojo.query('#'+entry)[0]) {
					dojo.attr(dojo.query('#'+entry)[0],ariaDescrib,'mainScreenHeadingText');
				}
			});
			
			//Set the language dropdown menu's role as menu instead of button 
			if(dojo.query(langMenu) && dojo.query(langMenu)[0] !== undefined) {
				dojo.attr(dojo.query(langMenu)[0], 'role', 'menu');
				dojo.attr(dojo.query(langMenu)[0], ariaDescrib, 'language-menu-instructions');
				//dijitReset dijitStretch dijitButtonContents dijitDownArrowButton
			}
			
			//Favourites menu
			if(dojo.query(bookmrkMenu) && dojo.query(bookmrkMenu)[0] !== undefined) {
				dojo.attr(dojo.query(bookmrkMenu)[0], ariaDescrib, 'bookmark-menu-instructions');
				dojo.attr(dojo.query(langMenu)[0], 'role', 'listbox');
				//dijitReset dijitStretch dijitButtonContents dijitDownArrowButton
			}
			//
			dojo.query("#bookmarkToolTipDialog .bookmark").forEach(function(deleteBookmarkContainer){
				var firstA = dojo.query("a",deleteBookmarkContainer)[0];
				var secondA = dojo.query("a",deleteBookmarkContainer)[1];
				var labelConent =  dojo.attr(dojo.query('img',secondA)[0],'title') + " " + dojo.attr(firstA,'innerHTML') + " " + misys.getLocalization('bookmark') ;
				dojo.style(secondA,"display","inline");
				dojo.attr(secondA,'aria-label',labelConent);
			});			
			
			
			/*if(dojo.query(colbortionWindow) && dojo.query(colbortionWindow)[0] != undefined) {
				dojo.style(dojo.query(colbortionWindow)[0],'display','none');
			}
			
			if(dojo.query('#toc') && dojo.query('#toc')[0] != undefined) {
				dojo.style(dojo.query('#toc')[0],'display','none');
			}*/
			
			
			//Set the accessibility flags for the table headers 
			dojo.query(".dojoxGridHeader table.dojoxGridRowTable").forEach(function(tableHeader){
				try {
					dojo.attr(dojo.query('tbody>tr>th',tableHeader)[0],ariaDescrib,'table-head-instructions');
				} catch (exc) {
					// ignore the exception
					console.debug(exc);
				}
			});
			
			//Set the accessibility flags for the table data  
			dojo.query(".dojoxGridContent ").forEach(function(tableRow){
				try {
					if (dojo.query('div>div.dojoxGridRow>table>tbody>tr>td',tableRow)[0])
					{
						dojo.attr(dojo.query('div>div.dojoxGridRow>table>tbody>tr>td',tableRow)[0],ariaDescrib,'table-body-instructions');
					}
				} catch (exc) {
					// ignore the exception
					console.debug(exc);
				}
			});
			
			//Set the top menu navigation instructions to the first element 
			if(dojo.query(popuMenuItem) && dojo.query(popuMenuItem)[0] != undefined) {
				try {
					dojo.attr(dojo.query(popuMenuItem)[0],ariaDescrib,'top-menu-instructions');
				} catch (exc) {
					// ignore the exception
					console.debug(exc);
				}
			}
			
			
			//Toggle boxes like Search buttons 
			dojo.query(".collapsingImgSpan, .collapsingImgSpanLeftSide").forEach(function(selectTag){
				var helpAriaDescribedBy = 'toggle-box-inst';  
				//For the search criteria if any help is set then link the help text to the search Criteria
				if(dojo.attr(selectTag, 'onclick') === 'javascript:misys.toggleSearchGrid();') { 
					if(dojo.query(scrhCrieteria) && dojo.query(scrhCrieteria)[0] !== undefined ) {
						var searchHelpTextId;
						var searchHelpTag = dojo.query(scrhCrieteria)[0];
						if(dojo.attr(searchHelpTag,'id')) {
							searchHelpTextId = dojo.attr(searchHelpTag,'id');
						} else { 
							dojo.attr(searchHelpTag,'id','searchHelpText');
							searchHelpTextId = dojo.attr(searchHelpTag,'id');
						}
						helpAriaDescribedBy = helpAriaDescribedBy + ' ' + searchHelpTextId;
					} 
				}
				dojo.attr(selectTag, ariaDescrib,helpAriaDescribedBy);
			});
			
			//Buttons/images/links which open the dialog boxes 
			dojo.query("#GTPRootPortlet img, #GTPRootPortlet a, #GTPRootPortlet button, #GTPRootPortlet span, #GTPRootPortlet div ").forEach(function(selectTag){
				try {
					var clickURL = "";
				    if(dojo.attr(selectTag,'onClick')) {
				    	clickURL = dojo.attr(selectTag,'onClick');  
				    } else if(dojo.attr(selectTag,'href')) { 
				    	clickURL = dojo.attr(selectTag,'href');  
				    }
				    if(clickURL && clickURL.length>0) {
				    	//List of URLs with the popup 
				    	if(clickURL.indexOf('misys.showSearchDialog') !== -1 || clickURL.indexOf('misys.popup.showReporting') !== -1 || clickURL.indexOf('misys.popup.showPreview') !== -1 || clickURL.indexOf('misys.showBankTypeDialog')  !== -1 || clickURL.indexOf('misys.showSearchUserAccountsDialog') !== -1 || clickURL.indexOf('misys.showEntityDialog') !== -1 ) {
				    		dojo.attr(selectTag, ariaDescrib,'dialog-link-inst');
				    	}
				    } else {
				    	//Only applies to the images for e.g. //content/images/open_dialog.png" /content/images/search.png
				    	var imgUrl = "";
				    	if(dojo.attr(selectTag, 'src')) {
				    		imgUrl = dojo.attr(selectTag, 'src');
							if(imgUrl.indexOf('open_dialog.png') !== -1 || imgUrl.indexOf('search.png') !== -1 ) {
								//Need to get the container in the parent heirarchy. 
								var parentNode = selectTag.parentNode;
								//if(dojo.attr(parentNode, 'dojoattachpoint') &&   ) {
								if(dojo.attr(parentNode, 'dojoattachpoint') && (dojo.attr(parentNode, 'dojoattachpoint') === 'containerNode')  && !(dojo.attr(parentNode,'onClick')) ) {
									parentNode = parentNode.parentNode;
								}
								dojo.attr(parentNode,ariaDescrib,'dialog-link-inst');
							}
				    	}
				    }			    
				} catch (exc) {
					// ignore the exception
					console.debug(exc);
				}
			});

			/*
			//For alt missing images setting the alternate text. These should not be coming here ideally.  
			dojo.query("img").forEach(function(imageTag){
				if(!dojo.hasAttr(imageTag,'alt')){					
					dojo.attr(imageTag,'alt',misys.getLocalization('imageAlt'));
				}
			});
			*/
			
			
		},
		
		
		/**
		 * Focuses the first/top most element in the page. 
		 * Also sets the action container elements linked to the H1 tag. 
		 * Here right now below elements are assumed to be available in each page. 
		 */
		focusTopElement : function ()  {
			var screenTitle = '';
			var mainTitleHomePageElement; 
			if(window.isTopElementFirstH1 && dojo.query(GTPRootPotlet)) {
				try {
					dojo.query(GTPRootPotlet)[0].focus();
					screenTitle = dojo.attr(dojo.query(GTPRootPotlet)[0],'innerHTML');
					dojo.attr(dojo.query(GTPRootPotlet)[0],'id','mainScreenHeadingText');
					//mainTitleHomePageElement = dojo.query(GTPRootPotlet)[0];
				} catch (exc) {
					if(dojo.query(h1portletTitle) && dojo.query(h1portletTitle)[0] !== undefined ) { 
						dojo.query(h1portletTitle)[0].focus();
						//mainTitleHomePageElement = dojo.query(h1portletTitle)[0];
					} else if(dojo.query(h2portletTitle) && dojo.query(h2portletTitle)[0] !== undefined ) {
						dojo.query(h2portletTitle)[0].focus();
						mainTitleHomePageElement = dojo.query(h2portletTitle)[0];
					}
				}
			}
			else if(dojo.byId('skipToMenu')) {
				dojo.byId('skipToMenu').focus();
				//mainTitleHomePageElement = dojo.byId('skipToMenu');
			} else if(dojo.byId('helpDesk')) {
				dojo.byId('helpDesk').focus();
				//mainTitleHomePageElement = dojo.byId('helpDesk');
			} else if(dojo.byId('manageProfile')) {
				dojo.byId('manageProfile').focus();
				//mainTitleHomePageElement = dojo.byId('manageProfile');
			}
			if(mainTitleHomePageElement && mainTitleHomePageElement !== undefined ) { 
				//Linking the top bar entrees like the logged in user, logged in time and other details to the main title. 
				dojo.attr(mainTitleHomePageElement, ariaDescrib,'welcome userId lastLoginSpanID');
			}
		},
		/**
		 * <h4>Summary:</h4>
		 *   Perform page onload events
		 * <h4>Description:</h4> 
		 * Note that this overwrites the function of the same name defined
		 * in misys._base.You can't use 'this' to reference misys in anything
		 * that is passed to setTimeout/setInterval. This is because its really
		 * window.setTimeout and 'this' always refers to the window. So just use m. or
		 * misys.
		 * @method onLoad
		 * 
		 */
			onLoad : function(){
			//  summary:
		    //         Perform page onload events
			//
			//  dsecription: 
			//         Note that this overwrites the function of the same name defined
			//         in misys._base.
			//
			//		   By the way, remember that you can't use 'this' to reference misys in anything
			//         that is passed to setTimeout/setInterval. This is because its really 
			//         window.setTimeout and 'this' always refers to the window. So just use m. or
			//         misys.
			//
				m.onBeforeLoad();
			
				
				
				/**
				 * Get the closest matching element up the DOM tree.
				 * @private
				 * @param  {Element} elem     Starting element
				 * @param  {String}  selector Selector to match against
				 * @return {Boolean|Element}  Returns null if not match found
				 */
				var getClosest = function ( elem, selector ) {

					// Element.matches() polyfill
					if (!Element.prototype.matches) {
						Element.prototype.matches =
							Element.prototype.matchesSelector ||
							Element.prototype.mozMatchesSelector ||
							Element.prototype.msMatchesSelector ||
							Element.prototype.oMatchesSelector ||
							Element.prototype.webkitMatchesSelector ||
							function(s) {
								var matches = (this.document || this.ownerDocument).querySelectorAll(s),
									i = matches.length;
								while (--i >= 0 && matches.item(i) !== this) {console.debug("");}
								return i > -1;
							};
					}

					// Get closest match
					for ( ; elem && elem !== document; elem = elem.parentNode ) {
						if ( elem.matches( selector ) ) {		return elem;			}
					}

					return null;

				};
				
				function swapNodes(n1, n2) {

				    var p1 = n1.parentNode;
				    var p2 = n2.parentNode;
				    var i1, i2;

				    if ( !p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1) ) { return; } 

				    for (var i = 0; i < p1.children.length; i++) {
				        if (p1.children[i].isEqualNode(n1)) {
				            i1 = i;
				        }
				    }
				    for (i = 0; i < p2.children.length; i++) {
				        if (p2.children[i].isEqualNode(n2)) {
				            i2 = i;
				        }
				    }

				    if ( p1.isEqualNode(p2) && i1 < i2 ) {
				        i2++;
				    }
				    p1.insertBefore(n2, p1.children[i1]);
				    p2.insertBefore(n1, p2.children[i2]);
				}
				
				/** MPS-48922 To close Dropdowns when screen resolution is changed **/
				window.onresize = function() {
					 var popupElements = document.getElementsByClassName("dijitPopup dijitComboBoxMenuPopup");
					 for(var i=0;i<popupElements.length;i++) {
						 popupElements[i].style.display = "none"; 
					 }					  
				};
				
				window.setTimeout(function(){ 					
					if(dojo.byId('saveDashboard')) {
						console.log("in save dashboard function");
						dojo.byId('saveDashboard').addEventListener('click',function() {
							var allPortlets = {"level1": [], "level2": [], "level3":[]};
							for(var i=0; i<d.query(homepagePortlet).length;i++) {
								var obj = {};
								var ele = d.query(homepagePortlet)[i];
								if(ele && !getClosest(d.query(homepagePortlet)[i],'.colmid')) {
									if(ele && getClosest(d.query(homepagePortlet)[i],'.colLeft')) {
										console.log("COLLEFT");
										obj["position"] = ele.getAttribute("position");
										obj["id"] = ele.id;
										allPortlets.level1.push(obj);
									} else if(ele && getClosest(d.query(homepagePortlet)[i],'.colRight')){
										
										console.log("COLRIGHT");
										obj["position"] = ele.getAttribute("position");
										obj["id"] = ele.id;
										allPortlets.level2.push(obj);									
									} 
							}
								else {
									console.log("COLMID");
									obj["position"] = ele.getAttribute("position");
									obj["id"] = ele.id;
									allPortlets.level3.push(obj);
								}
								//console.log("Object",obj);
							}
							console.log("allPortlets",allPortlets);
							document.getElementById('_dashboardpositions').value = JSON.stringify(allPortlets);
							console.log("DragdropObj:", document.getElementById('_dashboardpositions').value);
										
							m.xhrPost({
								url : m.getServletURL("/screen/AjaxScreen/action/UserPreferencesAction"),
								handleAs : "text",
								sync : true,
								preventCache: true,
								content : {
									portletPositions : document.getElementById('_dashboardpositions').value, 
									PSML : document.getElementById('DashboardPSML').value,
									operation : 'SAVE',
									themeColor : document.documentElement.style.getPropertyValue('--main-bg-color'),
									textColor : document.documentElement.style.getPropertyValue('--main-text-color'),
									fontType : document.documentElement.style.getPropertyValue('--main-font-family'),
									fontSize : document.documentElement.style.getPropertyValue('--main-font-size')
								},		
								load : function(response, ioArgs)
								{
									window.location.href = m.getServletURL("");
								},
								customError : function(response, ioArgs)
								{
									console.debug("Error in UserPreferencesAction Call");
									console.error(response);
								}
							});							
							
						},false);
					}
					
				}, 100);
				
				var deleteIcon = function(e) {
					console.log('in delete icon fun');
					var closestElem = getClosest(e.target, '.portlet');
					closestElem.style.display = 'none';
				};
				
				if(d.query(".delIcon")[0]) {
					for(var i=0; i<d.query(".delIcon").length;i++) {
						console.log('deliconlength',d.query(".delIcon").length);
						d.query(".delIcon")[i].addEventListener("click", deleteIcon, true);
						console.log(d.query(".delIcon")[i]);
					}
					
					
				}
				
				if(dojo.byId('saveDashboard') && d.query(homepagePortlet)[0]) {
					
					/*for(var i=0; i<d.query(".portlet").length;i++) {console.log('portlets',d.query(".portlet").length);
					d.query(".portlet")[i].setAttribute("draggable","true");
					console.log(d.query(".portlet")[i])
					}*/
				//	var dragDropObj = {"level1": [], "level2": []};
					//var portlet_arr = [];
					for(i=0; i<d.query(homepagePortlet).length;i++) {
						var dEle = d.query(homepagePortlet)[i];
						console.log('portlets',d.query(homepagePortlet).length);
						dEle.setAttribute("draggable","true");					
						dEle.setAttribute("position",i);
						dEle.addEventListener('dragstart', function (e) {
						/*if(dragDropObj.level1 === undefined) {
							dragDropObj["level1"] = [];
						} else if(dragDropObj.level2 === undefined) {
							dragDropObj["level2"] = [];
						}*/
					      e.dataTransfer.effectAllowed = 'copy'; // only dropEffect='copy' will be dropable
					      e.dataTransfer.setData('Text', this.id);
					      console.log('drag start',dEle);// required otherwise doesn't work
					    });
					}
					
					if(d.query(".colContainer")[0]) {
						var parentContainer = d.query(".colContainer")[0];						
						console.log(parentContainer);
						parentContainer.addEventListener('dragover', function (e) {
						    if (e.preventDefault) {e.preventDefault(); } // allows us to drop
						    this.className = 'over';
						    e.dataTransfer.dropEffect = 'copy';						    
						    return false;
						  });
						
						parentContainer.addEventListener('dragenter', function (e) {
						    this.className = 'over';
						    return false;
						  });
						
						parentContainer.addEventListener('dragleave', function () {
						    this.className = '';
						  });
						
						
						parentContainer.addEventListener('drop', function (e) {
							if (e.stopPropagation) { e.stopPropagation(); } 
							//console.log('is this source',e.target.closest(".portlet").outerHTML);
							//var srcDestObj = {"dest":};
							/*var dest = {};
							var src = {};
							var res1 = {};var res2 = {};*/
							
							
							
							var sourceElement = document.getElementById(e.dataTransfer.getData('Text'));
							var destinationElement = getClosest(e.target, '.homepage .portlet');
							var srcPosition = sourceElement.getAttribute("position");
							var destPosition = destinationElement.getAttribute("position");
							
							//Swap Src/Dest Nodes
							swapNodes(sourceElement,destinationElement);
							//Exchange positions
							sourceElement.setAttribute('position',destPosition);
							destinationElement.setAttribute('position',srcPosition);
							
							console.log('source element-->',sourceElement);							
							console.log('destination element-->',destinationElement);	
							console.log('source element-->pos',sourceElement.getAttribute("position"));							
					});
				}
			}	
				/** MPS-59116 To show the Data Grid on home page if customer has less/limited permissions **/
				 if(dojo.query(".maincontent.homepage") && dojo.query(".maincontent.homepage")[0] !== undefined){
					 var onGoingTaskDIv = dojo.byId('CustomerOngoingTasksList')?true:false;
					 var internalNewsDiv= dojo.byId('InternalNewsPortlet')?true:false;
					 var outstandingChartDiv = dojo.byId('OutstandingPerProductChartPortlet')?true:false;
					 var tradeEventDiv = dojo.byId('TradeEventsGridPortlet')?true:false;
					 var accountSummaryDiv = dojo.byId("HomeAccountSummaryListPortlet")?true:false;
					 var actionRequiredDiv = dojo.byId("ActionRequiredPortlet")?true:false;
					 var opicsListBalanceDiv = dojo.byId("OpicsAccountListPortletPlusBalance")?true:false;
					 if(!onGoingTaskDIv && !internalNewsDiv && !outstandingChartDiv && !tradeEventDiv && !accountSummaryDiv && !actionRequiredDiv && !opicsListBalanceDiv)
					 { 	
						 if(dojo.byId("RatePortlet")){
					 		dojo.style("RatePortlet", "width", 10);
					 		dojo.style("RatePortlet", "position", "relative");
					 		dojo.style("RatePortlet", "left", "100%");
						 }
						 if(dojo.byId("ratesGrid")){
					 		dojo.style("ratesGrid", "width", 10);
					 		dojo.style("ratesGrid", "position", "relative");
						 }
					 }
				}
				 
			var p1 = function() {
					try {
						if(dojo.byId('footerMain') && dojo.byId('footerHtml')) {
							dojo.byId('footerHtml').style.cssText = 'display:none !important';
						}
						if(dojo.query('.homepage') && window.dontShowRouter && window.dontShowRouter === true) {
							//Main home page with classic dashboard with modern UX 
							dojo.style(dojo.query('.colContainer')[0], 'padding-top', '70px');
							dojo.byId('layout').style.cssText = 'padding:0px 24px 0px 24px !important';
							if(dojo.query('.colMask')[0]) {
								dojo.style(dojo.query('.colMask')[0], 'position', 'static');
							}
						}
					} catch(err) {
						//Do nothing. 
					}
					m._setupFocus(false);
					_setupGrids();
					_setupSearchFields();
					if(m._config.saveUnsavedData && m._config.saveUnsavedData === true){
						_setListeners();
					}

					var angularMenu = document.querySelector(".ui-menubar-root-list");
					if(angularMenu && angularMenu !== "undefined") { 
						m.angularMenuReSize(); 
						window.addEventListener('resize', m.angularMenuReSize());
					}	
				},
				p2 = function() {
					_setupTopicSubscriptions();
					_bindTabs();
					_focusFieldsOnError();
					m.resizeCharts();
					_setupCollaboration(); 
					_bindButtons();
					m._setupFocus(true);
				};
			
			return this._onLoad(p1, p2);
		},
		
		
		
		// Hook to perform any page specific tasks before the onLoad method is executed
		/**
		 * <h4>Summary:</h4>
		 * Hook to perform any page specific tasks before the onLoad method is executed
		 * @method onBeforeLoad
		 */
		onBeforeLoad : function(){
			if(window.isAccessibilitySkiptoLinksEnabled) {
				m.skipToMenuLink();
				m.skipToContentLink();
			}
		},
		/**
		 * <h4>Summary:</h4> Calls the confirmation dialog for specific actions.
		 * Otherwise, it passes the submit type to the _submit function.
		 * 
		 * <h4>Description:</h4> The behaviour of this function is slightly different in
		 * debug mode. In this case, we parse any bank-side fields and generate
		 * the XML first. This means that if you click submit but cancel the
		 * confirmation dialog, the XML is still generated and written to the
		 * Firebug/Chrome console, so it can be used for debugging.
		 * 
		 * This will act as an onClick or onSubmit event handler, so 'this' is
		 * not guaranteed to refer to the misys object
		 * 
		 * The default action is SAVE.
		 * 
		 * One thing to note is that the XML outputted to the JavaScript console
		 * in DEBUG mode specifically excludes disabled fields (i.e. hidden
		 * fields, conditionally enabled fields, etc.) as otherwise, in the case
		 * where the use hits 'cancel' and halts the submission, we would have
		 * to reenable all those fields again.
		 * @param {String} type
		 *  Type of submission (SUBMIT, DRAFT, APPROVE, REJECT, etc).
		 * @method submit
		 */
		submit : function( /*String*/ type) {
			//  summary:
		    //        Calls the confirmation dialog for specific actions. Otherwise, it passes the
			//        submit type to the _submit function.
			//  description:
			//        The behaviour of this function is slightly different in debug mode. 
			//        In this case, we parse any bank-side fields and generate the XML first. 
			//        This means that if you  click submit but cancel the confirmation dialog, the 
			//        XML is still generated and written to the Firebug/Chrome console, so it can 
			//        be used for debugging.
			//
			//		  This will act as an onClick or onSubmit event handler, so 'this' is not 
			//        guaranteed to refer to the misys object
			//
			//		  The default action is SAVE.
			//
			//		  One thing to note is that the XML outputted to the JavaScript console in 
			//		  DEBUG mode specifically excludes disabled fields (i.e. hidden fields,
			//		  conditionally enabled fields, etc.) as otherwise, in the case where the
			//		  use hits 'cancel' and halts the submission, we would have to reenable all
			//	      those fields again. 
			//
			//		  TODO Arguably, SUBMIT should be the default behaviour
					
			// Prepare default message and callback
		if(misys.commonclient && misys.commonclient.submit)
		{
			misys.commonclient.submit(type);
		}
		else
		{
			var message = m.getLocalization("saveTransactionConfirmation"),
		    callback = function()
			{
				if (type === "SUBMITBULK")
				{
					m.submitBulk(_validateForms);
				}
				else
				{
					m.beforeSubmit();
					_submit(type);
				}
			};
		//var originalOperationValue = ""; 
			
		 if(dj.byId("realform_operation") && (dj.byId("realform_operation").get("_resetValue")!==""))
		 {
			 originalOperationValue = dj.byId("realform_operation").get("_resetValue");
		 }
		console.debug("[misys.common] Performing a", type, "form action");
		switch(type){
		 case "VALIDATE":
		 	 _submit(type);
		 	 return;
			break;
		 case "SUBMITBULK":
		 case "SUBMIT":
			m.setCustomConfirmMessage();
			var submitMsg = m._config.globalSubmitConfirmationMsg;
			
			var warningMessagesSize = misys._config.warningMessages ? misys._config.warningMessages.length : 0;
			
			if(warningMessagesSize > 0)
			{
				var i;
				var messagesWithLineBreaks = "<b><ol>";
				for(i = 0; i < warningMessagesSize; i++)
				{
					messagesWithLineBreaks += ("<li>"+ misys._config.warningMessages[i]+ "</li>");
				}
				
				messagesWithLineBreaks += "</ol></b>";
				
				submitMsg = misys.getLocalization("submitTransactionConfirmationWithWarning",[ messagesWithLineBreaks ]);
			
			}
			
			message = (submitMsg && submitMsg !== "") ? submitMsg : m.getLocalization("submitTransactionConfirmation");
			
			//Raja: below code can be moved to setCustomConfirmMessage function of individual product binding
			var eucp = dj.byId("eucp_flag");
			if(eucp && !eucp.get("disabled")){
				 message = m.getLocalization("submitEUCPTransactionConfirmation");
			}
			break;
		 case "SYSTEM_SUBMIT":
			 var applicableWarningMsg = m.formApplicableWarningMsg();
			 message = applicableWarningMsg ? applicableWarningMsg : message;
			 callback  = function(){
				 _submit(type);
			 };
			break;
		 case "SAVE_TEMPLATE":
			 message = m.getLocalization("saveTemplateConfirmation");
			 callback  = function(){
				 _submit(type);
			 };
			break;
		 case "SAVE_REPORT_TEMPLATE":
			 message = m.getLocalization("saveTemplateConfirmation");
			 callback  = function(){
				 _submit(type);
			 };
			break; 
		 case "CANCEL":
			 message = m.getLocalization("cancelTransactionConfirmation");
			 callback  = function(){
				 _submit(type);
			 };
			break;
		 case "CANCEL_BULK_TRANSACTION":
			 message = m.getLocalization("cancelTransactionConfirmation");
			 callback  = function(){
				 _submit(type);
			 };
			break;		
		 case "REJECT":
			 message = m.getLocalization("rejectTransactionConfirmation");
			 callback  = function(){
				 _submit(type);
			 };
			break;
		 case "RETURN_TRANSACTION":
			 message = m.getLocalization("returnTransactionConfirmation");
			 callback  = function(){
				 _submit(type);
			 };
			break;	
		 case "HELP":
			 _openPopup(m._config.onlineHelpUrl, m.getLocalization("onlineHelpWindowTitle"),
					"width=1000,height=700,resizable=yes,scrollbars=yes");
			return;
			break;
		 case "APPROVE":
			 message = m.getLocalization("submitTransactionConfirmation");
			 dj.byId('realform_operation').set('value', 'APPROVE_FEATURES');
	         callback  = function(){
	        	 _submit(type);
			 };
			break;
		 case "DELETE":
			 message = m.getLocalization("deleteMCTransactionsConfirmation");
			 dj.byId("realform_operation").set("value", "APPROVE_FEATURES");
	         callback  = function(){
	        	 _submit(type);
			 };
			 break;
		 case "CHECKER_WARN_DELETE_ROLE_SUBMIT":
			 var roleName = dijit.byId("featureid").get("value");
			 var roleType = dijit.byId("roletype").get("value");
			 var isRoleMapped = false;
				m.xhrPost({
					url : m.getServletURL("/screen/AjaxScreen/action/CheckRoleMapping"),
					handleAs : "json",
					preventCache : true,
					sync : true,
					content: {role_name : roleName,
							  role_type : roleType},
					load : function(response, args){
						isRoleMapped = response.isRoleMapped;
					},
					error : function(response, args){
						isRoleMapped = false;
						console.error("Checking Role mapping  error ", response);
					}
				});
				
				if(isRoleMapped)
				{
					message = m.getLocalization("deleteMappedRoleConfirmation");
				}
				else
				{
					message = m.getLocalization("deleteRoleConfirmation");
				}
			 dj.byId("realform_operation").set("value", "APPROVE_FEATURES");
	         callback  = function(){
	        	 _submit(type);
			 };
			 break;
		 case "REVERT":
			 message = m.getLocalization("revertMCTransactionsConfirmation");
			 dj.byId("realform_operation").set("value", "REVERT_FEATURES");
	         callback  = function(){
	        	 _submit(type);
			 };
			 break;
		 case "RETURN":
			 message = m.getLocalization("returnMCTransactionsConfirmation");
			 dj.byId("realform_operation").set("value", "RETURN_FEATURES");
	         callback  = function(){
	        	 _submit(type);
			 };
			 break;
		 case "DRAFT":
			 dj.byId("realform_operation").set("value", "DRAFT_FEATURES");
	         callback  = function(){
	        	 _submit(type);
			 };
			 break;
		 case "MAKER_SUBMIT":				
			  m.setCustomConfirmMessage();
			  submitMsg = m._config.globalSubmitConfirmationMsg;
			 message = m.getLocalization("submitTransactionConfirmation");
			 message = submitMsg ? submitMsg : message;
			 callback  = function(){
				 _submit(type);
			 };
			break;
			
		 case "MAKER_BENE_SUBMIT":
			 message = m.getLocalization("submitTransactionConfirmationForMasterBeneficiary");
			 callback  = function(){
			 _submit("MAKER_SUBMIT");
			  };
				 break;
		 case "MAKER_BENE_FILE_UPLOAD_SUBMIT":
			  message = m.getLocalization("submitTransactionConfirmationForBeneficiaryFileUpload");
			  callback  = function(){
			  _submit("MAKER_SUBMIT");
			  };
			  break;
		 case "CHECKER_BENE_SUBMIT":
			    message = m.getLocalization("submitTransactionConfirmationForMasterBeneficiary");
			    dj.byId('realform_operation').set('value', 'APPROVE_FEATURES');
			    callback  = function(){
			    _submit("APPROVE");
			     };
			    break;
		case "CHECKER_BENE_FILE_UPLOAD_SUBMIT":
			   message = m.getLocalization("submitTransactionConfirmationForBeneficiaryFileUpload");
			   dj.byId('realform_operation').set('value', 'APPROVE_FEATURES');
			   callback  = function(){
			   _submit("APPROVE");
			    };
			 break;
		 case "AUTO_FORWARD_SUBMIT":
			 message = m.getLocalization("submitAutoForwardTransactionConfirmation");
			 callback  = function(){
				 _submit(type);
			 };
			break;
		 case "ADD_BULK":
			 message = m.getLocalization("addBulkConfirmation");
			 callback  = function(){
				 _submit(type);
			 };
			break;
		 case "UPDATE_BULK":
			 message = m.getLocalization("updateBulkConfirmation");
			 callback  = function(){
				 _submit("ADD_BULK");
			 };
			break;
		 case "CANCEL_BULK":
			 message = m.getLocalization("cancelBulkConfirmation");
			 callback  = function(){
				 _submit(type);
			 };
			break;
		case "SAVE_TEMPLATE_BULK":
			 message = m.getLocalization("saveTemplateBulkConfirmation");
			 callback  = function(){
				 _submit(type);
			 };
			break;
		case "RESUBMIT":
			 message = m.getLocalization("resubmitConfirmation");
			 callback  = function(){
				 _submit(type);
			 };
			break;
		default:
			break;
		}

		console.debug("[misys.common] Request XML", 
							this.formToXML({ignoreDisabled : true}));
		console.debug("[misys.common] Note that this XML *excludes* disabled fields (such",
					  "as hidden fields and conditionally enabled fields) as if you click",
					  "'cancel' and halt the submit, they will remain enabled, which may",
					  "appear to be a bug. For a complete XML tree, execute misys.formToXML()",
					  "in the console");
		
		var onCancelCallback = function() {
			if(originalOperationValue !== "")
			{
				dj.byId("realform_operation").set("value", originalOperationValue);
			}
			// Reinstate the onbeforeunload if it exists
			if(m.unloadListener)
			{
				window.onbeforeunload = m.unloadListener;
			}
		};
		m.dialog.show("CONFIRMATION", message, "", callback, "", "", "", onCancelCallback);
		}	
		},
		
		acceptLegalText: function () {
			_submit("LEGAL_TEXT_SUBMIT");
		},
		
		
		submitBulkNoAutoForward : function(/*String*/ type)
		{
			 _submit(type);
		},
		/**
		 * <h4>Summary:</h4>
		 * This is the Asynchronous version of submit("SAVE_XXX"). All validations are done silently.
		 * @param {String} Target Url
		 * @method saveAsync
		 */
		saveAsync : function(/*String*/ targetUrl) {
			//  summary:
			//		This is the Asynchronous version of submit("SAVE_XXX"). All validations are done silently.
		    //  description:
			//
			console.debug("[misys.common] Request XML", 
								this.formToXML({ignoreDisabled : true}));
			console.debug("[misys.common] Note that this XML *excludes* disabled fields (such",
						  "as hidden fields and conditionally enabled fields) as if you click",
						  "'cancel' and halt the submit, they will remain enabled, which may",
						  "appear to be a bug. For a complete XML tree, execute misys.formToXML()",
						  "in the console");
			var type;
			
			if(d.query("#draftButton").length > 0){
				type = "DRAFT"; 
				dj.byId('realform_operation').set('value', 'DRAFT_FEATURES');
			}
			else{
				type = "SAVE";
			}
			
			var errorMsg = _submitAsync(type);
			
			if(errorMsg !== "")
			{
				m.unsavedDataOption = 'notset';
				var onErrorCallback = function(){dijit.byId("entity")?dijit.byId("entity").focus():null;};
				m.dialog.show("ERROR", errorMsg, "", onErrorCallback);
			}
			else
			{
				var realForm = d.byId("realform");
				d.attr(realForm, "action", m.getServletURL("/screen/AsyncScreen"));
				
				var urlParams = {
						realscreen: _getScreenName()
				};
				
				m.xhrPost({
					url: m.getServletURL("/screen/AsyncScreen") + "?" + d.objectToQuery(urlParams),
					preventCache: true,
					sync: true,
					form : realForm,
					handleAs: "json",
					load: function(response, args){
						if(response.status === 'success')
						{
							location.href = targetUrl;
							m.isFormDirty = false;
						}
						else if(response.status === 'failure')
						{
							m.unsavedDataOption = 'notset';
							m.dialog.show("ERROR", m.getLocalization(response.message));
						}	
					},
					error: function(response, args){
						console.error("Error during Save");
						m.dialog.show("ERROR", m.getLocalization("technicalError"));
					}
				});
			}
		},
		/**
		 * <h4>Summary:</h4> Converts a form and its children to XML.
		 * 
		 * <h4>Description:</h4> We use the
		 * standard dijit.byId(form).get("value") as a reference, which returns a JSON
		 * object constructed from the [name, value] pairs of each of the form's
		 * children. Look at _FormMixin.js in Dijit core for more details.
		 * 
		 * If you wish a field to be excluded from the generated XML, simply do not give
		 * it a 'name' attribute, and it will be ignored. If you need specific
		 * formatting for the field value, you have 3 options:
		 * 
		 * 1. If it's a custom widget, override _getValueAttr and implement your
		 * formatting there; 2. Alternatively, you may implement toXML, the value of
		 * which will be taken in preference to get('value'); 3. If you can't do either
		 * of these, look at the private method _normalize in this file, for other
		 * options.
		 * 
		 * If you need specific formatting for the XML as a whole (which is sometimes
		 * required for certain system features screens), then create the property
		 * xmlTransform as a function on the misys._config object. This should take an
		 * XML string as its single argument, and output the transformed XML.
		 * 
		 * Note that in 90% of cases, this function takes no arguments. So
		 *  - if ignoreDisabled is false (which it is except for the XML outputted in
		 * the debug), then disabled fields will be enabled, so they can be collected -
		 * id takes the id of the form. If this is not passed, we select all forms with
		 * class .validate - xmlRoot is the root node of the generated XML. If it is not
		 * passed, we use the value of misys._config.xmlTagName
		 * @param {JSON} init
		 *  Set of initial properties.
		 * @method formToXML
		 */
		formToXML : function( /*JSON*/ init) {
			// summary:
			//    Converts a form and its children to XML
			//
			// description: 
			//	  We use the standard dijit.byId(form).get("value") as a reference, which
			//	  returns a JSON object constructed from the [name, value] pairs of
			//	  each of the form's children. Look at _FormMixin.js in Dijit core for
			//	  more details.
			//
			//	  If you wish a field to be excluded from the generated XML, simply do not
			//	  give it a 'name' attribute, and it will be ignored. If you need specific
			//	  formatting for the field value, you have 3 options:
			//
			//	  1. If it's a custom widget, override _getValueAttr and implement your
			//		 formatting there;
			//	  2. Alternatively, you may implement toXML, the value of which will be taken
			//		 in preference to get('value');
			//	  3. If you can't do either of these, look at the private method _normalize in
			//		 this file, for other options.
			//
			//	  If you need specific formatting for the XML as a whole (which is sometimes required
			//	  for certain system features screens), then create the property xmlTransform as a 
			//	  function on the misys._config object. This should take an XML string as its single 
			// 	  argument, and output the transformed XML.
			//
			//	  Note that in 90% of cases, this function takes no arguments. So
			//
			//		- if ignoreDisabled is false (which it is except for the XML outputted
			//		  in the debug), then disabled fields will be enabled, so they can be collected
			//		- id takes the id of the form. If this is not passed, we select all forms
			//		  with class .validate
			//		- xmlRoot is the root node of the generated XML. If it is not passed, we
			//		  use the value of misys._config.xmlTagName
			
			// TODO We should validate forms with .validate but collect XML for forms 
			// 		with .form (for example), to handle cases where a form should be 
			//		collected but not validated
			
			var params = {
					selector: ".validate",
					xmlRoot: m._config.xmlTagName,
					ignoreDisabled: false
				},
				xml = [];
			
			// Init the params
			d.mixin(params, init);
			
			if(params.xmlRoot) {
				xml = ["<", params.xmlRoot, ">"];
			}

			// If there are any disabled fields, enable them before
			// submitting, otherwise they won't be included in the XML
			if(!params.ignoreDisabled) {
				d.query(".dijitDisabled").forEach(function(w){
					var disabledField = dj.byId(d.attr(w, "widgetid"));
					if(disabledField) {
						disabledField.set("disabled", false);
					}
				});
			}	
			
			d.query(params.selector).forEach(function(node) {
				console.debug("[misys.common] Building XML for form", node.id);
				var form = dj.byId(node.id),
					widgets = {},
					values, widget, declaredClass, value;
				
				d.forEach(form.getDescendants(), function(widget){
					if(!widget.name || widgets[widget.name]){ return; }
					widgets[widget.name] = widget;
				});
				
				// Now that all fields are enabled and ready, collect the form value
				values = form.get("value");
				
				for(var name in values) {
					if(widgets.hasOwnProperty(name)) {  // don't traverse the prototype chain
						widget = widgets[name];
						declaredClass = widget.declaredClass;

						if(widget.toXML) {
							value = widget.toXML();
							value = (!value) ? "" : value;
						}
						else if(name === "org_narrative_description_goods" || 
								name === "org_narrative_documents_required" || 
								name === "org_narrative_additional_instructions" ||
								name === "org_narrative_special_beneficiary" ||
								name === "org_narrative_special_recvbank"){
							value = dojox.html.entities.decode(widget.value,dojox.html.entities.map);
						}
						else {
							value = _normalize(values[name], declaredClass);
						}
						
						// If the widget defines its own XML tag, use the tag as provided by this widget
						if (widget.xmlTagName) {
							xml.push(value);
						} else {
							xml.push("<", name, ">", value, "</", name, ">");
						}
					}
				}
			});
			
			if(params.xmlRoot) {
				xml.push("</", params.xmlRoot, ">");
			}
			
			//E2EE is not enabled for Dialog submission
			var dialogForm = false;
			if(dj.byId("xhrDialog") && dj.byId("xhrDialog").open)
			{
				dialogForm = true;
			}

			if(m._config.hasOwnProperty("xmlTransform") && d.isFunction(m._config.xmlTransform)) 
			{
				if(m.e2ee_transaction && m.e2ee_transaction.enabled === true && !dialogForm)
				{
					return m.e2ee_transaction.encryptData(m._config.xmlTransform(xml.join("")));
				}
				else
				{
					return m._config.xmlTransform(xml.join(""));
				}
			} 
			
			if(m.e2ee_transaction && m.e2ee_transaction.enabled === true && !dialogForm)
			{
				return m.e2ee_transaction.encryptData(xml.join(""));
			}
			else
			{
				return xml.join("");
			}
		},
		/**
		 * <h4>Summary:</h4> Utility function to generate an XML string from a given
		 * field or reference
		 * 
		 * <h4>Description:</h4> e.g. for the field
		 * 
		 * &lt;div data-dojo-type="dijit.form.TextBox" id="myField1" name="myField"
		 * value="&myValue"&gt;&lt;/div&gt;
		 * 
		 * the following node will be generated
		 * 
		 * <myField>&amp;myValue</myField>
		 * 
		 * Note that we use the name, and not the ID. Therefore, there could be
		 * duplicate tags in a given XML structure, if this is not correctly
		 * managed by the developer
		 * 
		 * If no name is found, we return the empty string.
		 * @param {Dijit._Widget || String} node
		 *  Node/widget to be converted to XML string. 
		 * @method fieldToXML 
		 */
		fieldToXML : function( /*Dijit._Widget | String*/ node) {
			// summary:
			//		Utility function to generate an XML string from a given field or reference
			//
			// description:
			//		e.g. for the field
			//
			//  <div data-dojo-type="dijit.form.TextBox" id="myField1"
			//					name="myField" value="&myValue"></div>
			//
			//	    the following node will be generated
			//
			//  <myField>&amp;myValue</myField>
			//
			//	Note that we use the name, and not the ID. Therefore, there could be duplicate
			//  tags in a given XML structure, if this is not correctly managed by the developer
			//
			//	If no name is found, we return the empty string.
			
			var field = dj.byId(node), 
				fieldName = field.get("name"),
				tag = [];
			
			if(fieldName) {
				tag.push("<", fieldName, ">",
						d.trim(dojox.html.entities.encode(field.get("value"), 
								dojox.html.entities.html)),
						"</", fieldName, ">");
			}
			
			return tag.join("");
		},
		/**
		 * <h4>Summary:</h4> Utility function to generate an XML string from a given
		 * DOM element identified by its node name.
		 * 
		 * If no element is found, we return the empty string.
		 * @param {DOM fragment} dom
		 * @param {String} nodeName 
		 * @method getDomNode 
		 */
		getDomNode : function( /*Dom Fragment*/ dom, 
				  			   /*String*/ nodeName) {
			//  summary:
			//          Gets the tag nodeName and its value from the
			//          DOM fragment

			var nodes = dom.getElementsByTagName(nodeName),
				xml = [],
				node;
			
			if(nodes.length > 0) {
				xml.push("<", nodeName, ">");
				node = nodes[0].childNodes[0];
				if(node && node.nodeValue) {
					xml.push(dojo.isString(node.nodeValue)?dojox.html.entities.encode(node.nodeValue, dojox.html.entities.html) : node.nodeValue);
				}
				xml.push("</", nodeName, ">");
			}

			return xml.join("");
		},
		/**
		 * <h4>Summary:</h4>
		 *  Gets the tag nodeName and its value from the
		 *  DOM fragment
		 *  @param {DOM Fragment} dom
		 *  @param {String} Node name
		 *  @method getDomValue
		 */
		getDomValue : function( /*Dom Fragment*/ dom, 
	  			   /*String*/ nodeName) {
			//  summary:
			//          Gets the tag nodeName and its value from the
			//          DOM fragment
			
			var nodes = dom.getElementsByTagName(nodeName),
				xml = [],
				node;
			
			if(nodes.length > 0) {
				node = nodes[0].childNodes[0];
				if(node && node.nodeValue) {
					xml.push(dojo.isString(node.nodeValue)?dojox.html.entities.encode(node.nodeValue, dojox.html.entities.html) : node.nodeValue);
				}
			}
			
			return xml.join("");
			},

		// TODO Needs another refactor; we should probably take JSON as a param instead
		// of an ever increasing array, cause noone remembers the order of the params
		/**
		 * <h4>Summary:</h4> Toggle the display and enabling/disabling of fields
		 * 
		 * <h4>Description:</h4> 
		 * - guardPassed true when some test is passed 
		 * - fieldIDs array of ids of non-required fields. Pass null if there
		 * are none 
		 * - requiredFieldIDs array of ids of required fields. Pass
		 * null if there are none
		 * - keepFieldValues true if the current
		 * value of the fields should be preserved
		 * - keepFieldsEnabled true if the field should remain enabled at all times
		 * @param {Boolean} guardPassed
		 * @param {Array} fieldIDs
		 * @param {Array} requiredFieldIDs
		 * @param {Boolean} keepFieldValues
		 * @param {Boolean} keepFieldsEnabled
		 * @method toggleFields
		 * 
		 */
		toggleFields : function(/*Boolean*/ guardPassed,
		          				/*Array*/ fieldIDs, 
		          				/*Array*/ requiredFieldIDs,
		          				/*Boolean*/ keepFieldValues,
		          				/*Boolean*/ keepFieldsEnabled) {
			//  summary:
			//        Toggle the display and enabling/disabling of fields
			//  description:
			//      - guardPassed true when some test is passed
			//      - fieldIDs array of ids of non-required fields. Pass null if there are none
			//      - requiredFieldIDs array of ids of required fields. Pass null if there are none.
			//      - keepFieldValues true if the current value of the fields should be preserved
			//      - keepFieldsEnabled true if the field should remain enabled at all times  
			
			var requiredPrefix = m._config.requiredFieldPrefix || "*", 
				allFields = requiredFieldIDs,
				requiredStartIndex = 0,
				checkboxRegex = /Check/,
				dateRegex = /Date/,
				timeRegex = /Time/;
			
			// Setup array, with non-required in first half
			if(fieldIDs && d.isArray(fieldIDs)) {
				if(requiredFieldIDs && d.isArray(requiredFieldIDs)) {
					allFields = fieldIDs.concat(requiredFieldIDs);
				} else {
					allFields = fieldIDs;
				}
				requiredStartIndex = fieldIDs.length;
			}

			d.forEach(allFields, function(id, i){
				var field = dj.byId(id);
				if(field) {
					// Clear the value
					if(!guardPassed && !keepFieldValues) {
						var declaredClass = field.declaredClass;
						var clearValue = "";
						if(checkboxRegex.test(declaredClass)) {
							clearValue = false;
						}
						else if(dateRegex.test(declaredClass) || (timeRegex.test(declaredClass))) {
							clearValue = null;
						}
						field.set("value", clearValue);
					}
		
					if(keepFieldsEnabled)
					{
						field.set("readOnly", false);
						field.set("disabled", false);
					}
					else
					{
						field.set("readOnly", !guardPassed);
						field.set("disabled", !guardPassed);
					}

					// Setup required fields
					if(i >= requiredStartIndex) {
						field.set("required", guardPassed);
						// If field is not required, call validate to remove the "error" style from previous calls
						// (Check validate function exists, since it currently doesn't for textareas)
						if(!guardPassed && field.validate) {
							field.validate(false);
						}

						// Set the fields row class attribute and required prefix,
						// to signal a required field.
						var row = d.byId(id + "_row");
						if(row) {
							var fieldLabel = d.query("label[for="+id+"]")[0];

							// Add required class to row
							d.toggleClass(row, "required", guardPassed);

							// Add the required prefix
							var labelString = "";
							if(guardPassed) {
								if(fieldLabel &&
										fieldLabel.innerHTML.indexOf(requiredPrefix) === -1) {
									// setting a checkbox as required makes no sense
									if(!(checkboxRegex.test(declaredClass))) {
										d.place(d.create("span", {
											"class" : "required-field-symbol",
											innerHTML : requiredPrefix
										}), fieldLabel, "first");
									}
								}
							} else {
								if(fieldLabel && 
										fieldLabel.innerHTML.indexOf(requiredPrefix) != -1) {
									// TODO We should show/hide the span, cause this probably
									// causes a reflow
									d.query("span", fieldLabel).orphan();
								}
							}
						}
					}
				}
			});
		}, 
		
		// TODO I think this is already covered by the toggleFields function
		// David R on 09/2011: I don't think so, this function allows to 
		// 	set a field to a certain state regardless of the previous one. 
		// But there is definitely duplicated code between the two functions.
		// Mannan: toggleFields(required, null, [node], true, true) does the same
		/**
		 * <h4>Summary:</h4> Set a field mandatory or not
		 * 
		 * <h4>Description:</h4> => Set Dojo validation on or off => Add a red star
		 * before label when mandatory 
		 * Warning : not working yet with Complex date !
		 * @param {Dijit._Widget || DomNode ||String} node
		 * @param {Boolean} required
		 * @method toggleRequired
		 */
		toggleRequired : function( /*dijit._Widget || DomNode || String*/ node,
                				   /*Boolean*/ required) {
			// 	summary:
			//		Set a field mandatory or not
			//
			//  description:
			//		=> Set Dojo validation on or off
			//		=> Add a red star before label when mandatory
			//  	Warning : not working yet with Complex date !
			
			var field = dj.byId(node);
			if (field){
				field.set("required", required);
				var listObj = d.query("#"+field.id+"_row > label");
				listObj.forEach(function(label){
					//Always remove old required
					d.query("span", label).orphan();
					//Add only if needed
					if(required) {
						d.create("span", {innerHTML:"*", "class":"required-field-symbol"}, 
												label, "first");
					}		
				});
			}
		},
		/**
		 * <h4>Summary:</h4> Set the state of a Dijit field
		 * @param {dijit._Widget} node
		 * @param {Boolean} isValid
		 * @method setFieldState
		 * 
		 */
		setFieldState : function( /*dijit._Widget*/ node, 
				 	   			  /*Boolean*/ isValid) {
			//
			// summary:
			//        Set the state of a Dijit
			//
			// TODO There must be a way of doing this thru standard dijit functions?

			node.state = (isValid) ? "" : "Error";
			node._setStateClass();
			dj.setWaiState(node.focusNode, "invalid", !isValid);
		},
		/**
		 * <h4>Summary:</h4> 
		 * Show a popup of confirmation to allow the deletion of a record.
		 * And do a post request after that.
		 * @param {String} strTitle
		 * @param {Object} args
		 * @method confirmDelete
		 * 
		 */
		confirmDelete : function( /*String*/ strTitle,
		                          /*Object*/ args) {
			//  summary:
			//         Show a popup of confirmation to allow the deletion of a record
			
			// TODO Should this be here? No reason that it needs to be abstracted
			
			if(strTitle.indexOf("<")!==-1)
			{
			strTitle = strTitle.replaceAll("<", "&lt;");
			}
			
			if(strTitle !== ""){				
				this.dialog.show("CONFIRMATION",
						this.getLocalization("deleteTransactionConfirmation", [strTitle]), "",
						function() {
							m.post(args);
						}
				);				
			}
			else{
				this.dialog.show("CONFIRMATION",
						this.getLocalization("deleteTransactionConfirmationforEmptyTitle"), "",
						function() {
							m.post(args);
						}
				);
			}			
		},
		/**
		 * <h4>Summary:</h4> 
		 * Show a popup of confirmation to allow the deletion of a role.
		 * And do a post request after that.
		 * @param {String} strTitle
		 * @param {Object} args
		 * @method warnDeleteRole
		 * 
		 */
		warnDeleteRole : function( /*String*/ strTitle,
			                /*Object*/ args) {
			//  summary:
			//         Show a popup of confirmation to allow the deletion of a role
			
			// TODO Should this be here? No reason that it needs to be abstracted
			
			if(strTitle.indexOf("<")!==-1)
			{
			strTitle = strTitle.replaceAll("<", "&lt;");
			}
			
			if(strTitle !== ""){
				
				var isRoleMapped = false;
				var roleType = null;
				for(var arg = 0; arg < args.params.length; arg ++)
				{
				    var arr = args.params[arg].name;
				    
				    if(arr == "Role_Type"){
				    	roleType = args.params[arg].value;
				    	break;
				    }
				}
				
				m.xhrPost({
					url : m.getServletURL("/screen/AjaxScreen/action/CheckRoleMapping"),
					handleAs : "json",
					preventCache : true,
					sync : true,
					content: {role_name : strTitle,
							  role_type : roleType},
					load : function(response, args){
						isRoleMapped = response.isRoleMapped;
					},
					error : function(response, args){
						isRoleMapped = false;
						console.error("Checking Role mapping  error ", response);
					}
				});
				
				if(isRoleMapped)
				{
					this.dialog.show("CONFIRMATION",
							this.getLocalization("deleteMappedRoleConfirmation", [strTitle]), "",
							function() {
								m.post(args);
							}
					);
				}
				else
				{
					this.dialog.show("CONFIRMATION",
							this.getLocalization("deleteRoleConfirmation", [strTitle]), "",
							function() {
								m.post(args);
							}
					);
				}
			}
			else{
				this.dialog.show("CONFIRMATION",
						this.getLocalization("deleteTransactionConfirmationforEmptyTitle"), "",
						function() {
							m.post(args);
						}
				);
			}			
		},
		/**
		 * Summary: Show a tooltip message on the given DOM node.
		 * 
		 * <h4>Description:</h4> 
		 * We implement our own wrapper to showTooltip as otherwise
		 * the tooltip will never hide until hideTooltip is manually called.
		 * 
		 * @param {String} message
		 *  Message to be shown with the tool tip
		 * @param {DomNode || String} node
		 *  Node on which tooltip is to be shown
		 * @param {Array} position
		 *  Position for the tool tip
		 * @param {Number}
		 *  Time Out for the tool tip
		 * @method showTooltip
		 * 
		 */
		showTooltip : function( /*String*/message, 
                				/*DomNode || String*/ node, 
                				/*String[] array*/ position, 
                				/*Number*/ timeout) {
			//  summary:
			//        Show a tooltip message on the given DOM node.
			//
			//	description:
			//		  We implement our own wrapper to showTooltip as otherwise the tooltip
			//		  will never hide until hideTooltip is manually called.

			var domNode = d.byId(node);
			if(domNode) {
				setTimeout(function(){
					dj.hideTooltip(domNode);
				}, (timeout || _defaultTooltipTimeout));
				return dj.showTooltip(message, domNode, position);
			}
		}, 
	/**
	 * <h4>Summary:</h4> Toggles the bank-side transaction details
	 * 
	 * <h4>Description:</h4> 
	 * Without the third parameter, this method will toggle the display of the transaction
	 * depending on whether it is currently visible or not. When forceShow is true,
	 * we will try to show the transaction regardless.
	 * 
	 * @param {Boolean} show
	 *  Show the details if it is true
	 * @param {Boolean} showConfirmation
	 *  Show confirmation dialog if it is true
	 * @param {Function} callback 
	 *  Call back function
	 * @method toggleTransaction
	 */
		toggleTransaction : function( /*Boolean*/ show,
									  /*Boolean*/ showConfirmation,
				  					  /*Function*/ callback) {
			// <h4>Summary:</h4> 
			//         Toggles the bank-side transaction details
			// description:
			//			Without the third parameter, this method will
			//			toggle the display of the transaction depending 
			//			on whether it is currently visible or not. When forceShow
			//			is true, we will try to show the transaction regardless.

			var transaction = d.byId("transactionDetails"),
				editLink = d.byId("editTransactionDetails"),
				hideLink = d.byId("hideTransactionDetails"),
				fadeInCallback = callback || function(){},
				chain = dojo.fx.chain([]);

//			if(!transaction || !editLink || !hideLink) {
//				// All three must be present to continue, so just fire the
//				// callback and return
//				fadeInCallback();
//				return chain;
//			}
				
			// onLoad, the transactionDetails element will be absolutely positioned
			// offscreen, so the first time we call this, we have to reset it to:
			//
			// 		position: inherit, left:0 , display: none
			//
			//	or, for IE6
			//
			//		position: inherit, right: auto, overflow: auto
			
			// This is to fix an occasional issue with widget instantiation, and also
			// for accessibility reasons (absolutely positioned content is still spoken
			// by a screenreader, display:none isn't)
			
			if(d.style(transaction, "position") === "absolute") {
				d.style(transaction, "position", "inherit");
				d.style(transaction, "display", "none");
				if(d.isIE !== 6) {
					d.style(transaction, "left", 0);
				} else {
					d.style(transaction, "right", "auto");
				}
			}
				
			if(show) {
				var action = function(){
					if(editLink)
					{
						return m.animate("fadeOut", editLink, function(){
							dojo.style(transaction, "display", "none");
							dojo.removeClass(transaction, "offscreen");
							m.animate("wipeIn", transaction, function(){
								m.animate("fadeIn", hideLink, fadeInCallback);
									
								// We have to call resize on all tabcontainers, to fix
								// an occasional rendering issue
								dojo.query(tabContainr).forEach(function(t){
									var tabc = dijit.byId(t.id);
									if(tabc.resize && d.isFunction(tabc.resize)) {
										tabc.resize();
									}
								});
							});
						});
					}
					else
					{
						return fadeInCallback();
					}
					
				};
				if(showConfirmation){
					m.dialog.show(
							"CONFIRMATION",
							m.getLocalization("editTransactionConfirmation"),
							null,
							action);
				} else {
					return action();
				}
			} else {
				return m.animate("wipeOut", transaction, function(){
					dojo.addClass(transaction, "offscreen");
					m.animate("fadeOut", hideLink, function(){
						m.animate("fadeIn", editLink, fadeInCallback);
					});
				});
			}
			
			// default return, empty animation chain
			return chain;
		},
		
		/**
		 * <h4>Summary:</h4>
		 * Toggles the amendment details
		 * 
		 * <h4>Description:</h4>
		 * Without the third parameter, this method will toggle the display of
		 * the amendment details depending on whether it is currently visible or
		 * not. When forceShow is true, we will try to show the amendment
		 * details regardless.
		 * 
		 * @param {Boolean}
		 *            show Show the details if it is true
		 * @param {Boolean}
		 *            showConfirmation Show confirmation dialog if it is true
		 * @param {Function}
		 *            callback Call back function
		 * @method toggleAmdDetails
		 */		
		toggleAmdDetails : function( /* Boolean */ show,
				  /* Boolean */ showConfirmation,
				  /* Function */ callback) {
		
			var transaction = d.byId("amdDetails"),
			editLink = d.byId("showAmdDetails"),
			hideLink = d.byId("hideAmdDetails"),
			fadeInCallback = callback || function(){},
			chain = dojo.fx.chain([]);
			
			// onLoad, the transactionDetails element will be absolutely positioned
			// offscreen, so the first time we call this, we have to reset it to:
			//
			// 		position: inherit, left:0 , display: none
			//
			//	or, for IE6
			//
			//		position: inherit, right: auto, overflow: auto
			
			// This is to fix an occasional issue with widget instantiation, and also
			// for accessibility reasons (absolutely positioned content is still spoken
			// by a screenreader, display:none isn't)
			
			if(d.style(transaction, "position") === "absolute") {
			d.style(transaction, "position", "inherit");
			d.style(transaction, "display", "none");
			if(d.isIE !== 6) {
			d.style(transaction, "left", 0);
			} else {
			d.style(transaction, "right", "auto");
			}
			}
			
			if(show) {
			var action = function(){
			if(editLink)
			{
				return m.animate("fadeOut", editLink, function(){
					dojo.style(transaction, "display", "none");
					dojo.removeClass(transaction, "offscreen");
					m.animate("wipeIn", transaction, function(){
						m.animate("fadeIn", hideLink, fadeInCallback);
							
						// We have to call resize on all tabcontainers, to fix
						// an occasional rendering issue
						dojo.query(tabContainr).forEach(function(t){
							var tabc = dijit.byId(t.id);
							if(tabc.resize && d.isFunction(tabc.resize)) {
								tabc.resize();
							}
						});
					});
				});
			}
			else
			{
				return fadeInCallback();
			}
			
			};
			if(showConfirmation){
			m.dialog.show(
					"CONFIRMATION",
					m.getLocalization("editTransactionConfirmation"),
					null,
					action);
			} else {
			return action();
			}
			} else {
			return m.animate("wipeOut", transaction, function(){
			dojo.addClass(transaction, "offscreen");
			m.animate("fadeOut", hideLink, function(){
				m.animate("fadeIn", editLink, fadeInCallback);
			});
			});
			}
			
			// default return, empty animation chain
			return chain;
		},
		
		
		
		/**
		 * <h4>Summary:</h4> 
		 * Create a table of contents ie. a summary of the form.
		 * @method createTOC
		 */
		createTOC : function(){
			//  summary:
		    //        Create a table of contents ie. a summary of the form.
			
			var toc = d.byId("toccontent");
			if(toc) {
				console.debug("[misys.common] Creating table of contents (TOC) ... ");
			
				// If the menu is already open, close it
				if(d.style(toc, "display") === "block") {
					m.toggleTOC();
				}

				var counter = 0,
				    tocRoot = d.create("ul");
			
				d.query(_tocItemSelector).forEach(function(legend){
					var headerId = legend.id || "link" + counter++;
					legend.id = headerId;
					var legendText;
					try {
						var labelChild = legend.firstChild;
						if(labelChild) {
							legendText = labelChild.innerHTML;
						}
					} catch(err){
						console.error("[m.form.common] There was an error building the TOC!");
						console.error(err);
					}
					 
					if(legendText && legendText !== ""){
						console.debug("[misys.common] Adding TOC entry for", legendText);
						var li = d.create("li");
						var a = d.create("a", {
							href: "javascript:void(0)",
							id: "goto_" + headerId,
							innerHTML: legendText
						}, li);
						d.place(li, tocRoot);
					}
				});
				d.empty(toc);
				d.place(tocRoot, toc);
				console.debug("[misys.common] TOC created with", counter, "entries");
			}
		},
		/**
		 * <h4>Summary:</h4> 
		 * Toggle the display of the table of contents (TOC).
		 * create a TOC if it is not there set attributes like width,opacity etc.
		 *  Use animate function for toggeling.Create a chain with node as tocConatiner
		 *  return chain.play() at the end.
		 * 
		 * @param {Function} callBack
		 * @method toggleTOC
		 * 
		 */
		toggleTOC : function( /*Function*/ callback) {
			//  summary:
		    //        Toggle the display of the table of contents (TOC).
			
			var tocContent = d.byId("toccontent");
			if(tocContent) {
				// If toc is empty, generate the summary
				if(tocContent.innerHTML === "") {
					m.createTOC();
				}
				
				var toggleTocLink = d.byId("toggleTocLink"),
					tocContainer = d.byId("toc"),
					show = (d.style(tocContent, "display") === "none"),
					width = (show) ? d.style(d.byId("toc"), "width") + 6 : 
										d.style(d.byId("toc"), "width") - 6,
					opacity = (show) ? 0.9 : 1,
					animation = (show) ? "wipeIn" : "wipeOut",
					linkText = (show) ? 
							m.getLocalization("hideFormSummaryMessage") : m.getLocalization("showFormSummaryMessage"),
					chain = [],
					animations = [];
					
				chain.push(d.animateProperty({
					node: tocContainer,
					properties: {
						width: width
					}
				}));

				animations = animations.concat(
									m.animate(animation, tocContent, null, true)._animations);
				animations.push(d.animateProperty({
									node: tocContainer, 
									properties: {opacity: opacity}}));
				chain = dojo.fx.chain(chain.concat(animations));
				
				d.connect(chain, "onBegin", function(){
					setTimeout(function(){
						toggleTocLink.innerHTML = linkText;
					}, 500);
				});
				d.connect(chain, "onEnd", function(){
					if(callback && d.isFunction(callback)){callback();}
				});
				
				return chain.play();
			}
		}, 
		/**
		 * <h4>Summary:</h4> 
		 * Returns the object value without spaces and CRLF.
		 * @param {String} str
		 * Object you want to trim
		 * @method trim
		 */
		trim : function( /*String*/ str) {
			//  summary:
			//          Returns the object value without spaces and CRLF.
			
			// TODO Examine regular expression solutions to this, for example
			// return str.replace(/(?:(?:^|\n)\s+|\s+(?:$|\n))/g,'').replace(/\s+/g,' ');
			
			var value = str + "",
			    result = [];
			
			d.forEach(value, function(c) {
				if((c !== "\r") && (c !== "\n")) {
			      result.push(c);
			    }
			});

			return d.trim(result.join(""));
		},
		/**
		 *  <h4>Summary:</h4>
		 *  Move items from one multi-select field to another mulit select field
		 *  @param {digit._Widget} target
		 *   Target widget to which items are to be moved
		 *  @param {digit._Widget}  source
		 *   Source widget from which items are to be moved
		 *  @method addMultiSelectItems
		 */
		addMultiSelectItems : function( /*dijit._Widget*/ target,
										/*dijit._Widget*/ source) {
			//  summary:
			//        Move items from one multi-select to another
			
			var targetWidget = dijit.byId(target),
				sourceWidget = dijit.byId(source);
			
			targetWidget.addSelected(sourceWidget);
			
			// Have to call focus, otherwise sizing issues in Internet Explorer
			sourceWidget.focus();
			targetWidget.focus();
		},
		/**
		 * Summary:
		 *  Insert a value into a textarea at the cursor.
		 *  @param {dijit._Widget} field
		 *  Field in which value to be set
		 *  @param {String} text
		 *  Value to be inserted in ot text area 
		 *  @method insertAtCursor
		 */
		insertAtCursor : function( /*dijit._Widget*/ field,
				   				   /*String*/ text) {
			//  summary:
		    //        Insert a value into a textarea at the cursor.
			
			var fieldNode = field.domNode,
			    fieldValue = field.get("value");
			if(document.selection) {
				field.focus();
				var sel = window.getSelection();
				sel.text = text;
				field.set("value", fieldValue + text);
			} else if(fieldNode.selectionStart || fieldNode.selectionStart == "0"){
				field.set("value", fieldValue + text);
			} else{
				field.set("value", fieldValue + text);
			}
		},
		/**
		 * <h4>Summary:</h4> Resize all the charts in the page
		 * Query for all the nodes with css class as _chartSelector.
		 * resize all ten charts .
		 * @method resizeCharts
		 * 
		 */
		resizeCharts : function() {
			// summary: Resize all the charts in the page
			//

			var charts = d.query(_chartSelector);
			if(charts.length > 0) {
				if(_resizeChartTimeoutHandle) {
					clearTimeout(_resizeChartTimeoutHandle);
				}
				_resizeChartTimeoutHandle = setTimeout(function(){_resizeCharts(charts);}, 
						_defaultResizeTimeout);
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * Resize all the grids in the page
		 * Query for all the grids and resixe the grids by providing a time out.
		 * @method resizeGrids
		 */
		resizeGrids : function() {
			// summary: Resize all the grids in the page
			//
			
			var grids = d.query(_gridClassSelector),
				// Increase the timeout for IE6, give it time to recover
				timeout = (d.isIE <= 6) ? 2000 : 200;
			
			if(grids.length > 0) {
				if(_resizeGridTimeoutHandle) {
					clearTimeout(_resizeGridTimeoutHandle);
				}
				_resizeGridTimeoutHandle =
					setTimeout(function(){_resizeGrids(grids);}, timeout);
			}
		},
		
		/**
		 * <h4>Summary:</h4>
		 * Get an image map for a given chart
		 * @param {String} url
		 * @param {String} targetId
		 * @param {String} dealId
		 * @method getChartImageMap
		 */
		getChartImageMap : function( /*String*/ url,
									 /*String*/ targetId, 
									 /*String*/ dealId, 
									 /*String*/ borrowerId){
			// summary: 
			//		Get an image map for a given chart
			
			m.xhrGet( {
				url : m.getServletURL("/screen/AjaxScreen/action/" + url),
				handleAs : "text",
				contentType: "text/html; charset=utf-8",
				content : {
					getmap: "true",
					dealID: dealId,
					borrowerID: borrowerId
				},
				load : function(response){
					d.byId(targetId).innerHTML = response;
				}
			});
		},
		/**
		 * <h4>Summary:</h4>
		 * This function shows chart dialog
		 * @param {String} id
		 * @method showChartDialog
		 */
		showChartDialog : function( /*String*/ id){
			// summary:
			//
			var chartImg = d.create("img", {
				src: d.attr(d.byId(id), "alt") + "&chartwidth=" + 
			    		_defaultChartInDialogWidth + "&chartheight=" +
			    		_defaultChartInDialogHeight,
				width: _defaultChartInDialogWidth,
				height: _defaultChartInDialogHeight,
				alt: "Chart"
			});

			if(!_chartDialog) {
				_chartDialog = new misys.widget.Dialog({
					onLoad: function(){
						var that = this;
						setTimeout(function() {
							that.show();
						}, dj.defaultDuration);
					}
				});
			}
			
			_chartDialog.set("width", _defaultChartInDialogWidth + 50);
			_chartDialog.set("height", _defaultChartInDialogHeight + 50);
			_chartDialog.set("content", chartImg);
			_chartDialog.show();
		},
		/**
		 * <h4>Summary:</h4>
		 * Return true if node/widget is visible in the viewport
		 * @param {dijit._Widget || DomNode} node
		 * @method isVisible
		 */
		isVisible : function(/*dijit._Widget || DomNode*/ node){
			// summary:
			//		Return true if node/widget is visible in the viewport
			
			if(!node) {
				return false;
			}
			
			var p;
			if(node.domNode){ node = node.domNode; }
			/*jsl:ignore*/
			return (dojo.style(node, "display") != "none") &&
				(dojo.style(node, "visibility") != "hidden") &&
				(p = dojo.position(node), (p.y + p.h >= 0) && 
						(p.x + p.w >= 0) && (p.h && p.w));
			/*jsl:end*/
		},
		/**
		 * This function is overriden in Product Bindings
		 * @method beforeSubmitValidations
		 */
		beforeSubmitValidations : function(){
			// summary:
			// 	 this is overridden in the product bindings

			return true;
		},
		/**
		 * This function is overriden in Product Bindings
		 * @method beforeSaveValidations
		 */
		beforeSaveValidations : function(){
			// summary:
			// 	 this is overridden in the product bindings

			return true;
		},
		
		/**
		 * This function can be overridden in Product Bindings
		 * @method onCancelNavigation
		 */
		onCancelNavigation : function(){
			return m._config.homeUrl;
		},
		/**
		 * This function is overriden in Product Bindings
		 * @method beforeSaveValidations
		 */
		setCustomConfirmMessage : function(){
			//   summary: This sets the customized confirmation message for submit
			// 	 this is overridden in the product bindings
		},
		/**
		 * <h4>Summary:</h4> 
		 * Returns a localized date of a date field.
		 *  
		 * <h4>Description:</h4> 
		 * Return the date of the field in a standard format, for comparison. If
		 * the field is hidden, we convert it to a standardized format for
		 * comparison, otherwise we simply return the value.
		 * @param {dijit._Widget} dateField
		 * @method localizeDate
		 */
		localizeDate : function( /*dijit._Widget*/ dateField) {
			//  summary:
		    //        Returns a localized date of a date field.
			//  description:
			//        Return the date of the field in a standard format, for comparison. If the field 
			//        is hidden, we convert it to a standardized format for comparison, otherwise we 
			//        simply return the value.
			
			var dateFieldValue = dateField.get("value");
			if(dateField.get("type") === "hidden") {
				return d.date.locale.parse(dateFieldValue, {
					selector :"date",
					datePattern : m.getLocalization("g_strGlobalDateFormat")
				});
			}
			
			return dateFieldValue;
		},
		/**
		 * <h4>Summary:</h4>
		 * Validates the data range for a search screen.
		 * @method validateSearchStartEndDates
		 */
		validateSearchStartEndDates : function() {			
			//  summary:
		    //        Validates the date range for a search screen. 
		    var start = dj.byId("dttm_begin"),
			end = dj.byId("dttm_end");
			if (end && end.get('value') === null)
			{
				return true;
			}
			if(start && end)
			{
				if (!m.compareDateFields(start, end))
				{
					this.invalidMessage = m.getLocalization("dateRangeValidityMessage");
					return false;
				}
			}
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function compares two date fields
		 * Get the localised value of both the dates if both are present 
		 *  then comapre them using <b>dojo.date.compare</b> function
		 * @param {dijit._Widget} earlyDateField
		 * @param {dijit._Widget} lateDateField
		 * @method compareDateFields
		 */
		compareDateFields : function( /*dijit._Widget*/ earlyDateField,
				 					  /*dijit._Widget*/ lateDateField) {
			//  summary:
		    //        Compares two date fields.
			
			var lateDateFieldValue,
				earlyDateFieldValue,
				standardizedEarlyDate,
				standardizedLaterDate;
			
			if(earlyDateField && lateDateField) {
				earlyDateFieldValue = earlyDateField.get("value");
				lateDateFieldValue = lateDateField.get("value");
				
				if(earlyDateFieldValue && lateDateFieldValue) {
					console.debug("[misys.common] Performing date comparison validation");
					standardizedEarlyDate = m.localizeDate(earlyDateField);
					standardizedLaterDate = m.localizeDate(lateDateField);
					
					console.debug("[misys.common] Early Date [", earlyDateField.id, "] = ", 
							standardizedEarlyDate);
					console.debug("[misys.common] Later Date [", lateDateField.id, "] = ", 
							standardizedLaterDate);

					if(d.date.compare(standardizedLaterDate, standardizedEarlyDate) < 0){
						return false;
					}
				}
			}
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 *   Show a popup of confirmation to allow the cancellation of a record.
		 *   Do a post after that.
		 *   @param {String} strTitle
		 *   @param {Object} args
		 *   @method confirmMCCancel
		 */
		confirmMCCancel : function( /*String*/ strTitle,
                					/*Object*/ args) {
			//  summary:
			//         Show a popup of confirmation to allow the cancel of a record
			
			this.dialog.show("CONFIRMATION",
				this.getLocalization("cancelMCTransactionConfirmation", [strTitle]), "",
				function() {
					m.post(args);
				}
			);
		},
		
		// 
		/**
		 * <h4>Summary:</h4> This method trim the amount value to remove characters ','
		 * space and removes the 0's in decimal if unnecessory
		 * 
		 * <h4>Description:</h4> This is basically used in re-authentication to have
		 * consistancy in java and javascript side.
		 * @param {String} amount
		 * @method trimAmount
		 * 
		 */
		trimAmount : function(/*String*/ amount){
			
			//Summary: This method trim the amount value to remove characters ',' space and removes the 0's in decimal if unnecessory
			
			// Description: This is basically used in re-authentication to have consistancy in java and javascript side.
			// ex: javascript value: 12,345.00 and java value: 12345 (this method coverts the 12,345.00 to 12345 in javascript side)
				
			var amountInDigits = (""+amount+"").replace(/[^\d.]/g, '');
			var dotIndex = amountInDigits.indexOf(".");
			var strlength = amountInDigits.length;
			var trimeAmountInDigits = amountInDigits;

			if(dotIndex !== -1)
			{
				for (var v=strlength;v>dotIndex;v--)
				{
					var n = amountInDigits.charAt(v-1);
					if(n === '0' || n === '.')
					{
						trimeAmountInDigits = trimeAmountInDigits.substring(0,v-1);
					}
					else
					{
						break;
					}
				}
			}

			return trimeAmountInDigits;
				
		},
		
		/**
		 *<h4>Summary:</h4>
		 *Formats the export list
		 *@param {String} format
		 *	Format to be set to the export_list id.
		 *@method exportListToFormat
		 */
		exportListToFormat : function (/*String*/format)
		{
			if(d.byId(_transactionSearchFormId)) 
			{
				dj.byId("export_list").set("value",format);
				d.create("input", {type: "hidden", name: "searchFlag", value: "true"}, TransactionSearchForm);
				dj.byId("TransactionSearchForm").submit();
				dj.byId("export_list").set("value","screen");
			}
		},
		
		/**
		 * Formats the export list, sets account_no to blank befor form submit and then set it back to existing value
		 *@param {String} format
		 *	Format to be set to the export_list id.
		 *@method exportListFormat
		 */
		exportListFormat : function (/* String */format)
		{
			if(d.byId(_transactionSearchFormId))
			{
				dj.byId("export_list").set("value",format);
				var form = dj.byId("TransactionSearchForm");
				var acctNo = dj.byId('account_no');
				var acctNoValue = dj.byId('account_no').get('value'); 
				var entityfield = dj.byId("entity");
				var hideTT;
				
				if (dj.byId("operation") && dj.byId("operation").get("value") === 'LIST_BALANCES')
				{
					if (entityfield && entityfield.get("value") === "")
					{
						m.dialog.show("ERROR", m.getLocalization("entityNotSelectedError"));
						return;
					}	
				}
				else if(dj.byId("operation") && dj.byId("operation").get("value") === 'LIST_STATEMENTS')
				{
						if(entityfield && entityfield.get("value") === "" )
						{
							m.dialog.show("ERROR", m.getLocalization("entityNotSelectedError"));
							dj.byId("export_list").set("value","");
							return;
						}
						if (acctNo.get('value') === "" )
						{
							m.dialog.show("ERROR", "Please select an account.");
							dj.byId("export_list").set("value","");
							return;
						}
				}
				if(dijit.byId("is_acc_mandatory") && acctNoValue == "")
				{
					m.dialog.show("ERROR", m.getLocalization("EmptyAccountError"));
				}
				else
				{
					if(dijit.byId('account_id') && dijit.byId('account_id').get('value'))
					{
						dijit.byId('account_no').set('required', false);
						dijit.byId('account_no').set('value', '');
					}
					var dateRange;
					var createDate;
					var createDate2;
					var today;
					var createDate2Str;
					//if (format === 'swift') 
					//{
						//var previousDay = dj.byId('Previous Day').get('value');
						//dateRange = dj.byId('dateRange').get('value');
						//createDate = dj.byId('create_date').get('value');
						//createDate2 = dj.byId('create_date2').get('value');
						//today = dj.byId('today').get('value');
						//AF, to fix MPG-4738 & MPG-4744
						//createDate2Str = dojo.date.locale.format(createDate2, {datePattern: "dd/MM/yyyy", selector: "date"});
						//createDate2Str = dojo.date.locale.format(createDate2, {datePattern: misys.getLocalization('g_strGlobalDateFormat'), selector: "date"});
						//AF, to fix MPG-4738 & MPG-4744 - end
						// only Previous day and Date range is 1 day is allowed for MT940 download
						//if ((previousDay === '2') || 
					         //((dateRange === '5') &&
					           //(dojo.date.compare(createDate, createDate2) == 0) &&
					             //!(today === createDate2Str)))
						//{
							//form.submit();
						//} else {
							//m.dialog.show("ERROR", m.getLocalization("MT940ExportError"));
						//}
					//}
					if (format === 'swift941' || format === 'swift942') 
					 {
						// MT941 & MT942 download is NOT allowed for external account 
						if (dijit.byId('owner_type').get('value') == '05')
						{
							m.dialog.show("ERROR", m.getLocalization("ExternalAccountError"));
						} 
						else 
						{
							var currentDay = dj.byId('Current Day').get('value');
							dateRange = dj.byId('dateRange').get('value');
							createDate = dj.byId('create_date').get('value');
							createDate2 = dj.byId('create_date2').get('value');
							today = dj.byId('today').get('value');
							//AF, to fix MPG-4738 & MPG-4744
							//createDate2Str = dojo.date.locale.format(createDate2, {datePattern: "dd/MM/yyyy", selector: "date"});
							createDate2Str = dojo.date.locale.format(createDate2, {datePattern: misys.getLocalization('g_strGlobalDateFormat'), selector: "date"});
							//AF, to fix MPG-4738 & MPG-4744 - end
							// only Current day is allowed for MT941 & MT942 download
							if ((currentDay === '1') || 
						         ((dateRange === '5') &&
						           (dojo.date.compare(createDate, createDate2) == 0) &&
						             (today === createDate2Str)))
							{
								//AF, to fix MPG-2249
								if (format ==='swift942')
								{
									dj.byId("export_list").set("value",'swift');
								}
								//AF, MPG-2249 - end								
								form.submit();
							} 
							else 
							{
								m.dialog.show("ERROR", m.getLocalization("MT941942ExportError"));
							}
						}
					 } 
					 else 
					 {				
						 form.submit();
					 }
				}	
				if(dijit.byId('account_id') && dijit.byId('account_id').get('value'))
				{
					dijit.byId('account_no').set('value', acctNoValue);
					dijit.byId('account_no').set('required', true);
				}
				dj.byId("export_list").set("value","screen");	
			}
		},
		
		/**
		 *<h4>Summary:</h4>
		 *Formats the export list
		 *@param {String} format
		 *	Format to be set to the export_list id.
		 *@method exportListToFormatInXsl
		 */
		exportListToFormatInXsl : function (/*String*/format)
		{
			var facilityId = dijit.byId("facility_id") ? dijit.byId("facility_id").value :"";
			dojo.io.iframe._currentDfd = null;
			dojo.io.iframe.send({
				url:m.getServletURL("/screen/AjaxScreen/action/GetLimitData"),
				handleAs 	: "json",
				sync 		: true,
				content		:{
								option : format,
								facility_id : facilityId,
								token : document.getElementById("_token").getAttribute('value')
				}
				}); 

		},
		
		/** 
		*<h4>Summary:</h4>
		 *Formats the export list
		 *@param {String} format
		 *	Format to be set to the export_list id.
		 *@method exportListToFormatInXslRpmntSc
		 */
		exportListToFormatInXslPdfRpmntSc : function (/*String*/format,/*String*/ isAllColumn )
		{
			dojo.io.iframe._currentDfd = null;
			var form = document.createElement("FORM");
			form.setAttribute("id", "dummyform");
			document.body.appendChild(form);
			dojo.io.iframe.send({
				url:m.getServletURL("/screen/AjaxScreen/action/LoanRepaymentScheduleAction"),
				handleAs 	: "json",
				form 		: "dummyform",
				method		: "POST",
				sync 		: true,
				content		:{
								option : format,
								allColumn : isAllColumn,
								token : document.getElementById("_token").getAttribute('value')
				}
				}); 

		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function is to fetch the code data for Liquidity frequency 
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 */
		getFrequencyCodeData : function(frequency)
		{
			var codeFrqDesc;
			m.xhrPost( {
				url : m.getServletURL("/screen/AjaxScreen/action/GetFrequencyCodeData"),
				handleAs 	: "json",
				sync 		: true,
				content : {
					frequencyValue : frequency
				},
				load : function(response)
				{
					codeFrqDesc = response.items.long_desc ;
				},
				error : function()
				{
					codeFrqDesc = frequency;
				}
			});
			
			return codeFrqDesc;
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function is to fetch the code data for Liquidity Balance Type  
		 * <h4>Description:</h4>
		 * Have an AJAX call inside it
		 */
		getBalanceTypeCodeData : function(balance_type)
		{
			var balance_type_Desc;
			m.xhrPost( {
				url : m.getServletURL("/screen/AjaxScreen/action/GetBalanceTypeCodeData"),
				handleAs 	: "json",
				sync 		: true,
				content : {
					balance_type_Value : balance_type
				},
				load : function(response)
				{
					balance_type_Desc = response.items.long_desc ;
				},
				error : function()
				{
					balance_type_Desc = balance_type;
				}
			});
			
			return balance_type_Desc;
		},
		
		getsubGroupTypeData : function(subGrp_type)
		{
			var subGrp_type_Desc;
			m.xhrPost( {
				url : m.getServletURL("/screen/AjaxScreen/action/GetSubGrpTypeCodeData"),
				handleAs 	: "json",
				sync 		: true,
				content : {
					subGrp_type_Value : subGrp_type
				},
				load : function(response)
				{
					subGrp_type_Desc = response.items.long_desc ;
				},
				error : function()
				{
					subGrp_type_Desc = subGrp_type;
				}
			});
			
			return subGrp_type_Desc;
		},
				
		// This is the default implementation of the hook method called before the Assignee Type fields are displayed on the
		// Collaboration window [refere to misys.widget.Collaboration.js]. Individual binding files should overwrite this as needed
		/**
		 * This is the default implementation of the hook method called before the Assignee Type fields are displayed on the
		 * Collaboration window [refere to misys.widget.Collaboration.js]. Individual binding files should overwrite this as needed
		 * @param {Array} assigneeTypeFields
		 * @method preDisplayAssigneeType
		 */
		preDisplayAssigneeType : function(/*Array of Objects*/ assigneeTypeFields){
	    	 var taskMode = m._config.task_mode || "userandbank";
	    	 dojo.forEach(assigneeTypeFields, function(fieldObj){
	    		if(fieldObj.description === "user_to_bank" && dj.byId(fieldObj.id))
	    		{
	    			if(taskMode === "userandbank")
	    			{
	    				if(dj.byId(fieldObj.id))
	    				{
	    					dj.byId(fieldObj.id).set('disabled', false);
	    				}
	    				else
	    				{
	    					console.error("Could not find widget with id "+fieldObj.id);
	    				}	
	    			}
	    			else
	    			{
	    				if(dj.byId(fieldObj.id))
	    				{
	    					dj.byId(fieldObj.id).set('disabled', true);
		    				console.info("Tasks for Bank is not allowed. Disabling the radio button.");
	    				}
	    				else
	    				{
	    					console.error("Could not find widget with id "+fieldObj.id);
	    				}
	    			}	
	    		}	 
	    	});
	     },
	     
	     isFormDirty : false,
	     
	     isSystemButtonClicked : false,
	     
	     unsavedDataOption : "notset",
	     
	     excludedMethods : [{object: m, method: "submit"}],
	     
		/**
		 * Mark the current entry form as dirty.
		 * @method markFormDirty
		 */
	     markFormDirty : function(){
	    	m.isFormDirty = true;
	    	console.log("Form is dirty - unsaved changes exist"); 
	     },
	     
	     /**
	      * The unsaved data alert appears only if the form is dirty and no user selection exists yet
	      * Also, the alert appears only if a Save option exists on the screen and is NOT hidden
	      * @method isPopupRequired
	      */
	     isPopupRequired : function(){
	    	 /* The unsaved data alert appears only if the form is dirty and no user selection exists yet
	    	  * Also, the alert appears only if a Save option exists on the screen and is NOT hidden
	    	  */
	    	var popupRequired = false;
	    	if(m.isFormDirty && m.unsavedDataOption === "notset")
			{			
				if(dojo.query(".saveButton").length > 0){
					popupRequired = true;						
				}
			} 
	    	return popupRequired;
	     },
	     /**
	      * Unload listner when form is dirty
	      * First check for the form if it is dirty.If it is then unload the listner.
	      * @method unloadListener
	      */
	     unloadListener : function(){
			if(misys.isFormDirty && misys.isFormDirty === true && m._config.saveUnsavedData && m._config.saveUnsavedData === true)
			{
				
				if(m.unsavedDataOption === "save")
				{
				//	m.saveAsync("SAVE");
					return undefined;
				}else if(m.unsavedDataOption === "nosave")
				{
					console.log("Nothing to do here");
					return undefined;
				}else
				{
					return m.getLocalization("unsavedData");
				}	

				
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * Set unsaved data 
		 * @method setUnsavedDataOption
		 */
		setUnsavedDataOption : function(val){
			misys.unsavedDataOption = val;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for showing unsaved data dialog.
		 * @method showUnsavedDataDialog
		 */
		showUnsavedDataDialog : function(){
			var asyncMsgDialog = dijit.byId("unsavedDataDialog");
			var asyncMsgDialogButtons = dojo.byId('unsavedDataDialogButtons');
			var asyncMsgButton1 = dijit.byId('SaveContButton').domNode;
			var asyncMsgButton2 = dijit.byId('ContButton').domNode;
			var asyncMsgButton3 = dijit.byId('CancelButton').domNode;
			var asyncMsgWidgetContainer = dijit.byId('unsavedDataDialog').domNode;
			
			dojo.style(asyncMsgDialogButtons, 'display', 'block');
			dojo.style(asyncMsgButton1, 'display', inlneBlock);
			dojo.style(asyncMsgButton2, 'display', inlneBlock);
			dojo.style(asyncMsgButton3, 'display', inlneBlock);
			dojo.style(asyncMsgWidgetContainer, 'display', inlneBlock);
			asyncMsgDialog.set('title', misys.getLocalization('unsavedDataPreUnload'));
			
			// Disable window closing by using the escape key
			misys.dialog.connect(asyncMsgDialog, 'onKeyPress', function(evt) {
				if (evt.keyCode === dojo.keys.ESCAPE) {
					dojo.stopEvent(evt);
				}
			});
				
			misys.dialog.connect(dijit.byId('SaveContButton'), 'onMouseUp', function(){
				misys.dialog.disconnect(asyncMsgDialog);
				asyncMsgDialog.hide();
			}, asyncMsgDialog.id);
			misys.dialog.connect(dijit.byId('ContButton'), 'onMouseUp', function(){
				misys.dialog.disconnect(asyncMsgDialog);
				asyncMsgDialog.hide();
			}, asyncMsgDialog.id);
			misys.dialog.connect(dijit.byId('CancelButton'), 'onMouseUp', function(){
				misys.dialog.disconnect(asyncMsgDialog);
				asyncMsgDialog.hide();
			}, asyncMsgDialog.id);
			
			misys.dialog.connect(asyncMsgDialog, 'onHide', function() {
					misys.dialog.disconnect(asyncMsgDialog);
			});
			
			asyncMsgDialog.show();
		},
		reloadChartImg: function(){
			var chartContainer = dojo.query('#GTPRootPortlet > .portlet-section-body > div.widgetContainer');
			var form = dj.byId("TransactionSearchForm");
			var dateRegex = /Date/;
			var timeRegex = /Time/;
			
			if(form && chartContainer && chartContainer[0] && chartContainer[0].id) {
				var listdefId =  chartContainer[0].id.split("id")[1];
				var chartImg = dojo.query('#chart'+ listdefId)[0];
				
				if(chartImg && chartImg.src && chartImg.alt) {
					var chartAlt = chartImg.alt;
			
					form.getDescendants().forEach(function(field, i){
						if(field.name) {
							var value ;
							// special case if the field is a radio button
							if(field.declaredClass == 'dijit.form.RadioButton')
							{
								var radioDomNodes = dojo.query("[name='" + field.name + "']", form.domNode);
								// iterate through radio buttons
								d.some(radioDomNodes, function(radioDomNode){
									var radioWidget=dj.byNode(radioDomNode.parentNode);
									// if the radio button checked get its value
									if(radioWidget.checked)
									 {
										value = radioWidget.params.value;
									 }
									
								});
							}
							else
							{
								value = field.get("value");
							}
							if(dateRegex.test(field.declaredClass) || (timeRegex.test(field.declaredClass))) {
								value = field.get("displayedValue");
							}
							if(value === " ") {
								value = "";
							}
							if(field.type !== 'hidden') {
								chartAlt = _setParamsToURLString(chartAlt, field.get("name"), value);
							}
							
						}
					});
					chartImg.alt = chartAlt;
					m.resizeCharts();
				}
			}
		},

		/**
		 * <h4>Summary:</h4>
		 * 
		 * This function returns the prepared the warning message(by using variable misys._config.warningMessages) 
		 * in applicable scenario at the point of submission context.
		 * 
		 * @method formApplicableWarningMsg
		 */
	     formApplicableWarningMsg : function() {
	    	
			var submitMsg = m._config.globalSubmitConfirmationMsg;
			var warningMessagesSize = misys._config.warningMessages ? misys._config.warningMessages.length : 0;
			
			if(warningMessagesSize > 0)
			{
				var i;
				var messagesWithLineBreaks = "<b><ol>";
				for(i = 0; i < warningMessagesSize; i++)
				{
					messagesWithLineBreaks += ("<li>"+ misys._config.warningMessages[i]+ "</li>");
				}
				
				messagesWithLineBreaks += "</ol></b>";
				
				submitMsg = misys.getLocalization("submitTransactionConfirmationWithWarning",[ messagesWithLineBreaks ]);
			}
			
			return (submitMsg && submitMsg !== "") ? submitMsg : "";
	     },

		  toggleErrorSection : function( /*Function*/ callback) {
				//  summary:
			    //        Toggle the display of the table of contents (Error Section).
				
				var errorContent = d.byId("errorContent");
				if(errorContent) {
					
					var errorLink = d.byId("errorLink"),
						errorContainer = d.byId("errorSection"),
						show = (d.style(errorContent, "display") === "none"),
						width = (show) ? d.style(d.byId("errorSection"), "width") + 6 : 
											d.style(d.byId("errorSection"), "width") - 6,
						opacity = (show) ? 0.9 : 1,
						animation = (show) ? "wipeIn" : "wipeOut",
						linkText = (show) ? 
								m.getLocalization("hideErrorSectionMessage") : m.getLocalization("showErrorSectionMessage"),
						chain = [],
						animations = [];
						
					chain.push(d.animateProperty({
						node: errorContainer,
						properties: {
							width: width
						}
					}));

					animations = animations.concat(
										m.animate(animation, errorContent, null, true)._animations);
					animations.push(d.animateProperty({
										node: errorContainer, 
										properties: {opacity: opacity}}));
					chain = dojo.fx.chain(chain.concat(animations));
					
					d.connect(chain, "onBegin", function(){
						setTimeout(function(){
							errorLink.innerHTML = linkText;
						}, 500);
					});
					d.connect(chain, "onEnd", function(){
						if(callback && d.isFunction(callback)){callback();}
					});
					
					return chain.play();
				}
			},
			
			encryptText : function(passPhrase)
			{
				if(misys._config.clientSideEncryption)
				{
					var rsa = new RSAKey();
					var htmlUsedModulus = misys._config.htmlUsedModulus; 
					var crSeq = misys._config.cr_seq; 
	    			rsa.setPublic(htmlUsedModulus, '10001');
	                return rsa.encrypt(passPhrase)+crSeq;						
				}
				else
				{
					return passPhrase;
				}
			}
	});

  m.popup = m.popup || {};
  d.mixin(m.popup, {
	  //
	  // summary:
	  //	Functions for manipulating popups (meaning new windows). Previously this lived in
	  //    FormPopupEvents.js
	  /**
		 * <h4>Summary:</h4> 
		 * Open a popup window showing the details of an unsigned
		 * transaction record. This is used for Preview and Print purposes.
		 * @param {String} type
		 * 	Type as preview or print.
		 * @param {String} prodCode
		 *  Product code.
		 * @param {String} refId
		 *  reference id.
		 * @param {String} tnxId
		 *  Transaction id.
		 * @param {String} strScreen
		 *  Technical screen name.
		 * @method showPreview
		 */
	  showPreview : function( /*String*/ type,
              				  /*String*/ prodCode,
              				  /*String*/ refId,
              				  /*String*/ tnxId,
              				  /*String*/ tnxTypeCode,
              				  /*String*/ subTnxTypeCode,
              				  /*String*/ strScreen)
              	{			  
		  //  summary:
		  //            Open a popup window showing the details of an unsigned transaction record.
		  //            This is used for Preview and Print purposes. The localization code
		  var screenParam = "ReportingPopup",url = [] ;
		  
		  if (misys._config.isBank === 'false' && misys._config.fccuiEnabled && misys._config.fccuiEnabled === 'true' && m.isAngularProductUrl(prodCode, "")) {
				url.push("/view?");
				url.push("referenceid=", refId);
				url.push("&tnxid=", tnxId);
				url.push("&productCode=", prodCode);
				url.push("&subProductCode=", "");
				url.push("&mode=", "view");
				url.push("&operation=", "PREVIEW");
				url.push("&tnxTypeCode=", tnxTypeCode);
				url.push("&subTnxTypeCode=", subTnxTypeCode);
				url.push("&eventTnxStatCode=", "");
				var popup =	window.open(m.getServletURL('').replace(/.$/,"#") + url.join(""), '_blank', 'top=100,left=200,height=400,width=900,toolbar=no,resizable=no');
				popup.onload = function(){
				var windowName =misys.getLocalization("mainTitle");
				var productId =misys.getLocalization(prodCode);
				popup.document.title = windowName + ' - ' + productId;
				};
		} else {
		
		  var tnxIdParam = "",tnxTypeCodeParam = "",subTnxTypeCodeParam = "",
			 // Default reporting screen is ReportingPopup
			 parentTitleParam = "";

		  if(tnxId) {
			tnxIdParam = "&tnxid=" + tnxId;
		  }
		  if(tnxTypeCode && tnxTypeCode !== "") {
			  tnxTypeCodeParam = "&tnxtype=" + tnxTypeCode;
		  }
		  if(subTnxTypeCode && subTnxTypeCode !== "") {
			  subTnxTypeCodeParam = "&subtnxtype=" + subTnxTypeCode;
		  }

		  // Use the target screen if passed
		  if(strScreen) {
			screenParam = strScreen;
		  }

		  url = ["/screen/", screenParam];
		  url.push("?option=", type, "&titlecode=INFO_MSG_PREVIEW_UNCONTROLLED&referenceid=", 
					refId, tnxIdParam);
		  url.push(tnxTypeCodeParam);
		  url.push(subTnxTypeCodeParam);
		  url.push(prductCode, prodCode);
		  if(window.isAccessibilityEnabled && window.document.title && window.document.title !== ""){
			  url.push("&parenttitle=", window.document.title); 
			}
		  _openPopup(m.getServletURL(url.join("")));
		  }
	},
	/**
	 * <h4>Summary:</h4> 
	 * The logic associated with the different actions offered to the
	 * user on the page. 
	 * <b>Note:</b> option, refId, tnxId and prodCode parameters are
	 * only used for PDF export so far.
	 * @param {String} type
	 *	Different type of actions
	 * @param {String} option
	 * 	Different option under any action like
	 *  summary or full for export
	 * @param {String} refId 
	 *  Reference Id.
	 * @param {String} tnxId
	 *  Transaction id.
	 * @parm {String} prodCode
	 *  Product code.
	 * @method showSummary
	 */
	showSummary : function( /*String*/ type,
            				/*String*/ option,
            				/*String*/ refId,
            				/*String*/ tnxId,
            				/*String*/ prodCode) {
		//  summary:
		//         The logic associated with the different actions offered to the user on the page.
		//         Note: option, refId, tnxId and prodCode parameters are only used for PDF
		//         export so far.
		switch(type.toLowerCase()) {
		 case "print":
			d.global.print();
			break;
		 case "close":
			d.global.close();
			break;
		 case "export":
			if(option){
				option = option.toLowerCase();
				var pdfOption = option;
				if(option === "summary") {
					pdfOption = "EXPORT_PDF_SUMMARY";
				} else if(option === "full") {
					pdfOption = "EXPORT_PDF_FULL";
				} else if(option === "details") {
					pdfOption = "EXPORT_PDF_DETAILS";
				} else if(option === "pdf_ec_details") {
					pdfOption = "PDF_EC_DETAILS";
				} else if(option === "csv_bk_details") {
					pdfOption = "CSV_BK_DETAILS";
				}else if(option === "snapshot_pdf") {
					pdfOption = "SNAPSHOT_PDF";
				}
				 else if(option === "updated") {
						pdfOption = "EXPORT_PDF_FULL";
					} 
				//as options always will be upper case
				// in module files, convert the final option to upper case
				pdfOption = pdfOption.toUpperCase();

				var url = [reportingPopup];
				url.push("?option=", pdfOption);
				url.push(refrnceId, refId);
				if(tnxId && tnxId !== ""){
					url.push("&tnxid=", tnxId);
				}
				url.push(prductCode, prodCode);
				_openPopup(misys.getServletURL(url.join("")));
			}
			break;
		 default:
			break;
		}
	},
	/**
	 * <h4>Summary:</h4> 
	 * Export to PDF based on the given paramters. 
	 * @method showPDF
	 */
	showPDF : function(url) {
		_openPopup(misys.getServletURL(url));
	},
	
	/**
	 * <h4>Summary:</h4> 
	 * Show reporting summary popup.
	 * @param {String} type
	 *	 Option type like summary or full
	 * @param {String} prodCode
	 * 	Product code.
	 * @param {String} refId
	 *  Reference id.
	 * @param {String} tnxId
	 *  Transaction id.
	 * @param {String} strScreen
	 *  Target screen name.
	 * @method showReporting
	 */
	showReporting : function( /*String*/ type,
            				  /*String*/ prodCode, 
            				  /*String*/ refId, 
            				  /*String*/ tnxId,
            				  /*String*/ tnxTypeCode,
            				  /*String*/ subTnxTypeCode,
            				  /*String*/ tnxstatus,
            				  /*String*/ strScreen,
            				  /*String*/ subProductCode) {
		//  summary:
		//         Show reporting summary popup.
		
		var objPopReporting,
			prodCodeParam = [],
			refIdParam = [],
			tnxIdParam = [],
			parentTitleParam = [],
	        screenParam = "ReportingPopup",
	        url = [],
	        tnxTypeCodeParam = [],
	        subTnxTypeCodeParam = [],
	        tnxStatusParam = [];

		if (misys._config.isBank === 'false' && misys._config.fccuiEnabled && misys._config.fccuiEnabled === 'true' && m.isAngularProductUrl(prodCode, subProductCode)) {
			url.push("/view?");
			url.push("referenceid=", refId);
			url.push("&tnxid=", tnxId);
			url.push("&productCode=", prodCode);
			url.push("&subProductCode=", subProductCode);
			url.push("&mode=", "view");
			url.push("&operation=", "PREVIEW");
			url.push("&tnxTypeCode=", tnxTypeCode);
			url.push("&subTnxTypeCode=", subTnxTypeCode);
			url.push("&eventTnxStatCode=", tnxstatus);
			var popup =	window.open(m.getServletURL('').replace(/.$/,"#") + url.join(""), '_blank', 'top=100,left=200,height=400,width=900,toolbar=no,resizable=no');
			popup.onload = function(){
			var windowName =misys.getLocalization("mainTitle");
			var productId =misys.getLocalization(prodCode);
			popup.document.title = windowName + ' - ' + productId;
			};
	} 
		else {
		if(prodCode && prodCode !== ""){
			prodCodeParam.push(prductCode, prodCode);
		}

		if(refId && refId !== ""){
			refIdParam.push(refrnceId, refId);
		}

		if(tnxId && tnxId !== ""){
			tnxIdParam.push("&tnxid=", tnxId);
		}
		
		if(tnxTypeCode && tnxTypeCode !== "") {
			tnxTypeCodeParam.push("&tnxtype=", tnxTypeCode);
		 }
		
		if(subTnxTypeCode && subTnxTypeCode !== "") {
			subTnxTypeCodeParam.push("&subtnxtype=", subTnxTypeCode);
		 }
		if(tnxstatus && tnxstatus !== "") {
			tnxStatusParam.push("&tnxstatus=", tnxstatus);
		 }

		// Use the target screen if passed
		if(strScreen && strScreen !== ""){
			screenParam = strScreen;
		}

		url.push("/screen/", screenParam);
		url.push("?option=", type);
		url.push(refIdParam.join(""), tnxIdParam.join(""), prodCodeParam.join(""), tnxTypeCodeParam.join(""), subTnxTypeCodeParam.join(""), tnxStatusParam.join(""));
		//url.push("&tnxTypeCode=", tnxTypeCode);
		//url.push("&subTnxTypeCode=", subTnxTypeCode);
		if(window.isAccessibilityEnabled && window.document.title && window.document.title !== ""){
			parentTitleParam.push("&parentTitle=", window.document.title);
			url.push(parentTitleParam.join(""));
		}
		_openPopup(m.getServletURL(url.join("")));
	}
	}, 
	
	openIframePopup : function( /*String*/ type,
			  /*String*/ entitlementCode, 
			  /*String*/ entitlementDescription, 
			  /*String*/ companyAbbvName) {
//  summary:
//         Show entitlement view popup.

			var entitlementCodeParam = [],
			entitlementDescriptionParam = [],
			companyAbbvNameParam = [],
			parentTitleParam = [],
			screenParam = "IframePopup",
			url = [];
			
			if (misys._config.isBank === 'false' && misys._config.fccuiEnabled && misys._config.fccuiEnabled === 'true' && m.isAngularProductUrl(prodCode, subProductCode)) {
			url.push("/view?");
			url.push("entitlementcode=", entitlementCode);
			url.push("&companyabbvname=", companyAbbvName);
			url.push("&entitlementdescription=", entitlementdescription);
			url.push("&mode=", "view");
			url.push("&operation=", "PREVIEW");
			
			window.open(m.getServletURL('').replace(/.$/,"#") + url.join(""), '_blank', 'top=100,left=200,height=400,width=900,toolbar=no,resizable=no');
			} 
			else {
			if(entitlementCode && entitlementCode !== ""){
				entitlementCodeParam.push(entitlementCod, entitlementCode);
			}
			
			if(entitlementDescription && entitlementDescription !== ""){
				entitlementDescriptionParam.push(entitlementDescp, entitlementDescription);
			}
			
			if(companyAbbvName && companyAbbvName !== ""){
				companyAbbvNameParam.push("&companyAbbvName=", companyAbbvName);
			}
			url.push("/screen/", screenParam);
			url.push("?option=", type);
			url.push(entitlementDescriptionParam.join(""), companyAbbvNameParam.join(""), entitlementCodeParam.join(""));
			if(window.isAccessibilityEnabled && window.document.title && window.document.title !== ""){
			parentTitleParam.push("&parentTitle=", window.document.title);
			url.push(parentTitleParam.join(""));
			}
			_openPopup(m.getServletURL(url.join("")));
			}
}, 
	
	/**
     * <h4>Summary:</h4>
     * Show Popup.
     * This method will invokes the portlet which matches to the option with the post method.
     * The params that should pass to this method should in query string format(like refId=val1&product=LN etc).
     * @param {String}
     *            params.
     * @param {String}
     *            option.
     * @method showPopup
     */
     showPopup : function(  /* String */ params,option) {              

           var url = [];
                 url.push("/screen/", "ReportingPopup");
                 url.push("?option=", option);
                 
           var windowName =misys.getLocalization("transactionPopupWindowTitle");
                 
           var mapForm = document.createElement("form");
                 mapForm.target = windowName;
                 mapForm.method = "POST"; 
                 mapForm.action = m.getServletURL(url.join(""));
                 if(window.isAccessibilityEnabled && window.document.title && window.document.title !== ""){
           			params = params + "&parenttitle=" + window.document.title;
           		}
                 if(params){
                     var paramTokens=params.split("&");
                     for(var i = 0; i < paramTokens.length; i++) {         
                           if(paramTokens[i]){
                        	   if(paramTokens[i].indexOf("=") ==-1){
                                	paramTokens[i-1] = paramTokens[i-1] + "&" + paramTokens[i];
                                	var paramArr = Array.from(paramTokens);
                                	paramArr.splice(i,1);
                                	paramTokens = paramArr;
                                }
                           }
                     }
                     for(i = 0; i < paramTokens.length; i++) {
                    	 if(paramTokens[i]){
                                var token=paramTokens[i].split("=");                        
                                var mapInput = document.createElement("input");
                                mapInput.type = "hidden";
                                mapInput.name = token[0];
                                var value = token[1];
                                if(token.length > 2) {
                                	for(var j = 2; j<token.length; j++) {
                               		value = value + "=" + token[j];
                               	}
                               }
                                 mapInput.value = value;
                                 mapForm.appendChild(mapInput);
                           }
                     }           
               }           
           document.body.appendChild(mapForm);
           
           var popupWindow;
           if(misys._config.showAddressBarInPopup && misys._config.showAddressBarInPopup == true ) {
        	   popupWindow = d.global.open('', windowName, "width=800,height=500,resizable=yes,scrollbars=yes,location=yes");
           } else {
        	   popupWindow = d.global.open('', windowName, "width=800,height=500,resizable=yes,scrollbars=yes");
           }  
     
           console.debug("[misys.common] Opening a standard popup with name", windowName, "at URL", url);
           if(!popupWindow.opener){
                 popupWindow.opener = self;
           }
           popupWindow.focus();          

           if(popupWindow){
                 mapForm.submit();
           }                       
     },

	
	
	/**
	 * <h4>Summary:</h4>
	 * The logic associated with the different actions offered to the user
	 * on the page. Note: option, refId, tnxId and prodCode parameters are only used
	 * for PDF export so far.
	 * 
	 * @param {String} type
	 * @param {String} pdfOption
	 * 	Option like full or summary
	 * @param {String} refId
	 * @param {String} tnxId
	 * @param {String} prodCode
	 * @param {String} strFeatureId
	 * @param {String} companyId
	 * @method generateDocument
	 */
	generateDocument : function(/*String*/ type,
								/*String*/ pdfOption,
	                            /*String*/ refId, 
	                            /*String*/ tnxId, 
	                            /*String*/ prodCode, 
	                            /*String*/ strFeatureId,
	                            /*String*/ companyId) {
		//  summary:
		//         The logic associated with the different actions offered to the user on the page.
		//         Note: option, refId, tnxId and prodCode parameters are only used for PDF
		//         export so far.

		switch(type.toLowerCase()){
		 case "bg-document":
			var url = [reportingPopup];
			url.push("?option=", pdfOption);
			if(refId && refId !== "") {
				url.push(refrnceId, refId);
			}
			if(tnxId && tnxId !== "") {
				url.push("&tnxid=", tnxId);
			}
			url.push(prductCode, prodCode);
			if(strFeatureId && !(strFeatureId === "")){
				url.push("&featureid=", strFeatureId);
			}
			if(companyId && !(companyId === "")){
				url.push("&companyId=", companyId);
			}

			_openPopup(m.getServletURL(url.join(""), null, 
					m.getLocalization("pdfSummaryWindowTitle")));
			break;
		 case "si-document":
			var urlSI = [reportingPopup];
			urlSI.push("?option=", pdfOption);
			if(refId && refId !== "") {
				urlSI.push(refrnceId, refId);
			}
			if(tnxId && tnxId !== "") {
				urlSI.push("&tnxid=", tnxId);
			}
			urlSI.push(prductCode, prodCode);
			if(strFeatureId && !(strFeatureId === "")){
				urlSI.push("&featureid=", strFeatureId);
			}
			if(companyId && !(companyId === "")){
				urlSI.push("&companyId=", companyId);
			}

			_openPopup(m.getServletURL(urlSI.join(""), null, 
					m.getLocalization("pdfSummaryWindowTitle")));
			break;
		 default:
			break;
		}
	},
	/**
	 * Bulk specific Summary script to call respective popup based on csv or pdf
	 * selection
	 * @param {String} type
	 * @param {String} option
	 * @param {String} refId
	 * @param {String} tnxId
	 * @param {String} productCode
	 * @param {DomNode} secondDiv
	 * @method showBulkSummary
	 */
	showBulkSummary: function(type, option, refId, tnxId, productCode, secondDiv)
	{
		var exportType;
		if(!secondDiv)	
		{
			if(dj.byId("export_field"))
			{
				exportType = dj.byId("export_field").get("value");
				m.popup.showSummary(type,exportType,refId,tnxId,productCode);
			}
		}else if(secondDiv)
		{
			if(dj.byId("export_field_bottom"))
			{
				exportType = dj.byId("export_field_bottom").get("value");
				m.popup.showSummary(type,exportType,refId,tnxId,productCode);
			}	
		}
	}
  });
  
  m.dialog = m.dialog || {};
  d.mixin(m.dialog, {
	  //
	  // summary:
	  //	Functions for manipulating dialogs (meaning overlays). Previously this lived in
	  //    FormPopupEvents.js
		/**
		 * <h4>Summary:</h4> 
		 * Open a new form in the popup dialog e.g. addCounterparty page
		 * 
		 * <h4>Description:</h4> 
		 * Populates an open dialog with the content of the given
		 * URL. Note that the dialog must have its content wrapped in a &lt;div&gt; or
		 * other block-level tag with the id type + "data" e.g. bankdata,
		 * beneficiarydata, etc.
		 * 
		 * bindingPackagePrefix is optional, in case the popup binding is not
		 * located at misys/binding/dialog
		 * @param {String} type
		 * @param {String} url
		 * @param {String} bindingPackagePrefix
		 * @param {Object} queryOptions
		 * @method populate
		 */	
	  populate: function( /*String*/ type,
						  /*String*/ url,
						  /*String*/ bindingPackagePrefix,
						  /*Object*/ queryOptions) {
		  //  summary:
		  //       Open a new form in the popup dialog e.g. addCounterparty page
		  //
		  //  description:
		  //	   Populates an open dialog with the content of the given URL. Note that the 
		  //	   dialog must its conten wrapped in a <div>, or other block-level
		  //	   tag with the id type + "data" e.g. bankdata, beneficiarydata, etc. 
		  //
		  //	   bindingPackagePrefix is optional, in case the popup binding is not located at
		  //	   misys/binding/dialog

		  var prefixBinding = bindingPackagePrefix || "misys.binding.dialog";
		  
		  m._config.popupType = type;
		  
		  // Must do require like this, otherwise it breaks the ANT build process
		  console.debug("[misys.common] Loading the dialog binding at ", 
				  (prefixBinding + "." + type));
		  
		  d["require"](prefixBinding + "." + type);
				
		  var containerDiv = d.byId(type + "data");
		  
		  // TODO Maybe we should just create the DIV on-the-fly?
		  if(!containerDiv) {
			  console.error("[misys.common] Cannot populate the dialog with content for URL", url);
			  console.error("[misys.common] Check that the dialog content has an element with",
					  		"ID equal to", (type + "data"));
			  return;
		  }
		  
		  // Create the ContentPane to hold the content
		  //
		  // NOTE: the contentPane must have an overflow:auto (for the scrollbar)
		  // and position:relative otherwise widgets will not render correctly under
		  // IE6
		  
		  var dim = d.coords(containerDiv),
		  	  contentPaneContainer = d.create("div", {id: "contentPaneContainer"});
		  
		  var contentPane;

		  if(!dj.byId("contentPane"))
		  {
			 contentPane = new dijit.layout.ContentPane({
				  id: "contentPane",
			      style: {
			    	  height: dim.h + "px",
			    	  width: dim.w + "px",
			    	  overflow: "auto",
			    	  position: "relative"
			      } 
			  });
		   }
		  else
		  {
			  contentPane = dj.byId("contentPane");
		  }
		  
				
		  contentPane.placeAt(contentPaneContainer, "first");
		  d.style(contentPaneContainer, "visibility", "hidden");
		  d.style(contentPaneContainer, "height", "0px");
		  d.place(contentPaneContainer, containerDiv, "after");

		  m.animate("wipeOut", containerDiv, function(){
			  m.animate("wipeIn", contentPaneContainer, function(){
				  m.connect(contentPane.get("id"), "onLoad", function(){
					  m.dialog.bind();
					 _bindPopupButtons();
					 _bindTabs(_popupFormId);
				  });
				  // do an HTTP POST if queryOptions exist,
				  // it may content long parameters and/or sensitive data
				  if (queryOptions){
					  contentPane.set("ioMethod", m.xhrPost);
					  contentPane.set("ioArgs", { content : queryOptions});
				  }
				  contentPane.set("href", url);
				  contentPane.startup();
				  contentPane.resize();
			 }, null, null, true);
		  }, null, null, true);
	  }, 
		/**	
		 * <h4>Summary:</h4>
		 * Close and destroy the dialog content and reopen the parent
		 * content
		 * @param {DomNode} containerDiv
		 * @param {Dijit._Widget} contentPane
		 * @param {Function} callback
		 * @param {String} response
		 * @method clear
		 */
	  clear : function( /*DomNode*/ containerDiv,
                		/*Dijit._Widget*/ contentPane,
                		/*Function*/ callback, 
                		/*String*/ response) {
			//  summary:
		    //            Close and destroy the dialog content and reopen the parent
			//            content 

			var contentPaneContainer = d.byId("contentPaneContainer");
			
			//Show Response in the XHR dialog
			if(response)
			{
				if(d.byId("responseXHRDialogDiv"))
				{
					d.destroy(d.byId("responseXHRDialogDiv"));
				}
				var responseNode = dojo.create("div");
				responseNode.id = "responseXHRDialogDiv";
				dojo.addClass(responseNode, "responseXHRDialogDiv");
				d.place(response, responseNode, "first");
			}
			
			m.animate("wipeOut", contentPaneContainer, function(){
				d.place(contentPaneContainer, d.body(), "last");
				
				if(response)
				{
					d.place(responseNode, containerDiv, "first");
				}
				
				m.animate("wipeIn", containerDiv, function(){
					contentPane.destroyRecursive();
					d.destroy(contentPaneContainer);
					if(callback && d.isFunction(callback)){
						callback();
					}
					delete m._config.popupType;
				});
			});
	  }, 
	  
		/**
		 * <h4>Summary:</h4> :
		 * Submits the popup form via AJAX
		 * <h4>Description:</h4> 
		 * First it checks for the submit type and takes action according to that.
		 * It has three types [SUBMIT,CANCEL,HELP]
		 * @param {String} submitType
		 *  Type of the submit e.g. (submit,cancel,help)
		 * @method submit
		 */	
	  submit : function( /*String*/ submitType){
			//  summary:
		    //           Submits the popup form via AJAX

			switch(submitType){
			case "SUBMIT":
				console.debug("[misys.common] Performing a Popup SUBMIT via AJAX");
				console.debug("[misys.common] Request XML follows ...");
				var productCode = dj.byId("product_code") ? dj.byId("product_code").get("value") : null;
				var disableFieldsForTrade = false; 
				//Enable disabled fields only for LC, EL, SI and SR product codes 
				//for other product codes disableFieldsForTrade and ignoreDisabled is false.
				if(productCode === "LC" || productCode === "EL" || productCode === "SI" || productCode === "SR")
				{
					disableFieldsForTrade = true; //disableFieldsForTrade and ignoreDisabled is true for TRADE.
				}
				console.debug(m.formToXML({
					ignoreDisabled : disableFieldsForTrade,	//Adding to avoid enabling of disabled fields.
					selector: "#" + _popupFormId, 
					xmlRoot : dj.byId("node_name").get("value")
				}));
				var forms = d.query("#" + _popupFormId);
				if(_validateForms(false, forms)) {
					var confirmationMessage =
						m.getLocalization("submitTransactionConfirmation");
					m.dialog.show("CONFIRMATION", confirmationMessage, "", function(){
						var operation = dj.byId("popup_realform_operation");
						if(operation.get("value") === ""){
							operation.set("value", "SUBMIT");
						}
						
						dj.byId("popup_TransactionData").set("value", 
								m.formToXML({
									ignoreDisabled : disableFieldsForTrade,	//Adding to avoid enabling of disabled fields.
									selector: "#" + _popupFormId, 
									xmlRoot : dj.byId("node_name").get("value")
						}));
						_submitDialog("popup_realform", function(){
							m.grid.setStoreURL(dj.byId(m._config.popupType+"data_grid"));
						});
					});
				} else {
					_validateTabs(_popupFormId);
					m.dialog.show("ERROR", m.getLocalization("mandatoryFieldsToSubmitError"), 
							"", function(){_validateForms(true, forms);});
				}
				break;
			case "CANCEL":
				 m.dialog.clear(d.byId(m._config.popupType+"data"), dj.byId("contentPane"));
				 break;
			case "HELP":
				_openPopup(m._config.onlineHelpUrl, 
							 m.getLocalization("onlineHelpWindowTitle"),
							"width=1000,height=700,resizable=yes,scrollbars=yes");
				return;
				break;
			default:
				break;
			}
	  }, 
	  /**
		 * <h4>Summary:</h4> Passback action for the overlay popup 
		 * @param {Array} arrFieldIds
		 *  An array of ids
		 * @param {Array} arrFieldValues
		 *   An array of values
		 * @param {Boolean} closeParent
		 *  Closes the parent dialog or not
		 * @param {String} type
		 *  Dialog type (Eg: bank, user, entity, accounts etc.)
		 *  @method passBack
		 */
	  passBack : function( /*Array*/ arrFieldIds,
				 		   /*Array*/ arrFieldValues, 
				 		   /*Boolean*/ closeParent,
				 		   /*String*/ type) {
		  //  summary:
		  //        Passback action for the overlay popup
		  //  description: 
		  //        arrFieldIds - an array of ids
		  //        arrFieldValues - an array of values
		  //        closeParent - closes the parent dialog
		  //		type - dialog type (Eg: bank, user, entity, accounts etc.)
		  //companytype is used only in counterparty login and in counterparty login case existingProg will not be  cleared.
		  var jsonData=null;
		  var refsStore=null;
		  var customerBankIndexValue = null;
		  var applicantNickNameValue = null;
		  var benApplicantNickNameValue = null;
		  var beneficiaryNickNameValue = null;		  
		  var applicationCollectionNickNameValue = null;
		  var applicantNickNameIndex = arrFieldIds.indexOf("applicant_act_nickname")!==-1?arrFieldIds.indexOf("applicant_act_nickname"):arrFieldIds.indexOf("applicant_collection_act_nickname");
		  var beneficiaryAccountNickNameIndex = arrFieldIds.indexOf("beneficiary_account_nickname");
		  var beneficiaryNickNameIndex = arrFieldIds.indexOf("beneficiary_nickname");		  
		  customerBankIndexValue = arrFieldIds.indexOf("customer_associated_bank");
		  applicantNickNameValue = arrFieldValues[applicantNickNameIndex];
		  beneficiaryNickNameValue = arrFieldValues[beneficiaryNickNameIndex];		  
		  benApplicantNickNameValue = arrFieldValues[beneficiaryAccountNickNameIndex];
		  var customerBankName = arrFieldValues[customerBankIndexValue];
		  if(customerBankName !== "" && customerBankName !== null)
		  {
			  m._config.customerBankName = customerBankName;
	      }
		  if(applicantNickNameValue !== undefined && applicantNickNameValue !=="" && applicantNickNameValue!==null && dj.byId("applicant_act_nickname")){
			  dj.byId("applicant_act_nickname").set("value", applicantNickNameValue);
		  }
		  if(beneficiaryNickNameValue !== undefined && beneficiaryNickNameValue !=="" && beneficiaryNickNameValue!==null && dj.byId("beneficiary_nickname")){
			  dj.byId("beneficiary_nickname").set("value", beneficiaryNickNameValue);
		  }		  
		  if(benApplicantNickNameValue !== undefined && benApplicantNickNameValue!=="" && benApplicantNickNameValue!==null && dj.byId("beneficiary_act_nickname")){
			  dj.byId("beneficiary_act_nickname").set("value", benApplicantNickNameValue);
		  }
		  var childXhrDialog = dj.byId("childXhrDialog"),
		  	  simpleTextareaRegex = /SimpleTextArea/,
		  	  misysSimpleTextareaRegex = /SimpleTextarea/,
		  	  filteringSelectRegex = /FilteringSelect/,
		  	  obj;
		  /**
		    Restrict on blur event swift bic code is selected from Popup. 
			When bic is from popup set a global variable, 
		    if this global variable is true donot bind on blur event for swift bic code.
          **/ 
		  if(type === "swift_bic")
		  {
			  m._config.isBankDetailsPopulated = true;
		  }
		  else if( type === "beneficiary_accounts")
		  {
			  m._config.isBeneficiaryAccountsPopulated = true;
		  }
		 
		  
		  d.forEach(arrFieldIds, function(id, index){
			  //For filtering select value add the widget Id if the select widget is to be kept editable and to populate the value
			  var editableFields = ["seller_account_type"];
			  obj = dj.byId(id);
			  if(obj) {
				  var insertionValue = arrFieldValues[index];
				  if(simpleTextareaRegex.test(obj.declaredClass) || misysSimpleTextareaRegex.test(obj.declaredClass)) {
					  // Insert a space before the text, if the textarea
					  // already has a value.
					  if(obj.get("value") !== "") {
						  insertionValue = "\n" + insertionValue;
					  }
					  m.insertAtCursor(obj, insertionValue);
				  } else if(filteringSelectRegex.test(obj.declaredClass)){
					 if(editableFields.indexOf(obj.id) > -1)
					 {
						 obj.set("value",insertionValue);
					 }
					 else
					 {
						 if( type === "treasury_beneficiary_accounts"){
							 obj.set("value", insertionValue);
							 obj.set("displayedValue",insertionValue);
						 }				 
						 else{ 
							  obj.set("value","");
							  obj.store = new dojo.data.ItemFileReadStore({
									data: {
										 identifier: "value",
								         label: "name",
								         items: insertionValue
									}
							   });
							 }
						 }
				  } else {
					  // We overwrite the value of non-textarea fields
					  obj.set("value", insertionValue);
				  }

				  // TODO This looks hacky
				  // Call the object events, since we've entered a value
				  obj.onChange();
				  obj.onFocus();
				  obj.onBlur();
			  }
		  });

		  //If BIC Code is available clear the other fields and display only BIC Code
		  var showBICFlag = "false";
		  if(dj.byId("show_bic_code"))
			  {
			  	showBICFlag = dj.byId("show_bic_code").get("value");
			  }
		  if(showBICFlag === "true")
			  {
				  if(type === "treasury_beneficiary_accounts" && dj.byId("beneficiary_bank_bic") && dj.byId("beneficiary_bank_bic").get('value') !== "")
				  {
					dj.byId("beneficiary_bank").set('value','');
					dj.byId("beneficiary_bank_branch").set('value','');
					dj.byId("beneficiary_bank_address").set('value','');
					dj.byId("beneficiary_bank_city").set('value','');
					dj.byId("beneficiary_bank_country").set('value','');
					dj.byId("beneficiary_bank_bic").set('disabled', true);
				  }
			  }
		  
		  // TODO Refactor
		  if(childXhrDialog) {
			  if(closeParent) {
				  m.dialog.connect(childXhrDialog, "onHide", function(){
					  setTimeout(function(){
						  dj.byId("xhrDialog").hide();
					  }, dj.defaultDuration);
				  });
			  }
			  childXhrDialog.hide();
		  } else {
			  // Try to close the parent dialog
			  if(dj.byId("xhrDialog")) {
				  dj.byId("xhrDialog").hide();
			  }
		  }

		  // Filling Entity field if exists
		  // TODO This should be moved elsewhere, looks v. specific
		  var entity1 = dj.byId("01entity");
		  var entity2 = dj.byId("02entity");
		  var entity3 = dj.byId("03entity");
		  if (entity1) {
			  entity1.set("value", arrFieldValues[0]);
		  }
		  if (entity2) {
			  entity2.set("value", arrFieldValues[0]);
		  }
		  if (entity3) {
			  entity3.set("value", arrFieldValues[0]);
		  }
		  var swift_charges_type = arrFieldValues[arrFieldIds.indexOf("swift_charges_type")];
		  
		  if(swift_charges_type){					
			  if (swift_charges_type === "01") {
				  document.getElementById("swift_charges_type_1").click();
			  } else if(swift_charges_type === "02"){
				  document.getElementById("swift_charges_type_2").click();
			  } else if(swift_charges_type === "05"){
				  document.getElementById("swift_charges_type_3").click();
			  }  
		  }
		 
		  //passBack Extension for client specific
		  if(d.isFunction(m._config.passBack)) {
				return m._config.passBack(arrFieldIds,arrFieldValues,closeParent);
		 }
		  
		 
	  }
	});
			  
	 // Initialise 
	 d.subscribe("ready", function(){		
	  if(d.query(_chartSelector).length > 0) {
	   m.connect(window, "onresize", m.resizeCharts);
	  }
	  
	  if(d.query(_gridClassSelector).length > 0) {
		m.connect(window, "onresize", m.resizeGrids);
	  }
 });
})(dojo, dijit, misys);
//Including the client specific implementation


}

if(!dojo._hasResource["misys.form.SortedFilteringSelect"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.form.SortedFilteringSelect"] = true;
dojo.provide("misys.form.SortedFilteringSelect");
dojo.experimental("misys.form.SortedFilteringSelect");



dojo.declare("misys.form.SortedFilteringSelect", dijit.form.FilteringSelect,{
	postCreate: function(){
		this.inherited(arguments);
		console.debug("[misys.form.SortedFilteringSelect] postCreate");
		this.fetchProperties =
		{
			sort : [
			{
				attribute : "name"
			} ]
		};
	}
});

}

if(!dojo._hasResource['misys.client.form.common_client']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['misys.client.form.common_client'] = true;
dojo.provide('misys.client.form.common_client');
(function(/*Dojo*/d, /*Dijit*/dj, /*Misys*/m) {
'use strict'; // ECMA5 Strict Mode

})(dojo, dijit, misys);

}

if(!dojo._hasResource["misys.form.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.form.common"] = true;
dojo.provide("misys.form.common");



// Copyright (c) 2000-2011 Misys (http://www.misys.com),
// All Rights Reserved. 
// version:   1.2
// date:      08/04/11
// author:    Cormac Flynn
/**
 * <h4>Summary:</h4>
 * Library of code used across all pages that contain a product form
 * 
 * <h4>Description</h4>: 
 * This file contains code that is used specifically in product and
 * some system forms. It should not* contain code that is critical to the
 * creation of a page or form. Hence the functions below tend to be those that
 * are particular to a particular screen.
 * 
 * @class common(Form)
 * 
 * 
 */
(function(/*Dojo*/d, /*Dijit*/dj, /*Misys*/m) {

	 // ECMA5 Strict Mode
	var tabTitle ="tab title:";
	var tenorLabel="label[for=tenor_period_label]";
	var advBank="Advising Bank";
	var reqConfParBankDet="requested-conf-party-bank-details";
    var viewNarrativeSwift	="view-narrative-swift";
    var varProdCode ="&productcode=";
   var chilDialog="[misys.form.common] Opening a child dialog at URL";
   var ajaxActionUrl="/screen/AjaxScreen/action/";
   var ajaxStaticDPopup="AjaxScreen/action/GetStaticDataPopup";
   var messageGridContent="[misys.form.common] Retrieving grid content from URL";
   var excValue ='excluded-value';
   var attFile ="attachment-file";
	// Private Functions and Variables
	
	var 
		// Default dimensions for the BG document editor pane
		_defaultEditorRows = "13",
		_defaultEditorCols = "40",
		_defaultEditorMaxSize = "300",
		limit = 0,
		limitSingle = 0,
		entered = 0,
		enteredSingle = 0,
		isCombinedValid = true, 
		isSingleFieldValid = true;	
	 
	
	/**
	 * <h4>Summary:</h4>Unwraps text based on given identifiers for swift 2018 extended
	 *  narratives.
	 * 
	 * <h4>Description:</h4>Unwraps all the text unless a specific identifier appears
	 *  as the first character of a line. In a case, the specific identifier comes in 
	 *  the middle of a specific line, the unwrap function is applied and a new line or
	 *  paragraph is not started.
	 *  
	 *  @param {String} msg
	 *  @method _unwrap
	 *  Allowed identifiers are :
                         +,
                         #,
                         -,
                         a to z),
                         A) to Z),
                         a. to z.,
                         A. to Z.,
                         1) to 99),
                         1. to 99.,
                         1- to 99-
                         1# to 99#
                         1+ to 99+
                         a to z-
                         a# to z#
                         a+ to z+
                         A- to Z-
                         A# to Z#
                         A+ to Z+
                         
	 */
	function _unwrap(/*String*/ msg){
		var re = new RegExp(/^[a-zA-Z]{1}[).#+-]|^[1-9]{1,2}[).#+-]|^[\+#-]/);
		var message = msg.split(/\n/);
		var unwrappedMessage = '<pre style="background-color:#ffffff;border-width:0px; white-space: pre-wrap;">';
		for(var i = 0; i < message.length; i++){
			message[i] = message[i] + '\n';
			var len =  message[i].length;
			var temp = '';
			if(message[i][len-1] === '\n' && message[i+1] != undefined &&
			  (re.test(message[i+1].trim()) || message[i+1].trim() ==='' || message[i+1].trim()==='\n'  )){
				temp = message[i].replace(/\n/g,'');
				temp = temp+'<br/>';
			}else{
				temp = message[i].replace(/\n/g,' ');
			}
			unwrappedMessage += temp;
		}
		unwrappedMessage+="</pre>";
		return unwrappedMessage;
	}
	
	/**
	 * 
	 * Custom decode for narrative extension while the display-mode is view
	 */
	
	function _decode(/*String*/ msg){
		var message = msg;
		message = message.replace(/&#xa;/g,'\n');
		message = message.replace(/&#xa;/g,'\t');
		message = message.replace(/&#x29;/g,')');
		message = message.replace(/&#x2b;/g,'+');
		message = message.replace(/&#x23;/g,'#');
		message = message.replace(/&#x2d;/g,'-');
		message = message.replace(/&#x3e;/g,'>');
		message = message.replace(/&#x3c;/g,'<');
		message = message.replace(/&#x2f;/g,'/');
		message = message.replace(/&#x9;/g,'');
		message = message.replace(/&#x26;nbsp&#x3b;/g,' ');
		message = message.replace(/&#x26;amp&#x3b;/g,'&');
		return _unwrap(message);
	}

	/**
	 * <h4>Summary:</h4> Calculate the new amt. 
	 * 
	 * <h4>Description:</h4>  Calculate the new amount in
	 * the case of amendment. Handles both increment and decrement in amount.
	 * 
	 * {misys._config.productCode}_amt fields must exist for this function to be
	 * correctly called.
	 * 
	 * @param {Dijit} node
	 * 	Node either inc_amt or dec_amt
	 * @method _calculateNewAmt
	 */
	function _calculateNewAmt( /*Dijit*/ node) {
		var productCode = m._config.productCode.toLowerCase(),
			amtField = dj.byId(productCode + "_amt"),
			orgAmtField = dj.byId("org_" + productCode + "_amt"),
			// We parse to number in case either field happens to be a hidden field.
			orgAmt = d.number.parse(orgAmtField.get("displayedValue")),
			amendAmt = d.number.parse(node.get("displayedValue"));

		orgAmt = !isNaN(orgAmt) ? orgAmt : 0;
		amendAmt = !isNaN(amendAmt) ? amendAmt : null;
		
		if(node.id === "inc_amt" || node.id === "inc_amt_value") {
			console.debug("[misys.form.common] Incrementing amount from", amtField.get("value"), 
								"to", (orgAmt + amendAmt));
			amtField.set("value", orgAmt + amendAmt);
			m.setTnxAmt(amendAmt);
		} else {
			if(amendAmt <= orgAmt) {
				console.debug("[misys.form.common] Changing amount from", 
						amtField.get("value") ,"to", (orgAmt - amendAmt));
				amtField.set("value", orgAmt - amendAmt);
				m.setTnxAmt(amendAmt);
			} else {
				// TODO This should be handled by a validation attached
				// to the field
				m.setFieldState(node, false);
			}
		}
	}
	
	/**
	 * <h4>Summary:</h4> 
	 * Deletes counterparties and clears tnx_amt upon currency change
	 * @param {Dijit} widget
	 *  Currency widget  
	 * @method _resetFTCounterparties
	 */
	function _resetFTCounterparties(/*Dijit*/ widget) {

		// 1. Clear tnx_amt val
		m.setTnxAmt("");

		// 2. Set currency values
		var value = widget.get("value");
		dj.byId("ft_cur_code").set("value", value);
		dj.byId("counterparty_details_ft_cur_code_nosend").set("value", value);
		m.setCurrency(widget, ["ft_amt", "counterparty_details_ft_amt_nosend"]);

		// 3. Delete beneficiaries, if there are any 
		d.query(
				".widgetContainer #counterparty_fields " + 
				"[id^='counterparty_details_document_id_']").forEach(function(field){
			if(field.id.indexOf("nosend") === -1)
			{
				var w = dj.byId(field.id);
				if(w){
					m.deleteTransactionAddon("counterparty", w.get("value"));
				}
			}
		});
	}
	/**
	 * <h4>Summary:</h4> 
	 * Set the value of drawee details. 
	 * <h4>Description:</h4>  
	 * Sets the values of Drawee bank details.Depending upon crAvailCode set the drawee bank details
	 * It can be issuing bank or advising bank depending upon the value of code
	 * @param {String} crAvlCode
	 * @param {String} bankType
	 *  Whether bank is issuing bank or advising bank or any other bank
	 * @method _toggleDraweeBankDetails
	 */
	function _toggleDraweeBankDetails( /*String*/ crAvlCode, 
									   /*String*/ bankType) {
		
		var draweeDetailsBankName = dj.byId("drawee_details_bank_name");
		var amendmentTransaction = (dj.byId("tnxtype") && dj.byId("tnxtype").get("value")==="03") || 
		(dj.byId("tnx_type_code") && dj.byId("tnx_type_code").get("value")==="03") || 
		(dj.byId("prod_stat_code") && (dj.byId("prod_stat_code").get("value")==="08" || dj.byId("prod_stat_code").get("value")==="31"));
		if(!(amendmentTransaction)) {
		switch(bankType) {
		 case m._config.issuingBank:
			draweeDetailsBankName.set("value", m._config.issuingBank);
			break;
		 case m._config.advisingBank:
			if(crAvlCode !== "03") {
				draweeDetailsBankName.set("value", m._config.advisingBank);
			} else {
				draweeDetailsBankName.set("value", m._config.issuingBank);
			}
			break;
		 case m._config.anyBank:
			draweeDetailsBankName.set("value", m._config.issuingBank);
			break;
		 default:
			if(crAvlCode === "01" || crAvlCode === "02" || crAvlCode === "04" || crAvlCode === "05" || crAvlCode === "03") {
				/*jsl:pass*/
				// TODO error in original script but I don't know the business logic so I can't 
				//		correct it
				// draweeDetailsBankName.set("value",m._config.namedBank);
			} else {
				draweeDetailsBankName.set("value", m._config.issuingBank);
			}
			break;
		}
		}
	}
/**
 * <h4>Summary:</h4>
 * This function creates transaction grid like any other grid in application
 * @param {String} url	
 * @param {String} containerId
 * @method _createTransactionGrid
 */
	function _createTransactionGrid( /*String*/ url, 
									 /*String*/ containerId){
		// summary:
		//		TODO add summary
		//		TODO Dimensions should not be hardcoded
		// 		TODO This grid is created in a manner unlike other grids in the application
		
		var layout = [{field: "REFIDLINK",name: "ref_id",width: "100px", 
						styles: "text-align: center;",formatter: m.grid.formatHTML},
						{field: "CURCODE",name: "cur_code",width: "auto"},
						{field: "TNXID",name: "tnx_id",width: "auto"},
						{field: "TYPE",name: "type",width: "auto",formatter: m.grid.formatHTML},
						{field: "STATUS",name: "status",width: "auto"},
						{field: "AMOUNT",name: "tnx_amt",width: "auto"}],
			json = "items: ''",
			store = new dojo.data.ItemFileReadStore({data:json}),
			grid = new dojox.grid.DataGrid({
				  query: {
				      id: "*"
				  },
				  id: "transaction_Grid",
				  structure: layout,
				  height: "100px",
				  noDataMessage: m.getLocalization("noTransactionsFound"),
				  onSelected: function(inRowIndex){_selectTransactionIndex(inRowIndex);},
				  selectionMode: "single"
			}, document.createElement("div"));
			d.byId(containerId).appendChild(grid.domNode);
			grid.startup();
			store.url = url;
			grid.setStore(store);
	}
	/**
	 * <h4>Summary:</h4>
	 * This function provides selection of transaction grid.
	 * @param {Number} inRowIndex
	 *  Index of the items to be selected
	 * @method _selectTransactionIndex
	 * 
	 */
	function _selectTransactionIndex( /*Number*/ inRowIndex){
		//	Summary
		//		TODO Add <h4>Description:</h4> 
		//		TODO 

		var transationSelected = dj.byId("transaction_Grid").get("store")._arrayOfAllItems[inRowIndex];
		dj.byId("imp_bill_ref_id").set("value", transationSelected.TNXID);
		d.byId("TransactionLink").innerHTML = 
			"<a id='javascriptLink' href='javascript:void(0)\'>" + 
			m.getLocalization("TransactionLink") + "</a>";
		d.attr("javascriptLink", "onclick", 
				"misys.popup.showReporting('FULL','" + transationSelected.PRODUCTCODE + 
				"','" + transationSelected.REFID + "','" + transationSelected.TNXID + "');");
		dj.byId("linkedTransaction_dialog").hide();
	}
	/**
	 * <h4>Summary:</h4>
	 *  Method to reset Limit fields on change of facility and applicant reference and Entity.
	 *  Set the displayed value of all the fields to empty in the same.
	 * @method _resetLimitDetails
	 */
	function _resetLimitDetails(){
		//Summary
		//Method to reset Limit fields onchange of facility and applicant reference and entity
		var fieldIds 	  	= m._config.limitFieldIdCollection;
		console.debug("[misys.form.common] Reset Limit Fields");
		
		d.forEach(fieldIds, function(id, index){
			var obj = dj.byId(id);
			if(obj) 
			{
				obj.set("displayedValue","");
			}
		});
	}
	/**
	 * <h4>Summary:</h4>
	 *  Method to store Limit collection.Create a itemFileReadStore from the store and form the response object
	 *  @param {Object} response
	 *   Response object contains all required fields ,items,store.
	 *  @method _setLimitCollection
	 * 
	 */
	function _setLimitCollection(response){
		//Summary
		//Method to store Limit collection
		console.debug("[misys.form.common] Set Limit Reference Store");
		m._config.limitFieldIdCollection = response.fields;
		m._config.limitCollection 		= response.items;
		m._config.limitStore			= response.store;
		var limitIdWidget 				= dj.byId("limit_id");
			
		if(limitIdWidget)
		{
			limitIdWidget.store = new dojo.data.ItemFileReadStore(
					{
						data :
						{
							identifier : "value",
							label : "name",
							items : m._config.limitStore
						}
					});
		}
	}
	/**
	 * <h4>Summary:</h4>
	 * This function is used to set the dynamic text content to the field selected.
	 * <h4>Description:</h4> 
	 * The phrase text is appended to the existing text area field.
	 * @param {Object} response
	 * @method _showExistingPoRefMsg
	 */
	function _showDynamicNarrativeText(response){
		
		console.debug("[misys.form.common] _showDynamicNarrativeText : start ");
		
		var fieldId;
			if(response.items !== "")
			{
				fieldId = response.items.widget;
				var field = dj.byId(fieldId);
				var value = field.get("value");
				if(value === ""){
					field.set("value",value + response.items.text);
				}
				else{
					field.set("value",value + "\n" +response.items.text);
				}
				console.debug("[misys.form.common] _showDynamicNarrativeText : end ");
			}
			dj.byId("xhrDialog")?dj.byId("xhrDialog").hide():"";
	}
	
	/**
	 * <h4>Summary:</h4>
	 * This function is used to populate the selected user details to the user fields.
	 * <h4>Description:</h4> 
	 * The user details are populated to the existing fields.
	 * @param {Object} response
	 * @method _PopulateCloneUserDetails
	 */
	function _PopulateCloneUserDetails(response){
		
		console.debug("[misys.form.common] _PopulateCloneUserDetails : start ");
		
		if(response.message !== "")
		{
			var firstname = dj.byId("first_name"),
			lastname = dj.byId("last_name"),
			legalcountry =dj.byId("legal_country"),
			legaltype=dj.byId("legal_type"),
   		    legalno=dj.byId("legal_no"),
			addr1=dj.byId("address_line_1"),
			addr2=dj.byId("address_line_2"),
			countrysubdiv=dj.byId("country_sub_div"),
			county=dj.byId("county"),
			country_name=dj.byId("country_name"),
			phone=dj.byId("phone"),
			fax=dj.byId("fax"),
			email=dj.byId("email"),
			dom=dj.byId("dom"),
			timezone=dj.byId("time_zone"),
			crsplang=dj.byId("correspondence_language"),
			status=dj.byId("actv_flag"),
			curcode=dj.byId("base_cur_code"),
			department=dj.byId("employee_department");
			var authlen=response.message.static_user.group_record.length;
			var rolelistref;
			var availrolelistref;
			var firstnamevalue = response.message.static_user.first_name,
			lastnamevalue = response.message.static_user.last_name,
			addr1value = response.message.static_user.address_line_1,
			addr2value = response.message.static_user.address_line_2,
			countrysubdivvalue = response.message.static_user.country_sub_div,
			countyvalue = response.message.static_user.county,
			countryvalue = response.message.static_user.country_name,
			phonevalue = response.message.static_user.phone,
			faxvalue = response.message.static_user.fax,
			emailvalue = response.message.static_user.email,
			domvalue = response.message.static_user.dom,
			timezonevalue = response.message.static_user.time_zone,
			crspdlangvalue = response.message.static_user.correspondence_language,
			curcodevalue = response.message.static_user.cur_code;
			if(response.message.static_user.company_type == '03'){
			rolelistref = dojo.byId("company_role_list");
			availrolelistref = dojo.byId("company_avail_list_nosend");
			var pendingtransvalue = response.message.static_user.pending_trans_notify,
			legalcountryvalue = response.message.static_user.legal_country,
			legaltypevalue = response.message.static_user.legal_type,
			legalnovalue = response.message.static_user.legal_no;
			legalcountry.set("value",legalcountryvalue);
			legaltype.set("value",legaltypevalue);
			legalno.set("value",legalnovalue);
			if(pendingtransvalue == 'Y')
				{
				dj.byId("pending_trans_notify").set("checked", true);
				dj.byId("email").set("required", true);
				}
			if(response.message.static_user.group_record.length > 0)
				{
				for(var m=1;m<=authlen-1;m++){
					dj.byId("company_auth_level_"+m).set("value","");
					dj.byId("company_limit_amt_"+m).set("value", "");
					dj.byId("company_limit_cur_code_"+m).set("value","");
					if(response.message.static_user.group_record[m-1].existing_roles)
					{
					var authval= response.message.static_user.group_record[m-1].existing_roles.role.name;
					var amtval = response.message.static_user.group_record[m-1].existing_roles.role.limit_amt;
					var curval = response.message.static_user.group_record[m-1].existing_roles.role.limit_cur_code;
					dj.byId("company_auth_level_"+m).set("value",authval);
					dj.byId("company_limit_amt_"+m).set("value", amtval);
					dj.byId("company_limit_cur_code_"+m).set("value",curval);
					misys.animate('wipeIn', "grp_rec_"+response.message.static_user.group_record[m-1].group_abbv_name);
					}
				}
				}
			}
			if(response.message.static_user.company_type == '01' || response.message.static_user.company_type == '02'){
				rolelistref = dojo.byId("bank_role_list");
				availrolelistref = dojo.byId("bank_avail_list_nosend");
				var option;
				if(response.message.static_user.group_record.existing_roles != "")
					{
					var bankauthlevelvalue = null;
					if(response.message.static_user.group_record.existing_roles.role.length > 0)
						{
						for(var x=0; x<response.message.static_user.group_record.existing_roles.role.length; x++)
							{
							  if(response.message.static_user.group_record.existing_roles.role[x].roletype=='02')
								  {
									 bankauthlevelvalue = response.message.static_user.group_record.existing_roles.role[x].role_description;
								     option = document.createElement("OPTION");
									 option.innerHTML = bankauthlevelvalue;
									 option.value= response.message.static_user.group_record.existing_roles.role[x].name;
									 dj.byId("bank_auth_level_1").set("item", option);
								  }
							}
						}
					else
						{
						if(response.message.static_user.group_record.existing_roles.role.roletype=='02')
						  {
							 bankauthlevelvalue = response.message.static_user.group_record.existing_roles.role.role_description;
						     option = document.createElement("OPTION");
							 option.innerHTML = bankauthlevelvalue;
							 option.value= response.message.static_user.group_record.existing_roles.role[x].name;
							 dj.byId("bank_auth_level_1").set("item", option);
						  }
						}
					}
				var departmentvalue = response.message.static_user.employee_department;
				department.set("value", departmentvalue );
				}
			firstname.set("value",firstnamevalue);
			lastname.set("value",lastnamevalue);
			addr1.set("value",addr1value);
			addr2.set("value",addr2value);
			countrysubdiv.set("value",countrysubdivvalue);
			county.set("value",countyvalue);
			country_name.set("value",countryvalue);
			phone.set("value",phonevalue);
			fax.set("value",faxvalue);
			email.set("value",emailvalue);
			dom.set("value",domvalue);
			timezone.set("value",timezonevalue);
			crsplang.set("value",crspdlangvalue);
			curcode.set("value", curcodevalue);
			var roledesc;
			var roleval;
			
			if(availrolelistref)
				{
					availrolelistref.innerHTML = "";
				}
			if(rolelistref)
			{
				rolelistref.innerHTML = "";
			}
			// populating existing roles for corportae user
			if(response.message.static_user.company_type == '03' && response.message.static_user.static_company.owner_id != '2' && response.message.static_user.group_record[1].group_abbv_name == "global")
			{
			// if there are existing roles are not empty
			if(response.message.static_user.group_record[1].existing_roles)
			{
			// if there are existing roles are not empty and has more than 1 role
			if(response.message.static_user.group_record[1].existing_roles.role.length>0)
			{
									for(var j = 0; j < response.message.static_user.group_record[1].existing_roles.role.length; j++)
									{
										roledesc = response.message.static_user.group_record[1].existing_roles.role[j].role_description;
										roleval = response.message.static_user.group_record[1].existing_roles.role[j].name;
										dojo.create("option", { text: roledesc, value: roleval, innerHTML: roledesc, textValue: roledesc}, rolelistref);
									}
			}
			// if there are existing roles are not empty and has only 1 role
			else{
			dojo.byId("company_role_list").add(dojo.create("option", { text: response.message.static_user.group_record[1].existing_roles.role.role_description, innerHTML: response.message.static_user.group_record[1].existing_roles.role.role_description, value: response.message.static_user.group_record[1].existing_roles.role.name}));
			}
			}
		}

			// populating existing roles for bank and bankgroup side
			var desc3;
			var val3;
			if(response.message.static_user.company_type == '01' || response.message.static_user.company_type == '02')
			{
			//if the existing roles are not empty
			if(response.message.static_user.group_record.existing_roles)
			{
				// if the existing roles are not empty and having more than 1 role
				if(response.message.static_user.group_record.existing_roles.role.length>0)
				{
				for(var y = 0; y < response.message.static_user.group_record.existing_roles.role.length; y++)
					{
						// check if the condition is needed for roledest also for bankgroup and bank users.
					  if(response.message.static_user.group_record.existing_roles.role[y].roletype=="01")
					  {
						  desc3 = response.message.static_user.group_record.existing_roles.role[y].role_description;
						  val3 = response.message.static_user.group_record.existing_roles.role[y].name;
						  dojo.create("option", { text: desc3, value: val3, innerHTML: desc3, textValue: desc3}, rolelistref);
					  }
					}
				}
				// if the existing roles are not empty and having only single role
				else
				{
					if(response.message.static_user.group_record.existing_roles.role.roletype=="01")
						{
							dojo.byId("bank_role_list").add(dojo.create("option", { text: response.message.static_user.group_record.existing_roles.role.role_description, innerHTML: response.message.static_user.group_record.existing_roles.role.role_description,  value: response.message.static_user.group_record.existing_roles.role.name}));
						}
				}
			}
			}
			
			// populating existing roles for customers from bankgroup side
			if(response.message.static_user.company_type == '03' && response.message.static_user.static_company.owner_id == '2')
			{
				//multibank scenario
				var len=response.message.static_user.group_record.length;
				if(response.message.static_user.group_record.length > 0)
					{
					// if there are existing roles are not empty
					if(response.message.static_user.group_record[len-1].existing_roles)
					{
					// if there are existing roles are not empty and has more than 1 role
					if(response.message.static_user.group_record[len-1].existing_roles.role.length>0)
					{
											for(var z = 0; z < response.message.static_user.group_record[len-1].existing_roles.role.length; z++)
											{
												roledesc = response.message.static_user.group_record[len-1].existing_roles.role[z].role_description;
												roleval = response.message.static_user.group_record[len-1].existing_roles.role[z].name;
												dojo.create("option", { text: roledesc, value: roleval, innerHTML: roledesc, textValue: roledesc}, rolelistref);
											}
					}
					// if there are existing roles are not empty and has only 1 role
					else{
					dojo.byId("company_role_list").add(dojo.create("option", { text: response.message.static_user.group_record[len-1].existing_roles.role.role_description, innerHTML: response.message.static_user.group_record.existing_roles.role.role_description, value: response.message.static_user.group_record.existing_roles.role.name}));
					}
					}
					}
					
				// no multibank
				else{
					// if there are existing roles are not empty
			if(response.message.static_user.group_record.existing_roles)
			{
			// if there are existing roles are not empty and has more than 1 role
			if(response.message.static_user.group_record.existing_roles.role.length>0)
			{
									for(var zn = 0; zn < response.message.static_user.group_record.existing_roles.role.length; zn++)
									{
										roledesc = response.message.static_user.group_record.existing_roles.role[zn].role_description;
										roleval = response.message.static_user.group_record.existing_roles.role[zn].name;
										dojo.create("option", { text: roledesc, value: roleval, innerHTML: roledesc, textValue: roledesc}, rolelistref);
									}
			}
			// if there are existing roles are not empty and has only 1 role
			else{
			dojo.byId("company_role_list").add(dojo.create("option", { text: response.message.static_user.group_record.existing_roles.role.role_description, innerHTML: response.message.static_user.group_record.existing_roles.role.role_description, value: response.message.static_user.group_record.existing_roles.role.name}));
			}
			}
				}
		}
			
			//available roles for corporate user
			var desc1;
			var val1;
			if(response.message.static_user.company_type == '03' && response.message.static_user.static_company.owner_id != '2' && response.message.static_user.group_record[1].group_abbv_name == "global")
			{
						// if the available roles are not empty
						if(response.message.static_user.group_record[1].avail_roles != "")
						{
							// if there are available roles are not empty and has more than 1 role
							if(response.message.static_user.group_record[1].avail_roles.role.length > 0)
							{
								response.message.static_user.group_record[1].avail_roles.role.sort(GetSortOrder("role_description"));
							for(var k = 0; k < response.message.static_user.group_record[1].avail_roles.role.length; k++)
									{
										if(response.message.static_user.group_record[1].avail_roles.role[k].roledest =='03' && response.message.static_user.group_record[1].avail_roles.role[k].roletype == '01')
										{
										desc1 = response.message.static_user.group_record[1].avail_roles.role[k].role_description;
										val1 = response.message.static_user.group_record[1].avail_roles.role[k].name;
										dojo.create("option", { text: desc1, value: val1, innerHTML: desc1, textValue: desc1}, availrolelistref);
										}
									}
							}
							// if there are available roles are not empty and has only single role
							else{
								if(response.message.static_user.group_record[1].avail_roles.role.roledest =='03' && response.message.static_user.group_record[1].avail_roles.role.roletype == '01')
								{
									dojo.byId("company_avail_list_nosend").add(dojo.create("option", { text: response.message.static_user.group_record[1].avail_roles.role.role_description,
									innerHTML : response.message.static_user.group_record[1].avail_roles.role.role_description,
									value: response.message.static_user.group_record[1].avail_roles.role.name}));
								}
							}
						
							
						}
			}

				// populating available roles for customers from bankgroup side 
			if(response.message.static_user.company_type == '03' && response.message.static_user.static_company.owner_id == '2')
			{

				//multibank scenario
				var ln=response.message.static_user.group_record.length;
				if(response.message.static_user.group_record.length > 0)
					{
					// if the available roles are not empty
					if(response.message.static_user.group_record[ln-1].avail_roles != "")
					{
						// if there are available roles are not empty and has more than 1 role
						if(response.message.static_user.group_record[ln-1].avail_roles.role.length > 0)
						{
							response.message.static_user.group_record[ln-1].avail_roles.role.sort(GetSortOrder("role_description"));
						for(var mor = 0; mor < response.message.static_user.group_record[ln-1].avail_roles.role.length; mor++)
								{
									if(response.message.static_user.group_record[ln-1].avail_roles.role[mor].roledest =='03' && response.message.static_user.group_record[ln-1].avail_roles.role[mor].roletype == '01')
									{
									desc1 = response.message.static_user.group_record[ln-1].avail_roles.role[mor].role_description;
									val1 = response.message.static_user.group_record[ln-1].avail_roles.role[mor].name;
									dojo.create("option", { value: val1, innerHTML: desc1/*, textValue: desc1*/}, availrolelistref);
									}
								}
						}
						// if there are available roles are not empty and has only single role
						else{
							if(response.message.static_user.group_record[ln-1].avail_roles.role.roledest =='03' && response.message.static_user.group_record[ln-1].avail_roles.role.roletype == '01')
							{
								dojo.byId("company_avail_list_nosend").add(dojo.create("option", {/* text: response.message.static_user.group_record.avail_roles.role.role_description,*/
								innerHTML : response.message.static_user.group_record[ln-1].avail_roles.role.role_description,
								value: response.message.static_user.group_record[ln-1].avail_roles.role.name}));
							}
						}
					
						
					}
				}
				else
					{
					// if the available roles are not empty
					if(response.message.static_user.group_record.avail_roles != "")
					{
						// if there are available roles are not empty and has more than 1 role
						if(response.message.static_user.group_record.avail_roles.role.length > 0)
						{
							response.message.static_user.group_record.avail_roles.role.sort(GetSortOrder("role_description"));
						for(var mr = 0; mr < response.message.static_user.group_record.avail_roles.role.length; mr++)
								{
									if(response.message.static_user.group_record.avail_roles.role[mr].roledest =='03' && response.message.static_user.group_record.avail_roles.role[mr].roletype == '01')
									{
									desc1 = response.message.static_user.group_record.avail_roles.role[mr].role_description;
									val1 = response.message.static_user.group_record.avail_roles.role[mr].name;
									dojo.create("option", { value: val1, innerHTML: desc1/*, textValue: desc1*/}, availrolelistref);
									}
								}
						}
						// if there are available roles are not empty and has only single role
						else{
							if(response.message.static_user.group_record.avail_roles.role.roledest =='03' && response.message.static_user.group_record.avail_roles.role.roletype == '01')
							{
								dojo.byId("company_avail_list_nosend").add(dojo.create("option", {/* text: response.message.static_user.group_record.avail_roles.role.role_description,*/
								innerHTML : response.message.static_user.group_record.avail_roles.role.role_description,
								value: response.message.static_user.group_record.avail_roles.role.name}));
							}
						}
					
						
					}
					}
			}
			
			//available roles for bank and bank group users

			// avaialble roles for bankgroup side
			if(response.message.static_user.company_type == '02')
						{
								// if the available roles are not empty
									if(response.message.static_user.group_record.avail_roles)
									{
										

										// if there are available roles are not empty and has more than 1 role
										if(response.message.static_user.group_record.avail_roles.role.length > 0)
										{
											response.message.static_user.group_record.avail_roles.role.sort(GetSortOrder("role_description"));
										for(var n = 0; n < response.message.static_user.group_record.avail_roles.role.length; n++)
												{
													if(response.message.static_user.group_record.avail_roles.role[n].roledest =='02' &&
															 response.message.static_user.group_record.avail_roles.role[n].roletype == '01')
													{
														//response.message.static_user.group_record.avail_roles.role.sort(GetSortOrder("role_description"));
														desc1 = response.message.static_user.group_record.avail_roles.role[n].role_description;
														val1 = response.message.static_user.group_record.avail_roles.role[n].name;
														dojo.create("option", { text: desc1, value: val1, innerHTML: desc1, textValue: desc1}, availrolelistref);
													}
												}
										}
										// if there are available roles are not empty and has only single role
										else{
										if(response.message.static_user.group_record.avail_roles.role[n].roledest =='02' &&
												 response.message.static_user.group_record.avail_roles.role.roletype == '01')
												{
										  						dojo.byId("company_avail_list_nosend").add(dojo.create("option", { text: response.message.static_user.group_record[i].avail_roles.role.role_description,
																innerHTML : response.message.static_user.group_record.avail_roles.role.role_description,
																value: response.message.static_user.group_record.avail_roles.role.name}));
												}
											}
										
									}
						}
						
						
						// avaialble roles for bank side
			            if(response.message.static_user.company_type == '01')
						{
								// if the available roles are not empty
									if(response.message.static_user.group_record.avail_roles)
									{
										

										// if there are available roles are not empty and has more than 1 role
										if(response.message.static_user.group_record.avail_roles.role.length > 0)
										{
											response.message.static_user.group_record.avail_roles.role.sort(GetSortOrder("role_description"));
										for(var p = 0; p < response.message.static_user.group_record.avail_roles.role.length; p++)
												{
													if(response.message.static_user.group_record.avail_roles.role[p].roledest =='01' &&
															 response.message.static_user.group_record.avail_roles.role[p].roletype == '01')
													{
														desc1 = response.message.static_user.group_record.avail_roles.role[p].role_description;
														val1 = response.message.static_user.group_record.avail_roles.role[p].name;
														dojo.create("option", { text: desc1, value: val1, innerHTML: desc1, textValue: desc1}, availrolelistref);
													}
												}
										}
										// if there are available roles are not empty and has only single role
										else{
										if(response.message.static_user.group_record.avail_roles.role[p].roledest =='01' &&
												 response.message.static_user.group_record.avail_roles.role.roletype == '01')
												{
										  						dojo.byId("company_avail_list_nosend").add(dojo.create("option", { text: response.message.static_user.group_record[i].avail_roles.role.role_description,
																innerHTML : response.message.static_user.group_record.avail_roles.role.role_description,
																value: response.message.static_user.group_record.avail_roles.role.name}));
												}
											}
										
									}
						}

			
			
			// populating roles for entities
			if(response.message.static_user.company_type == '03')
			{
				if(response.message.static_user.entity_record)
					{
				
				// populating existing roles for entities
			var entityroledesc,
			entityroleval,
			entityId,
			entflag,
			entityrolelistref,
			entflagval,
			defaultent = dj.byId("default_entity");
			 var option1 = document.createElement("OPTION");
			 option1.innerHTML = "";
			 option1.value= "";
			 if(defaultent)
				 {
				 	defaultent.set("item", option1);
				 }
			 			// if there are more than one entities related to company
						if(response.message.static_user.entity_record.length > 0)
						{
						for(var x1 in response.message.static_user.entity_record){
							if(response.message.static_user.entity_record[x1].default_entity == "Y"){
								var temp=response.message.static_user.entity_record[x1].entity_name;
								 var opt = document.createElement("OPTION");
								 opt.innerHTML = temp;
								 opt.value= temp;
								 defaultent.set("item", opt);
								break;
							}
						}
						for(var a=0; a < response.message.static_user.entity_record.length; a++)
							{
								entityId = response.message.static_user.entity_record[a].entity_id;
								entflag = dijit.byId("entity_flag_nosend_"+entityId);
								entityrolelistref = dojo.byId("entity_roles_exist_nosend_"+entityId);
								entityrolelistref.innerHTML="";
							    entflagval = response.message.static_user.entity_record[a].entity_flag;
							    entflag.set("value", entflagval);
							    // populating existing roles only when the entity is checked
							    if(entflagval == "Y")
							    {
							    	// if existing roles are not empty
							    	if(response.message.static_user.entity_record[a].existing_roles)
							    		{
							    			// if existing roles are not empty and having more than 1 role.
							    			if(response.message.static_user.entity_record[a].existing_roles.role.length > 0)
											 {
												for(var q = 0; q < response.message.static_user.entity_record[a].existing_roles.role.length; q++)
												{
												entityroledesc = response.message.static_user.entity_record[a].existing_roles.role[q].role_description;
												entityroleval = response.message.static_user.entity_record[a].existing_roles.role[q].name;
												dojo.create("option", { text: entityroledesc, value: entityroleval, innerHTML: entityroledesc, textValue: entityroledesc}, entityrolelistref);
												}
											 }
							    			// if existing roles are not empty and having only 1 role.
											else
											 {
												dojo.byId("entity_roles_exist_nosend_"+entityId).add(dojo.create("option", { text: response.message.static_user.entity_record[a].existing_roles.role.role_description, innerHTML:response.message.static_user.entity_record[a].existing_roles.role.role_description, value: response.message.static_user.entity_record[a].existing_roles.role.name}));
												
											 }
							    			
							    			dj.byId("entity_flag_nosend_"+entityId).set("checked", true);
									    	   misys.animate('wipeIn', "entity_roles_div_"+entityId);
							    		}
							    }
							    // if entity is not checked no action for existing roles
							    else
							    	{
							    	  dj.byId("entity_flag_nosend_"+entityId).set("checked", false);
							    	   misys.animate('wipeOut', "entity_roles_div_"+entityId);
							    	}
							}
						}
						
						// if there is single entity related to company
					else
						{
						if(response.message.static_user.entity_record.default_entity == "Y")
							{
								 var temp1=response.message.static_user.entity_record.entity_name;
								 var opt1 = document.createElement("OPTION");
								 opt1.innerHTML = temp1;
								 opt1.value= temp1;
								 defaultent.set("item", opt1);
							}
						entityId = response.message.static_user.entity_record.entity_id;
						entityrolelistref = dojo.byId("entity_roles_exist_nosend_"+entityId);
						entityrolelistref.innerHTML="";
						entflagval = response.message.static_user.entity_record.entity_flag;
						// populating existing roles only when the entity is checked
						if(entflagval == 'Y')
						{
							// if existing roles are not empty
							if(response.message.static_user.entity_record.existing_roles)
								{
							
								// if existing roles are not empty and having more than 1 role.
						if(response.message.static_user.entity_record.existing_roles.role.length>0)
						 {
							for(var r = 0; r < response.message.static_user.entity_record.existing_roles.role.length; r++)
							{
							entityroledesc = response.message.static_user.entity_record.existing_roles.role[r].role_description;
							entityroleval = response.message.static_user.entity_record.existing_roles.role[r].name;
							dojo.create("option", { text: entityroledesc, value: entityroleval, innerHTML: entityroledesc, textValue: entityroledesc}, entityrolelistref);
							}
							dj.byId("entity_flag_nosend_"+entityId).set("checked", true);
					    	   misys.animate('wipeIn', "entity_roles_div_"+entityId);
						 }
						
						// if existing roles are not empty and having only 1 role.
						else
						 {
							dojo.byId("entity_roles_exist_nosend_"+entityId).add(dojo.create("option", { text: response.message.static_user.entity_record.existing_roles.role.role_description, innerHTML:response.message.static_user.entity_record.existing_roles.role.role_description, value: response.message.static_user.entity_record.existing_roles.role.name}));
							
						 }
								}
						}
						
						// when the entity checkobox is unchecked, no need of populating existing roles
						else{
							dj.byId("entity_flag_nosend_"+entityId).set("checked", false);
					    	   misys.animate('wipeOut', "entity_roles_div_"+entityId);
						}
						}
					
						// to populate the available role list from available roles
						var entityavailroledesc,
						entityavailroleval,
						entityavailrolelistref,
						entflagval1,
						defaultentity = dj.byId("default_entity");
						
						// if there are more than one entities related to company
						if(response.message.static_user.entity_record.length > 0)
						{
						for(var b=0; b < response.message.static_user.entity_record.length; b++)
							{
								entityId = response.message.static_user.entity_record[b].entity_id;
								entflag = dijit.byId("entity_flag_nosend_"+entityId);
								entityavailrolelistref = dojo.byId("entity_roles_avail_nosend_"+entityId);
							    entflagval1 = response.message.static_user.entity_record[b].entity_flag;
							    entflag.set("value", entflagval1);
							    // 
							    if(entflagval1 == "Y")
							    {
							    	entityavailrolelistref.innerHTML="";
							    	// if available roles not empty
							    	if(response.message.static_user.entity_record[b].avail_roles)
							    		{
							    			// if available roles are not empty and having more than 1 role
							    			if(response.message.static_user.entity_record[b].avail_roles.role.length > 0)
											 {
							    				response.message.static_user.entity_record[b].avail_roles.role.sort(GetSortOrder("role_description"));
												for(var s = 0; s < response.message.static_user.entity_record[b].avail_roles.role.length; s++)
												{
												entityavailroledesc = response.message.static_user.entity_record[b].avail_roles.role[s].role_description;
												entityavailroleval = response.message.static_user.entity_record[b].avail_roles.role[s].name;
												dojo.create("option", { text: entityavailroledesc, value: entityavailroleval, innerHTML: entityavailroledesc, textValue: entityavailroledesc}, entityavailrolelistref);
												}
											 }
							    			// if available roles are not empty and having only 1 role
											else
											 {
												dojo.byId("entity_roles_avail_nosend_"+entityId).add(dojo.create("option", { text: response.message.static_user.entity_record[b].avail_roles.role.role_description, innerHTML:response.message.static_user.entity_record[b].avail_roles.role.role_description, value: response.message.static_user.entity_record[b].avail_roles.role.name}));
												
											 }
							    			
							    			dj.byId("entity_flag_nosend_"+entityId).set("checked", true);
									    	   misys.animate('wipeIn', "entity_roles_div_"+entityId);
							    		}
							    }
							    //
							    else
							    	{
							    	  dj.byId("entity_flag_nosend_"+entityId).set("checked", false);
							    	   misys.animate('wipeOut', "entity_roles_div_"+entityId);
							    	}
							}
						}
						
						// if only single entity is linked to company
					else
						{
						if(response.message.static_user.entity_record.default_entity == "Y")
							{
								 var tmp=response.message.static_user.entity_record.entity_name;
								 var op = document.createElement("OPTION");
								 op.innerHTML = tmp;
								 op.value= tmp;
								 defaultentity.set("item", op);
							}
						entityId = response.message.static_user.entity_record.entity_id;
						entityavailrolelistref = dojo.byId("entity_roles_avail_nosend_"+entityId);
						entflagval1 = response.message.static_user.entity_record.entity_flag;
						if(entflagval1 == 'Y')
						{
							entityavailrolelistref.innerHTML="";
							// if available roles not empty
							if(response.message.static_user.entity_record.avail_roles)
								{
								// if available roles are not empty and having more than 1 role
						if(response.message.static_user.entity_record.avail_roles.role.length>0 /*&& response.message.static_user.entity_record.avail_roles*/)
						 {
							response.message.static_user.entity_record.avail_roles.role.sort(GetSortOrder("role_description"));
							for(var t = 0; t < response.message.static_user.entity_record.avail_roles.role.length; t++)
							{
							entityavailroledesc = response.message.static_user.entity_record.avail_roles.role[t].role_description;
							entityavailroleval = response.message.static_user.entity_record.avail_roles.role[t].name;
							dojo.create("option", { text: entityavailroledesc, value: entityavailroleval, innerHTML: entityavailroledesc, textValue: entityavailroledesc}, entityavailrolelistref);
							}
							dj.byId("entity_flag_nosend_"+entityId).set("checked", true);
							/* misys.animate('wipeIn', "entity_roles_div_"+entityId);*/
						 }
						// if available roles are not empty and having only 1 role
						else
						 {
							dojo.byId("entity_roles_avail_nosend_"+entityId).add(dojo.create("option", {text: response.message.static_user.entity_record.avail_roles.role.role_description, innerHTML: response.message.static_user.entity_record.avail_roles.role.role_description,  value: response.message.static_user.entity_record.avail_roles.role.name}));
							
						 }
								}
						}
						
						else{
							dj.byId("entity_flag_nosend_"+entityId).set("checked", false);
					    	   misys.animate('wipeOut', "entity_roles_div_"+entityId);
						}
						}
						
				}
		}
			// populating roles for entitlement
		if(response.message.static_user.company_type == '03')
		{
			if(response.message.static_user.entitlement_record)
			{
				var entitlementId;
				var entitlementFlag = false;
				for(var t2 = 0; t2 < response.message.static_user.entitlement_record.length; t2++){
					entitlementId = response.message.static_user.entitlement_record[t2].entitlement_id;
					if(response.message.static_user.entitlement_code !== null && response.message.static_user.entitlement_code !== undefined && response.message.static_user.entitlement_code === response.message.static_user.entitlement_record[t2].entitlement_code && dj.byId("entitlement_flag_nosend_"+entitlementId) !== null && dj.byId("entitlement_flag_nosend_"+entitlementId) !== undefined)
					{
						entitlementFlag= true;
					}
				}
				for(var t1 = 0; t1 < response.message.static_user.entitlement_record.length; t1++)
				{
					entitlementId = response.message.static_user.entitlement_record[t1].entitlement_id;
					var subsidiaryIDValue;
					var entitlementCode = response.message.static_user.entitlement_record[t1].entitlement_code;
					var defaultSubsidiary = response.message.static_user.entitlement_record[t1].default_subsidiary;
					var subsidiaryIDListValue = response.message.static_user.entitlement_record[t1].subsidiary_List;
					if(subsidiaryIDListValue !== undefined && subsidiaryIDListValue.length > 0) {
						subsidiaryIDValue = subsidiaryIDListValue.substring(1,subsidiaryIDListValue.length-1);
					}
					if(response.message.static_user.entitlement_code !== null && response.message.static_user.entitlement_code !== undefined && response.message.static_user.entitlement_code === response.message.static_user.entitlement_record[t1].entitlement_code && dj.byId("entitlement_flag_nosend_"+entitlementId) !== null && dj.byId("entitlement_flag_nosend_"+entitlementId) !== undefined)
					{
						dj.byId("entitlement_flag_nosend_"+entitlementId).set("checked", true);
						misys.animate('wipeIn', 'userSubsidiaryTable_'+entitlementId);
						if(subsidiaryIDValue !== "" && subsidiaryIDValue !== undefined) {
							if(dijit.byId("subsidiary_flag_nosend_".concat(subsidiaryIDValue)))
							{
								dijit.byId("subsidiary_flag_nosend_".concat(subsidiaryIDValue)).set("checked",true);
								dijit.byId("subsidiary_radio_flag_nosend_".concat(subsidiaryIDValue)).set("checked",true);
								dijit.byId("default_subsidiary").set("value",defaultSubsidiary);
							}
							dijit.byId("entitlement_code").set("value",entitlementCode);
						}
					}
					else if (response.message.static_user.entitlement_code === "")
					{
						dj.byId("entitlement_flag_nosend_"+entitlementId).set("checked", false);
						dj.byId("entitlement_flag_nosend_"+entitlementId).set("disabled", false);
						misys.animate('wipeOut', 'userSubsidiaryTable_'+entitlementId);
						if(subsidiaryIDValue !== "" && subsidiaryIDValue !== undefined) {
							dijit.byId("subsidiary_flag_nosend_".concat(subsidiaryIDValue)).set("checked",false);
							dijit.byId("subsidiary_radio_flag_nosend_".concat(subsidiaryIDValue)).set("checked",false);
						}
					}
					else
					{
						if (response.message.static_user.entitlement_code !== response.message.static_user.entitlement_record[t1].entitlement_code && !entitlementFlag) {
							dj.byId("entitlement_flag_nosend_"+entitlementId).set("disabled", false);
						} else if(dj.byId("entitlement_flag_nosend_"+entitlementId) !== null && dj.byId("entitlement_flag_nosend_"+entitlementId)) {
							dj.byId("entitlement_flag_nosend_"+entitlementId).set("disabled", true);
						}
					}
				}			
			}
		}
		console.debug("[misys.form.common] _PopulateCloneUserDetails : end ");
		}
		dj.byId("xhrDialog")?dj.byId("xhrDialog").hide():"";
	}
	
	function GetSortOrder(prop) {  
	    return function(a, b) {  
	        if (a[prop] > b[prop]) {  
	            return 1;  
	        } else if (a[prop] < b[prop]) {  
	            return -1;  
	        }  
	        return 0;  
	    };  
	}  
	
	
	
	/**
	 * <h4>Summary:</h4>
	 * This function is used to set the ajax response to the store id.
	 * <h4>Description:</h4> 
	 * The store value is refreshed with the ajax response for the search options.
	 * @param {Object} response
	 * @method _showExistingPoRefMsg
	 */
	function _showAjaxSearchData(response) {
		console.debug("[misys.form.common] _showAjaxSearchData : start ");
		if(response && response.items !=="")
		{
			var storeId = response.store_id ;
			var field = dj.byId(storeId);
			if(field && field.store)
			{
				var emptyStore = new dojo.data.ItemFileWriteStore({data:{"identifier":"id","items" :[]}});
				var ctr = 0;
				dojo.forEach(response.items, function(item){
					var newItem = item;
					newItem.id = ctr++;
					emptyStore.newItem(newItem);
				});
				field.setStore(emptyStore);
				field.resize();
			}
		}
		console.debug("[misys.form.common] _showAjaxSearchData : end ");
	}
	
	// Public Functions and Variables
	d.mixin(m, {
		
		selectEntityBeforeBank : function()	{
			if(dj.byId("entity") && dj.byId("entity").get("value") == "" && Object.keys(misys._config.entityBankMap).length > 1)
			{
				var id = this.id;
				var onLoadCallback = function() {
					dj.byId(id).set("value", "");
					 dojox.fx.smoothScroll({
							node: document.getElementById("entity"), 
							win: window
						}).play();
				};
				
				m.dialog.show("ERROR", m.getLocalization("selectEntityBeforeBank"),"", onLoadCallback);
			}
		},
		populateBankAsPerEntity : function(bankFieldId) {
			var linkedBankBox = dj.byId(bankFieldId);
		    var banksArray = Object.keys(misys._config.entityBankMap).map(function(itm) { return misys._config.entityBankMap[itm]; });
			var jsonData = {
			    		"identifier" :"value",
			    		"items" : []
			    },
		    linkedBankBoxStore = new d.data.ItemFileWriteStore({
				data : jsonData
			});
			
			if(linkedBankBox) {
				linkedBankBox.store = null;
				
				for(var i = 0; i < banksArray.length; i++) {
					if (dj.byId("entity") && banksArray[i].indexOf(dj.byId("entity").get("value")) > -1) {
						linkedBankBoxStore.newItem({
						"value" : Object.keys(misys._config.entityBankMap).map(function(itm) { return misys._config.entityBankMap[itm]; })[i][0],
						"name" : Object.keys(misys._config.entityBankMap)[i]
						});
					}
				}
			}
			linkedBankBox.store = linkedBankBoxStore;
			var bankValue = dj.byId(bankFieldId)?dj.byId(bankFieldId).get("value"):"";
			var arrayLineItems = linkedBankBox.store._arrayOfAllItems;
			var flag = false;
			for(i=0;i<arrayLineItems.length;i++) {
				if(arrayLineItems[i] && arrayLineItems[i].value!="" && arrayLineItems[i].value==bankValue) {
					flag=true;
					break;
				}
			}	
			if(!flag)
				{
				dj.byId(bankFieldId).set("value", "");
				}
		},
		/**
		 * <h4>Summary:</h4> Populate a select box based on the content
		 * of the current bank and entity selection.
		 * @method populateReferences
		 */
		populateReferences : function() {
		    //  summary:
		    //        Populate a select box based on the content of the current bank and entity 
			//        selection.

			// Retrieve the prefix and set the name value;
			console.debug("[misys.form.common] Populating references ");
			
			// TODO Needs another refactor
			
			 var value = this.get("displayedValue"),
			    splitter = "_",
			    tokens = this.id.split(splitter),
			    prefix = tokens[0] + splitter + tokens[1],
			    referencesBox = dj.byId(prefix + "_customer_reference"),
			    applicantRefObj = dj.byId("applicant_reference") || 
			    					dj.byId("applicant_reference_hidden") || dj.byId("seller_reference") || dj.byId("drawer_reference") || dj.byId("buyer_reference"),
			    entity = dj.byId("entity") ? dj.byId("entity").get("value") : "",
			    currentReferencesIndex = this.get("value") + "_" + entity,
			    currentReferences = (m._config.customerReferences && 
			    					   m._config.customerReferences[currentReferencesIndex]) ?
			    						  m._config.customerReferences[currentReferencesIndex] : "",
			    jsonData = {
			    		"identifier" :"id",
			    		"items" : []
			    },
			    referenceBoxStore = new d.data.ItemFileWriteStore( {
					data : jsonData
				});
			    // changes done as part of MPS-49250 -Reverting the changes done for MPS-49250 solves MPS-53828					  
			    if(dj.byId(prefix + "_name"))
		    	{
					dj.byId(prefix + "_name").set("value", value);
		    	}

			// If the contents of currentReferences are undefined
			
			if(referencesBox) {
				// Clear references
				referencesBox.store = null;

				if(currentReferences && currentReferences.length !== 0) {
					console.debug("[misys.form.common]", currentReferences.length,  
							"refs were found");
					
					// Arrays are pairs of (description, value), so we 
					// iterate in groups of 2
					for(var i = 0, limit = (currentReferences.length) / 2; i < limit; i++){
						referenceBoxStore.newItem( {
							"id" : currentReferences[2 * i + 1],
							"name" : currentReferences[2 * i]
						});
					}
				} /*else {
					referenceBoxStore.newItem({
						"id" : "",
						"name" : ""
					});
				}*/
				referencesBox.store = referenceBoxStore;
				
				//Remove previously entered text if any
				if(referenceBoxStore._arrayOfAllItems.length === 1)
				{
					referencesBox.set("displayedValue",referenceBoxStore._arrayOfAllItems[0].name[0]);
				}
				else
				{
					if(applicantRefObj )
					{
						if(applicantRefObj.get("value")!=='' && currentReferences.indexOf(applicantRefObj.get("value"))!==-1)
						{
							referencesBox.set("value",applicantRefObj.get("value"));
						}
						else
						{
							referencesBox.item = null;
							applicantRefObj.set("value","");
							referencesBox.set("displayedValue","");
						}
					}
				}
			}
			if (dj.byId("product_code") && dj.byId("product_code").get("value") === "IO" && dj.byId("buyer_bank_bic"))
			{
				dj.byId("buyer_bank_bic").set("value", m._config.isoCodes[this.get("value")]);
			}
			if (dj.byId("product_code") && dj.byId("product_code").get("value") === "EA" && dj.byId("seller_bank_bic"))
			{
				dj.byId("seller_bank_bic").set("value", m._config.isoCodes[this.get("value")]);
			}
		}, 
		updateBusinessDate: function() {
			 var ownerBankDate = m._config.bankBusinessDate;
			 var currentDate;
			 var tempDate;
			if(this.get("value")!="")
			{
				var yearServer = parseInt(misys._config.businessDateForBank[this.get('value')][0].value.substring(0,4), 10);
				var monthServer = parseInt(misys._config.businessDateForBank[this.get('value')][0].value.substring(5,7), 10);
				var dateServer = parseInt(misys._config.businessDateForBank[this.get('value')][0].value.substring(8,10), 10);
				tempDate=new  Date(yearServer, monthServer - 1, dateServer);
				currentDate = d.date.locale.format((tempDate), {
					selector :"date"
				});
			    m._config.bankBusinessDate = misys._config.businessDateForBank[this.get('value')][0].name;
				if(m._config.bankBusinessDate != ownerBankDate)
					{
					 m.dialog.show("CUSTOM-NO-CANCEL", m.getLocalization("changeInBusinessDates"),"Warning",function(){});
					 if(dj.byId("appl_date"))
						{
							dj.byId("appl_date").set("value",currentDate);
							dojo.byId("appl_date_view_row").childNodes[1].innerHTML=dj.byId("appl_date").get("value");
						}
					}
			}
		},
		
		checkBeneficiaryNicknameDiv: function()
		{
			if(misys._config.beneficiarynickname==="true")
			{
				if(dj.byId("beneficiary_nickname") && dj.byId("beneficiary_nickname").get("value")!==""  && d.byId("beneficiarynickname") && d.byId("beneficiary_nickname_row")){
					d.style("ben_label", "display", "inline-block");
					d.byId("beneficiarynickname").innerHTML = dj.byId("beneficiary_nickname").get("value");
					d.byId("beneficiarynickname").value = dj.byId("beneficiary_nickname").get("value");
					d.style("beneficiarynickname", "display", "inline");
					m.animate("fadeIn", d.byId("beneficiary_nickname_row"));
				}else{
					if(d.byId("beneficiarynickname")){
						d.style("beneficiarynickname", "display", "none");	
						m.animate("fadeOut", d.byId("beneficiary_nickname_row"));
					}
				}
			}
		},
		
		checkBeneficiaryNicknameOnFormLoad : function()
		{
			if(misys._config.beneficiarynickname==="true" && dj.byId("beneficiary_nickname") && dj.byId("beneficiary_nickname").get("value")!=="" && dj.byId("beneficiary_nickname").get("value")!=="null" && d.byId("beneficiarynickname")){
				m.animate("fadeIn", d.byId("beneficiarynickname"));
				d.style("beneficiarynickname","display","inline");
				d.byId("beneficiarynickname").innerHTML = dj.byId("beneficiary_nickname").get("value");
			}else{
				m.animate("wipeOut", d.byId("beneficiary_nickname_row"));
			}
		},		
		
		/**
		 * <h4>Summary:</h4> 
		 * Set the currency of a set of amount
		 * fields 
		 * <h4>Description:</h4>  
		 * This function takes two
		 * parameters - a node (or id) of a Dijit
		 * containing a currency code, and a single ID
		 * or array of IDs for fields on which this
		 * currency should be set as a constraint
		 * @param {Dijit||String} node
		 *  A node of dijit containing currency code.
		 * @param {Array|| String} arr
		 *  A single ID or array of IDs for fields on which this currency should be set as a constraint
		 * @param {Object} constraints
		 * @method setCurrency
		 */
		setCurrency : function( /*Dijit|String*/ node,
                				/*Array|String*/ arr,
                				/*Object*/ constraints) {
			//  summary:
			//        Set the currency of a set of amount fields
			//	description:
			//		  This function takes two parameters - a node (or id) of a Dijit containing
			//		  a currency code, and a single ID or array of IDs for fields on which this
			//		  currency should be set as a constraint
			
			var currencyField = dj.byId(node),
				targetFieldIds = d.isArray(arr) ? arr : [arr],
				currency, field, cldrMonetary;
			
			if(currencyField && currencyField.get("value") !== "" &&
					currencyField.state !== "Error") {
				currency = currencyField.get("value");
				d.forEach(targetFieldIds, function(id){
					field  = dj.byId(id);
					if(field){
						console.debug("[misys.form.common] Setting currency code", currency, 
										"on field", id);
						cldrMonetary = d.cldr.monetary.getData(currency);
						//added as part of MPS-34571(5.4) fix.
						if (dj.byId("product_code") && ((dj.byId("product_code").get("value") === "IP")||(dj.byId("product_code").get("value") === "IN") || (dj.byId("product_code").get("value") === "PO") || (dj.byId("product_code").get("value") === "SO")))
						{
							currencyField.set("readOnly",true);
						}
						
						
						//Client specific (FIX ME : Need to find a solution to override common 
						//function's for client specific requirement)
						var monetaryConst = {round: cldrMonetary.round, 
											places: cldrMonetary.places,
											max:999999999999.99,
											min: 0.01};
						
						if(cldrMonetary.places === 2)
						{
							monetaryConst = {
								round: cldrMonetary.round,
								places: cldrMonetary.places,
								min:0.00,
								max:999999999999.99
							};
						}
						else if(cldrMonetary.places === 3)
						{
							monetaryConst = {
								round: cldrMonetary.round,
								places: cldrMonetary.places,
								min:0.000,
								max:99999999999.999
							};
						}
						else if(cldrMonetary.places === 0)
						{
							monetaryConst = {
								round: cldrMonetary.round,
								places: cldrMonetary.places,
								min:0,
								max:999999999999
							};
						}

						// Mixin any provided constraints
						d.mixin(monetaryConst, constraints);

						field.set("constraints", monetaryConst);
						field.set("value",field.get("value"));
					}
				});
			}
		},
						/**
						 * <h4>Summary:</h4> Populate the TNX amount 
						 * 
						 * <h4>Description:</h4>  Just a
						 * helper function 
						 * 
						 * @param String || Number
						 * @method setTnxAmt 
						 */
		setTnxAmt : function( /*String|number*/ amt) {
			//  summary:
		    //        Populate the TNX amount
			//  description:
			//        Just a helper function - tnx_amt doesn't always exist and its a pain to
			//        check every time
			
			var tnxAmt = dj.byId("tnx_amt");
			if(tnxAmt){
				tnxAmt.set("value", amt);
			}
		},
		setTnxCurCode : function(curCode) {
				//  summary:
		    //        Populate the TNX currency
			//  description:
			//        Just a helper function - tnx_cur_code doesn't always exist and its a pain to
			//        check every time
			var tnxCurCode = dj.byId("tnx_cur_code");
			if(tnxCurCode){
				tnxCurCode.set("value", curCode);
			}
		},
						/**
						 * <h4>Summary:</h4>
						 *  Amend the transaction amount by taking the
						 * value of the field "node", and either incrementing or
						 * decrementing the transaction amount.
						 * 
						 *  <h4>Description:</h4> 
						 * Amends the transaction amount by incrementing or
						 * decrementing the transaction amount (action chosen
						 * based on the ID of field "this"). If an increment is
						 * performed, the decrement field is disabled (and vice
						 * versa).
						 * 
						 * Note that the value of misys._config.productCode must
						 * be correctly set for this function to work.
						 * Previously, we were passing around the product code
						 * but we want to avoid that...
						 * 
						 * @method amendTransaction
						 * 
						 * 
						 */
		amendTransaction : function() {
			//  summary:
		    //        Amend the transaction amount by taking the value of the field
			//		  "node", and either incrementing or decrementing the transaction 
			//		  amount.
			//	description
			//		  Amends the transaction amount by incrementing or decrementing
			//		  the transaction amount (action chosen based on the ID of field "this").
			//		  If an increment is performed, the decrement field is disabled (and vice versa).
			//
			//		  Note that the value of misys._config.productCode must be correctly set
			//		  for this function to work. Previously, we were passing around the product code
			//		  but we want to avoid that...

			var otherField = ("inc_amt" === this.get("id")) ? 
								dj.byId("dec_amt") : dj.byId("inc_amt");
			
			if(!isNaN(this.get("value"))) {
				otherField.set("disabled", true);
			} else {
				this.set("disabled", false);
				otherField.set("disabled", false);
			}
			_calculateNewAmt(this);
		},
		amendTransactionBank : function() {
			var otherField = ("inc_amt_value" === this.get("id")) ? 
								dj.byId("dec_amt_value") : dj.byId("inc_amt_value");
			
			if(!isNaN(this.get("value"))) {
				otherField.set("disabled", true);
			} else {
				this.set("disabled", false);
				otherField.set("disabled", false);
			}
			_calculateNewAmt(this);
		}, 

		amendTransactionLiabAmt : function()
		{
			dj.byId("lc_liab_amt").set("value",dj.byId("org_lc_cur_code_liab_amt").value);
		},
		
		setPaymentDescriptionForCAD : function()
		{
			if (dojo.byId("date-value_description").innerHTML !== "" && dojo.byId("request_value_code").value === 'SPOT' && 
					dojo.byId("payment_cur_code").value ==='CAD' && dojo.byId("applicant_cur_code").value === 'USD')
			{
				dojo.byId("date-value_description").innerText = m.getLocalization("valueOneBusinessDayCADdeal");
			}
			else if (dojo.byId("date-value_description").innerHTML !== "" && dojo.byId("request_value_code").value === 'SPOT' && 
			 (dojo.byId("payment_cur_code").value !=='CAD' ||  dojo.byId("applicant_cur_code").value !== 'USD'))
			{
				dojo.byId("date-value_description").innerText = m.getLocalization("valueTwoBusinessDay");
			}
		},
		
		/**
		 * <h4>Summary:</h4>
		 *  Reset the increased and transaction amounts
		 *  
		 * <h4>Description:</h4> 
		 * @method  toggleAmendmentFields
		 */
		toggleAmendmentFields : function(){
			//  summary:
		    //        Reset the increased and tnx amounts
			//	decription:
			//		  TODO The business logic behind this needs to be better explained here
			//
			//	      Note that misys._config.productCode must be correctly set, otherwise
			//		  _calculateNewAmt will not be able to find certain fields.

			var incrementField = dj.byId("inc_amt"),
			    decrementField = dj.byId("dec_amt");
			// Reset the increased and tnx amount
			if(this.get("checked")){
				incrementField.set("value", "");
				incrementField.set("disabled", true);
				decrementField.set("disabled", false);
				_calculateNewAmt(decrementField);
			} else {
				incrementField.onBlur();
				decrementField.onBlur();
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * Update sub transaction type code depending upon Flag checked
		 * @method updateSubTnxTypeCode
		 */
		updateSubTnxTypeCode : function() {
			// summary:
			//		TODO Need a better explanation of the business logic here, particularly
			//		why the if/else logic is in this particular order
			
			var productCode = misys._config.productCode.toLowerCase(),
				incrementField = dj.byId("inc_amt"),
				decrementField = dj.byId("dec_amt"),
				releaseFlagField = dj.byId(productCode + "_release_flag"),
				subTnxTypeCodeField = dj.byId("sub_tnx_type_code"),
				subTnxTypeCode = "03", // default value
				incrementAmount = incrementField ? dojo.number.parse(incrementField.get("value")) : "",
				decrementAmount = decrementField ? dojo.number.parse(decrementField.get("value")) : "";
		
			if(releaseFlagField && releaseFlagField.get("checked")) {
				subTnxTypeCode = "05";
			} 
			else if(incrementField && !isNaN(incrementAmount) && incrementAmount !== "") {
				subTnxTypeCode = "01";
			}
			else if(decrementField && !isNaN(decrementAmount) && decrementAmount !== "") {
				subTnxTypeCode = "02";
			}
			
			if(subTnxTypeCodeField) {
				subTnxTypeCodeField.set("value", subTnxTypeCode);
			}
		}, 
		/**
		 * <h4>Summary:</h4>
		 * Enable a set of beneficiary fields.Do a loop over all the fields and enable all  of them.
		 * @method enableBeneficiaryFields
		 */
		enableBeneficiaryFields : function(){
			//  summary:
		    //        enable a set of fields
			
			var ids = ["beneficiary_address_line_1",
			           		"beneficiary_address_line_2", "beneficiary_dom", "beneficiary_address_line_4"];
			d.forEach(ids, function(id){
				var field = dj.byId(id);
				if(field) {
					field.set("disabled", false);
					field.set("readOnly", false);
				}
			});
		}, 
		/**
		 * <h4>Summary:</h4>
		 * Setting action required depending upon product status code
		 * @method toggleProdStatCodeFields
		 */
		toggleProdStatCodeFields : function() {
			//  summary:
		    //        Actions for the prod stat code
			//	description:
			//		  TODO The business logic behind this function must be explained here
			// 		  TODO This code needs to be reviewed, and compared with v3. Not clear
			//			   at all what its doing
			
			var prodStatCode = dj.byId("prod_stat_code").get("value"),
			    actionReqCodeField = dj.byId("action_req_code"),
			    //Comment for TF maturity getting disable on reporting status selection
			    //requiredFields = ["tnx_amt", "maturity_date"],
			   // nonRequiredFields = ["tnx_amt", "maturity_date", "latest_answer_date"];
			 	requiredFields = ["tnx_amt"],
			    nonRequiredFields = ["tnx_amt", "latest_answer_date"];
			
			if(actionReqCodeField)
			{
				if (prodStatCode === "01" || prodStatCode === "18") {
					actionReqCodeField.set("readOnly", true);
					actionReqCodeField.reset();
				} 
				else if(prodStatCode === "12") {
					actionReqCodeField.set("value", "12");
					actionReqCodeField.set("readOnly", true);
				    m.toggleFields(false, ["latest_answer_date"], requiredFields, true);
					requiredFields = ["tnx_amt"];
				}
				else if(prodStatCode === "26") {
					actionReqCodeField.set("value", "26");
					actionReqCodeField.set("readOnly", true);
					m.toggleFields(false, ["latest_answer_date"], requiredFields, true);
					requiredFields = ["tnx_amt"];
				}
				else if(prodStatCode === "78" || prodStatCode === "79" || (prodStatCode === "98" && dj.byId("product_code") && dj.byId("product_code").get("value") === "TF")) {
					actionReqCodeField.set("value", "07");
					actionReqCodeField.set("readOnly", true);
				}
				else if(prodStatCode === "A9") {
					actionReqCodeField.reset();
					actionReqCodeField.set("readOnly", false);
					nonRequiredFields = ["tnx_amt"];
					requiredFields = [];
				}
				else if(prodStatCode === "31") {
					var productCode = dj.byId("product_code").get("value");
					if(dj.byId("product_code") && (productCode === "LC" || productCode === 'SI' || productCode === 'BG' || productCode === 'SG')) {
						actionReqCodeField.set("value", "");
						actionReqCodeField.set("readOnly", true);
					} else {
						actionReqCodeField.set("value", "03");
						actionReqCodeField.set("readOnly", true);
					}
				}
				else if(prodStatCode === "81") {
					actionReqCodeField.set("value", "05");
					actionReqCodeField.set("readOnly", true);
				}
				else {
					//actionReqCodeField.reset();
					actionReqCodeField.set("readOnly", false);
					nonRequiredFields = ["latest_answer_date"];
				}
			}
			
			var toggleTnxAmt = (prodStatCode === "08" && dj.byId("tnx_type_code") && dj.byId("tnx_type_code").get("value") === "03") ? true : !(prodStatCode !== "01" && prodStatCode !== "07" &&
					prodStatCode !== "04" && prodStatCode !== "05" &&
					prodStatCode !== "12" && prodStatCode !== "26" && prodStatCode !== "13" &&
					prodStatCode !== "14" && prodStatCode !== "15" && prodStatCode !== "A9");

			m.toggleFields(toggleTnxAmt, nonRequiredFields, requiredFields);
		},
	/**
	 * <h4>Summary:</h4>
	 * Toggle the guarantee text rich text editor. Must be called via d.connect.
	 * If bg_text_type_code is 04 animate the guarantee text field otherwise do a fade out.
	 * @method toggleGuaranteeText
	 */
		toggleGuaranteeText : function() {
			//  summary:
			//          Toggle the guarantee text rich text editor. Must be called via d.connect.
			
			var value = this.get("value"),
			    documentEditorDiv = d.byId("document-editor"),
			    bgDocument = dj.byId("bg_document");
			
			m.toggleFields(value === "03", null, ["bg_text_type_details"]);
			if(value === "04") {
				m.animate("fadeIn", documentEditorDiv, function(){
				console.debug("[misys.form.common] - toggleGuaranteeText - Test editor");
					if (!bgDocument) {
						var attachPoint = d.byId("bg_document");
						bgDocument = new dj.Editor({
							id: "bg_document",
							name: "bg_document",
							rows: _defaultEditorRows,
							cols: _defaultEditorCols,
							maxSize: _defaultEditorMaxSize,
							plugins:[
							         "undo", "redo", "|", "bold", "italic", "underline", "strikethrough", 
							         "|", "insertOrderedList", "insertUnorderedList", "|", "indent", 
							         "outdent", "|", "justifyLeft", "justifyRight", "justifyCenter", 
							         "justifyFull", "||",
							         {
							        	 name: "dijit._editor.plugins.FontChoice", 
							        	 command: "fontName"
							         },
							         {
							        	 name: "m.editor.plugins.ProductFieldChoice", 
							        	 command: "misysEditorPluginsProductFieldChoice", 
							        	 product: "BG"
							         }
							        ]
							}, attachPoint);
						var rteContentDiv = d.byId("rteContent");
						var rteContent = rteContentDiv.innerHTML;
						rteContent.replaceAll("&lt;", "<");
						rteContent.replaceAll("&gt;", ">");
						rteContent.replaceAll("&amp;", "&");
						bgDocument.set("value", (rteContent || ""));
					}
				});
			} else {
				m.animate("fadeOut", documentEditorDiv, function(){
					if (bgDocument){
						bgDocument.set("value", "");
					}
				});
			}
		},
		
						/**
						 * <h4>Summary:</h4> 
						 * Set buyer reference on issuing bank
						 * reference change. 
						 * <h4>Description:</h4>  
						 * Another helper function to avoid repetition.
						 * @method setBuyerReference
						 */
		setBuyerReference : function() {
			//  summary:
		    //        Set buyer reference on issuing bank reference change.
			//  description:
			//        Another helper function to avoid repetition
			//
			
			var buyerRefObj = dj.byId("buyer_reference") || 
									dj.byId("buyer_reference_hidden");
			if(buyerRefObj) {
				buyerRefObj.set("value", this.get("value"));
			}
		},
						/**
						 * <h4>Summary:</h4> 
						 * Set Seller reference on issuing bank
						 * reference change.
						 *  
						 * <h4>Description:</h4>  Another helper
						 * function to avoid repetition
						 * @method setSellerReference 
						 */
		setSellerReference : function() {
			//  summary:
		    //        Set Seller reference on issuing bank reference change.
			//  description:
			//        Another helper function to avoid repetition
			//
			
			var sellerRefObj = dj.byId("seller_reference") || 
									dj.byId("seller_reference_hidden");
			if(sellerRefObj) {
				sellerRefObj.set("value", this.get("value"));
			}
		},
		
		setApplicantReference : function() {
			//  summary:
		    //        Set applicant reference on issuing bank reference change.
			//  description:
			//        Another helper function to avoid repetition
			//
			
			var applicantRefObj = dj.byId("applicant_reference") || 
									dj.byId("applicant_reference_hidden");
			if(applicantRefObj) {
				applicantRefObj.set("value", this.get("value"));
			}
		},

				/**
				 * <h4>Summary:</h4>
				 *  Recompute the maturity date based on the issue date and the tenor.
				 *  @method getMaturityDate 
				 */
		getMaturityDate : function() {
			//  summary:
		    //        Recompute the maturity date based on the issue date and the tenor.
			var tenorField = dj.byId("tenor"),
				tenor = tenorField.get("value"),
				issDate = dj.byId("iss_date").get("value"),
				maturityDateField = dj.byId("maturity_date"),
				newValue = "";
			
			// If we've changed the maturity date, then change the tenor
			if(this.id === "maturity_date") {
				newValue = issDate ? 
								d.date.difference(issDate, this.get("value"), "day") : tenor;
				tenorField.set("value", newValue);
			} else if(tenor !== '' && issDate) {
				maturityDateField.set("value", d.date.add(issDate, "day", tenor));
			}
		},
		/**
		 * <h4>Summary:</h4>
		 *  This function manages the deletion of the counterparties.
		 *  First it check if new currency code is not same as the ft_cur_code's value,
		 *  It means currency change has happened now delete the counterparties or reset them.
		 *  @method initFTCounterparties
		 */
		initFTCounterparties : function(){
			//  summary:
		    //        This function manages the deletion of the counterparties.
			
			var inputCurCode = this.get("value"),
				that;
			
			if(inputCurCode !== dj.byId("ft_cur_code").get("value")){
				console.debug(
						"[misys.form.common] Currency change, may have to delete counterparties"); 
				if(d.query(
						".widgetContainer *[id^='counterparty_details_document_id_']").length > 0){
					that = this; // For closure reference, below
					m.dialog.show("CONFIRMATION", 
							m.getLocalization("modifyFundTransferCurrencyConfirmation"), "",
							function() {
								_resetFTCounterparties(that);
							}
					);
				} else {
					_resetFTCounterparties(this);
				}
			}
		}, 
		/**
		 * <h4>Summary:</h4>
		 * Disabling non acceptance field.It depends on the value of the term_code ,disable the fields if its value os '01'.
		 * @method disableNonAcceptanceFields
		 */
		disableNonAcceptanceFields : function(){
			// summary:
			//
			
			if(dj.byId("term_code").get("value") === "01") {
				console.debug("[misys.form.common] Disabling Protest non-acceptance");
				this.set("checked", false);
			}
		}, 

								/**
								 * <h4>Summary:</h4> 
								 * Set the value for the credit bank
								 * name, and perform other actions. 
								 * @method setCreditAvailBy
								 * 
								 */
		setCreditAvailBy : function() {
			//  summary:
		    //        Set the value for the credit bank name, and perform other actions.
			//	description:
			//			TODO Business logic explanation should go here
			
			var bankType = this.get("value"),
				crAvlBankName = dj.byId("credit_available_with_bank_name"),
				crAvlCode = dj.byId("fakeform1").get("value").cr_avl_by_code,
				crAvlBankNameValue, crAvlBankAdd1Value,
				crAvlBankAdd1 = dj.byId("credit_available_with_bank_address_line_1");
			
			console.debug("[misys.form.common] Setting Credit/Available By Values for bank type", 
								bankType);
			m.toggleFields(bankType === m._config.other, 
					["credit_available_with_bank_address_line_1",
					"credit_available_with_bank_address_line_2",
					"credit_available_with_bank_dom",
					"credit_available_with_bank_address_line_4"]);
			
			crAvlBankNameValue = crAvlBankName.get("value");
			crAvlBankAdd1Value = crAvlBankAdd1.get("value");
			// address-line-1 is a mandatory field
		    if((!(crAvlBankNameValue != '' && crAvlBankAdd1Value != '') && (dj.byId("formLoad") && dj.byId("formLoad").get("value") === "false") || !dj.byId("formLoad")) || (dj.byId("template_id") && dj.byId("template_id").getValue() !== ''))
			{
				crAvlBankName.set("value", this.get("displayedValue"));
			}
			
			
			console.debug(
					"[misys.form.common] credit_available_with_bank_name now has the value",  
					crAvlBankName.get("value"));
			
			var keepFieldValues = 
				(!crAvlBankNameValue && !dj.byId("tenor_maturity_date").get("value") && !dj.byId("tenor_days").get("value") && !dj.byId("tenor_period").get("value") && !dj.byId("tenor_from_after").get("value") && !dj.byId("tenor_days_type").get("value") && !m._config.firstPageLoad);
			
			if(keepFieldValues) {
				// Drawee Bank Details
				if(crAvlCode) {
					_toggleDraweeBankDetails(crAvlCode, bankType);
				}
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * Populates the Bank Fields based on SWIFT BIC CODE from My Banks and Other banks
		 * @param {Boolean} includeCustomerBanks
		 * @param {String} swiftWidgetId
		 * @param {Array} arrayOfBankFields
		 * @param {Array} arrayOfRequiredFields
		 * @param {String} bankType
		 * @param {Boolean} populateFlag
		 * @param {Boolean} toggleRequired
		 * @param {Booelan} toggleReadOnly
		 * @param {String} country
		 * @method getSwiftBankDetails
		 */
		getSwiftBankDetails : function(/*boolean*/ includeCustomerBanks,
									   /*String*/swiftWidgetId, 
									   /*String*/ brch_code,
									   /*Array*/arrayOfBankFields, 
									   /*Array*/arrayOfRequiredFields,
									   /*String*/bankType, 
									   /*boolean*/ populateFlag,
									   /*boolean*/ toggleRequired,
									   /*boolean*/toggleReadOnly, 
									   /*String*/ country){
			/** 
			 * <h4>Summary:</h4>
			 * Populates the Bank Fields based on SWIFT BIC CODE from My Banks and Other banks
			 */
			var retValid = false;
			if (!country)
			{
				country = "";
			}
				
			if(!arrayOfBankFields)
			{
				arrayOfBankFields = [bankType+"name", bankType+"address_line_1", bankType+"address_line_2", 
				                         	bankType+"dom", bankType+"contact_name", bankType+"phone", bankType+"country"];
			}
					
			if(!arrayOfRequiredFields)
			{
				arrayOfRequiredFields = [bankType+"name", bankType+"address_line_1", bankType+"country"];
			}
										
			var swiftWidget = dj.byId(swiftWidgetId);
			var brchcode= dj.byId(brch_code);
			if(swiftWidget && (swiftWidget.get("value") !== ""))
			{
				d.forEach(arrayOfBankFields,function(node){
					if(dj.byId(node))
					{
						if(populateFlag)
						{
							dj.byId(node).set("value","", false);
						}
						if(toggleReadOnly)
						{
							dj.byId(node).set("readOnly",true);
						}
					}
				});
				if(toggleRequired)
				{
					d.forEach(arrayOfRequiredFields,function(node){
						if(dj.byId(node))
						{
							m.toggleRequired(node, true);
						}
					});
					}
				
				if(populateFlag && (swiftWidget.validate()))
				{
					var bicCodeValue = "";
					var brchCodeValue = "";
					if(swiftWidget.get("value"))
					{
						bicCodeValue = swiftWidget.get("value");
					}
					if(brchcode && (brchcode.get("value")))
					{
					brchCodeValue = brchcode.get("value");
					}
				
					//AJAX Call
					m.xhrPost({
								url : misys.getServletURL("/screen/AjaxScreen/action/GetSwiftBankDetails"),
								content : {
									bicCode : bicCodeValue,
									brchCode: brchCodeValue,
									country : country,
									customerBanks : includeCustomerBanks
								},
								sync : true,
								handleAs : "json",
								load : function(response, args){
									
								    //Response 
									var swiftBankDetails = response;
									retValid = response.valid;
									if(retValid)
									{
										var arrayOfDetails = [swiftBankDetails.bankName, swiftBankDetails.bankAddressLine1, 
										                      swiftBankDetails.bankAddressLine2, swiftBankDetails.bankDom, swiftBankDetails.bankContactName,
										                      swiftBankDetails.bankPhone, swiftBankDetails.bankCountry];
										
										d.forEach(arrayOfBankFields,function(node,i){
											if(dj.byId(node))
											{
												if(i < 7)
												{
													dj.byId(node).set("value", arrayOfDetails[i], false);
												}
											}
										});
									}
									else
									{
										var displayMessage = "";
										// focus on the widget and set state to error and
										// display a tooltip indicating the same
										if((swiftWidget && (swiftWidget.get("value") !== "")))
										{
											swiftWidget.focus();
											displayMessage = m.getLocalization("swiftValidationFailed", [swiftWidget.get("value")]);
											swiftWidget.set("value", "");
											swiftWidget.set("state", "Error");
											dijit.hideTooltip(swiftWidget.domNode);
											dijit.showTooltip(displayMessage,swiftWidget.domNode, 0);
										}
									}
								},
								customError : function(response, args){
									console.warn("getSwiftBankDetails error");
								}
						});
				}
				else
				{
					if(dijit.byId("bank_iso_code"))
					{
					// If ISO code not valid, enable it so that user can correct it
					setTimeout(function(){
						dijit.byId("bank_iso_code").set("readOnly", false);
					}, 600);
				}
				}
			}
			else
			{
				d.forEach(arrayOfBankFields,function(node){
					if(dj.byId(node))
					{
						if(toggleReadOnly)
						{
							dj.byId(node).set("readOnly",false);
						}
					}
				});
				if(toggleRequired)
				{
					d.forEach(arrayOfRequiredFields,function(node){
					if(dj.byId(node))
					{
							m.toggleRequired(node, false);
						}
				});
					}
				if(d.byId(bankType+"iso_code_row") && d.byId(bankType+"iso_code_row").parentNode && d.byId(bankType+"iso_code_row").parentNode.id)
									{
					var tabId = d.byId(bankType+"iso_code_row").parentNode.id;
					if(dj.byId(tabId))
					{
						var title = dj.byId(tabId).get("title");
						if(title.indexOf("*") !== -1)
						{
							title = title.substring(title.indexOf(">")+1,title.lastIndexOf("<"));
							console.debug(tabTitle,title);
							if(title.indexOf("*") !== -1)
							{
								title = title.substring(title.indexOf("*")+1);
								console.debug(tabTitle,title);
								dj.byId(tabId).set("title",title);
							}
							else
							{
								dj.byId(tabId).set("title",title);
							}
						}
					}
				}
			}
			
		},
		
		
		
		getIFSCCodeDetails : function(
				   /*String*/ifscWidgetId, 
				   /*Array*/arrayOfBankFields, 
				   /*Array*/arrayOfRequiredFields,
				   /*String*/bankType, 
				   /*boolean*/ populateFlag,
				   /*boolean*/ toggleRequired,
				   /*boolean*/toggleReadOnly){
				/** 
				* <h4>Summary:</h4>
				* Populates the Bank Fields based on SWIFT BIC CODE from My Banks and Other banks
				*/
				var retValid = false;
				
				if(!arrayOfBankFields)
				{
					arrayOfBankFields = [bankType+"ifsc_name", bankType+"ifsc_address_line_1", bankType+"ifsc_address_line_2", 
					                         	bankType+"ifsc_city"];
				}
				
				
				if(!arrayOfRequiredFields)
				{
				arrayOfRequiredFields = [bankType+"ifsc_code", bankType+"ifsc_name"];
				}
									
				var ifscWidget = dj.byId(ifscWidgetId);
				if(ifscWidget && (ifscWidget.get("value") !== ""))
				{
					d.forEach(arrayOfBankFields,function(node){
						if(dj.byId(node))
						{
							if(populateFlag)
							{
								dj.byId(node).set("value","", false);
							}
							if(toggleReadOnly)
							{
								dj.byId(node).set("readOnly",true);
							}
						}
					});
					
				if(toggleRequired)
				{
				d.forEach(arrayOfRequiredFields,function(node){
					if(dj.byId(node))
					{
						m.toggleRequired(node, true);
					}
				});
				}
				
				if(populateFlag && (ifscWidget.validate()))
				{
				var ifscCodeValue = "";
				if(ifscWidget.get("value"))
				{
					ifscCodeValue = ifscWidget.get("value");
				}
				//AJAX Call
				m.xhrPost({
							url : misys.getServletURL("/screen/AjaxScreen/action/GetIFSCCodeDetails"),
							content : {
								ifscCode : ifscCodeValue,
								paramId  : "P701"
							},
							sync : true,
							handleAs : "json",
							load : function(response, args){
								
							    //Response 
								var ifscCodeDetails = response;
								retValid = response.valid;
								if(retValid)
								{
									var arrayOfDetails = [ifscCodeDetails.bankName, ifscCodeDetails.bankAddressLine1, 
									                      ifscCodeDetails.bankAddressLine2, ifscCodeDetails.city];
									
									d.forEach(arrayOfBankFields,function(node,i){
										if(dj.byId(node))
										{
											if(i < 7)
											{
												dj.byId(node).set("value", arrayOfDetails[i], false);
											}
										}
									});
											ifscWidget.set("value", ifscCodeDetails.bankIFSCCode);
								}
								else
								{
									var displayMessage = "";
									// focus on the widget and set state to error and
									// display a tooltip indicating the same
									if((ifscWidget && (ifscWidget.get("value") !== "")))
									{
										ifscWidget.focus();
										displayMessage = m.getLocalization("ifscCodeValidationFailed", [ifscWidget.get("value")]);
										ifscWidget.set("value", "");
										ifscWidget.set("state", "Error");
										dijit.hideTooltip(ifscWidget.domNode);
										dijit.showTooltip(displayMessage,ifscWidget.domNode, 0);
									}
								}
							},
							customError : function(response, args){
								console.warn("getSwiftBankDetails error");
							}
					});
				}
				else
				{
				// If ISO code not valid, enable it so that user can correct it
				setTimeout(function(){
					dijit.byId("bank_iso_code").set("readOnly", false);
				}, 600);
				}
				}
				else
				{
				d.forEach(arrayOfBankFields,function(node){
				if(dj.byId(node))
				{
					if(toggleReadOnly)
					{
						dj.byId(node).set("readOnly",false);
					}
				}
				});
				if(toggleRequired)
				{
				d.forEach(arrayOfRequiredFields,function(node){
				if(dj.byId(node))
				{
						m.toggleRequired(node, false);
					}
				});
				}
				if(d.byId(bankType+"ifsc_code_row") && d.byId(bankType+"ifsc_code_row").parentNode && d.byId(bankType+"ifsc_code_row").parentNode.id)
								{
				var tabId = d.byId(bankType+"ifsc_code_row").parentNode.id;
				if(dj.byId(tabId))
				{
					var title = dj.byId(tabId).get("title");
					if(title.indexOf("*") !== -1)
					{
						title = title.substring(title.indexOf(">")+1,title.lastIndexOf("<"));
						console.debug(tabTitle,title);
						if(title.indexOf("*") !== -1)
						{
							title = title.substring(title.indexOf("*")+1);
							console.debug(tabTitle,title);
							dj.byId(tabId).set("title",title);
						}
						else
						{
							dj.byId(tabId).set("title",title);
						}
					}
				}
				}
				}
				
				},
		/**
		 * <h4>Summary:</h4>
		 * This function is for setting swift details on blur event
		 * @param {Boolean} includeCustomerBanks
		 * @param String swiftWidget
		 * @param Array arrayOfBankFields
		 * @param Array arrayOfRequiredFields
		 * @param String bankType
		 * @param Boolean populateFlag
		 * @param Boolean toggleRequired
		 * @param Boolean toggleRequired
		 * @param String toggleReadOnly
		 * @param String country
		 * @method setSwiftBankDetailsForOnBlurEvent
		 */
		setSwiftBankDetailsForOnBlurEvent : function(/*boolean*/ includeCustomerBanks,
													   /*String*/swiftWidget, 
													   /*String*/brch_code,
													   /*Array*/arrayOfBankFields, 
													   /*Array*/arrayOfRequiredFields,
													   /*String*/bankType, 
													   /*boolean*/ populateFlag,
													   /*boolean*/ toggleRequired,
													   /*boolean*/toggleReadOnly, 
													   /*String*/ country){
			if(m._config.isBankDetailsPopulated)
			{
				m.getSwiftBankDetails(includeCustomerBanks, swiftWidget,brch_code,arrayOfBankFields,arrayOfRequiredFields,bankType,false,toggleRequired,toggleReadOnly,country);
			}
			else
			{
				m.getSwiftBankDetails(includeCustomerBanks, swiftWidget,brch_code,arrayOfBankFields,arrayOfRequiredFields,bankType,populateFlag,toggleRequired,toggleReadOnly,country);
			}
			m._config.isBankDetailsPopulated = false;
		},
		
		setIFSCCodeDetailsForOnBlurEvent : function(
				   /*String*/ifscWidget, 
				   /*Array*/arrayOfBankFields,
				   /*Array*/arrayOfRequiredFields,
				   /*String*/bankType, 
				   /*boolean*/ populateFlag,
				   /*boolean*/ toggleRequired,
				   /*boolean*/toggleReadOnly){
			
			m.getIFSCCodeDetails(ifscWidget,arrayOfBankFields,arrayOfRequiredFields,bankType,populateFlag,toggleRequired,toggleReadOnly);
			},
		/**
		 * <h4>Summary:</h4>
		 * Toggels the display of draft terms.Basically check for the value of draftTermType Toggels the fields.For toggeling it calls m.toggleFields.
		 * @param {String} draftTermType
		 * @method toggleDraftTerm
		 */
		toggleDraftTerm : function( /*String*/ draftTermType) {
			//  summary:
		    //        Toggles the display of the draft term
			//	description:
			//		  TODO Add business logic description here
			
			var keepFieldValues = 
					(!dj.byId("tenor_maturity_date").get("value") && !dj.byId("tenor_days").get("value") && !dj.byId("tenor_period").get("value") && !dj.byId("tenor_from_after").get("value") && !dj.byId("tenor_days_type").get("value") && !m._config.firstPageLoad);
			if(!d.isString(draftTermType)) {
				draftTermType = this.get("value");
			}
			m.toggleFields(draftTermType === "02", null, 
							["tenor_maturity_date"], keepFieldValues); 
			m.toggleFields(draftTermType === "03", null, 
					["tenor_days", "tenor_period", "tenor_from_after", "tenor_days_type"],
					keepFieldValues);
			m.toggleFields(draftTermType === "05", null, 
					["draft_term"],
					keepFieldValues);
			if(dj.byId("tenor_days_type").get("value") !== "99"){
				dj.byId("tenor_type_details").set("value", "");
			}
			if(dj.byId("tenor_days_type"))
			{
				var tenorDaysType = dj.byId("tenor_days_type").get("value") === "99";
				m.toggleFields((tenorDaysType),
						null, ["tenor_type_details"]);
			}
		},
		/**
		 * <h4>Summary:</h4>
		 *  Control the drawee details value.It checks for the values of the flags credit avail by code 2 and 3.
		 *  If both are not checked set the values of all the address field to empty and fade out the drawee details image.
		 *  Otherwise fade in the drawee datails bank image.
		 *  <h4>Description:</h4> 
		 *  Initilaise Drawee fields
		 *  @method initDraweeFields
		 */
		initDraweeFields : function() {
			//  summary:
		    //        Control the drawee details value.
			//	description:
			//		  TODO Add business logic description here
			
			var crAvlByCode2Checked = false; 
			if(dj.byId("cr_avl_by_code_2")) {
				crAvlByCode2Checked = dj.byId("cr_avl_by_code_2").get("checked");
			}
			
			var crAvlByCode3Checked = false; 
			if(dj.byId("cr_avl_by_code_3")) {
				crAvlByCode3Checked = dj.byId("cr_avl_by_code_3").get("checked");
			} 
			
			if(!crAvlByCode2Checked && !crAvlByCode3Checked){
				dj.byId("drawee_details_bank_name").set("value", "");
				if (dj.byId("drawee_details_bank_iso_code")){
					dj.byId("drawee_details_bank_iso_code").set("value", "");
				}
				if(dj.byId("drawee_details_bank_address_line_1")) {
					dj.byId("drawee_details_bank_address_line_1").set("value", "");
					dj.byId("drawee_details_bank_address_line_2").set("value", "");
					dj.byId("drawee_details_bank_dom").set("value", "");
					dj.byId("drawee_details_bank_address_line_4").set("value", "");
				}
				if (d.byId('drawee_details_bank_img'))
				{
					m.animate("fadeOut","drawee_details_bank_img");
				}
			}
			else
			{
				if (d.byId('drawee_details_bank_img'))
				{
					m.animate("fadeIn","drawee_details_bank_img");
				}
			}
			
			m.toggleFields(
					crAvlByCode2Checked || crAvlByCode3Checked,
					["drawee_details_bank_address_line_2", "drawee_details_bank_dom", "drawee_details_bank_address_line_4"],
					["drawee_details_bank_name", "drawee_details_bank_address_line_1", "drawee_details_bank_iso_code"],
					true);
			
			if(dj.byId("mode") && dj.byId("mode").get("value") === 'RELEASE'){
				m.toggleRequired("drawee_details_bank_address_line_1",false);
			}
			
			//MPSSC-14966 - Drawee Details non mandatory for LC and SI
			var productCode = dj.byId("product_code").get("value") ;
			if(dj.byId("product_code") && (productCode === "LC" || productCode === 'SI') && (crAvlByCode2Checked || crAvlByCode3Checked))
			{
				if (dj.byId("drawee_details_bank_iso_code") && dj.byId("drawee_details_bank_name") && dj.byId("drawee_details_bank_address_line_1"))
				{
					m.toggleRequired("drawee_details_bank_iso_code", false);
					m.toggleRequired("drawee_details_bank_name", false);
					m.toggleRequired("drawee_details_bank_address_line_1", false);
				}
			}
		},
						/**
						 * <h4>Summary:</h4>
						 * Shows the particular form fields depending
						 * on the selection made in "Credit Available By".
						 * @method togglePaymentDraftAt
						 */
		togglePaymentDraftAt: function() {
			//  summary:
		    //        Shows the particular form fields depending on the selection made in 
			//        "Credit Available By".
			//	description:
			//		  TODO Add business logic explanation here 
			//
			
			var tenorType1 = dj.byId("tenor_type_1"),
				tenorType2 = dj.byId("tenor_type_2"),
				tenorType3 = dj.byId("tenor_type_3"),
				draftTerm = dj.byId("draft_term"),
				crAvlByCode = this.get("value"),
				paymentDraftDiv = d.byId("payment-draft"),
				draftTermDiv = d.byId("draft-term"),
				creditAvlBankType = dj.byId("credit_available_with_bank_type");
			
			// to prevent error with undefined variable
			if (!tenorType1 || !tenorType2 || !tenorType3){
				return;
			}
			
			tenorType1.set("disabled", true);
			tenorType2.set("disabled", true);
			tenorType3.set("disabled", true);
			
			// Everything disabled and cleared by default
			// TODO Look at getting rid of this, seems hacky
			if(m._config.firstPageLoad && crAvlByCode !== "05") {
				draftTerm.set("value", "");
			}

			// By default, display payment draft
			if(crAvlByCode !== "05" && d.style(paymentDraftDiv, "opacity") !== 1){
				m.animate("fadeOut", draftTermDiv);
				m.animate("fadeIn", paymentDraftDiv);
			}

			switch(crAvlByCode) {
			 case "01":
				tenorType1.set("disabled", false);
				tenorType1.set("checked", true);
				m.toggleDraftTerm("01");
				break;
			 case "02":
				tenorType2.set("disabled", false);
				tenorType3.set("disabled", false);
				if(dj.byId("tenor_maturity_date").get("displayedValue") !== ""){
					tenorType2.set("checked", true);
					m.toggleDraftTerm("02");
					draftTerm.set("value", dj.byId("tenor_maturity_date").get("displayedValue"));
					break;
				} else{
					tenorType3.set("checked", true);
					m.toggleDraftTerm("03");
					break;
				}
				break;
			 case "03":
				tenorType1.set("disabled", false);
				tenorType2.set("disabled", false);
				tenorType3.set("disabled", false);
				if(tenorType1.get("checked")){
				   tenorType1.set("checked", true);
				   m.toggleDraftTerm("01");
				   break;
				} 
				else if(dj.byId("tenor_maturity_date").get("displayedValue") !== ""){
				   tenorType2.set("checked", true);
				   m.toggleDraftTerm("02");
				   break;
				}
				else{
				   tenorType3.set("checked", true);
				   m.toggleDraftTerm("03");
				   break;
				}
				break;
			 case "06":
				 tenorType1.set("disabled", true);
				 tenorType2.set("disabled", true);
				 tenorType3.set("disabled", true);
				 m.toggleDraftTerm("01");
				 break;
			 case "04":
				tenorType2.set("disabled", false);
				tenorType3.set("disabled", false);
				if(dj.byId("tenor_maturity_date").get("displayedValue") !== ""){
					tenorType2.set("checked", true);
					m.toggleDraftTerm("02");
					break;
				} else{
					tenorType3.set("checked", true);
					m.toggleDraftTerm("03");
					break;
				}
				break;
			 case "05":
				m.animate("fadeOut", paymentDraftDiv);
				m.animate("fadeIn", draftTermDiv);
				tenorType1.set("checked", false);
				tenorType2.set("checked", false);
				tenorType3.set("checked", false);
				m.toggleDraftTerm("05");
				break;
			 default:
				break;
			}
			
			var tnx_type_code_val='01';
			if(dj.byId("tnx_type_code")){
				tnx_type_code_val = dj.byId("tnx_type_code").get("value");
			}
			if(creditAvlBankType && !(tnx_type_code_val=== '03')) {
				_toggleDraweeBankDetails(crAvlByCode, creditAvlBankType.get("value"));
			}
			m.initDraweeFields();
		},
		/**
		 * <h4>Summary:</h4>
		 * Calculates the maturity date based on the base date and the tenor period
		 * @method calcMaturityDate
		 */
		calcMaturityDate : function(){
			if(dj.byId("tenor_days").get("value")!=="" && !isNaN(dj.byId("tenor_days").get("value")) && dj.byId("tenor_period").get("value")!=="" && dj.byId("tenor_from_after").get("value")!==""){
				var baseDate = dj.byId("tenor_base_date").get("value");
				var tenorDays = dj.byId("tenor_days").get("value");
				var tenorPeriod = dj.byId("tenor_period").get("value");
				var interval,milliSecTillDate = null;
				var maturityDate;
					
				switch(tenorPeriod){
				case "D": 
						interval= "day";
						break;
				case "W": 
						interval="week";
						break;
				case "M": 
						interval= "month";
						break;
				case "Y": 
						interval= "year";
						break;
				default:
					break;
					
				}
				var tenorFromAfter = dj.byId("tenor_from_after").get("value");
				
				if (dj.byId("tenor_base_date").get("displayedValue")!=="") 
				{
					milliSecTillDate = d.date.add(baseDate,interval, tenorDays);
					
					if(tenorFromAfter === "F" )
					{
						milliSecTillDate = d.date.add(milliSecTillDate,"day", -1);
					}
					
					maturityDate= new Date(milliSecTillDate.getTime());
					maturityDate = d.date.locale.format(maturityDate, {
						selector :"date"
					});
					dj.byId("tenor_maturity_date").set("displayedValue", maturityDate);
					//Added as part of MPS-50580
					dj.byId("tenor_maturity_date").set("disabled", true);
				}
				else {
					dj.byId("tenor_maturity_date").set("displayedValue", "");					
				}
				
			}
		},
		
		/**
		 * <h4>Summary:</h4>
		 * Toggels the display of all tenor fields.Basically check for the value of tenorType Toggels the fields.For toggeling it calls m.toggleFields.
		 * @method toggleTenorFields
		 */
		toggleAllTenorFields : function() {
			
			var keepFields = ["tenor_days", "tenor_period", "tenor_from_after" , "tenor_base_date" , "tenor_maturity_date" , "tenor_days_type"];
			if(m._config.isBank){
				keepFields = ["tenor_days", "tenor_period", "tenor_from_after" ,"tenor_base_date","tenor_maturity_date","tenor_days_type"];
			}
			var tenor2Checked = dj.byId("tenor_type_2").get("checked");
			var tenor3Checked = dj.byId("tenor_type_3").get("checked");
			var termCodeValue = dj.byId("term_code") ? dj.byId("term_code").get("value") : "";
			
			if(tenor2Checked)
			{	
				m.toggleFields(tenor2Checked, ["tenor_days_type"], keepFields, tenor2Checked, tenor2Checked);
				if(dojo.query(tenorLabel)[0].innerHTML.indexOf("*")=== -1){
					dojo.query(tenorLabel)[0].innerHTML = "<span class='required-field-symbol'>*</span>"+dojo.query(tenorLabel)[0].innerHTML;
				}
				m.toggleRequired("tenor_days_type", true);
				m.toggleRequired("tenor_days", true);
				m.toggleRequired("tenor_period", true);
				m.toggleRequired("tenor_from_after", true);
				m.toggleRequired("tenor_maturity_date", true);
				// Made following fields optional and enabled for the issue MPS-42032 
				m.toggleRequired("tenor_maturity_date", false);
				m.toggleRequired("tenor_base_date", false);
				/*dj.byId("tenor_maturity_date").set("disabled", false);
				dj.byId("tenor_base_date").set("disabled", false);*/
				if(termCodeValue === "03"){
					m.animate("fadeIn", d.byId("boe"));
			}
			}
			else if(tenor3Checked)
			{	
				m.toggleFields(tenor3Checked, ["tenor_days_type"], keepFields, tenor3Checked, tenor3Checked);
				if(dojo.query(tenorLabel)[0].innerHTML.indexOf("*")=== -1){
					dojo.query(tenorLabel)[0].innerHTML = "<span class='required-field-symbol'>*</span>"+dojo.query(tenorLabel)[0].innerHTML;
				}
				m.toggleRequired("tenor_days_type", true);
				m.toggleRequired("tenor_days", true);
				m.toggleRequired("tenor_period", true);
				m.toggleRequired("tenor_from_after", true);	
				if(dj.byId("tenor_type_2").get("checked")){
					m.toggleRequired("tenor_base_date", false);
					m.toggleRequired("tenor_maturity_date", false);
				} else {
					m.toggleRequired("tenor_base_date", true);
					m.toggleRequired("tenor_maturity_date", true);
				}	
				if(termCodeValue === "03"){
					m.animate("fadeIn", d.byId("boe"));
			}
			}
				
			else
			{
				dojo.query(tenorLabel)[0].innerHTML = m.getLocalization("tenorPeriod");
				m.toggleRequired("tenor_days_type", false);
				m.toggleRequired("tenor_days", false);
				m.toggleRequired("tenor_period", false);
				m.toggleRequired("tenor_from_after", false);
				m.toggleRequired("tenor_maturity_date", false);
				//m.toggleRequired("tenor_base_date", true);
				dj.byId("tenor_type_details").set("displayedValue", "");
				dj.byId("tenor_type_details").set("disabled", true);
				dj.byId("tenor_maturity_date").set("displayedValue", "");
				dj.byId("tenor_days").set("displayedValue", "");
                dj.byId("tenor_days").set("disabled", true);
                dj.byId("tenor_period").set("displayedValue", "");
                dj.byId("tenor_period").set("disabled", true);
                dj.byId("tenor_from_after").set("displayedValue", "");
                dj.byId("tenor_from_after").set("disabled", true);
                dj.byId("tenor_days_type").set("displayedValue", "");
                dj.byId("tenor_days_type").set("disabled", true);
                dj.byId("tenor_base_date").set("displayedValue", "");
                dj.byId("tenor_base_date").set("disabled", true);
				// Made following fields enabled for the issue MPS-42032 
				/*dj.byId("tenor_maturity_date").set("disabled", true);
				dj.byId("tenor_base_date").set("disabled", true);*/
				if(termCodeValue === "03"){
					m.animate("fadeOut", d.byId("boe"));
					dj.byId("boe_flag").set("checked", false);
				}
			}
		},
		
		/**
		 * <h4>Summary:</h4>
		 * Toggles bank-side "payment draft at" fields.Create an array of all the fields to clear.
		 * Loop through the array and reset all fields one by one.
		 * @method toggleBankPaymentDraftAt
		 */
		toggleBankPaymentDraftAt : function() {
			//  summary:
		    //        Toggles bank-side "payment draft at" fields.
			
			var field, 
				fieldsToClear = ["draft_term", "drawee_details_bank_name", 
			                     "drawee_details_bank_address_line_1",
			                     "drawee_details_bank_address_line_2", 
			                     "drawee_details_bank_dom","drawee_details_bank_address_line_4", "drawee_details_bank_iso_code",
			                     "drawee_details_bank_reference"];
			    

			d.forEach(fieldsToClear, function(id){
				field = dj.byId(id);
				if(field) {
					field.reset();
				}
			});
		},
/**
 * <h4>Summary:</h4>
 * Write or set the draft termm value
 * <h4>Description:</h4> 
 * Checks the value of tenor_type_1.If this falg is checked set the value of draftTerm to "Sight".If tenor_type_2 is checked set  the value of maturity date if it is there.
 * Otherwise set the tenor period.
 * @method setDraftTerm
 * 
 */
		setDraftTerm : function() {
			//  summary:
		    //        Write the draft term value.
			
			var draftTerm = dj.byId("draft_term"),
				tenorPeriodLabels = misys._config.tenorPeriodLabels,
				tenorFromAfterLabels = misys._config.tenorFromAfterLabels,
				tenorDaysTypeLabels = misys._config.tenorDaysTypeLabels,
				period,
				fromAfter,
				days,
				daysType;
			
			if(draftTerm){
				if(!(dj.byId("cr_avl_by_code_5") && dj.byId("cr_avl_by_code_5").get("checked"))){
					draftTerm.set("value", "");
				}
						
				if(dj.byId("tenor_type_1") && dj.byId("tenor_type_1").get("checked")) {
					draftTerm.set("value", m.getLocalization("tenorSight"));
				}				
				else if((dj.byId("tenor_type_2") && dj.byId("tenor_type_2").get("checked")) && 
						dj.byId("tenor_maturity_date").get("displayedValue") !== "") {
					draftTerm.set("value",
							dj.byId("tenor_maturity_date").get("displayedValue"));
				}
				else {
					period = dj.byId("tenor_period").get("value");
					fromAfter = dj.byId("tenor_from_after").get("value");
					days = dj.byId("tenor_days").get("value");
					daysType = dj.byId("tenor_days_type").get("value");
			
					if(!isNaN(days) && days !== 0 || ( days === 0 && daysType === "07" ) ) {
						if(daysType !== "99") {
							draftTerm.set("value", days + " " + tenorPeriodLabels[period] + " " + 
								tenorFromAfterLabels[fromAfter] + " " + 
									tenorDaysTypeLabels[daysType]);
						} else {
							draftTerm.set("value", days + " " + tenorPeriodLabels[period] + " " + 
								tenorFromAfterLabels[fromAfter] + " " + 
									dj.byId("tenor_type_details").get("value"));
						}
					} 
				}
				console.debug("[misys.form.common] draft_term value is now", 
						draftTerm.get("value"));
			}
		}, 
/**
 * <h4>Summary:</h4>
 * Control draft days read only.
 * If tenor_type_3 is not checked set Draft Days to read only.
 * @method setDraftDaysReadOnly
 */
		setDraftDaysReadOnly : function() {
			//  summary:
		    //        Control draft days read only.
			//
			//	TODO Add business logic reasoning here
			
			this.set("readOnly", !dj.byId("tenor_type_3").get("checked"));
		}, 

								/**
								 * <h4>Summary:</h4>
								 *  Validate the Irrevocable flag
								 * against the Transferable and Stand By flags
								 * (if required).
								 */
		checkIrrevocableFlag : function() {
			//  summary:
		    //        Validate the Irrevocable flag against the Transferable and 
			//        Stand By flags (if required).
			//	TODO Add business logic reasoning here
			
			var ntrfFlag = dj.byId("ntrf_flag"),
			    stndByLcFlag = dj.byId("stnd_by_lc_flag");

			if(!this.get("checked") && ntrfFlag && stndByLcFlag && !ntrfFlag.get("checked") && 
						stndByLcFlag.get("checked")){
				this.set("checked", true);
				m.showTooltip(m.getLocalization("irrevocableStandByError"), 
						this.domNode, ["before"]);
			}
		}, 
		/**
		 * <h4>Summary:</h4>
		 *  Check the Non Transferable flag against the Irrevocable and Stand By flags.
		 *  @method checkNonTransferableFlag
		 */
		checkNonTransferableFlag : function() {
			//  summary:
		    //        Check the Non Transferable flag against the Irrevocable and Stand By flags.
			//	TODO Add business logic reasoning here
			
			var irvFlag = dj.byId("irv_flag"),
			    stndByLcFlag = dj.byId("stnd_by_lc_flag");

			if(!this.get("checked") && irvFlag && stndByLcFlag && !irvFlag.get("checked") && 
					stndByLcFlag.get("checked")){
				this.set("checked", false);
				irvFlag.set("checked", true);
				m.showTooltip(m.getLocalization("irrevocableStandByError"), 
						irvFlag.domNode, ["before"]);
			}
		}, 

								/**
								 * <h4>Summary:</h4> 
								 * Check the Stand By flag against the
								 * Irrevocable and Non Transferable flag. It
								 * checks if stnd_by_lc_flag is set in which
								 * this function was called .Checks for the
								 * values of Irrevocable and Non Transferable
								 * flag also if both are not checked .Make check
								 * of the Irrevocable falg true and show an
								 * error .
								 * @checkStandByFlag
								 */
		checkStandByFlag: function() {
			//  summary:
		    //        Check the Non Transferable flag against the Irrevocable and Non Transferable flag.
			//	TODO Add business logic reasoning here
			//  TODO Check against v3 
			
			var irvFlag = dj.byId("irv_flag"),
			    ntrfFlag = dj.byId("ntrf_flag");

			if(this.get("checked") && ntrfFlag && irvFlag &&
						!ntrfFlag.get("checked") && !irvFlag.get("checked")) {
					irvFlag.set("checked", true);
					m.showTooltip(m.getLocalization("irrevocableStandByError"), 
							irvFlag.domNode, ["before"]);
			}
		}, 
		/**
		 * <h4>Summary:</h4>
		 *   Reset the confirmation charges according to the confirmation instructions.
		 *   @method resetConfirmationCharges
		 */
		resetConfirmationCharges : function() {
			//  summary:
		    //        Reset the confirmation charges according to the confirmation instructions.
			if(m._config.charge_splitting_lc){
				if(dj.byId("open_chrg_brn_by_code_3")){ // if defined
					if(!dj.byId("cfm_chrg_brn_by_code_3").get("checked")) {
						dj.byId("cfm_chrg_brn_by_code_1").set("checked", false);
						dj.byId("cfm_chrg_brn_by_code_2").set("checked", this.get("value") !== "03");
						dj.byId("cfm_chrg_brn_by_code_3").set("checked", false);
					}
					if(dj.byId("cfm_inst_code_3").get("checked")) {
						dj.byId("cfm_chrg_brn_by_code_1").set("checked", false);
						dj.byId("cfm_chrg_brn_by_code_2").set("checked", this.get("value") !== "03");
						dj.byId("cfm_chrg_brn_by_code_3").set("checked", false);
	
						dj.byId("cfm_chrg_applicant").set("disabled", true).set("value", "").set("required", false);
						dj.byId("cfm_chrg_beneficiary").set("disabled", true).set("value", "").set("required", false);
					}
				}
			}
			else
			{
				if(dj.byId("cfm_chrg_brn_by_code_1")){
					dj.byId("cfm_chrg_brn_by_code_1").set("checked", false);
				}
				if(dj.byId("cfm_chrg_brn_by_code_2")){
					dj.byId("cfm_chrg_brn_by_code_2").set("checked", this.get("value") !== "03");
				}			
			}
			var effect = (this.get("value") === "01") ? "fadeIn" : "fadeOut";
			m.animate(effect, d.byId("confirmation-charges"));

			//Execute this piece of code only for SWIFT 2018 SWITCH ON
			if(m._config.swift2018Enabled){
				if(this.get("value") === "01" || this.get("value") === "02"){
					m.animate("fadeIn", d.byId("requested-conf-party"));
					m.toggleFields(true ,["req_conf_party_flag"],null,null,true);
					dj.byId("req_conf_party_flag").set("value",advBank);		
				}
				else{
					m.animate("fadeOut", d.byId("requested-conf-party"));
					m.toggleFields(false , 
							["req_conf_party_flag","requested_confirmation_party_name","requested_confirmation_party_address_line_1","requested_confirmation_party_address_line_2","requested_confirmation_party_dom","requested_confirmation_party_address_line_4","requested_confirmation_party_iso_code"],null,null,false);
				}			
			}
			
		}, 	 
		/**
		 * <h4>Summary:</h4>
		 *   Reset the confirmation charges according to the confirmation instructions for ILC Product
		 *   This also validates the conditions when Requested Confirmation Party details need to be displayed 
		 *   on selection of Confirmation Instructions
		 *   @method resetConfirmationChargesLC
		 *   
		 */
		resetConfirmationChargesLC : function() {
			
			var companyCode;
			var parentTabRCF;
			//_userType is defined in Topdemobank.vm
			//companycode is used to identify the company of user who is logged into the application.
			if (document.getElementById("_userType"))
			{
				companyCode = document.getElementById("_userType").getAttribute('value');
			}
			var userType = (companyCode !== '03' && companyCode !== '06') ? "bank":"customer";
			
			if(dj.byId("cfm_chrg_brn_by_code_1")){
				dj.byId("cfm_chrg_brn_by_code_1").set("checked", false);
			}
			if(dj.byId("cfm_chrg_brn_by_code_2")){
				dj.byId("cfm_chrg_brn_by_code_2").set("checked", this.get("value") !== "03");
			}
			
			var effect = (this.get("value") === "01") ? "fadeIn" : "fadeOut";
			m.animate(effect, d.byId("confirmation-charges"));
			var reqConfParty=dj.byId("req_conf_party_flag");
			var reqConfPartyFiltered=dj.byId("req_conf_party_flag_filtered");
			var tnx_type_code_val='01';
			if(dj.byId("tnx_type_code")){
				tnx_type_code_val = dj.byId("tnx_type_code").get("value");
			}
			var prod_stat_code_val='01';
			if(dj.byId("prod_stat_code")){
				prod_stat_code_val = dj.byId("prod_stat_code").get("value");
			}
			if(reqConfPartyFiltered && ((tnx_type_code_val=== '15' && prod_stat_code_val === '08') ||
					tnx_type_code_val=== '03')){
				reqConfParty=reqConfPartyFiltered;
			}
			//SWIFT 2018
			//If confirmation instructions is Without then reset the value of req_conf_party_flag and do not display the block requested-conf-party-bank-details
			if(this.get("value") === "01" || this.get("value") === "02"){
				reqConfParty.set("disabled",false);
				reqConfParty.set("value","");	
//				if(userType === "bank"){
//					m.toggleRequired(reqConfParty,true);
//		    	}
			}else{
				if(userType === "bank"){
					m.toggleRequired(reqConfParty,false);
					//If the transaction is of amendment type in existing records,we have 2 RCF's and hence this needs to be executed again
					//for amendment reqConfParty will actually refer to dj.byId("req_conf_party_flag_filtered")
					if((tnx_type_code_val=== '15' && prod_stat_code_val === '08') || tnx_type_code_val=== '03'){
							var originalrcf=dj.byId("req_conf_party_flag");
							m.toggleRequired(originalrcf,false);
					}
					parentTabRCF = dj.byId("req_conf_party_flag").parentTab;
					m.resetTabState(dijit.byId(parentTabRCF));
		    	}
				reqConfParty.set("disabled",true);
				reqConfParty.set("value","");
				d.byId(reqConfParBankDet).style.display = "none";
			}
		},
		/**
		 * <h4>Summary:</h4>
		 *   Validates before form is submitted for an Advising Bank,Advise Thru Bank and Other bank if 
		 *   1.Either Name and Address or BIC code is entered in the bank fields
		 *   2.Focusses the higlighted object which is missing
		 *   A pop up informing user about the error will be displayed to the user
		 *   @method validateBankEntry
		 *   
		 */
		validateBankEntry : function( bankType){	
			
			var bankName = dj.byId( bankType + "_name");
			var bankAddress = dj.byId(bankType + "_address_line_1");	
			var bankIsoCode = dj.byId(bankType + "_iso_code");		
			
			if(bankName.get("value") == "" && bankIsoCode.get("value") == "" && bankAddress.get("value") == ""){
				m.setRequiredFields([bankName,bankAddress] , true);
				bankName.focus();
				bankAddress.focus();			
				return false;
			}
			else if(bankIsoCode.get("value") == "" && (bankName.get("value") =="" || bankAddress.get("value") =="")){
				var focusObject = bankName.get("value") =="" ? bankName : bankAddress;
				m.setRequiredFields([focusObject] , true);
				focusObject.focus();				
				return false;
			}
			else{
				return true;
			}
		
		},
		/**
		 * <h4>Summary:</h4>
		 *  When RequestedConfirmationParty dropdown is changed,reset the required fields for advising,advise thru and other bank as per RCF selected
		 *   @method resetBankRequiredFields
		 *   
		 */
		resetBankRequiredFields : function () {			
			var reqConfFlagValue = this.get("value");
			var parentTabId;
			var bicCodeValue;
			if(reqConfFlagValue === "Other"){
				parentTabId=dj.byId("advising_bank_name").parentTab;
				//Reset tabstate of Advising bank to non mandatory if it was mandatory earlier
				m.resetTabState(dijit.byId(parentTabId));
				parentTabId=dj.byId("advise_thru_bank_name").parentTab;
				//Reset tabstate of advise_thru_bank_name to non mandatory if it was mandatory earlier
				m.resetTabState(dijit.byId(parentTabId));
				m.setRequiredFields(["advising_bank_name","advising_bank_address_line_1","advise_thru_bank_name","advise_thru_bank_address_line_1"] , false);
				d.byId(reqConfParBankDet).style.display = "block";
				m.toggleFields(true , 
						["requested_confirmation_party_name","requested_confirmation_party_address_line_1","requested_confirmation_party_address_line_2","requested_confirmation_party_dom","requested_confirmation_party_address_line_4","requested_confirmation_party_iso_code"],null,null,true);
				
			}
			else if(reqConfFlagValue === advBank){
				bicCodeValue = dj.byId("advising_bank_iso_code").get("value");
				parentTabId=dj.byId("advise_thru_bank_name").parentTab;
				//Reset tabstate of Advise thru bank to non mandatory if it was mandatory earlier
				m.resetTabState(dijit.byId(parentTabId));
				//If BIC Code is present,advising_bank_name and address will not be mandatory
				if(bicCodeValue!== "null" && bicCodeValue.length > 0){
					m.setRequiredFields(["advising_bank_name","advising_bank_address_line_1"] , false);
				}else{
					m.setRequiredFields(["advising_bank_name","advising_bank_address_line_1"] , true);
				}
				m.setRequiredFields(["advise_thru_bank_name","advise_thru_bank_address_line_1"] , false);
				d.byId(reqConfParBankDet).style.display = "none";
				m.toggleFields(false , 
						["requested_confirmation_party_name","requested_confirmation_party_address_line_1","requested_confirmation_party_address_line_2","requested_confirmation_party_dom","requested_confirmation_party_address_line_4","requested_confirmation_party_iso_code"],null,null,false);
				
			}
			else if(reqConfFlagValue === "Advise Thru Bank"){
				bicCodeValue = dj.byId("advise_thru_bank_iso_code").get("value");
				parentTabId=dj.byId("advising_bank_name").parentTab;
				//Reset tabstate of Advising bank to non mandatory if it was mandatory earlier
				m.resetTabState(dijit.byId(parentTabId));
				//If BIC Code is present,advise_thru_bank_name and address will not be mandatory
				if(bicCodeValue!== "null" && bicCodeValue.length > 0){
					m.setRequiredFields(["advise_thru_bank_name","advise_thru_bank_address_line_1"] , false);
				}else{
					m.setRequiredFields(["advise_thru_bank_name","advise_thru_bank_address_line_1"] , true);
				}
				m.setRequiredFields(["advising_bank_name","advising_bank_address_line_1"] , false);		
				d.byId(reqConfParBankDet).style.display = "none";
				m.toggleFields(false , 
						["requested_confirmation_party_name","requested_confirmation_party_address_line_1","requested_confirmation_party_address_line_2","requested_confirmation_party_dom","requested_confirmation_party_address_line_4","requested_confirmation_party_iso_code"],null,null,false);
			
			}
			else{
				parentTabId=dj.byId("advising_bank_name").parentTab;
				//Reset tabstate of Advising bank to non mandatory if it was mandatory earlier
				m.resetTabState(dijit.byId(parentTabId));
				parentTabId=dj.byId("advise_thru_bank_name").parentTab;
				//Reset tabstate of advise_thru_bank_name to non mandatory if it was mandatory earlier
				m.resetTabState(dijit.byId(parentTabId));
				
				m.setRequiredFields(["advising_bank_name","advising_bank_address_line_1","advise_thru_bank_name","advise_thru_bank_address_line_1"] , false);
				d.byId(reqConfParBankDet).style.display = "none";
				m.toggleFields(false , 
						["requested_confirmation_party_name","requested_confirmation_party_address_line_1","requested_confirmation_party_address_line_2","requested_confirmation_party_dom","requested_confirmation_party_address_line_4","requested_confirmation_party_iso_code"],null,null,false);
			}
		},
		
		/**
		 * <h4>Summary:</h4>
		 *  Removes the mandatory state and warning icon message from the advisingbank,advise thru bank if they are not selected in 
		 *  Requested confirmation Party
		 *   @method resetTabState
		 *   @parameters:Tab header element
		 */
		resetTabState : function( /*dijit._Widget*/ tab) {
			
			if(tab){
				var title = tab.get("title");
				//If Mandatory * icon OR warning icon alt text image is present in the tab,they are to be removed from tab title
				if(title.indexOf("<img") !== -1 && title.indexOf("*")!== -1) {
					title = title.replace("*","");
					title = title.substring(0, title.indexOf("<img"));
				}
				//Only asterisk is present in the tab
				else if(title.indexOf("*")!== -1){    
					title = title.replace("*","");
				}
				tab.set("title", title);			
			}		
		},	
		/**
		 * <h4>Summary:</h4>
		 *   Disables Requested Confirmation Party if Confirmation instructions is Not 'Confirm' or 'Maybe'
		 *   @method resetRequestedConfirmationParty
		 *   
		 */
		resetRequestedConfirmationParty : function () {			
			var companyCode;
			var parentTabRCF;
			//_userType is defined in Topdemobank.vm
			//companycode is used to identify the company of user who is logged into the application.
			if (document.getElementById("_userType"))
			{
				companyCode = document.getElementById("_userType").getAttribute('value');
			}
			var userType = (companyCode !== '03' && companyCode !== '06') ? "bank":"customer";
			if(dijit.byId("cfm_inst_code_1") && !dijit.byId("cfm_inst_code_1").get("value") && !dijit.byId("cfm_inst_code_2").get("value")){
				dj.byId("req_conf_party_flag").set("disabled",true);
				if(dj.byId("req_conf_party_flag_filtered")){
                    dj.byId("req_conf_party_flag_filtered").set("disabled",true);
                    m.toggleRequired(dj.byId("req_conf_party_flag_filtered"),false);
                    parentTabRCF = dj.byId("req_conf_party_flag_filtered").parentTab;
                    m.resetTabState(dijit.byId(parentTabRCF));
				}
				//This check is done only on bank side to make RCF Flag and the tab non mandatory if confirmation istructions is without
				if(userType === "bank"){
					m.toggleRequired(dj.byId("req_conf_party_flag"),false);
					parentTabRCF = dj.byId("req_conf_party_flag").parentTab;
					m.resetTabState(dijit.byId(parentTabRCF));
		    	}
			}
			else{
				if(dj.byId("req_conf_party_flag")){
					dj.byId("req_conf_party_flag").set("disabled",false);
					}
				if(dj.byId("req_conf_party_flag_filtered")){
					dj.byId("req_conf_party_flag_filtered").set("disabled",false);
				}
			}
		},

		/**
		 * <h4>Summary:</h4>
		 *   Modify UI to render/disable amendment related fields for BG
		 *   @method refreshUBGIforAmendment
		 *   
		 */
		refreshUIforBGAmendment: function() {
			var prod_stat_code_val = dj.byId("prod_stat_code").get("value");
			var tnx_type_code_val = dj.byId("tnx_type_code").get("value");
			
			if( (tnx_type_code_val=== '15' && prod_stat_code_val === '08') || (tnx_type_code_val=== '15' && prod_stat_code_val === '31') ||
					tnx_type_code_val=== '03'){
			
			  if(tnx_type_code_val=== '03'){
				if(d.byId("amd_no_date_display_div")){
					d.byId("amd_no_date_display_div").style.display="none";
					dj.byId("amd_date").set("disabled",false);
				}
			  }
			
		       if((tnx_type_code_val=== '15' && prod_stat_code_val === '08') || (tnx_type_code_val=== '15' && prod_stat_code_val === '31') ||
					(tnx_type_code_val=== '03' && prod_stat_code_val === '08')){
				if(d.byId("amd_no_date_display_div")){
					d.byId("amd_no_date_display_div").style.display="block";
					dj.byId("amd_date").set("disabled",false);
			}
				if(d.byId("amd_no_date_bg_display_div")){
					d.byId("amd_no_date_bg_display_div").style.display="block";
					dj.byId("amd_date").set("disabled",false);
			}
			}
		      
		}
			else {
				if(d.byId("amd_no_date_bg_display_div")){
					d.byId("amd_no_date_bg_display_div").style.display="none";
					dj.byId("amd_date").set("disabled",false);
			}		
			}
		},
		
		/**
		 * <h4>Summary:</h4>
		 *   Modify UI to render/disable amendment related fields 
		 *   @method refreshUIforAmendment
		 *   
		 */
		refreshUIforAmendment : function() {
			var prod_stat_code_val = dj.byId("prod_stat_code").get("value");
			var tnx_type_code_val = dj.byId("tnx_type_code").get("value");
			var sub_tnx_type_code_val = dj.byId("sub_tnx_type_code") ? dj.byId("sub_tnx_type_code").get("value") : '';
			
			if( (tnx_type_code_val=== '15' && prod_stat_code_val === '08') || (tnx_type_code_val=== '15' && prod_stat_code_val === '31') ||
					tnx_type_code_val=== '03'){
				if(d.byId("amd_chrg_brn_by_code_div")){
				d.byId("amd_chrg_brn_by_code_div").style.display="block";
				}
				if(d.byId("cfm_chrg_brn_by_code_div")){
					d.byId("cfm_chrg_brn_by_code_div").style.display="block";
				}
				if(tnx_type_code_val=== '03'){
				if(d.byId("amd_no_date_display_div")){
					d.byId("amd_no_date_display_div").style.display="none";
					dj.byId("amd_date").set("disabled",false);
				}
				}
				if((tnx_type_code_val=== '15' && prod_stat_code_val === '08') || (tnx_type_code_val=== '15' && prod_stat_code_val === '31') ||
						(tnx_type_code_val=== '03' && prod_stat_code_val === '08')){
					if(d.byId("amd_no_date_display_div")){
						d.byId("amd_no_date_display_div").style.display="block";
						dj.byId("amd_date").set("disabled",false);
				}
				}
				
				m.toggleFields(false , 
						["advising_bank_name","advising_bank_address_line_1","advising_bank_address_line_2","advising_bank_dom","advising_bank_address_line_4","advising_bank_iso_code","advising_bank_reference"],null,true,null);
				m.toggleFields(false , 
						["advise_thru_bank_name","advise_thru_bank_address_line_1","advise_thru_bank_address_line_2","advise_thru_bank_dom","advise_thru_bank_address_line_4","advise_thru_bank_iso_code","advise_thru_bank_reference"],null,true,null);
				//d.byId("req_conf_party_flag_adv_bank_div").style.display="block";
				if(d.byId("req_conf_party_flag_filtered_div"))
				{
				d.byId("req_conf_party_flag_filtered_div").style.display="block";
				}
				if(dj.byId("req_conf_party_flag_filtered"))
				{
				dj.byId("req_conf_party_flag_filtered").set("value",dj.byId("req_conf_party_flag").getValue());	
				}
				if(d.byId("req_conf_party_flag_div"))
				{
				d.byId("req_conf_party_flag_div").style.display="none";	
				}
				m.resetRequestedConfirmationParty();
				if(dj.byId("req_conf_party_flag_filtered"))
				{
				m.setRequiredFields(['req_conf_party_flag_filtered'],true);
				}
				if(dj.byId("amd_chrg_brn_by_code_1") && !dj.byId("amd_chrg_brn_by_code_1").get("value") && !dj.byId("amd_chrg_brn_by_code_2").get("value") && !dj.byId("amd_chrg_brn_by_code_4").get("value") && (dj.byId("amd_chrg_brn_by_code_5") && !dj.byId("amd_chrg_brn_by_code_5").get("value")) && !dj.byId("amd_chrg_brn_by_code_9").get("value")){
					dj.byId("amd_chrg_brn_by_code_2").set("checked",true);
				}
				if(d.byId("advising_bank_name_img")){
					m.animate("wipeOut", d.byId('advising_bank_name_img'));
				}
				if(d.byId("advise_thru_bank_name_img")){
					m.animate("wipeOut", d.byId('advise_thru_bank_name_img'));
				}
				m.resetFormFields(["advising_bank_name","advising_bank_address_line_1","advising_bank_address_line_2","advising_bank_dom","advising_bank_address_line_4","advising_bank_iso_code","advising_bank_reference"]);
				m.resetFormFields(["advise_thru_bank_name","advise_thru_bank_address_line_1","advise_thru_bank_address_line_2","advise_thru_bank_dom","advise_thru_bank_address_line_4","advise_thru_bank_iso_code","advise_thru_bank_reference"]);
				
				if(m._config.narrativeDescGoodsDataStore || m._config.narrativeDocsReqDataStore || m._config.narrativeAddInstrDataStore || m._config.narrativeSpBeneDataStore || m._config.narrativeSpRecvbankDataStore) {
					m._config.currentNarrativeDescGoodsDataStore = m._config.narrativeDescGoodsDataStore;
					m._config.currentNarrativeDocsReqDataStore = m._config.narrativeDocsReqDataStore;
					m._config.currentNarrativeAddInstrDataStore = m._config.narrativeAddInstrDataStore;
					m._config.currentNarrativeSpBeneDataStore = m._config.narrativeSpBeneDataStore;
					m._config.currentNarrativeSpRecvbankDataStore = m._config.narrativeSpRecvbankDataStore;
				}
				
				if(d.byId("amend_narratives_display")) {
					d.byId("amend_narratives_display").style.display="block";
				}
				if(d.byId(viewNarrativeSwift)) {
					d.byId(viewNarrativeSwift).style.display="none";
				}
			}
			else if (tnx_type_code_val=== '15'){
				if(d.byId("amd_chrg_brn_by_code_div")){
				d.byId("amd_chrg_brn_by_code_div").style.display="none";
				}
				if(d.byId("cfm_chrg_brn_by_code_div")){
					d.byId("cfm_chrg_brn_by_code_div").style.display="none";
				}
				if(d.byId("amd_no_date_display_div")){
					dj.byId("amd_date").set("disabled",true);
					d.byId("amd_no_date_display_div").style.display="none";
				}
				m.toggleFields(true , 
						["advising_bank_name","advising_bank_address_line_1","advising_bank_address_line_2","advising_bank_dom","advising_bank_address_line_4","advising_bank_iso_code","advising_bank_reference"],null,true,null);
				m.toggleFields(true , 
						["advise_thru_bank_name","advise_thru_bank_address_line_1","advise_thru_bank_address_line_2","advise_thru_bank_dom","advise_thru_bank_address_line_4","advise_thru_bank_iso_code","advise_thru_bank_reference"],null,true,null);
				//d.byId("req_conf_party_flag_adv_bank_div").style.display="none";
				if(d.byId("req_conf_party_flag_filtered_div"))
					{
				d.byId("req_conf_party_flag_filtered_div").style.display="none";
					}
				if(d.byId("req_conf_party_flag_div"))
					{
				d.byId("req_conf_party_flag_div").style.display="block";
					}
				
				if(d.byId("advising_bank_name_img")){
					m.animate("wipeIn", d.byId('advising_bank_name_img'));
				}
				if(d.byId("advise_thru_bank_name_img")){
					m.animate("wipeIn", d.byId('advise_thru_bank_name_img'));
				}
				m.resetRequestedConfirmationParty();
				if(dj.byId("req_conf_party_flag_filtered")){
				m.setRequiredFields(['req_conf_party_flag_filtered'],false);
				}
				
				if(d.byId("amend_narratives_display")) {
					d.byId("amend_narratives_display").style.display="none";
				}
				if(d.byId(viewNarrativeSwift)) {
					d.byId(viewNarrativeSwift).style.display="block";
				}
				
				if(m._config.currentNarrativeDescGoodsDataStore) {
					m._config.narrativeDescGoodsDataStore = m._config.currentNarrativeDescGoodsDataStore;
					m._config.narrativeDocsReqDataStore = m._config.currentNarrativeDocsReqDataStore;
					m._config.narrativeAddInstrDataStore = m._config.currentNarrativeAddInstrDataStore;
					m._config.narrativeSpBeneDataStore = m._config.currentNarrativeSpBeneDataStore;
					m._config.narrativeSpRecvbankDataStore = m._config.currentNarrativeSpRecvbankDataStore;
				} else {
					m._config.narrativeDescGoodsDataStore = '';
					m._config.narrativeDocsReqDataStore = '';
					m._config.narrativeAddInstrDataStore = '';
					m._config.narrativeSpBeneDataStore = '';
					m._config.narrativeSpRecvbankDataStore = '';
					if(document.getElementById("narrativeDescriptionGoods")){
						document.getElementById("narrativeDescriptionGoods").innerHTML = "";
					}
					if(document.getElementById("narrativeDocumentsRequired")){
						document.getElementById("narrativeDocumentsRequired").innerHTML = "";
					}
					if(document.getElementById("narrativeAdditionalInstructions")){
						document.getElementById("narrativeAdditionalInstructions").innerHTML = "";
					}
					if(document.getElementById("narrativeSpecialBeneficiary")){
						document.getElementById("narrativeSpecialBeneficiary").innerHTML = "";
					}
					if(document.getElementById("narrativeSpecialReceivingBank")){
						document.getElementById("narrativeSpecialReceivingBank").innerHTML = "";
					}					
				}
			}else if((tnx_type_code_val=== '13' && !(sub_tnx_type_code_val === '12' || sub_tnx_type_code_val ==='19')) || tnx_type_code_val !=='13'){
				if(d.byId("amend_narratives_display")) {
					d.byId("amend_narratives_display").style.display="none";
				}
				if(d.byId(viewNarrativeSwift)) {
					d.byId(viewNarrativeSwift).style.display="block";
				}
			}
			
		},
		/**
		 * <h4>Summary:</h4>
		 *   Modify UI MO amendment to render/disable amendment related fields 
		 *   @method refreshUIforAmendment
		 *   
		 */
		refreshUIforAmendmentMO : function() {
			var prod_stat_code_val = dj.byId("prod_stat_code") ? dj.byId("prod_stat_code").get("value") : null;
			var tnx_type_code_val = dj.byId("tnx_type_code") ? dj.byId("tnx_type_code").get("value") : null;
			
			if( (tnx_type_code_val=== '15' && prod_stat_code_val === '08') || (tnx_type_code_val=== '15' && prod_stat_code_val === '31') ||
					tnx_type_code_val=== '03'){
				if(d.byId("amd_chrg_brn_by_code_div")){
				d.byId("amd_chrg_brn_by_code_div").style.display="block";
				}
				if(d.byId("cfm_chrg_brn_by_code_div")){
				d.byId("cfm_chrg_brn_by_code_div").style.display="block";
				}
				if(d.byId("amd_no_date_display_mo_div")){
					d.byId("amd_no_date_display_mo_div").style.display="block";
				}
				if(d.byId("amd_date_display_mo_div")){
					d.byId("amd_date_display_mo_div").style.display="block";
				}
				
				if(dj.byId("amd_chrg_brn_by_code_1") && !dj.byId("amd_chrg_brn_by_code_1").get("value") && !dj.byId("amd_chrg_brn_by_code_2").get("value") && !dj.byId("amd_chrg_brn_by_code_4").get("value") && (dj.byId("amd_chrg_brn_by_code_5") && !dj.byId("amd_chrg_brn_by_code_5").get("value")) && !dj.byId("amd_chrg_brn_by_code_9").get("value")){
					dj.byId("amd_chrg_brn_by_code_2").set("checked",true);
				}
				
				if(m._config.narrativeDescGoodsDataStore || m._config.narrativeDocsReqDataStore || m._config.narrativeAddInstrDataStore || m._config.narrativeSpBeneDataStore || m._config.narrativeSpRecvbankDataStore) {
					m._config.currentNarrativeDescGoodsDataStore = m._config.narrativeDescGoodsDataStore;
					m._config.currentNarrativeDocsReqDataStore = m._config.narrativeDocsReqDataStore;
					m._config.currentNarrativeAddInstrDataStore = m._config.narrativeAddInstrDataStore;
					m._config.currentNarrativeSpBeneDataStore = m._config.narrativeSpBeneDataStore;
					m._config.currentNarrativeSpRecvbankDataStore = m._config.narrativeSpRecvbankDataStore;
				}
				if(document.getElementById("amd_no"))
				{
				document.getElementById("amd_no").value = m._config.amendmentNumber;
				}
				if(d.byId("amend_narratives_display")) {
					d.byId("amend_narratives_display").style.display="block";
				}
				if(d.byId(viewNarrativeSwift)) {
					d.byId(viewNarrativeSwift).style.display="none";
				}
					
					
			}
			else if (tnx_type_code_val=== '15' || tnx_type_code_val=== '13'){
				if(d.byId("amd_chrg_brn_by_code_div")){
				d.byId("amd_chrg_brn_by_code_div").style.display="none";
				}
				if(d.byId("cfm_chrg_brn_by_code_div")){
				d.byId("cfm_chrg_brn_by_code_div").style.display="none";
				}
				if(d.byId("amd_no_date_display_mo_div")){
					d.byId("amd_no_date_display_mo_div").style.display="none";
				}
				if(d.byId("amd_date_display_mo_div")){
					d.byId("amd_date_display_mo_div").style.display="none";
				}
				if(d.byId("amend_narratives_display")) {
					d.byId("amend_narratives_display").style.display="none";
				}
				if(d.byId(viewNarrativeSwift)) {
					d.byId(viewNarrativeSwift).style.display="block";
				}
				
				if(document.getElementById("amd_no"))
				{
				document.getElementById("amd_no").value ='';
				}
				if(m._config.currentNarrativeDescGoodsDataStore) {
					m._config.narrativeDescGoodsDataStore = m._config.currentNarrativeDescGoodsDataStore;
					m._config.narrativeDocsReqDataStore = m._config.currentNarrativeDocsReqDataStore;
					m._config.narrativeAddInstrDataStore = m._config.currentNarrativeAddInstrDataStore;
					m._config.narrativeSpBeneDataStore = m._config.currentNarrativeSpBeneDataStore;
					m._config.narrativeSpRecvbankDataStore = m._config.currentNarrativeSpRecvbankDataStore;
				} else {
					m._config.narrativeDescGoodsDataStore = '';
					m._config.narrativeDocsReqDataStore = '';
					m._config.narrativeAddInstrDataStore = '';
					m._config.narrativeSpBeneDataStore = '';
					m._config.narrativeSpRecvbankDataStore = '';
					if(document.getElementById("narrativeDescriptionGoods")){
						document.getElementById("narrativeDescriptionGoods").innerHTML = "";
					}
					if(document.getElementById("narrativeDocumentsRequired")){
						document.getElementById("narrativeDocumentsRequired").innerHTML = "";
					}
					if(document.getElementById("narrativeAdditionalInstructions")){
						document.getElementById("narrativeAdditionalInstructions").innerHTML = "";
					}
					if(document.getElementById("narrativeSpecialBeneficiary")){
						document.getElementById("narrativeSpecialBeneficiary").innerHTML = "";
					}
					if(document.getElementById("narrativeSpecialReceivingBank")){
						document.getElementById("narrativeSpecialReceivingBank").innerHTML = "";
					}					
				}
			}
		},
		
		resetFormFields : function ( fieldArray ){
			d.forEach(fieldArray, function (id, index) {
				var item = dj.byId(id);
				if(item){
					item.reset();
				}
			});
		},
		
		/**
		 * <h4>Summary:</h4>
		 *   sets the required attribute of each Dijit form field in the fieldarray to true or false based on requiredFlag
		 *   @method setRequiredFields
		 *   
		 */
		setRequiredFields : function ( fieldArray , requiredFlag) {			
			
			d.forEach(fieldArray, function (id, index) {
				var item = dj.byId(id);
				item.set("required", requiredFlag);			
			});
		},
		/**
		 * <h4>Summary:</h4>
		 *   Utility method for comparing Transaction and Master form elements
		 *   Even if a single field is different b/w transaction and master, return true and no further comparison is necessary
		 *  
		 *   @method compareTransactionMaster
		 *   @Parameters : tnxFormArray->This contains the form elements we want to compare with Master
		 *   @Returns :True if even a single field is different between Transaction and Master.
		 *   		   False otherwise
		 *   
		 */
		compareTransactionMaster : function( tnxFormArray , type){
			
			var compareResult = false;
			for(var i=0 ; i<tnxFormArray.length ; i++){
				var transactionData = dj.byId(tnxFormArray[i]);
				var masterData = dj.byId("org_" + tnxFormArray[i]);
				
				//Present in Master but not Transaction
				if((masterData && !transactionData)||(transactionData && !masterData)){
					compareResult=true;
					break;
				}
				//Present in Transaction and Master,then compare the values
				else{
					if(type === "TXT"){
						if( m.trim(masterData.get("value")) !== m.trim(transactionData.get("value")) ){
							compareResult=true;
							break;				
						}					
					}else if(type === "CHECK"){			
						var transactionCheckBoxValue =  (transactionData.get("checked") === true) ? "Y" : "N";
						if( masterData.get("value") !== transactionCheckBoxValue){
							compareResult=true;
							break;				
						}
					}
				}
			}	
			return compareResult;
		},
		/**
		 * <h4>Summary:</h4>
		 *   Utility method for comparing Transaction and Master radio button elements
		 *   Even if a single field is different b/w transaction and master, return true and no further comparison is necessary
		 *  
		 *   @method compareTransactionMasterRadio
		 *   @Parameters : tnxFormArray->This contains the form elements we want to compare with Master
		 *   @Returns :True if even a single field is different between Transaction and Master.
		 *   		   False otherwise
		 *   
		 */
		compareTransactionMasterRadio : function( tnxFormArray ){
			var compareResult = false;
			
			for(var i=0 ; i<tnxFormArray.length ; i++){
				var transactionData = dj.byId(tnxFormArray[i]);
			//This gives which radio button been selected currently in the amendment screen.
			//Radio buttons generally have some value if they are selected like "01","07" etc
				if(transactionData && transactionData.get("value") !== false){
					var masterData = dj.byId("org_" + tnxFormArray[i]);
					//Compare the same selection with that of the master.If they are different means value are different
					if( !masterData || (masterData.get("value") !== transactionData.get("value"))){
						compareResult=true;
						break;
					}
				}
			}
			return compareResult;		
		},
		/**
		 * <h4>Summary:</h4>
		 *  
		 *   @method amendChargesLC
		 *   Disables Other Narrative in Amendment page when amendment charges are applicant/beneficiary
		 *   Enables Other Narrative when Amendment charges is selected  'Other'
		 */
		amendChargesLC : function() {
			var amdChargesArea = dj.byId("narrative_amend_charges_other");
			var optId = this.get("id");
			if(amdChargesArea) {
				if(optId === "amd_chrg_brn_by_code_4" || optId === "amd_chrg_brn_by_code_5") {
					amdChargesArea.set("value", "");
					amdChargesArea.set("disabled", false);
				}
				else {
						amdChargesArea.set("value", "");
						amdChargesArea.set("disabled", true);			
				}
			}
		},
		/**
		 * <h4>Summary:</h4>
		 *  
		 *   @method calculateAmendTransactionAmount
		 *   Calculates the tnx amount for the amendmentment
		 */
		calculateAmendTransactionAmount : function() {
			var amendmentTransaction = (dj.byId("tnxtype") && dj.byId("tnxtype").get("value")==="03") || 
					(dj.byId("tnx_type_code") && dj.byId("tnx_type_code").get("value")==="03") || 
					(dj.byId("prod_stat_code") && (dj.byId("prod_stat_code").get("value")==="08" || dj.byId("prod_stat_code").get("value")==="31"));
			var tnxAmt = dj.byId("tnx_amt");
			if(amendmentTransaction)
			{
			var incAmt = dj.byId("inc_amt");
			if(incAmt){
				incAmt.set("value", "");
			}
			var decAmt = dj.byId("dec_amt");
			if(decAmt){
				decAmt.set("value", "");
			}
			
			var amtField = dj.byId("lc_amt"),
			orgAmtField = dj.byId("org_lc_amt"),
			// We parse to number in case either field happens to be a hidden field.
			orgAmt = d.number.parse(orgAmtField.get("displayedValue")),
			amendedAmt = d.number.parse(amtField.get("displayedValue"));

			orgAmt = !isNaN(orgAmt) ? orgAmt : 0;
			amendedAmt = !isNaN(amendedAmt) ? amendedAmt : 0;
			
			var diffAmt = amendedAmt - orgAmt;
			if(diffAmt > 0){
				//Inc Amt
				if(tnxAmt){
					tnxAmt.set("value", diffAmt);
				}
				if(incAmt){
					incAmt.set("value", diffAmt);
				}
			}
			else if(diffAmt < 0){
				//Dec Amt
				if(tnxAmt){
					tnxAmt.set("value", (-1*diffAmt));
				}
				if(decAmt){
					decAmt.set("value", (-1*diffAmt));
				}
			}
			}
			else
			{
				tnxAmt.set("value", d.number.parse(dj.byId("lc_amt").get("value")));
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * If the confirmation instructions say Without, always uncheck the
		 * confirmation charges.
		 * @method checkConfirmationCharges
		 */
		checkConfirmationCharges: function() {
			//  summary:
		    //        If the confirmation instructions say Without, always uncheck the
			//        confirmation charges.
			
			if(dj.byId("cfm_inst_code_3").get("checked")) {
				this.set("checked", false);
				m.showTooltip(m.getLocalization("confirmationInstructionsError"), 
						d.byId("cfm_chrg_brn_by_code_1"), ["before"]);
			}
			if(m._config.charge_splitting_lc){
				if(dj.byId("open_chrg_brn_by_code_3")){ // if defined
					if(dj.byId("cfm_chrg_brn_by_code_3").get("checked")) {
						dj.byId("cfm_chrg_applicant").set("disabled", false).set("required", true);
						dj.byId("cfm_chrg_beneficiary").set("disabled", false).set("required", true);
					}
					else {
						dj.byId("cfm_chrg_applicant").set("disabled", true).set("value", "").set("required", false);
						dj.byId("cfm_chrg_beneficiary").set("disabled", true).set("value", "").set("required", false);
					}
				}
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * If the splitting button of open_charge and corr_charge selected, enable amount text boxes,
		 * Otherwise, disbale them.
		 * @method checkApplBeneCharges
		 */		
		checkApplBeneCharges: function() {
			if(dj.byId("open_chrg_brn_by_code_3")){ // if defined
				if(dj.byId("open_chrg_brn_by_code_3").get("checked")) {
					dj.byId("open_chrg_applicant").set("disabled", false).set("required", true);
					dj.byId("open_chrg_beneficiary").set("disabled", false).set("required", true);
				}
				else {
					dj.byId("open_chrg_applicant").set("disabled", true).set("value", "").set("required", false);
					dj.byId("open_chrg_beneficiary").set("disabled", true).set("value", "").set("required", false);
				}
			}
			if(dj.byId("corr_chrg_brn_by_code_3")){ // if defined
				if(dj.byId("corr_chrg_brn_by_code_3").get("checked")) {
					dj.byId("corr_chrg_applicant").set("disabled", false).set("required", true);
					dj.byId("corr_chrg_beneficiary").set("disabled", false).set("required", true);
				}
				else {
					dj.byId("corr_chrg_applicant").set("disabled", true).set("value", "").set("required", false);
					dj.byId("corr_chrg_beneficiary").set("disabled", true).set("value", "").set("required", false);
				}
			}
		},		
		/**
		 * <h4>Summary:</h4>
		 * Toggle the display of the renewal details.
		 * Checks for the value of is_bank depending upon that it toggels diffrent field.
		 * Also sets values of some of the fields of depending upon the value of renew_flag on which this function is called.
		 * @method toggleRenewalDetails
		 */
		toggleRenewalDetails : function( /*Boolean*/ keepFieldValues) {
			//  summary:
		    //        Toggle the display of the renewal details.
			
			if(dj.byId("is_bank") && dj.byId("is_bank").get("value") === "N")
			{
				m.toggleFields(this.get("checked"), ["advise_renewal_flag",
				           "rolling_renewal_flag", "renew_amt_code_1", "renew_amt_code_2", "final_expiry_date"],
				           ["renew_on_code", "renew_for_nb", "renew_for_period"], 
				           keepFieldValues);
			}
			else
			{
				m.toggleFields(this.get("checked"), ["advise_renewal_flag",
  				           "rolling_renewal_flag", "renew_amt_code_1", "renew_amt_code_2", "projected_expiry_date", "final_expiry_date"],
  				           ["renew_on_code", "renew_for_nb", "renew_for_period"], 
  				           keepFieldValues);
			}

			// Reset other fields
			if(!this.get("checked")) {
				dj.byId("renew_on_code").set("value", "");
				dj.byId("renew_for_nb").set("value", "");
				dj.byId("renew_for_period").set("value", "");
				dj.byId("advise_renewal_flag").set("checked", false);
				dj.byId("rolling_renewal_flag").set("checked", false);
				dj.byId("renew_amt_code_1").set("checked", false);
				dj.byId("renew_amt_code_2").set("checked", false);
				if(dj.byId("projected_expiry_date"))
				{
					dj.byId("projected_expiry_date").set("value", null);
				}
				dj.byId("final_expiry_date").set("value", null);
			}
		}, 
		
		/**
		 * <h4>Summary:</h4>
		 * Toggle the display of the renewal details.
		 * Checks for the value of is_bank depending upon that it toggels diffrent field.
		 * Also sets values of some of the fields of depending upon the value of renew_flag on which this function is called.
		 * @method toggleRenewalDetails
		 */
		resetRenewalDetails : function( /*Boolean*/ keepFieldValues, /*Dijit._widget || DomNode*/ node) {
			//  summary:
		    //        Toggle the display of the renewal details.
			
			if(dj.byId("is_bank") && dj.byId("is_bank").get("value") === "N")
			{
				m.toggleFields(node.get("checked"), ["advise_renewal_flag",
				           "rolling_renewal_flag", "renew_amt_code_1", "renew_amt_code_2", "final_expiry_date"],
				           ["renew_on_code", "renew_for_nb", "renew_for_period"], 
				           keepFieldValues);
			}
			else
			{
				m.toggleFields(node.get("checked"), ["advise_renewal_flag",
  				           "rolling_renewal_flag", "renew_amt_code_1", "renew_amt_code_2", "projected_expiry_date", "final_expiry_date"],
  				           ["renew_on_code", "renew_for_nb", "renew_for_period"], 
  				           keepFieldValues);
			}

			// Reset other fields
			if(!node.get("checked")) {
				dj.byId("renew_on_code").set("value", "");
				dj.byId("renew_for_nb").set("value", "");
				dj.byId("renew_for_period").set("value", "");
				dj.byId("advise_renewal_flag").set("checked", false);
				dj.byId("rolling_renewal_flag").set("checked", false);
				dj.byId("renew_amt_code_2").set("checked", true);
				if(dj.byId("projected_expiry_date"))
				{
					dj.byId("projected_expiry_date").set("value", null);
				}
				dj.byId("final_expiry_date").set("value", null);
			}
		},

								/**
								 * <h4>Summary:</h4> 
								 * Toggle dependent fields.
								 * The object field cannot have a value
								 * if the object dependent Field already has one
								 * 
								 * @param {Dijit._Widget||DonNode} node
								 * @param {Dijit._Widget||DomNode} dependentNode
								 * @param {String} tooltip
								 * @method toggleDependentFields
								 */
		toggleDependentFields : function( /*Dijit._widget || DomNode*/ node,
										  /*Dijit._widget || DomNode */ dependentNode,
										  /*String*/ tooltip) {
			//  summary:
		    //        The object field cannot have a value if the object 
			//        dependentField already has one
			//
			//	TODO Field should have its state changed to Error, otherwise the form can be 
			//		 submitted
			
			var field = dj.byId(node),
				dependentField = dj.byId(dependentNode);			
			
			if(dependentField.get("displayedValue") !== "" && field.get("displayedValue") !== "") {
				field.set("displayedValue", "");
				field.set("readOnly", true);
				if(tooltip) {
					m.setFieldState(field, false);
					m.showTooltip(tooltip, field.domNode);
				}
			} else {
				field.set("readOnly", false);
				dependentField.set("readOnly", false);
				//why change state the field is clear ? 
				//this made conflict with validation of field
				//m.setFieldState(field, true);
			}
		}, 
		/**
		 * <h4>Summary:</h4>
		 * This function updates outstanding amount depending upon 
		 * tnx type code and prod stat code,sub tnx type code.
		 * @param {Dijit._Widget} liabAmtField
		 * 
		 * @param {Dijit._Widget} orgLiabAmtField 
		 * @method updateOutstandingAmount
		 */
		updateOutstandingAmount : function( /*Dijit._widget*/ liabAmtField, 
											/*Dijit._widget*/ orgLiabAmtField,productCode) {
			// summary:
			//		TODO Explain business logic
			
			var prodStatCodeValue = dj.byId("prod_stat_code").get("value");
				if(productCode == null)
					{
					var product = dj.byId("product_code").get("value").toLowerCase();
					productCode = dj.byId(product+"_amt");
					}
						
				
				var originalLiabAmt = dojo.number.parse(orgLiabAmtField.get("value")) || productCode.get("value");
				var tnxAmt;
				if(dj.byId("tnx_amt") && dj.byId("tnx_amt").get("value")){
				tnxAmt = isNaN(dojo.number.parse(dj.byId("tnx_amt").get("value"))) ? 0: dj.byId("tnx_amt").get("value");
				}
				else
				{
					tnxAmt = 0;
				}
				var liabAmt,tnxTypeCode = dj.byId("tnx_type_code"),subTnxTypeCode = dj.byId("sub_tnx_type_code");
				
			
			// Reduce outstanding amount by document amount value, in the following cases
			if(prodStatCodeValue === "04" || prodStatCodeValue === "14" ||
					prodStatCodeValue === "15" || prodStatCodeValue === "13" || prodStatCodeValue === "05" ) {
				liabAmt = originalLiabAmt - tnxAmt;
				liabAmt = (liabAmt > 0) ? liabAmt : 0;
				liabAmtField.set("value", liabAmt);
			} 
			else if(tnxTypeCode && subTnxTypeCode && tnxTypeCode.get("value") != "03" && subTnxTypeCode.get("value") != "05" && isNaN(liabAmtField.get("value")))
			{
				liabAmtField.set("value", originalLiabAmt);
			}
			else if((prodStatCodeValue=="07" || prodStatCodeValue === "03") && !isNaN(liabAmtField.get("value")))
			{
				console.log("liability amount retained");
			}
			else
			{
				liabAmtField.set("value", originalLiabAmt);
			}
						},
						
						/**
						 * <h4>Summary:</h4> 
						 * 
						 * Show a popup of confirmation to allow the
						 * deletion of a record 
						 * <h4>Description:</h4>  
						 * Confirmation popup
						 * when deleting an account / bill payee (Accounts
						 * Management Module)
						 * @param {String} title
						 * @param {String} url
						 * @param {String} type
						 * @method confirmAccountDelete
						 */
		confirmAccountDelete : function( /*String*/ title,
										 /*String*/ url,
										 /*String*/ type) {
			
			//  summary:
			//         Show a popup of confirmation to allow the deletion of a record
			//  description:
			//		   Confirmation popup when deleting an account / bill payee 
			//         (Accounts Management Module)

			var mess = (type === "bill") ? 
					"deleteBillPayeeConfirmation" : "deleteTransactionConfirmation";
			
			m.dialog.show("CONFIRMATION",
				m.getLocalization(mess, [title]), "",
					function(){ document.location.href = url; }
			);
		},
						/**
						 * <h4>Summary:</h4> 
						 * Open a popup window showing the details of
						 * static data such as entities, phrases, etc.
						 * @param {String} option
						 * @param {String} operation
						 * @param {String[]} arrFieldValues
						 * @param {String} screen
						 * @param {String} product
						 * @method populateStaticDataDialog
						 */
		populateStaticDataDialog : function( /*String*/ option, 
					 						 /*String*/ operation,
					 						 /*String[]*/ arrFieldValues,
					 						 /*String*/ screen,
					 						 /*String*/ product){
			//  summary:
			//            Open a popup window showing the details of static data such as 
			//            entities, phrases, etc.

			var url = "/screen/AjaxScreen/action/GetStaticDataPopup",
			    query = {};
			query.option = option;
			query.operation = operation;
			query.fields = arrFieldValues;
			query.popupType = "ADD_DATA";
			
			if(product) {
				query.productcode = product;
			}

			console.debug("[misys.form.common] Opening an 'Add Static Data' popup screen at URL",  url, query);
			m.dialog.populate(option, m.getServletURL(url), null, query);
		},
		
		/**
		 * <h4>Summary:</h4>
		 * Returns a URL for the static data auch as Entities ,Pharses etc.
		 * @param {String} option
		 * @param {String} operation
		 * @param {String} formName
		 * @paran {String[]} arrFieldValues
		 * @param {String} screen
		 * @param {String} product
		 * @method getStaticDataURL
		 */
		getStaticDataURL : function( /*String*/ option,
				 					 /*String*/ operation,
				 					 /*String*/ formName,
				 					 /*String[]*/ arrFieldValues,
				 					 /*String*/ screen, 
				 					 /*String*/ product){
			//  summary:
		    //        Open a popup window showing the details of static data such as 
			//        entities, phrases, etc.
			
			var url = ["/screen/"],
				urlScreen = screen || "StaticDataListPopup";
			
			url.push(urlScreen, "?option=", option, "&operation=", operation, 
					"&fields=", arrFieldValues, "&formname=", formName);
	
			if(product){
				url.push(varProdCode, product);
			}

			return m.getServletURL(url.join(""));
		}, 
		
		// TODO Switch to JSON object as a parameter
		// TODO Replace references to "popup" with "dialog"
		/**
		 * <h4>Summary:</h4>
		 * Open a popup window to perform the search in the available list of entity
		 * records. The screen can also be given as parameter.
		 *  Set isInPopup to true for a button that is already in a popup
		 *  @param String,String[],String,String,String,String,String,String,String,String
		 *  @param Boolean,Boolean,String,String
		 */
		showEntityDialog : function( /*String*/entity,
					                /*String[]*/fields, 
					                /*String*/product, 
					                /*String*/entityContext,
					                /*String*/company, 
					                /*String*/ featureid, 
					                /*String*/ option, 
					                /*String*/dimensions, 
					                /*String*/title, 
					                /*String*/ subProduct,
					                /*Boolean*/ isInPopup, 
					                /*Boolean*/ closeParent,
					                /*String*/ popupPrefix,
					                /*String*/ wildCard) {
			//  summary:
			//        Open a popup window to perform the search in the available list of entity
			//        records. The screen can also be given as parameter.   
			//		  Set isInPopup to true for a button that is already in a popup

			
			var url = "/screen/EntityListPopup",
				query = {},
				contentURL = "/screen/AjaxScreen/action/GetEntities",
				queryStore = {}, grid, gridId, childDialog, onShowCallback;

			
			if(closeParent) {
				queryStore.closeParent = closeParent;
				query.closeParent = closeParent;
			}
			
			if (wildCard){
				query.wildcard = wildCard;	
				queryStore.wildcard = wildCard;
			}

			if(fields){
				queryStore.fields = fields;
				query.fields = fields;
			}

			if(product){
				query.productcode = product;
				queryStore.productcode = product;
			} else {
				query.productcode = "*";
				queryStore.productcode = product;
			}
			if(subProduct){
				query.subproductcode = subProduct;
				queryStore.subproductcode = subProduct;
			} 

			if(company){
				query.company = company;
				queryStore.company = company;
			}

			if(entityContext){
				query.entitycontext = entityContext;
				queryStore.entitycontext = entityContext;
			}

			if(featureid){
				query.featureid = featureid;			
				queryStore.featureid = featureid;
			}

			if(option){
				query.option = option;
				queryStore.option = option;
			}
			
			if(popupPrefix) {
				query.popupPrefix = popupPrefix;
				queryStore.popupPrefix = popupPrefix;
			}
			query.dimensions = dimensions;

			gridId = entityContext + "entities_grid";
			onShowCallback = function() {
				// Show loading message, otherwise it doesn't necessarily appear
				if(popupPrefix){
					gridId = popupPrefix + gridId;
				}
				grid = dj.byId(gridId);
				console.debug("[misys.form.common] Calling onShowCallback for grid", gridId);
				console.debug("[misys.form.common] Grid content URL is", contentURL);
				grid.showMessage(grid.loadingMessage);
				if(!entityContext || entityContext !== 'CUSTOMER')
				{
					m.grid.setStoreURL(grid, m.getServletURL(contentURL), queryStore);
				}
				/*m.grid.setStoreURL(grid, m.getServletURL(contentURL), queryStore);*/
				
				m.connect("sy_name", "onKeyPress", function(evnt){
					if(evnt.keyCode === dojo.keys.ENTER){
						m.grid.filter(dj.byId('USERentities_grid'), ['NAME'], ['sy_name']);
				  }
				});
				m.connect("sy_abbvname", "onKeyPress", function(evnt){
					if(evnt.keyCode === dojo.keys.ENTER){
						m.grid.filter(dj.byId('USERentities_grid'), ['ABBVNAME'], ['sy_abbvname']);
				  }
				});
				m.connect("sy_name", "onKeyPress", function(evnt){
					if(evnt.keyCode === dojo.keys.ENTER){
						m.grid.filter(dj.byId('USER_WITH_ENTITY_WILDCARDentities_grid'), ['NAME'], ['sy_name']);
				  }
				});
				m.connect("sy_abbvname", "onKeyPress", function(evnt){
					if(evnt.keyCode === dojo.keys.ENTER){
						m.grid.filter(dj.byId('USER_WITH_ENTITY_WILDCARDentities_grid'), ['ABBVNAME'], ['sy_abbvname']);
				  }
				});

				m.connect("sy_abbvname", "onKeyPress", function(evnt){
					if(evnt.keyCode == dojo.keys.ENTER){
						m.grid.filter(dj.byId('CUSTOMERentities_grid'), ['ABBVNAME'], ['sy_abbvname']);
					}
				});
				
				m.connect("sy_name", "onKeyPress", function(evnt){
					if(evnt.keyCode == dojo.keys.ENTER){
						m.grid.filter(dj.byId('CUSTOMERentities_grid'), ['NAME'], ['sy_name']);
					}
				});
				
				m.connect("sy_prefixentity", "onKeyPress", function(evnt){
					if(evnt.keyCode == dojo.keys.ENTER){
						m.grid.filter(dj.byId('prefixCUSTOMERentities_grid'), ['ENTITY_ABBV_NAME'], ['sy_prefixentity']);
					}
				});
				
				m.connect("sy_prefixname", "onKeyPress", function(evnt){
					if(evnt.keyCode == dojo.keys.ENTER){
						m.grid.filter(dj.byId('prefixCUSTOMERentities_grid'), ['NAME'], ['sy_prefixname']);
					}
				});
				
//				m.connect("abbv_name", "onKeyPress", function(evnt){
//					if(evnt.keyCode == dojo.keys.ENTER){
//						m.grid.filter(dj.byId('gridColumn_phrasedata_grid'), ['ABBVNAME'], ['abbv_name']);
//				  }
//				});
			};
			if(isInPopup) {
				console.debug(chilDialog, url);
				childDialog = dj.byId("childXhrDialog") || new dj.Dialog({
					title: title,
					id: "childXhrDialog",
					href: m.getServletURL(url),
					ioMethod: misys.xhrPost,
					ioArgs: { content: query }
				});
				
				m.dialog.connect(childDialog, "onLoad", onShowCallback);
				m.dialog.connect(childDialog, "onHide", function(){setTimeout(function(){
					m.dialog.disconnect(childDialog);
					childDialog.destroyRecursive();
				}, 2000);});
				
				// Offset the dialog from the parent window
				var co = d.coords("xhrDialog");
				childDialog._relativePosition = {
						x: co.x + 30,
						y: co.y + 30
				};
				
				childDialog.show();
			} else {
				m.dialog.show("URL", "", title, null, onShowCallback, m.getServletURL(url), null, null, query);
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * Shows a dialog if credit availlable with bank's type is Other.Internally it calls showSearchDialog to create a dialog.
		 * @param String type
		 *  Type of the dialog
		 * @param {String[]} fields
		 *  Fields to populate in the dialog.
		 * @param {String} product
		 * @param {String} dimensions
		 *  Dimensions for dialog
		 * @param {String} title
		 *  Title for the dialog
		 * @method showBankTypeDialog
		 */
		showBankTypeDialog : function( /*String*/ type,
				   					   /*String[]*/ fields, 
				   					   /*String*/ product,
				   					   /*String*/ dimensions, 
				   					   /*String*/ title) {
			//  summary:
			//        Search credit available by

			if(dj.byId("credit_available_with_bank_type").get("value") === "Other"){
				m.showSearchDialog(type, fields, "", "", product, 
							dimensions, title);
			}
		},

		// TODO Get rid of hardcoded width
		/**
		 * <h4>Summary:</h4>
		 * Shows Drawee Dialog .This function internally calls showSearchDialog.
		 * @param {String} type
		 *  Tyope of the dialog
		 * @param {String} formName
		 * @param {String[]} fields
		 * @param {String} title
		 *  Title of dialog
		 * @method showDraweeDialog
		 */
		showDraweeDialog : function ( /*String*/ type,
				  					  /*String*/ formName, 
				  					  /*String[]*/ fields, 
				  					  /*String*/ title)  {
			//	summary:
			//

			if( (dj.byId("cr_avl_by_code_1") && dj.byId("cr_avl_by_code_1").get("checked")) || 
					(dj.byId("cr_avl_by_code_2") && dj.byId("cr_avl_by_code_2").get("checked")) ||
					(dj.byId("cr_avl_by_code_3") && dj.byId("cr_avl_by_code_3").get("checked"))){
				m.showSearchDialog(type, fields, "", "", 
						"EL", "width:580px;height:auto;", title);
			}
		},
		
				showUsersDialog : function ( /*String*/ type,
								 /*String[]*/ fields, 
								/*String*/ companyName,
								/*String*/ userId,
								/*Object*/ parameter,
								/*String*/ screen,
								/*String*/ dimensions, 
								/*String*/ title, 
								/*String*/ companyId,
								/*String*/ action, 
								/*boolean*/ isQueryReadStore, 
								/*String*/ userAction){
				var url = [],
				query = {},
				contentURL = [ ajaxActionUrl ],
				queryStore = {},
				urlAction = action || "GetStaticData",
				urlScreen = screen || ajaxStaticDPopup,
				entity,
				onLoadCallback;
				// Check that the dimensions have a trailing semi-colon
				// as it will be appended to other rules later
				if(dimensions.slice(dimensions.length - 1) !== ";") {
				dimensions += ";";
				}
				contentURL.push(urlAction);
				queryStore.option = type;
				queryStore.fields = fields;
				queryStore.companyName = companyName;
				queryStore.userId = userId;
				queryStore.entity = entity;
				queryStore.user_action = userAction;
				d.mixin(queryStore, parameter);
				
				url.push("/screen/", urlScreen);	
				query.option = type;
				query.fields = fields;
				query.companyName = companyName;
				query.userId = userId;
				query.companyId = companyId;
				query.dimensions = dimensions;
				d.mixin(query, parameter);
				query.popupType = "LIST_DATA";
				
				if (companyId) {
				query.companyid = companyId;
				queryStore.companyid = companyId;
				}
				
				console.debug(messageGridContent, contentURL.join(""), queryStore);
				
				// Load data
				onLoadCallback = function() {
				var grid = dj.byId(type + "data_grid");
				grid.showMessage(grid.loadingMessage);
				m.grid.setStoreURL(grid, m.getServletURL(contentURL.join("")), queryStore);
				};
				
				m.dialog.show("URL", "", title, null, onLoadCallback, m.getServletURL(url.join("")), null, null, query);
				
				 m.connect("lastname", "onKeyPress", function(evnt){
                     if(evnt.keyCode === dojo.keys.ENTER){
                             m.grid.filter(dj.byId('userdata_grid'), ['LAST_NAME'], ['last_name']);
               }
             });
             m.connect("firstname", "onKeyPress", function(evnt){
                     if(evnt.keyCode === dojo.keys.ENTER){
                             m.grid.filter(dj.byId('userdata_grid'), ['FIRST_NAME'], ['first_name']);
               }
         });
             m.connect("loginId", "onKeyPress", function(evnt){
                     if(evnt.keyCode === dojo.keys.ENTER){
                             m.grid.filter(dj.byId('userdata_grid'), ['LOGIN_ID'], ['login_id']);
               }
             });
				
				},
		/**
		 * <h4>Summary:</h4>
		 * It is for showing External account dialog
		 * @param String
		 * @param String[]
		 * @param Object
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param boolean
		 * @param String
		 * @method showSearchExtAccountDialog
		 * 
		 */
		showSearchExtAccountDialog : function ( /*String*/ type,
												 /*String[]*/ fields, 
												/*Object*/ parameter, 
												/*String*/ screen,
												/*String*/ product, 
												/*String*/ dimensions, 
												/*String*/ title, 
												/*String*/ entityField,
												/*String*/ companyId,
												/*String*/ action, 
												/*boolean*/ isQueryReadStore, 
												/*String*/ userAction){
				var url = [],
				query = {},
				contentURL = [ ajaxActionUrl ],
				queryStore = {},
				urlAction = action || "GetStaticData",
				urlScreen = screen || ajaxStaticDPopup,
				entity,
				onLoadCallback;
				// Check that the dimensions have a trailing semi-colon
				// as it will be appended to other rules later
				if(dimensions.slice(dimensions.length - 1) !== ";") {
				dimensions += ";";
				}
				if (dj.byId(entityField))
				{
				entity = dj.byId(entityField).get('value');			
				}
				contentURL.push(urlAction);
				queryStore.option = type;
				queryStore.fields = fields;
				queryStore.entity = entity;
				queryStore.user_action = userAction;
				d.mixin(queryStore, parameter);
				
				url.push("/screen/", urlScreen);	
				query.option = type;
				query.fields = fields;
				query.dimensions = dimensions;
				d.mixin(query, parameter);
				query.popupType = "LIST_DATA";
				
				if(product) {
				query.productcode = product;
				queryStore.productcode = product;
				}
				
				if (companyId) {
				query.companyid = companyId;
				queryStore.companyid = companyId;
				}
				
				console.debug(messageGridContent, contentURL.join(""), queryStore);
				
				if (!isQueryReadStore) {
				// Load data
				onLoadCallback = function() {
				var grid = dj.byId(type + "data_grid");
				if(grid)
				{
				grid.showMessage(grid.loadingMessage);
				m.grid.setStoreURL(grid, m.getServletURL(contentURL.join("")), queryStore);
				}
				};
				}
				
				m.dialog.show("URL", "", title, null, onLoadCallback, m.getServletURL(url.join("")), null, null, query);
								
		},
						/**
						 * <h4>Summary:</h4>
						 *  Open a popup window to perform the search in
						 * the available list of records whose type is passed as
						 * a parameter("bank", "beneficiary", "phrase",
						 * "account", "currency", ...). The screen can also be
						 * given as parameter.
						 * @param String
						 * @param String[]
						 * @param Object
						 * @param String
						 * @param String
						 * @param String
						 * @param String
						 * @param String
						 * @param String
						 * @param boolean
						 * @param String
						 * @param String
						 * @method showSearchDialog
						 */
		showSearchDialog : function( /*String*/ type,
				 					 /*String[]*/ fields, 
				 					 /*Object*/ parameter, 
				 					 /*String*/ screen,
				 					 /*String*/ product, 
				 					 /*String*/ dimensions,
				 					 /*String*/ title,
				 					 /*String*/ companyId,
				 					 /*String*/ action, 
				 					 /*boolean*/ isQueryReadStore, 
				 					 /*String*/ userAction,
				 					/*String*/ excludedValueField,
				 					 /*String*/ subProduct){
				 					
			//  summary:
			//        Open a popup window to perform the search in the available list of records
			//        whose type is passed as a parameter("bank", "beneficiary", "phrase",
			//        "account", "currency", ...). The screen can also be given as parameter.        

			var url = [],
				query = {},
				contentURL = [ ajaxActionUrl ],
				queryStore = {},
				urlAction = action || "GetStaticData",
				urlScreen = screen || ajaxStaticDPopup,
				excludedValue,
				onLoadCallback,
				bank_abbv_name,
				product_type=dj.byId("product_type") ? dj.byId("product_type").get("value"):"",
				customerBankValue = dj.byId("customer_bank") ? dj.byId("customer_bank").get("value") : "",
				issuingBankAbbvName = dijit.byId("issuing_bank_abbv_name") ? dijit.byId("issuing_bank_abbv_name").get("value") : "";
				var fscmPgm = dj.byId("program_id");
			
			if (dj.byId(excludedValueField))
			{
			    excludedValue = dj.byId(excludedValueField).get('value'); 
			    if (excludedValue === "")
			     {
			         console.debug("[misys.form.common] cannot select an account if excluded value is mandatory");
			         return;
			     }
			}
			// Check that the dimensions have a trailing semi-colon
			// as it will be appended to other rules later
			if(dimensions.slice(dimensions.length - 1) !== ";") {
				dimensions += ";";
			}
			contentURL.push(urlAction);
			queryStore.option = type;
			queryStore.fields = fields;
			queryStore.user_action = userAction;
			queryStore[excValue] = excludedValue;
			d.mixin(queryStore, parameter);
			
			url.push("/screen/", urlScreen);	
			query.option = type;
			query.fields = fields;
			query.dimensions = dimensions;
			d.mixin(query, parameter);
			query.popupType = "LIST_DATA";

			if(product) {
				query.productcode = product;
				queryStore.productcode = product;
			}

			if (companyId) {
				query.companyid = companyId;
				queryStore.companyid = companyId;
			}
			
			if (parameter && parameter.entity_name==="") {
				queryStore.entity_name = dj.byId("entity") ? dj.byId("entity").get("value") : "";
				query.entity_name = dj.byId("entity") ? dj.byId("entity").get("value") : "";
			}
			if(customerBankValue)
			{
				bank_abbv_name = customerBankValue;
			}	
			else if(dj.byId("bank_abbv_name") && dj.byId("bank_abbv_name").get("value") !== "")
            {       
                bank_abbv_name = dj.byId("bank_abbv_name").get("value");
            }	
			else if(issuingBankAbbvName)
            {
				// if both customer_bank and bank_abbv_name are 'empty' or 'undefined', assign issuing_bank_abbv_name to bank_abbv_name.
                bank_abbv_name = issuingBankAbbvName;
            }			
			queryStore.bank_abbv_name = bank_abbv_name;
			
			if(fscmPgm)
			{
				query.fcmPgmId = fscmPgm.get('value');
				queryStore.fcmPgmId = fscmPgm.get('value');
			}
			
			if (product_type) {
				query.product_type = product_type;
				queryStore.product_type = product_type;
			}
			if(subProduct) {
				query.subproductcode = subProduct;
				queryStore.subproductcode = subProduct;
			}
			
			console.debug(messageGridContent, contentURL.join(""), queryStore);

			if (!isQueryReadStore) {
				// Load data
				onLoadCallback = function() {
					var grid = dj.byId(type + "data_grid");
					if(grid)
					{
						grid.showMessage(grid.loadingMessage);
						
						m.grid.setStoreURL(grid, m.getServletURL(contentURL.join("")), queryStore);
						
						m.connect("CurrencyName", "onKeyPress", function(evnt){
							if(evnt.keyCode === dojo.keys.ENTER){
								m.grid.filter(dj.byId('currencydata_grid'), ['NAME'], ['CurrencyName']);
						  }
						});
						m.connect("ISOCode", "onKeyPress", function(evnt){
							if(evnt.keyCode === dojo.keys.ENTER){
								m.grid.filter(dj.byId('currencydata_grid'), ['ISOCODE'], ['ISOCode']);
						  }
						});
						m.connect("abbv_name", "onKeyPress", function(evnt){
							if(evnt.keyCode === dojo.keys.ENTER){
								m.grid.filter(dj.byId('beneficiarydata_grid'), ['ABBVNAME'], ['abbv_name']);
						  }
						});
						m.connect("name", "onKeyPress", function(evnt){
							if(evnt.keyCode === dojo.keys.ENTER){
								m.grid.filter(dj.byId('beneficiarydata_grid'), ['NAME'], ['name']);
						  }
						});
						m.connect("abbv_name", "onKeyPress", function(evnt){
							if(evnt.keyCode == dojo.keys.ENTER){
								m.grid.filter(dj.byId('bankdata_grid'), ['ABBVNAME'], ['abbv_name']);
						  }
						});
						
						m.connect("name", "onKeyPress", function(evnt){
							if(evnt.keyCode == dojo.keys.ENTER){
								m.grid.filter(dj.byId('bankdata_grid'), ['NAME'], ['name']);
						  }
						});
						
						m.connect("abbv_name", "onKeyPress", function(evnt){
							if(evnt.keyCode == dojo.keys.ENTER){
								m.grid.filter(dj.byId('phrasedata_grid'), ['ABBVNAME'], ['abbv_name']);
						  }
						});
						
						m.connect("descriptionField", "onKeyPress", function(evnt){
							if(evnt.keyCode == dojo.keys.ENTER){
								m.grid.filter(dj.byId('phrasedata_grid'), ['DESCRIPTION'], ['descriptionField']);
						  }
						});
						m.connect("description", "onKeyPress", function(evnt){
							if(evnt.keyCode === dojo.keys.ENTER){
								m.grid.filter(dj.byId('accountdata_grid'), ['DESCRIPTION'], ['description']);
						  }
						});
						m.connect("account_no", "onKeyPress", function(evnt){
							if(evnt.keyCode === dojo.keys.ENTER){
								m.grid.filter(dj.byId('accountdata_grid'), ['ACCOUNTNO'], ['account_no']);
						  }
						});
					}
				};
			}

			m.dialog.show("URL", "", title, null, onLoadCallback, m.getServletURL(url.join("")), null, null, query);
		},
		/**
		 * <h4>Summary:</h4>
		 * Shows program Counterparty dialog
		 * @param String
		 * @param String []
		 * @param String
		 * @param String
		 * @param String		
		 * @param Boolean
		 * @method showProgramCptyDialog
		 * 
		 */
		showProgramCptyDialog : function(/*String*/ type,
						/* String[] */fields,
						/* String */program_id,
						/* String */screen,
						/* String */dimensions,
						/* String */title,
						/* Boolean */isInPopup) {
							
							var benAbbvNameList = "";
							if(dj.byId('gridPC') && dj.byId('gridPC').store && dj.byId('gridPC').store._arrayOfAllItems &&  dj.byId('gridPC').store._arrayOfAllItems.length)
							{
								var currentItems = dj.byId('gridPC').store._arrayOfAllItems;
								for(var i=0; i < currentItems.length; i++)
									{
										if(currentItems[i] && currentItems[i]["ABBVNAME"])
										{
											benAbbvNameList = benAbbvNameList + currentItems[i]["ABBVNAME"] + ",";
										}
									}
							}					
			
							var url = [], query = {}, contentURL = ajaxActionUrl, queryStore = {}, urlAction = "GetStaticData", urlScreen = screen|| ajaxStaticDPopup, onLoadCallback, childDialog;

							// Check that the dimensions have a trailing
							// semi-colon
							// as it will be appended to other rules later
							if (dimensions.slice(dimensions.length - 1) !== ";") {
								dimensions += ";";
							}
							contentURL += urlAction;
							queryStore.option = type;
							queryStore.fields = fields;
							queryStore.benAbbvNameList = benAbbvNameList;

							url.push("/screen/", urlScreen);
							query.option = type;
							query.fields = fields;
							
							if(program_id){
								query.program_id = program_id;			
								queryStore.program_id = program_id;
							}
							query.dimensions = dimensions;
							query.popupType = "LIST_DATA";

							console.debug(messageGridContent,contentURL);
							// Load data
							onLoadCallback = function() {
								var grid = dj.byId(type + "data_grid");
								grid.showMessage(grid.loadingMessage);
								m.grid.setStoreURL(grid, m.getServletURL(contentURL), queryStore);

								m.connect("prgm_cpty_popup","onKeyPress",function(evnt) {
													if (evnt.keyCode === dojo.keys.ENTER) {
														m.grid.filter(dj.byId('programCounterpartydata_grid'),[ 'ABBVNAME' ],[ 'prgm_cpty_popup' ]);
													}
												});
							};

							if (isInPopup) {
								console.debug(chilDialog,url.join(""), query);
								childDialog = dj.byId("childXhrDialog") || new dj.Dialog({title : title,
													id : "childXhrDialog",
													href : m.getServletURL(url.join("")),
													ioMethod : misys.xhrPost,
													ioArgs : { content : query
													}
												});

								m.dialog.connect(childDialog, "onLoad",
										onLoadCallback);
								m.dialog.connect(childDialog,"onHide",function() {
													setTimeout(function() {
																m.dialog.disconnect(childDialog);
																childDialog.destroyRecursive();
															}, 2000);
												});

								// Offset the dialog from the parent window
								var co = d.coords("xhrDialog");
								childDialog._relativePosition = {
									x : co.x + 30,
									y : co.y + 30
								};

								childDialog.show();
							} else {
								m.dialog.show("URL", "", title, null,onLoadCallback, m.getServletURL(url.join("")), null, null, query);
							}
						},
		/**
		 * <h4>Summary:</h4>
		 * Shows bank branch code dialog
		 * @param String[]
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param Boolean
		 * @method showBankBranchCodeDialog
		 * 
		 */
	  showBankBranchCodeDialog : function( /*String*/ type,
				 	 	  /*String[]*/ fields, 
				 	 	  /*String*/ parameter, 
				 	 	  /*String*/ branchIndicators, 
				 	 	  /*String*/ internal, 
				 	 	  /*String*/ screen,				 
				 	 	  /*String*/ dimensions, 
				 	 	  /*String*/ title, 
				 	 	  /*Boolean*/ isInPopup){
		var url = [],
		query = {},
		contentURL = ajaxActionUrl,
		queryStore = {},
		urlAction = "GetStaticData",
		urlScreen = screen || ajaxStaticDPopup,
		onLoadCallback,
		childDialog,
		co;
		
		// Check that the dimensions have a trailing semi-colon
		// as it will be appended to other rules later
		if(dimensions.slice(dimensions.length - 1) !== ";") {
			dimensions += ";";
		}
				
		contentURL += urlAction;
		queryStore.option = type;
		queryStore.fields = fields;
		queryStore.parameter = parameter;
		queryStore.branchindicators = branchIndicators;
		queryStore.internal = internal;
		
		url.push("/screen/", urlScreen);
		query.option = type;
		query.fields = fields;
		query.parameter = parameter;
		query.branchindicators = branchIndicators;
		query.internal = internal;
		query.dimensions = dimensions;
		query.popupType = "LIST_DATA";
		
		console.debug(messageGridContent, contentURL);
		
		// Load data
		onLoadCallback = function() {
			var grid = dj.byId(type + "data_grid");
			grid.showMessage(grid.loadingMessage);
			m.grid.setStoreURL(grid, m.getServletURL(contentURL), queryStore);
		};
		
		if(isInPopup) {
			console.debug(chilDialog, url.join(""), query);
			childDialog = dj.byId("childXhrDialog") || new dj.Dialog({
				title: title,
				id: "childXhrDialog",
				href: m.getServletURL(url.join("")),
				ioMethod: misys.xhrPost,
				ioArgs: { content: query }
			});
			
			m.dialog.connect(childDialog, "onLoad", onLoadCallback);
			m.dialog.connect(childDialog, "onHide", function(){setTimeout(function(){
				m.dialog.disconnect(childDialog);
				childDialog.destroyRecursive();
			}, 2000);});
			
			// Offset the dialog from the parent window
			// even if is in pop up, check for the parent dialog exists 
			// and then assign the coordinates for the child dialog
			co = d.coords("xhrDialog");
			childDialog._relativePosition = {
				x: co.x + 30,
				y: co.y + 30
			};
			childDialog.show();
		} else {
			m.dialog.show("URL", "", title, null, onLoadCallback, m.getServletURL(url.join("")), null, null, query);
		}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for showing user account dialog
		 * @param String
		 * @param String[]
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String 
		 * @param boolean
		 * @param String
		 * @param String[]
		 * @param String
		 * @param String
		 *@method  showSearchUserAccountsDialog     
		 */
		showSearchUserAccountsDialog : function( /*String*/ type,
												 /*String[]*/ fields, 
												 /*String*/ excludedValueField,
												 /*String*/ entityField,
												 /*String*/ drCr,
												 /*String*/ productTypes,
												 /*String*/ dimensions, 
												 /*String*/ title,
												 /*String*/ parameter,
												 /*String*/ companyId,
							 					 /*String */ action, 
							 					 /*boolean*/ isQueryReadStore, 
							 					 /*String*/ userAction,
							 					 /*String[]*/ ccy_code_fields,
							 					 /*String*/ accountType,
							 					 /*String*/ excludedaccttype,
							 					 /*String*/ isSearchScreen){
				//  summary:
				//        Open a popup window to perform the search in the available list of user accounts

				var url = [],
				query = {},
				contentURL = ajaxActionUrl,
				queryStore = {},
				urlAction = "GetStaticData",
				urlScreen = ajaxStaticDPopup,
				onLoadCallback,
				entity,
				bank_abbv_name,
				excludedValue;
	
				if (dj.byId(entityField))
				{
					entity = dj.byId(entityField).get('value'); 
					if (entity === "")
					{
					if( dj.byId("applicant_abbv_name"))
						{
						var recipient = dj.byId("applicant_abbv_name").get('value');
							if (recipient === "")
						{
							console.debug("[misys.form.common] cannot select an account if entity is mandatory");
							m.showTooltip(m.getLocalization("entitynotselected"), document.activeElement, ["after"]);
							return;
						}	
						}
						else if(isSearchScreen && isSearchScreen === true)
						{
							// MPSSC-10358 - Check is this the request is from ListDef search screen. 
							console.debug("[misys.form.common] It's a listdef request.");
						}
						else
						{
							console.debug("[misys.form.common] cannot select an account if entity is mandatory");
							m.showTooltip(m.getLocalization("entitynotselected"), document.activeElement, ["after"]);
							return;
						}
				}
				}
				else if(misys._config.isEntityRequired)
				{
					console.debug("[misys.form.common] cannot select an account as user does not have any entity level permission");
					m.showTooltip(m.getLocalization("entitynotselected"), document.activeElement, ["after"]);
					return;
				}
				
				if (dj.byId(excludedValueField))
				{
				    excludedValue = dj.byId(excludedValueField).get('value'); 
				    if (excludedValue === "")
				     {
				         console.debug("[misys.form.common] cannot select an account if excluded value is mandatory");
				         return;
				     }
				}
				var ccyValues = [];
				if (ccy_code_fields)
				{
					var ccyArray = ccy_code_fields.split(",");
					for(var i in ccyArray)
					{
						if (dj.byId(ccyArray[i]))
						{
							ccyValues.push(dj.byId(ccyArray[i]).get('value'));
						}
					}
				}
										
				if(dj.byId("customer_bank") && dj.byId("customer_bank").get("value") !== "")
				{
					bank_abbv_name = dj.byId("customer_bank").get("value");
				}	
				else if(dj.byId("bank_abbv_name") && dj.byId("bank_abbv_name").get("value") !== "")
                {       
                    bank_abbv_name = dj.byId("bank_abbv_name").get("value");
                }
				else if(dj.byId("issuing_bank") && dj.byId("issuing_bank").get("value") !== "")
				{
					bank_abbv_name = dj.byId("issuing_bank").get("value");
				}


				// Check that the dimensions have a trailing semi-colon
				// as it will be appended to other rules later
				if(dimensions.slice(dimensions.length - 1) !== ";") {
					dimensions += ";";
				}
				
				contentURL += urlAction;
				queryStore.option = type;
				queryStore.user_action = userAction;
				queryStore.fields = fields;
				queryStore.entity = entity;
				queryStore.bank_abbv_name = bank_abbv_name;
				queryStore[excValue] = excludedValue;
				queryStore['dr-cr'] = drCr;
				queryStore['product-types'] = productTypes;
				queryStore.parameter = parameter;
				queryStore.companyId = companyId;
				queryStore.accountType = accountType;
				queryStore.isSearchScreen = isSearchScreen;
				
				if(dj.byId("issuing_bank_customer_reference") && dj.byId("issuing_bank_customer_reference").get("value") !== "" && productTypes.length > 0 && (("FT:TRTPT" === productTypes)||("FT:TRINT" === productTypes)))
				{	
//					issuing_bank_customer_reference value has to be passed , so we fetch accounts which belong to the particular reference only.
					queryStore['issuing_bank_customer_reference']=dj.byId("issuing_bank_customer_reference").get("value");
				}
				
				if(productTypes.length > 0 && "FX" === productTypes && parameter.indexOf("ownerType:") > -1) {
					queryStore.ownerType = parameter.substring(10);
				}
				
				if(ccyValues.length > 0){
					queryStore.ccy_codes = ccyValues.join(",");
				}
				
				url.push("/screen/", urlScreen);
				query.option = type;
				query.dimensions = dimensions;
				query.bank_abbv_name = bank_abbv_name; 
				query.entity = entity;
				query.popupType = "LIST_DATA";
				query.pageType = parameter;
				
				if (companyId) {
					query.companyid = companyId;
				}
				
				console.debug(messageGridContent, contentURL);
				
				if (!isQueryReadStore) {
					// Load data
					onLoadCallback = function() {
						var grid = dj.byId(type + "data_grid");
						grid.showMessage(grid.loadingMessage);
						m.grid.setStoreURL(grid, m.getServletURL(contentURL), queryStore);
					};
				}
				
				m.dialog.show("URL", "", title, null, onLoadCallback, m.getServletURL(url.join("")), null, null, query);
				 m.connect("accountNo", "onKeyPress", function(evnt){
		                                        if(evnt.keyCode === dojo.keys.ENTER){
		                                                m.grid.filter(dj.byId('useraccountdata_grid'), ['ACCOUNTNOTEMP'], ['accountNo']);
		                                  }
		                                });
		                                m.connect("curCode", "onKeyPress", function(evnt){
		                                        if(evnt.keyCode === dojo.keys.ENTER){
		                                                m.grid.filter(dj.byId('useraccountdata_grid'), ['CURCODE'], ['curCode']);
		                                  }
	                                });
		                                m.connect("descriptionDialog", "onKeyPress", function(evnt){
		                                        if(evnt.keyCode === dojo.keys.ENTER){
		                                                m.grid.filter(dj.byId('useraccountdata_grid'), ['DESCRIPTION'], ['descriptionDialog']);
		                                  }
		                                });
				if (bank_abbv_name !== "") {
		        	 m.connect("bankName", "onKeyPress", function(evnt){
                         if(evnt.keyCode === dojo.keys.ENTER){
                                 m.grid.filter(dj.byId('useraccountdata_grid'), ['BANKNAME'], ['bankName']);
	                   }
	                 });
		         }		                                
			},
			
			/**
			 * <h4>Summary:</h4>
			 * This function is for showing fscm program dialog
			 * 
			 * @param String
			 * @param String[]
			 * @param String
			 * @param String
			 * @param Object
			 * @param boolean
			 * @param String
			 * @method showSearchFSCMProgramDialog
			 */
			showSearchFSCMProgramDialog : function(
					/* String */type,
					/* String[] */fields,
					/* String */dimensions,
					/* String */title,
					/* Object */parameter,
					/* boolean */isQueryReadStore,
					/* String */userAction) {
				var url = [], query = {}, contentURL = ajaxActionUrl, queryStore = {}, urlAction = "GetStaticData", urlScreen = ajaxStaticDPopup, onLoadCallback, entity, excludedValue;

				// Check that the dimensions have a trailing
				// semi-colon
				// as it will be appended to other rules later
				if (dimensions.slice(dimensions.length - 1) !== ";") {
					dimensions += ";";
				}

				contentURL += urlAction;
				queryStore.option = type;
				queryStore.user_action = userAction;
				queryStore.fields = fields;
				queryStore.entity = entity;
				queryStore[excValue] = excludedValue;
				d.mixin(queryStore, parameter);

				url.push("/screen/", urlScreen);
				query.option = type;
				query.dimensions = dimensions;
				d.mixin(query, parameter);
				query.popupType = "LIST_DATA";

				console.debug(messageGridContent,contentURL);

				if (!isQueryReadStore) 
				{
					// Load data
					onLoadCallback = function() 
					{
						var grid = dj.byId(type + "data_grid");
						grid.showMessage(grid.loadingMessage);
						m.grid.setStoreURL(grid, m.getServletURL(contentURL),queryStore);
					};
				}

				m.dialog.show("URL", "", title, null, onLoadCallback, m.getServletURL(url.join("")), null, null, query);

				m.connect("programCode", "onKeyPress", function(evnt) {
					if (evnt.keyCode === dojo.keys.ENTER) {
						m.grid.filter(dj.byId('fscmprogramdata_grid'),[ 'PROGRAM_CODE' ],[ 'programCode' ]);
					}
				});

				m.connect("programName", "onKeyPress", function(
						evnt) {
					if (evnt.keyCode === dojo.keys.ENTER) {
						m.grid.filter(dj.byId('fscmprogramdata_grid'),[ 'PROGRAM_NAME' ],[ 'programName' ]);
					}
				});
				
				m.connect("programId", "onKeyPress", function(evnt) {
					if (evnt.keyCode === dojo.keys.ENTER) {
						m.grid.filter(dj.byId('fscmprogramdata_grid'),[ 'PROGRAM_ID' ],[ 'programId' ]);
					}
				});

			},
			
			
			/**
			 * <h4>Summary:</h4>
			 * This function is for showing fscm program for finance request, in a dialog.
			 * 
			 * @param String
			 * @param String[]
			 * @param String
			 * @param String
			 * @param String
			 * @param String
			 * @param boolean
			 * @method showFSCMProgramFinanceRequestDialog
			 */
			showFSCMProgramFinanceRequestDialog : function( /*String*/ type,
									 	 	  /*String[]*/ fields, 
									 	 	  /*String*/ parameter, 
									 	 	  /*String*/ screen,
									 	 	  /*String*/ dimensions, 
									 	 	  /*String*/ title, 
									 	 	  /*Boolean*/ isInPopup){
								
				var url = [],
					query = {},
					contentURL = ajaxActionUrl,
					queryStore = {},
					urlAction = "GetStaticData", 
					urlScreen = screen || ajaxStaticDPopup, 
					onLoadCallback, childDialog;

				// Check that the dimensions have a trailing
				// semi-colon
				// as it will be appended to other rules later
				if (dimensions.slice(dimensions.length - 1) !== ";") {
					dimensions += ";";
				}

				contentURL += urlAction;
				queryStore.option = type;
				queryStore.fields = fields;
				d.mixin(queryStore, parameter);

				url.push("/screen/", urlScreen);
				
				query.option = type;
				query.fields = fields;
				d.mixin(query, parameter);
				query.dimensions = dimensions;
				query.popupType = "LIST_DATA";

				console.debug(messageGridContent, contentURL);

				// Load data
				onLoadCallback = function() {
					var grid = dj.byId(type + "data_grid");
					grid.showMessage(grid.loadingMessage);
					m.grid.setStoreURL(grid, m.getServletURL(contentURL), queryStore);
					m.connect("CurrencyName", "onKeyPress", function(evnt){
						if(evnt.keyCode === dojo.keys.ENTER){
							m.grid.filter(dj.byId('currencydata_grid'), ['NAME'], ['CurrencyName']);
					  }
					});
					
				};

				if (isInPopup) 
				{
					console.debug(chilDialog, url.join(""));
					childDialog = dj.byId("childXhrDialog") || new dj.Dialog({
																		title : title,
																		id : "childXhrDialog",
																		href : m.getServletURL(url.join("")),
																		ioMethod: misys.xhrPost,
																		ioArgs: { content: query }
																	});

					m.dialog.connect(childDialog, "onLoad", onLoadCallback);
					m.dialog.connect( childDialog, "onHide", 
							function() {
											setTimeout(function() {
												m.dialog.disconnect(childDialog);
												childDialog.destroyRecursive();
											}, 2000);
										}
					);

					// Offset the dialog from the parent window
					var co = d.coords("xhrDialog");
					childDialog._relativePosition = {
						x : co.x + 30,
						y : co.y + 30
					};

					childDialog.show();
				} 
				else 
				{
					m.dialog.show("URL", "", title, null, onLoadCallback, m.getServletURL(url.join("")), null, null, query);
				}
			},			
		/**
		 * <h4>Summary:</h4>
		 * This fuction is for showing Country code dialog
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param Boolean
		 * @method showCountryCodeDialog
		 * 
		 */
		showCountryCodeDialog : function( /*String*/ type,
								 	 	  /*String[]*/ fields, 
								 	 	  /*String*/ parameter, 
								 	 	  /*String*/ screen,
								 	 	  /*String*/ product, 
								 	 	  /*String*/ subProduct, 
								 	 	  /*String*/ dimensions, 
								 	 	  /*String*/ title, 
								 	 	  /*Boolean*/ isInPopup){
			var url = [],
				query = {},
				contentURL = ajaxActionUrl,
				queryStore = {},
				urlAction = "GetStaticData",
				urlScreen = screen || ajaxStaticDPopup,
				onLoadCallback,
				childDialog;
		
			// Check that the dimensions have a trailing semi-colon
			// as it will be appended to other rules later
			if(dimensions.slice(dimensions.length - 1) !== ";") {
				dimensions += ";";
			}

			contentURL += urlAction;
			queryStore.option = type;
			queryStore.fields = fields;
			queryStore.parameter = parameter;
			
			url.push("/screen/", urlScreen);
			query.option = type;
			query.fields = fields;
			query.parameter = parameter;
			query.dimensions = dimensions;
			query.popupType = "LIST_DATA";
			
			if(product) {
				query.productcode = product;
				queryStore.productcode = product;
			}
			
			if(subProduct) {
				query.subproductcode = subProduct;
				queryStore.subproductcode = subProduct;
			}
	
			console.debug(messageGridContent, contentURL);

			// Load data
			onLoadCallback = function() {
					var grid = dj.byId(type + "data_grid");
					grid.showMessage(grid.loadingMessage);
					m.grid.setStoreURL(grid, m.getServletURL(contentURL), queryStore);
					
					m.connect("country_name_popup", "onKeyPress", function(evnt){
						if(evnt.keyCode === dojo.keys.ENTER){
							m.grid.filter(dj.byId('codevaluedata_grid'), ['DESCRIPTION'], ['country_name_popup']);
					  }
					});
//					
			};
			
			if(isInPopup) {
				console.debug(chilDialog, url.join(""), query);
				childDialog = dj.byId("childXhrDialog") || new dj.Dialog({
					title: title,
					id: "childXhrDialog",
					href: m.getServletURL(url.join("")),
					ioMethod: misys.xhrPost,
					ioArgs: { content: query }
				});

				m.dialog.connect(childDialog, "onLoad", onLoadCallback);
				m.dialog.connect(childDialog, "onHide", function(){setTimeout(function(){
					m.dialog.disconnect(childDialog);
					childDialog.destroyRecursive();
				}, 200);});
				
				// Offset the dialog from the parent window
				var co = d.coords("xhrDialog");
				childDialog._relativePosition = {
						x: co.x + 30,
						y: co.y + 30
				};
				
				childDialog.show();
			} else {
				m.dialog.show("URL", "", title, null, onLoadCallback, m.getServletURL(url.join("")), null, null, query);
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for showing currency code dialog
		 * @param String
		 * @param String[]
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param Boolean
		 * @method showCurrencyCodeDialog
		 * 
		 */
		showCurrencyCodeDialog : function( /*String*/ type,
								 	 	  /*String[]*/ fields, 
								 	 	  /*String*/ parameter, 
								 	 	  /*String*/ screen,
								 	 	  /*String*/ product, 
								 	 	  /*String*/ subProduct, 
								 	 	  /*String*/ dimensions, 
								 	 	  /*String*/ title, 
								 	 	  /*Boolean*/ isInPopup){
							
			var url = [],
				query = {},
				contentURL = ajaxActionUrl,
				queryStore = {},
				urlAction = "GetStaticData", 
				urlScreen = screen || ajaxStaticDPopup, 
				onLoadCallback, childDialog;

			// Check that the dimensions have a trailing
			// semi-colon
			// as it will be appended to other rules later
			if (dimensions.slice(dimensions.length - 1) !== ";") {
				dimensions += ";";
			}

			contentURL += urlAction;
			queryStore.option = type;
			queryStore.fields = fields;
			queryStore.parameter = parameter;

			url.push("/screen/", urlScreen);
			
			query.option = type;
			query.fields = fields;
			query.parameter = parameter;
			query.dimensions = dimensions;
			query.popupType = "LIST_DATA";

			if (product) {
				query.productcode = product;
				contentURL.push(varProdCode, product);
			}

			if (subProduct) {
				query.subproductcode = subProduct;
				contentURL.push("&subproductcode=", subProduct);
			}

			console.debug(messageGridContent, contentURL);

			// Load data
			onLoadCallback = function() {
				var grid = dj.byId(type + "data_grid");
				grid.showMessage(grid.loadingMessage);
				m.grid.setStoreURL(grid, m.getServletURL(contentURL), queryStore);
				m.connect("CurrencyName", "onKeyPress", function(evnt){
					if(evnt.keyCode === dojo.keys.ENTER){
						m.grid.filter(dj.byId('currencydata_grid'), ['NAME'], ['CurrencyName']);
				  }
				});
				
			};

			if (isInPopup) 
			{
				console.debug(chilDialog, url.join(""));
				childDialog = dj.byId("childXhrDialog") || new dj.Dialog({
																	title : title,
																	id : "childXhrDialog",
																	href : m.getServletURL(url.join("")),
																	ioMethod: misys.xhrPost,
																	ioArgs: { content: query }
																});

				m.dialog.connect(childDialog, "onLoad", onLoadCallback);
				m.dialog.connect( childDialog, "onHide", 
						function() {
										setTimeout(function() {
											m.dialog.disconnect(childDialog);
											childDialog.destroyRecursive();
										}, 200);
									}
				);

				// Offset the dialog from the parent window
				var co = d.coords("xhrDialog");
				childDialog._relativePosition = {
					x : co.x + 30,
					y : co.y + 30
				};

				childDialog.show();
			} 
			else 
			{
				m.dialog.show("URL", "", title, null, onLoadCallback, m.getServletURL(url.join("")), null, null, query);
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function to check whether the data grid in the
		 * amendment pop up is empty.
		 */
		isGridEmpty : function(){
			var emptyFlag = true;
			if(dijit.byId("amendments").store){
				for(var i = 0; i < dijit.byId("amendments").store._arrayOfAllItems.length; i++){
					if(dijit.byId("amendments").store._arrayOfAllItems[i] != null){
						emptyFlag = false;
					}
				}
			}
			return emptyFlag;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for toggling the radio buttons
		 * in the amendment pop up.
		 * ADD/DELETE selected and grid NOT empty: REPALL is enabled.
		 * ADD/DELETE selected and grid is empty: REPALL is enabled.
		 * Multiple ADD/DELETE allowed.
		 * REPALL can be done only once.
		 */
		toggleADR : function(){
			if(dj.byId("adr_1").get("value") || dj.byId("adr_2").get("value")){
				var adr3 = dj.byId("adr_3");
				if(!m.isGridEmpty()){
					adr3.set("disabled", true);
				}
				dj.byId("narrative_description_goods_popup").set("value","");
				if(dj.byId("adr_1").get("value")){
					dj.byId("narrative_description_goods_popup").set("value","/ADD/");
				}
				else if(dj.byId("adr_2").get("value")){
					dj.byId("narrative_description_goods_popup").set("value","/DELETE/");
				}
			}
			if(dj.byId("adr_3").get("value")){
				dj.byId("narrative_description_goods_popup").set("value","");
				if(!m.isGridEmpty() && dijit.byId("amendments").store._arrayOfAllItems[0].verb[0] != "REPALL"){
					dj.byId("adr_3").set("disabled", true);
					dj.byId("narrative_description_goods_popup").set("disabled",true);
					dj.byId("adr_3").set("value",false);
				}
				dj.byId("narrative_description_goods_popup").set("value","/REPALL/");
			}
			if(dj.byId("adr_1").get("value") === "ADD" || dj.byId("adr_2").get("value") === "DELETE" || dj.byId("adr_3").get("value") === "REPALL"){
				dj.byId("narrative_description_goods_popup").set("disabled",false);
			}
			if(!m.isGridEmpty() && dijit.byId("amendments").store._arrayOfAllItems[0].verb[0] == "REPALL"){
				dj.byId("adr_1").set("disabled", true);
				dj.byId("adr_2").set("disabled", true);
				dj.byId("adr_3").set("disabled", false);
				dj.byId("adr_3").set("value", "REPALL");
				dj.byId("narrative_description_goods_popup").set("disabled",true);
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for handles the action on click of
		 * OK button in amendment pop up.
		 * Places the current grid data, above the tab group container 
		 * on the base page.
		 */
		consolidateGridData : function(){
			var table;
			var verb, text;
			if(m.isGridEmpty()){
				m.dialog.show("CONFIRMATION", m.getLocalization("saveEmptyDataConfirmation"), "", onLoadCallback);
				table = "<table><tr><span style='height: 1px;'></span></tr>" ;
			}
			else if(!m.isGridEmpty() && dijit.byId("amendments").store._arrayOfAllItems) {
				table = "<table><tr><b><span style='color: blue;' class='indented-header;'>Current Amendment</span></b></tr>" ;
				for(var u = 0; u < dijit.byId("amendments").store._arrayOfAllItems.length; u++){
					if(dijit.byId("amendments").store._arrayOfAllItems[u] != null){
						table += "<tr><td style='white-space: pre-wrap;'>";
						var verbId = dijit.byId("amendments").store._arrayOfAllItems[u].verb[0];
						var displayedVerb = '';
						if(verbId === "ADD") {
							displayedVerb = misys.getLocalization("add");
						}else if(verbId === "DELETE") {
							displayedVerb = misys.getLocalization("delete");
						}else if(verbId === "REPALL") {
							displayedVerb = misys.getLocalization("repall");
						}
						verb = "<b>/"+displayedVerb+"/</b>";
						text = dijit.byId("amendments").store._arrayOfAllItems[u].content[0];
						table += verb+" "+text;
						table += "</td></tr>";
					}
				}
				
			}
			table += "</table>";
			var onLoadCallback = function(){
				var gridStoreData;
				if(dijit.byId("amendments").store && !m.isGridEmpty()){
					gridStoreData = dijit.byId("amendments").store._arrayOfAllItems;
					if(m._config.narrativeId === "narrative_amend_goods"){
						m._config.narrativeDescGoodsDataStore = gridStoreData;
						document.getElementById("narrativeDescriptionGoods").innerHTML=table;
					}
					if(m._config.narrativeId === "narrative_amend_docs"){
						m._config.narrativeDocsReqDataStore = gridStoreData;
						document.getElementById("narrativeDocumentsRequired").innerHTML=table;
					}
					if(m._config.narrativeId === "narrative_amend_instructions"){
						m._config.narrativeAddInstrDataStore = gridStoreData;
						document.getElementById("narrativeAdditionalInstructions").innerHTML=table;
					}
					if(m._config.narrativeId === "narrative_amend_sp_beneficiary"){
						m._config.narrativeSpBeneDataStore = gridStoreData;
						document.getElementById("narrativeSpecialBeneficiary").innerHTML=table;
					}
					if(m._config.narrativeId === "narrative_amend_sp_recvbank"){
						m._config.narrativeSpRecvbankDataStore = gridStoreData;
						document.getElementById("narrativeSpecialReceivingBank").innerHTML=table;
					}
				}
				else if(m.isGridEmpty()){
					if(m._config.narrativeId === "narrative_amend_goods"){
						m._config.narrativeDescGoodsDataStore.length = 0;
						document.getElementById("narrativeDescriptionGoods").innerHTML=table;
					}
					if(m._config.narrativeId === "narrative_amend_docs"){
						m._config.narrativeDocsReqDataStore.length = 0;
						document.getElementById("narrativeDocumentsRequired").innerHTML=table;
					}
					if(m._config.narrativeId === "narrative_amend_instructions"){
						m._config.narrativeAddInstrDataStore.length = 0;
						document.getElementById("narrativeAdditionalInstructions").innerHTML=table;
					}
					if(m._config.narrativeId === "narrative_amend_sp_beneficiary"){
						m._config.narrativeSpBeneDataStore.length = 0;
						document.getElementById("narrativeSpecialBeneficiary").innerHTML=table;
					}
					if(m._config.narrativeId === "narrative_amend_sp_recvbank"){
						m._config.narrativeSpRecvbankDataStore.length = 0;
						document.getElementById("narrativeSpecialReceivingBank").innerHTML=table;
					}
				}
           	 	if(dj.byId("narrative_description_goods_popup").state === "" && !dj.byId("narrative_description_goods_popup").disabled){
					m.toggleNarrativeDivStatus(true);
           	 	}
				m.dialog.hide();
				m.initDivMouseOver();
			};
			if(!m.isGridEmpty()){
				if(m.hasTextBoxLogicalValue()){
					m.dialog.show("CONFIRMATION", m.getLocalization("unsavedDataExistInTextBox"), "", onLoadCallback);
				}
				else{
					m.dialog.show("CONFIRMATION", m.getLocalization("saveDataConfirmation"), "", onLoadCallback);
				}
			}
			else{
				m.dialog.show("CONFIRMATION", m.getLocalization("saveEmptyDataConfirmation"), "", onLoadCallback);
			}
			console.log(dj.byId("narrative_description_goods_popup").get("value"));
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for handling the ocClick of
		 * 'Cancel' in the amendment popup.
		 * 
		 */
		closeAmendmentPopup : function(){
			var onLoadCallback = function(){
				m._config.narrativeId = '';
				var dataStoreNarrative = [m._config.narrativeDescGoodsDataStore,m._config.narrativeDocsReqDataStore,m._config.narrativeAddInstrDataStore,m._config.narrativeSpBeneDataStore,m._config.narrativeSpRecvbankDataStore];
				var i = 0, msgRows = 0, fieldSize = 0;
				for(var itr = 0; itr < 5; itr++){
					if(dataStoreNarrative[itr]){
						d.forEach(dataStoreNarrative[itr], function(){
							if(dataStoreNarrative[itr][i] && dataStoreNarrative[itr][i] !== null){
								dataStoreNarrative[itr][i].content[0].replace(/&#xa;/g,'\n');
								fieldSize += dataStoreNarrative[itr][i].content[0].length;
								msgRows += dataStoreNarrative[itr][i].text_size[0];
							}
							i++;
						});
					}
				}
				if(msgRows <= (misys._config.is798 == 'Y' ? 792 : 800)){
					m.toggleNarrativeDivStatus(true);
				}
				else{
					m.initDivMouseOver();
				}
				m.dialog.hide();
			};
			if(!m.hasTextBoxLogicalValue()){
				m.dialog.show("CONFIRMATION", m.getLocalization("cancelTransactionConfirmation"), "", onLoadCallback);
			}
			else{
				if(dj.byId("narrative_description_goods_popup").get("value") != "/ADD/" &&
						dj.byId("narrative_description_goods_popup").get("value") != "/DELETE/" &&
						dj.byId("narrative_description_goods_popup").get("value") != "/REPALL/"){
					m.dialog.show("CONFIRMATION", m.getLocalization("unsavedDataExistInTextBox"), "", onLoadCallback);
				}
			}
		},

		/**
		 * To view extended views of base page narratives on amendment base page
		 * */
		viewNarrativeInPopUp : function( /*String*/ type,
				 /*String*/ fields, 
				 /*String*/ parameter,
				 /*String*/ product, 
				 /*String*/ dimensions,
				 /*String*/ title,
				 /*String*/ amdno){
			var url = [],
			query = {},
			contentURL = [ ajaxActionUrl ],
			urlAction = "GetStaticData",
			urlScreen = ajaxStaticDPopup,
			onLoadCallback;
			
			if(dimensions.slice(dimensions.length - 1) !== ";") {
				dimensions += ";";
			}
			
			var rundataXML;
			m._config.amendmentNumber = amdno;
			m._config.narrativeId = parameter;
			if(parameter === "narrative_amend_goods"){
				if(dj.byId("org_narrative_description_goods") && dj.byId("org_narrative_description_goods").get("value") != ''){
					rundataXML = dj.byId("org_narrative_description_goods").get("value");
				} else {
					rundataXML = dj.byId("original_narrative_description_goods") ? dj.byId("original_narrative_description_goods").get("value") : "";
				}
				if(dj.byId("tnx_type_code") && dj.byId("tnx_type_code").get("value")=="03" && misys._config.narrativeDescGoodsDataStore && misys._config.narrativeDescGoodsDataStore.length != 0){
					rundataXML = rundataXML.concat(m.customXMLForCurrentAmend(misys._config.narrativeDescGoodsDataStore));
				}
			}
			else if(parameter === "narrative_amend_docs"){
				if(dj.byId("org_narrative_documents_required") && dj.byId("org_narrative_documents_required").get("value") != ''){
					rundataXML = dj.byId("org_narrative_documents_required").get("value");
				} else {
					rundataXML = dj.byId("original_narrative_documents_required") ? dj.byId("original_narrative_documents_required").get("value") : "";
				}
				if(dj.byId("tnx_type_code") && dj.byId("tnx_type_code").get("value")=="03" && misys._config.narrativeDocsReqDataStore && misys._config.narrativeDocsReqDataStore.length != 0){
					rundataXML = rundataXML.concat(m.customXMLForCurrentAmend(misys._config.narrativeDocsReqDataStore));
				}
			}
			else if(parameter === "narrative_amend_instructions"){
				if(dj.byId("org_narrative_additional_instructions") && dj.byId("org_narrative_additional_instructions").get("value") != ''){
					rundataXML = dj.byId("org_narrative_additional_instructions").get("value");
				} else {
					rundataXML = dj.byId("original_narrative_additional_instructions") ? dj.byId("original_narrative_additional_instructions").get("value") : "";
				}
				if(dj.byId("tnx_type_code") && dj.byId("tnx_type_code").get("value")=="03" && misys._config.narrativeAddInstrDataStore && misys._config.narrativeAddInstrDataStore.length != 0){
					rundataXML = rundataXML.concat(m.customXMLForCurrentAmend(misys._config.narrativeAddInstrDataStore));
				}
			}
			else if(parameter === "narrative_amend_sp_beneficiary"){
				if(dj.byId("org_narrative_special_beneficiary") && dj.byId("org_narrative_special_beneficiary").get("value") != ''){
					rundataXML = dj.byId("org_narrative_special_beneficiary").get("value");
				} else {
					rundataXML = dj.byId("original_narrative_special_beneficiary") ? dj.byId("original_narrative_special_beneficiary").get("value") : "";
				}
				if(dj.byId("tnx_type_code") && dj.byId("tnx_type_code").get("value")=="03" && misys._config.narrativeSpBeneDataStore && misys._config.narrativeSpBeneDataStore.length != 0){
					rundataXML = rundataXML.concat(m.customXMLForCurrentAmend(misys._config.narrativeSpBeneDataStore));
				}
			}
			else if(parameter === "narrative_amend_sp_recvbank"){
				if(dj.byId("org_narrative_special_recvbank") && dj.byId("org_narrative_special_recvbank").get("value") != ''){
					rundataXML = dj.byId("org_narrative_special_recvbank").get("value");
				} else {
					rundataXML = dj.byId("original_narrative_special_recvbank") ? dj.byId("original_narrative_special_recvbank").get("value") : "";
				}
				if(dj.byId("tnx_type_code") && dj.byId("tnx_type_code").get("value")=="03" && misys._config.narrativeSpRecvbankDataStore && misys._config.narrativeSpRecvbankDataStore.length != 0){
					rundataXML = rundataXML.concat(m.customXMLForCurrentAmend(misys._config.narrativeSpRecvbankDataStore));
				}
			}
			
			contentURL.push(urlAction);
			query.option = type;
			query.dimensions = dimensions;
			query.messageValue = fields;
			query.node = type;
			query.rundataXML = rundataXML;
			
			
			url.push("/screen/", urlScreen);	
			//d.mixin(query, parameter);
						
			m.dialog.show("URL", "", title, null, onLoadCallback, m.getServletURL(url.join("")), null, null, query);
		},
		
		/**
		 * Custom xml to show the current amendment in the extended pop up on base page.
		 */
		customXMLForCurrentAmend : function(/*String*/ dataStore){
			var i = 0;
			var customXML = "<amendments>";
			customXML = customXML.concat("<amendment>");
			customXML = customXML.concat("<sequence>");
			customXML = customXML.concat(m._config.amendmentNumber);
			customXML = customXML.concat("</sequence>");
			customXML = customXML.concat("<data>");
			for(i = 0 ;i < dataStore.length; i++){
				if(dataStore[i] != null){
					customXML = customXML.concat("<datum>");
					customXML = customXML.concat("<id>");
					customXML = customXML.concat(i);
					customXML = customXML.concat("</id>");
					customXML = customXML.concat("<verb>");
					customXML = customXML.concat(dataStore[i].verb[0]);
					customXML = customXML.concat("</verb>");
					customXML = customXML.concat("<text>");
					customXML = customXML.concat( dojox.html.entities.encode(dataStore[i].content[0], dojox.html.entities.html));
					customXML = customXML.concat("</text>");
					customXML = customXML.concat("</datum>");
				}
			}
			customXML = customXML.concat("</data>");
			customXML = customXML.concat("</amendment>");
			customXML = customXML.concat("</amendments>");
			return customXML;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for showing the error bubble
		 * on the narrative tab group div on hovering of mouse, using tooltip.
		 * 
		 */
		initDivMouseOver : function(){
		    var tabNarrativeDescriptionGoodsNode = document.getElementById("tabNarrativeDescriptionGoods");
		    var sendMode = dj.byId("adv_send_mode") ? dj.byId("adv_send_mode").get("value") : '';

		    tabNarrativeDescriptionGoodsNode.onmouseover = function(){
			   if((dj.byId("narrative_description_goods_popup") && dj.byId("narrative_description_goods_popup").state == "Error") ||
					   (document.getElementById("tabNarrativeDescriptionGoods").status == false) && (sendMode === '01') && m._config.isZCharValid && m._config.isSingleNarrativeValid[0]){
				   isSingleFieldValid ? dijit.showTooltip(m.getLocalization("invalidFieldSizeError",[limit, entered]), tabNarrativeDescriptionGoodsNode,["after"]) :
					   dijit.showTooltip(m.getLocalization("invalidSingleFieldLength", [limitSingle, enteredSingle]), tabNarrativeDescriptionGoodsNode,["after"]);
				}
			   else if(m._config.isNarrativeZCharValidArray && ! m._config.isNarrativeZCharValidArray[0] && document.getElementById("tabNarrativeDescriptionGoods").status == false){
				   dijit.showTooltip(m.getLocalization("invalidSWIFTTransactionValidValuesWithExtBank"), tabNarrativeDescriptionGoodsNode,["after"]);
			   }
			   else if(m._config.isSingleNarrativeValid && ! m._config.isSingleNarrativeValid[0] && document.getElementById("tabNarrativeDescriptionGoods").status == false){
				   dijit.showTooltip(m.getLocalization("invalidSingleFieldLength", [limitSingle, enteredSingle]), tabNarrativeDescriptionGoodsNode,["after"]);
			   }
		    };
		    tabNarrativeDescriptionGoodsNode.onmouseout = function(){
			    dijit.hideTooltip(tabNarrativeDescriptionGoodsNode);
		    };
		    
		    var tabNarrativeDocumentsRequiredNode = document.getElementById("tabNarrativeDocumentsRequired");
		    tabNarrativeDocumentsRequiredNode.onmouseover = function(){
			   if((dj.byId("narrative_description_goods_popup") && dj.byId("narrative_description_goods_popup").state == "Error") ||
					   (document.getElementById("tabNarrativeDescriptionGoods").status == false) && tabNarrativeDocumentsRequiredNode.status==false && (sendMode === '01') && m._config.isZCharValid && m._config.isSingleNarrativeValid[1]){
				   isSingleFieldValid ? dijit.showTooltip(m.getLocalization("invalidFieldSizeError",[limit, entered]), tabNarrativeDocumentsRequiredNode,["after"]) :
					   dijit.showTooltip(m.getLocalization("invalidSingleFieldLength", [limitSingle, enteredSingle]), tabNarrativeDocumentsRequiredNode,["after"]);
				}
			   else if(m._config.isNarrativeZCharValidArray && !m._config.isNarrativeZCharValidArray[1] && document.getElementById("tabNarrativeDocumentsRequired").status == false){
				   dijit.showTooltip(m.getLocalization("invalidSWIFTTransactionValidValuesWithExtBank"), tabNarrativeDocumentsRequiredNode,["after"]);
			   }
			   else if(m._config.isSingleNarrativeValid && ! m._config.isSingleNarrativeValid[1] && document.getElementById("tabNarrativeDescriptionGoods").status == false){
				   dijit.showTooltip(m.getLocalization("invalidSingleFieldLength", [limitSingle, enteredSingle]), tabNarrativeDescriptionGoodsNode,["after"]);
			   }
		    };
		    tabNarrativeDocumentsRequiredNode.onmouseout = function(){
			    dijit.hideTooltip(tabNarrativeDocumentsRequiredNode);
		    };
		    
		    var tabNarrativeAdditionalInstructionsNode = document.getElementById("tabNarrativeAdditionalInstructions");
		    tabNarrativeAdditionalInstructionsNode.onmouseover = function(){
			   if((dj.byId("narrative_description_goods_popup") && dj.byId("narrative_description_goods_popup").state == "Error") ||
					   (document.getElementById("tabNarrativeDescriptionGoods").status == false) && tabNarrativeAdditionalInstructionsNode.status == false && (sendMode === '01') && m._config.isZCharValid && m._config.isSingleNarrativeValid[2]){
				   isSingleFieldValid ? dijit.showTooltip(m.getLocalization("invalidFieldSizeError",[limit, entered]), tabNarrativeAdditionalInstructionsNode,["after"]) :
					   dijit.showTooltip(m.getLocalization("invalidSingleFieldLength", [limitSingle, enteredSingle]), tabNarrativeAdditionalInstructionsNode,["after"]);
				}
			   else if(m._config.isNarrativeZCharValidArray && !m._config.isNarrativeZCharValidArray[2] && document.getElementById("tabNarrativeAdditionalInstructions").status == false){
				   dijit.showTooltip(m.getLocalization("invalidSWIFTTransactionValidValuesWithExtBank"), tabNarrativeAdditionalInstructionsNode,["after"]);
			   }
			   else if(m._config.isSingleNarrativeValid && ! m._config.isSingleNarrativeValid[2] && document.getElementById("tabNarrativeDescriptionGoods").status == false){
				   dijit.showTooltip(m.getLocalization("invalidSingleFieldLength", [limitSingle, enteredSingle]), tabNarrativeDescriptionGoodsNode,["after"]);
			   }
		    };
		    tabNarrativeAdditionalInstructionsNode.onmouseout = function(){
			    dijit.hideTooltip(tabNarrativeAdditionalInstructionsNode);
		    };
		    
		    var tabNarrativeSpecialBeneficiaryNode = document.getElementById("tabNarrativeSpecialBeneficiary");
		    tabNarrativeSpecialBeneficiaryNode.onmouseover = function(){
			   if((dj.byId("narrative_description_goods_popup") && dj.byId("narrative_description_goods_popup").state == "Error") ||
					   (document.getElementById("tabNarrativeDescriptionGoods").status == false) && tabNarrativeSpecialBeneficiaryNode == false && (sendMode === '01') && m._config.isZCharValid && m._config.isSingleNarrativeValid[3]){
				   isSingleFieldValid ? dijit.showTooltip(m.getLocalization("invalidFieldSizeError",[limit, entered]), tabNarrativeSpecialBeneficiaryNode,["after"]) :
					   dijit.showTooltip(m.getLocalization("invalidSingleFieldLength", [limitSingle, enteredSingle]), tabNarrativeSpecialBeneficiaryNode,["after"]);
				}
			   else if(m._config.isNarrativeZCharValidArray && !m._config.isNarrativeZCharValidArray[3] && document.getElementById("tabNarrativeSpecialBeneficiary").status == false){
				   dijit.showTooltip(m.getLocalization("invalidSWIFTTransactionValidValuesWithExtBank"), tabNarrativeSpecialBeneficiaryNode,["after"]);
			   }
			   else if(m._config.isSingleNarrativeValid && ! m._config.isSingleNarrativeValid[3] && document.getElementById("tabNarrativeDescriptionGoods").status == false){
				   dijit.showTooltip(m.getLocalization("invalidSingleFieldLength", [limitSingle, enteredtSingle]), tabNarrativeDescriptionGoodsNode,["after"]);
			   }
		    };
		    tabNarrativeSpecialBeneficiaryNode.onmouseout = function(){
			    dijit.hideTooltip(tabNarrativeSpecialBeneficiaryNode);
		    };
		    if(document.getElementById("tabNarrativeSpecialReceivingBank")){
		    	var tabNarrativeSpecialReceivingBankNode = document.getElementById("tabNarrativeSpecialReceivingBank");
			    tabNarrativeSpecialReceivingBankNode.onmouseover = function(){
					   if((dj.byId("narrative_description_goods_popup") && dj.byId("narrative_description_goods_popup").state == "Error") ||
							   (document.getElementById("tabNarrativeDescriptionGoods").status == false) && tabNarrativeSpecialReceivingBankNode.status == false && (sendMode === '01') && m._config.isZCharValid && m._config.isSingleNarrativeValid[4]){
						   isSingleFieldValid ? dijit.showTooltip(m.getLocalization("invalidFieldSizeError",[limit, entered]), tabNarrativeSpecialReceivingBankNode,["after"]) :
							   dijit.showTooltip(m.getLocalization("invalidSingleFieldLength", [limitSingle, enteredSingle]), tabNarrativeSpecialReceivingBankNode,["after"]);
						}
					   else if(m._config.isNarrativeZCharValidArray && !m._config.isNarrativeZCharValidArray[4] && document.getElementById("tabNarrativeSpecialReceivingBank").status == false){
						   dijit.showTooltip(m.getLocalization("invalidSWIFTTransactionValidValuesWithExtBank"), tabNarrativeSpecialReceivingBankNode,["after"]);
					   }
					   else if(m._config.isSingleNarrativeValid && ! m._config.isSingleNarrativeValid[4] && document.getElementById("tabNarrativeDescriptionGoods").status == false){
						   dijit.showTooltip(m.getLocalization("invalidSingleFieldLength", [limitSingle, enteredSingle]), tabNarrativeDescriptionGoodsNode,["after"]);
					   }
				    };
			    tabNarrativeSpecialBeneficiaryNode.onmouseout = function(){
				    dijit.hideTooltip(tabNarrativeSpecialBeneficiaryNode);
			    };
		    }
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for opening the amendment pop up.
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 */
		editNarrativeInPopUp : function( /*String*/ type,
				 /*String*/ fields, 
				 /*String*/ parameter,
				 /*String*/ product, 
				 /*String*/ dimensions,
				 /*String*/ title,
				 /*String*/ amdno){
			var url = [],
			query = {},
			contentURL = [ ajaxActionUrl ],
			urlAction = "GetStaticData",
			urlScreen = ajaxStaticDPopup,
			onLoadCallback;
			
			if(dimensions.slice(dimensions.length - 1) !== ";") {
				dimensions += ";";
			}
			
			var rundataXML, is798 = dj.byId("is798") ? dj.byId("is798").get("value") : (dj.byId("issuing_bank_abbv_name") ? (m._config.customerBanksMT798Channel[dj.byId("issuing_bank_abbv_name").get("value")] == true ? 'Y' : 'N') : (dj.byId("advising_bank_abbv_name") ? (m._config.customerBanksMT798Channel[dj.byId("advising_bank_abbv_name").get("value")] == true ? 'Y' : 'N') : 'N'));
			m._config.is798 = is798;
			m._config.amendmentNumber = amdno;
			m._config.narrativeId = parameter;
			if(parameter === "narrative_amend_goods"){
				rundataXML = dj.byId("org_narrative_description_goods") ? dj.byId("org_narrative_description_goods").get("value") : "";
			}
			else if(parameter === "narrative_amend_docs"){
				rundataXML = dj.byId("org_narrative_documents_required") ? dj.byId("org_narrative_documents_required").get("value") : "";
			}
			else if(parameter === "narrative_amend_instructions"){
				rundataXML = dj.byId("org_narrative_additional_instructions") ? dj.byId("org_narrative_additional_instructions").get("value") : "";
			}
			else if(parameter === "narrative_amend_sp_beneficiary"){
				rundataXML = dj.byId("org_narrative_special_beneficiary") ? dj.byId("org_narrative_special_beneficiary").get("value") : "";
			}
			else if(parameter === "narrative_amend_sp_recvbank"){
				rundataXML = dj.byId("org_narrative_special_recvbank") ? dj.byId("org_narrative_special_recvbank").get("value") : "";
			}
			
			contentURL.push(urlAction);
			query.option = type;
			query.dimensions = dimensions;
			query.messageValue = fields;
			query.node = type;
			query.rundataXML = rundataXML;
			query.is798 = is798;
			
			
			url.push("/screen/", urlScreen);	
			//d.mixin(query, parameter);
			
			var prevRadioButton = "";
			
			onLoadCallback = function() {
				if(m._config.codeword_enabled==true){
					dj.byId("narrative_description_goods_popup").set("disabled",true);
					
					var onOkCallback = function(){
						m.toggleADR();
					};
					var onCancelCallback = function(){
						dj.byId(prevRadioButton).set("value",true);
					};
					
					m.connect("adr_1", "onClick", function(){
						if(!m.hasTextBoxLogicalValue()){
							m.toggleADR();
						}
						else{
							m.dialog.show("Warning", m.getLocalization("textboxDataLossOnToggle"),"","","","",onOkCallback,onCancelCallback);
						}
					});
					m.connect("adr_1", "onChange", function(){
						prevRadioButton = "adr_1";
					});
					
					m.connect("adr_2", "onClick", function(){
						if(!m.hasTextBoxLogicalValue()){
							m.toggleADR();
						}
						else{
							m.dialog.show("Warning", m.getLocalization("textboxDataLossOnToggle"),"","","","",onOkCallback,onCancelCallback);
						}
					});
					m.connect("adr_2", "onChange", function(){
						prevRadioButton = "adr_2";
					});
					
					m.connect("adr_3", "onClick", function(){
						if(!m.hasTextBoxLogicalValue()){
							m.toggleADR();
						}
						else{
							m.dialog.show("Warning", m.getLocalization("textboxDataLossOnToggle"),"","","","",onOkCallback,onCancelCallback);
						}
					});
					m.connect("adr_3", "onChange", function(){
						prevRadioButton = "adr_3";
					});
					
					m.connect("narrative_description_goods_popup", "onKeyPress", function(evnt){
						var readOnlyLength;
						readOnlyLength = dj.byId("adr_1").get("value") == "ADD" ? 5:8;
						if ((evnt.keyCode !== dojo.keys.LEFT_ARROW && (evnt.keyCode !== dojo.keys.RIGHT_ARROW)) && ((this.domNode.selectionStart < readOnlyLength) ||
								((this.domNode.selectionEnd == readOnlyLength) && (evnt.keyCode === dojo.keys.BACKSPACE)))){
							evnt.preventDefault();
						}
					});
				}
				if(misys._config.swiftExtendedNarrativeEnabled){
					m.setValidation("narrative_description_goods_popup", m.validatePopupDataLength);
				}else{
					m.setValidation("narrative_description_goods_popup", m.validatePopupData);
				}
				m.connect("addAmendmentButton", "onClick", function(){
					if(m.hasTextBoxLogicalValue()){
						m.onSaveSizeAndSwiftValidation();
					}
				});
					
			};
			m.dialog.show("URL", "", title, null, onLoadCallback, m.getServletURL(url.join("")), null, null, query);
		},
		
		/**
		 * Function to check the values in the amendment narrative pop up text box
		 * */
		hasTextBoxLogicalValue : function(){
			if(dj.byId("narrative_description_goods_popup").disabled ||
				   dj.byId("narrative_description_goods_popup").get("value") === "/ADD/" ||
				   dj.byId("narrative_description_goods_popup").get("value") === "/DELETE/" ||
				   dj.byId("narrative_description_goods_popup").get("value") === "/REPALL/"){
				return false;
			}
				return true;
		},
		
		/**
		 * <h4>Summary:</h4>
		 * Function to do z-char validation and length validation
		 * onClick of 'Save' button in the pop up. 
		 */
		onSaveSizeAndSwiftValidation : function(){
            var value=dj.byId("narrative_description_goods_popup").get("value");
            var sendMode = '';
            if(dj.byId("adv_send_mode")) {
            	sendMode=dj.byId("adv_send_mode").get("value");
            }
            
            var regex=dj.byId("swiftregexzcharValue").get("value");
            if(sendMode !== '01' || value === null || value === ""){
            	m._config.isZCharValid = true;
            	m.toggleNarrativeDivStatus(true);
            }
            else{
	    	    var swiftchar = value;
	            var swiftregexp = new RegExp(regex);
	            m._config.isZCharValid= swiftregexp.test(swiftchar);
            }
            dj.byId("narrative_description_goods_popup").set("value", dojox.html.entities.encode(dj.byId("narrative_description_goods_popup").get("value"), dojox.html.entities.html));
            var onOkCallback = function(){
            	dj.byId("amendments").createDataGrid();
        		if(m._config.codeword_enabled == true){
					m.toggleADR();
        		}
				else if(!m.isGridEmpty() && dijit.byId("amendments").store._arrayOfAllItems[0].verb[0] == "REPALL"){
					dj.byId("narrative_description_goods_popup").set("disabled",true);
				}
			};
            var onOkCallback1 = function(){
    			var fieldValue = dj.byId("narrative_description_goods_popup").get("value");
            	if(m.validatePopupData()){
    				dj.byId("amendments").createDataGrid();
    			}
        		if(m._config.codeword_enabled == true){
					m.toggleADR();
					m._config.swiftExtendedNarrativeEnabled ? "" : dj.byId("narrative_description_goods_popup").set("value",fieldValue);
        		}
				else if(!m.isGridEmpty() && dijit.byId("amendments").store._arrayOfAllItems[0].verb[0] == "REPALL"){
					dj.byId("narrative_description_goods_popup").set("disabled",true);
				}
			};
            if(!m._config.isZCharValid){
               if(m.validatePopupData()){
	               var userType;
	               if (document.getElementById("_userType")){
	            	   userType = document.getElementById("_userType").getAttribute('value');
	               }
	               
	               if(userType == '03' || userType == '06'){
	                    m.dialog.show("CONFIRMATION", m.getLocalization("invalidSWIFTTransactionValidValuesWithExt"),"","","","",onOkCallback);
	               }
	               else{
	            	   m.dialog.show("Warning", m.getLocalization("invalidSWIFTTransactionValidValuesWithExtBank"),"","","","",onOkCallback);
	               }   
	               m.toggleNarrativeDivStatus(true);
               }else{
	               m.dialog.show("ERROR", m.getLocalization("invalidSWIFTTPopupValueLength"),"","","","",onOkCallback1);
               }
        	}
            else if(m._config.isZCharValid){
            	 if(dj.byId("narrative_description_goods_popup").state === "Error"){
	            	 m.toggleNarrativeDivStatus(false);
	            	 if(m._config.swiftExtendedNarrativeEnabled){
	            		 m.dialog.show("Warning", m.getLocalization("invalidSWIFTTPopupValueSize"),"","","","",onOkCallback);
	            	 }else{
	            		 m.dialog.show("ERROR", m.getLocalization("invalidSWIFTTPopupValueLength"),"","","","",onOkCallback1);
	            	 }
                 }
            	 else{
            	 dj.byId("amendments").createDataGrid();
        		 if(m._config.codeword_enabled == true){
					m.toggleADR();
             		}
					else if(!m.isGridEmpty() && dijit.byId("amendments").store._arrayOfAllItems[0].verb[0] == "REPALL"){
					dj.byId("narrative_description_goods_popup").set("disabled",true);
				}
        		m.toggleNarrativeDivStatus(true);
               }
           }
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function is setting the state of div to true/false. 
		 */
		toggleNarrativeDivStatus : function(/*Boolean*/divStatus, /*String*/divName){
			var domNodeArray = ["tabNarrativeDescriptionGoods","tabNarrativeDocumentsRequired","tabNarrativeAdditionalInstructions","tabNarrativeSpecialBeneficiary","tabNarrativeSpecialReceivingBank"];
			var divColor = divStatus ? 'solid 1px #B8B8B8' : 'solid 1px #d46464';
			if(divName == '' || divName == undefined){
				for(var itr = 0; itr < domNodeArray.length; itr++){
	           		if(document.getElementById(domNodeArray[itr]) != null) {
		           		document.getElementById(domNodeArray[itr]).status = divStatus;
		           		document.getElementById(domNodeArray[itr]).style.border = divColor;
	           		}
	           	 }
			}
			else{
				document.getElementById(divName).status = divStatus;
           		document.getElementById(divName).style.border = divColor;
			}
			if(document.getElementById("tabNarrativeDescriptionGoods") != null || document.getElementById("tabNarrativeDocumentsRequired") != null || 
					document.getElementById("tabNarrativeAdditionalInstructions") != null || document.getElementById("tabNarrativeSpecialBeneficiary") != null || 
					document.getElementById("tabNarrativeSpecialReceivingBank") != null) {
				m.initDivMouseOver();
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for validating the text size. 
		 */
		validatePopupDataLength : function() {
			var descOfGoodsSize = 0,fieldSizeTotal = 0, fieldSizeSingle = 0, i = 0, msgRowsTotal = 0, msgRowsSingle = 0;
			var dataStoreNarrative = [m._config.narrativeDescGoodsDataStore,m._config.narrativeDocsReqDataStore,m._config.narrativeAddInstrDataStore,m._config.narrativeSpBeneDataStore,m._config.narrativeSpRecvbankDataStore];
			var narrativeId = ["narrative_amend_goods","narrative_amend_docs","narrative_amend_instructions","narrative_amend_sp_beneficiary","narrative_amend_sp_recvbank"];
			var narrativeIdIndex = narrativeId.indexOf(m._config.narrativeId);
			var sendMode = dj.byId("adv_send_mode")? dj.byId("adv_send_mode").get("value") : '';

			if(sendMode !== '01'){
				  return true;
			}
			for(var itr = 0; itr < 5; itr++){
				if(dataStoreNarrative[itr] && (itr != narrativeIdIndex && narrativeIdIndex != -1)){
					i = 0;
					d.forEach(dataStoreNarrative[itr], function(){
						if(dataStoreNarrative[itr][i] && dataStoreNarrative[itr][i] !== null){
							dataStoreNarrative[itr][i].content[0].replace(/&#xa;/g,'\n');
							fieldSizeTotal += dataStoreNarrative[itr][i].content[0].length;
							msgRowsTotal += dataStoreNarrative[itr][i].text_size[0];
						}
						i++;
					});
				}
			}
			if(dijit.byId("amendments") && !m.isGridEmpty() && dijit.byId("amendments").store._arrayOfAllItems){
				for(var v = 0; v < dijit.byId("amendments").store._arrayOfAllItems.length; v++){
					if(dijit.byId("amendments").store._arrayOfAllItems[v] !== null){
						fieldSizeSingle += dijit.byId("amendments").store._arrayOfAllItems[v].content ? dijit.byId("amendments").store._arrayOfAllItems[v].content[0].length : 0;
						fieldSizeSingle += dijit.byId("amendments").store._arrayOfAllItems[v].verb ? ("/"+dijit.byId("amendments").store._arrayOfAllItems[v].verb[0]+"/").length : 0;
						msgRowsSingle += dijit.byId("amendments").store._arrayOfAllItems[v].text_size[0];
					}
				}
			}
			if(dj.byId("narrative_description_goods_popup")){
				descOfGoodsSize = (!m.hasTextBoxLogicalValue()) ? 0 : dj.byId("narrative_description_goods_popup").get("value").length;
				limitSingle = (misys._config.is798 == 'Y' ? 792 : 800) * 65;
				enteredSingle = fieldSizeSingle + descOfGoodsSize;
				isSingleFieldValid = m.validateExtendedNarrativeSwift2018(dj.byId("narrative_description_goods_popup").get("value"), msgRowsSingle, misys._config.is798, true);
			}
			isCombinedValid =  m.validateExtendedNarrativeSwift2018(dj.byId("narrative_description_goods_popup").get("value"), (msgRowsSingle+msgRowsTotal), misys._config.is798, false);
			limit = (misys._config.is798 == 'Y' ? 992 : 1000) * 65;
			entered = (fieldSizeSingle + fieldSizeTotal + descOfGoodsSize);
			if(!isSingleFieldValid) {
						this.invalidMessage = m.getLocalization("invalidSingleFieldLength",[limitSingle, enteredSingle]);
				}
			else {
					   	this.invalidMessage = m.getLocalization("invalidFieldSizeError",[limit, entered]);
				   }
			return isSingleFieldValid && isCombinedValid;
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function is for validating the text size while 
		 * swift.extended.narrative.enable=false only for amendment
		 * narrative pop up. 
		 */
		
		validatePopupData : function(){
			
			var isValid = true;
			if(m._config.swiftExtendedNarrativeEnabled){
				return isValid;
			}
			var descOfGoodsSize = 0,fieldSize = 0, msgRows = 0;
			
			if(dijit.byId("amendments") && !m.isGridEmpty() && dijit.byId("amendments").store._arrayOfAllItems){
				for(var w = 0; w < dijit.byId("amendments").store._arrayOfAllItems.length; w++){
					if(dijit.byId("amendments").store._arrayOfAllItems[w] !== null){
						fieldSize += dijit.byId("amendments").store._arrayOfAllItems[w].content ? dijit.byId("amendments").store._arrayOfAllItems[w].content[0].length : 0;
						fieldSize += dijit.byId("amendments").store._arrayOfAllItems[w].verb ? ("/"+dijit.byId("amendments").store._arrayOfAllItems[w].verb[0]+"/").length : 0;
						msgRows += dijit.byId("amendments").store._arrayOfAllItems[w].text_size[0];
					}
				}
			}
			
			if(dj.byId("narrative_description_goods_popup")){
				descOfGoodsSize = (!m.hasTextBoxLogicalValue()) ? 0 : dj.byId("narrative_description_goods_popup").get("value").length; 
			}
			
			limit = 100 * 65;
			entered = descOfGoodsSize + fieldSize;
			this.invalidMessage  = m.getLocalization("invalidFieldSizeError",[limit, entered]);
			return m.validateExtendedNarrativeSwift2018(dj.byId("narrative_description_goods_popup").get("value"), msgRows, false);
			
		},
		
		/**
		 * Shows limited number of lines in the data grid*/
		showTruncatedGridData : function( /* String */textContent,
										/* Integer */numberOfLines){
			var textToDisplay = null;
			if(textContent !== "" && textContent !== null){
				textToDisplay = '<p style="white-space: pre-wrap;">';
				var message = textContent.split(/\n/);
				var displayedLinesLength = message.length > numberOfLines ? numberOfLines : message.length;
				for(var i = 0; i < displayedLinesLength; i++){
					textToDisplay = textToDisplay + message[i] + "\n";
				}
				if(message.length > numberOfLines){
					var tail = ".....";
					textToDisplay = textToDisplay.trim() + tail;
				}
				textToDisplay+="</p>";
			}
			return textToDisplay;
		},

		/**
		 * Opens dialog box for Extended narrative for swift 2018
		 */

		showExtendedNarrativeView : function( /* String */type,
											/* String */product,
											/* String */title,
											/* String */messageValue,
											/*String*/ widget){
			if(dj.byId(widget)){
				var msg = dojox.html.entities.encode(dj.byId(widget).get("value"), dojox.html.entities.html);
					msg = _unwrap(msg);
					msg = "<div style='width: auto; height: 400px;  overflow:auto'>"+ msg + "</div>";
				}
				else if(messageValue != "gridPreviewOverlay")
				{
					msg = messageValue;
					msg = _decode(msg);
					msg = "<div style='height: 400px;width: auto; overflow:auto'>"+ msg + "</div>";
				}
				else if(messageValue == "gridPreviewOverlay")
				{
					msg = "";
					title = "Current Amendment";
					if(dijit.byId("amendments").store){
						for(var i = 0; i<dijit.byId("amendments").store._arrayOfAllItems.length; i++){
							if(dijit.byId("amendments").store._arrayOfAllItems[i]){
								var verbId = dijit.byId("amendments").store._arrayOfAllItems[i].verb[0];
								var displayedVerb = '';
								if(verbId === "ADD") {
									displayedVerb = misys.getLocalization("add");
								}else if(verbId === "DELETE") {
									displayedVerb = misys.getLocalization("delete");
								}else if(verbId === "REPALL") {
									displayedVerb = misys.getLocalization("repall");
								}
								msg +=  "<b>" + "/"+displayedVerb+"/"+"</b>";
								msg += _decode(dijit.byId("amendments").store._arrayOfAllItems[i].content[0]);
							}
							msg += "<div style='height: 8px; background-color: #FFFFFF'><div style='height: 1px; background-color: ##808080'></div></div>";
						}
					}
					else{
						msg =   m.getLocalization("emptyAmendmentGrid");
					}
					msg = "<div style='width: auto; height: 400px; overflow:auto'>"+ msg + "</div>";
				}
				m.dialog.show("EXTENDED-VIEW", msg , title);
			},
			/**
			 * Opens dialog box for Localization
			 */

			showLocalizationDialog : function(id,oldValue){
				//console.log(id);
				dj.byId("xsl_name").value=id;
				dj.byId("new_title").set("value",oldValue);
				dj.byId("localizationDialog").show();
			},
			
			undoLocalization :function(){
				dj.byId("new_title").set("value","");
				m.submitLocalization();
			},
			submitLocalization : function(){
				var xsl_name=dj.byId("xsl_name").value;
				var new_title=dj.byId("new_title").value;

				m.xhrPost({
					url : m.getServletURL("/screen/AjaxScreen/action/UpdateLocalizationAction"),
					sync : true,
					handleAs : "json",
					content: { 
						XSLNAME:xsl_name,
						NEWNAME:new_title
					},
					load : function(response, args){
						
					},
					error : function(response, args){
						console.error("[misys.grid._base] Country Validation error", response);
					}
				});
				dj.byId("localizationDialog").hide();
				location.reload();
			
			},
		/**
		 * <h4>Summary:</h4>
		 * This function is for showing transaction search dialog
		 * @param String
		 * @param String
		 * @param String
		 * @method showSearchTransactionsDialog
		 */
		showSearchTransactionsDialog : function( /*String*/ companyId, 
				 								 /*String*/ productCode, 
				 								 /*String*/ refId){
			
			//  summary:
			//		   Show reporting summary dialog.
			// 
			// TODO Dimensions should not be hardcoded like this


			var url = [m.getServletURL("/screen/AjaxScreen/action/ListOfTransactionsAction")];
			url.push("?companyid=", companyId, varProdCode, productCode, 
					 "&referenceid=", refId);

			d.style("linkedTransaction_dialog", "width", "650px");
			d.create("div", {id: "transaction_div"}, "linkedTransaction_div");

			if (!dj.byId("transaction_Grid")) {
				_createTransactionGrid(url.join(""), "transaction_div");
			}
			
			dj.byId("linkedTransaction_dialog").show();
			d.style("linkedTransaction_dialog", "height", "225px");
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for deleting the transaction 
		 * 
		 * <h4>Description:</h4> 
		 * Clears the transaction grid 
		 * @method deleteTransactions
		 */
		deleteTransactions : function(){
			// summary:
			//		TODO
			
			dj.byId("imp_bill_ref_id").set("value", "");
			dj.byId("transaction_Grid").selection.clear();
			d.byId("TransactionLink").innerHTML = m.getLocalization("NoTransactionLink");
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for creating rich text editor
		 * @method createRteEditor
		 */
		createRteEditor : function(productCode,editorId) {
			//	summary:
			//		TODO
			var editor = dj.byId(editorId);
			if (!editor) {
				var attachPoint = d.byId(editorId);
				var	rteContent = d.byId("rteContent").innerHTML;
					
				editor = new dj.Editor({
					id:editorId,
					name:editorId,
					rows:"13",
					cols:"40",
					maxSize:"300",
					plugins:[
						"undo", "redo", "|", "bold", "italic", "underline", "strikethrough", "|",
						"insertOrderedList", "insertUnorderedList", "|",
						"indent", "outdent", "|",
						"justifyLeft", "justifyRight", "justifyCenter", "justifyFull", "||",
						{name: "dijit._editor.plugins.FontChoice", command: "fontName"},
						{name: "misys.editor.plugins.ProductFieldChoice", command: "misysEditorPluginsProductFieldChoice", product: productCode}
						]
				}, attachPoint);
				
				rteContent = rteContent.replace(/&lt;/g, "<");
				rteContent = rteContent.replace(/&gt;/g, ">");
				rteContent = rteContent.replace(/&amp;/g, "&");
				rteContent = rteContent.replace(/&quot;/g, '"');
				editor.set("value", rteContent ? rteContent : "");
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * This fucntion is for toggling bank grids
		 * @methods toggleBankGrids
		 */
		toggleBankGrids : function(){
			var bankGridType = dj.byId("bankRadioId");
			if(bankGridType.checked)
			{
				m.animate("wipeOut",d.byId("bank_swift_data"),function(){
					m.animate("wipeIn",d.byId("bankdata"));
					dijit.byId("bankdata_grid").resize();
				});
			}
			else
			{
				m.animate("wipeOut",d.byId("bankdata"),function(){
					m.animate("wipeOut",d.byId("contentPaneContainer"));
					m.animate("wipeIn",d.byId("bank_swift_data"));
					d.query("#bankTypeContainer .dojoxGrid").forEach(function(/*DomNode*/ grid){
						var gridObj = dj.byId(grid.id);
						if(gridObj) 
						{
							gridObj.resize();
						}
					});
				});
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * Wipe In and Wipe Out a Set of Fields using Action UP n DOWN Img in the Header
		 * @param String - aniamteDivId
		 * @param String imgPrefix
		 * @param String direction
		 * @method toggleFieldSetContent
		 * 
		 */
		toggleFieldSetContent : function(/*String*/animateDivId,/*String*/imgPrefix,/*String*/direction){
			
			var downArrow = d.byId(imgPrefix+"_img_down");
			var upArrow = d.byId(imgPrefix+"_img_up");
			if(direction === 'down')
			{
				m.animate('wipeIn', animateDivId);
				d.style(downArrow, "display", "none");
				d.style(upArrow, "display", "block");
				d.style(upArrow, "cursor", "pointer");
			}
			else
			{
				m.animate('wipeOut', animateDivId);
				d.style(upArrow, "display", "none");
				d.style(downArrow, "display", "block");
				d.style(downArrow, "cursor", "pointer");
			}
		},
		
		/**
		 * <h4>Summary:</h4>
		 * Wipe In and Wipe Out a Set of Fields using Action UP n DOWN Img in the Header
		 * @param String - aniamteDivId
		 * @param String imgPrefix
		 * @param String direction
		 * @method toggleFieldSetContent
		 * 
		 */
		toggleEyeSetContent : function(/*String*/animateDivId,/*String*/imgPrefix,/*String*/direction,/*String*/fieldValue,/*String*/toggleFieldName){
			
			var downArrow = d.byId(imgPrefix+"_eye_down");
			var upArrow = d.byId(imgPrefix+"_eye_up");
			if(direction === 'down')
			{
				d.style(downArrow, "display", "none");
				d.style(upArrow, "display", "inline");
				d.style(upArrow, "cursor", "pointer");
				document.getElementById(toggleFieldName).getElementsByClassName('content')[0].innerHTML = fieldValue;
			}
			else
			{
				d.style(upArrow, "display", "none");
				d.style(downArrow, "display", "inline");
				d.style(downArrow, "cursor", "pointer");
				document.getElementById(toggleFieldName).getElementsByClassName('content')[0].innerHTML = "************";
			}
		},

		/**
		 * <h4>Summary:</h4>
		 *  Method to handle hide and show of inline-block elements
		 *  since IE6 and IE7 dont support display:inline-block css style
		 *  @param String - divId
		 *  @param boolean - show
		 *  @method toggleClassInlineBlock
		 */
		toggleClassInlineBlock : function(/*String*/divId,/* boolean*/show)
		{
			/**
			 * Method to handle hide and show of inline-block elements 
			 * since IE6 and IE7 dont support display:inline-block css style 
			 */
			if(show === true)
			{
				d.removeClass(divId,"hide");
				d.addClass(divId,"inlineBlock");
			}
			else
			{
				d.removeClass(divId,"inlineBlock");
				d.addClass(divId,"hide");
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * Method to handle toggeling a array of fields readOnly based on the guard
		 * @param Array - Array of widgets
		 * @param boolean - readOnly
		 * @param boolean clearFields
		 * @method toggleFieldsReadOnly
		 */
		toggleFieldsReadOnly : function(/*Array of widget ids*/ array, /* boolean*/ readOnly, /*boolean*/clearFields)
		{
			d.forEach(array, function(node){
				if (dj.byId(node))
				{
					if(clearFields)
					{
						dj.byId(node).set("value", '');
					}
					dj.byId(node).set("readOnly", readOnly);
				}
			});
		},
		
		/**
		 * <h4>Summary:</h4>
		 * Method to handle toggeling a array of fields readOnly based on the guard
		 * @param Array - Array of widgets
		 * @param boolean - isDisable
		 * @method disableFields
		 */
		disableFields : function(/*Array of widget ids*/ array, /* boolean*/ isDisable)
		{
			d.forEach(array, function(node){
				if (dj.byId(node))
				{
					dj.byId(node).set("disabled", isDisable);
				}
			});
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for generating Esign request transaction
		 * @param String - operation
		 * @param String - action
		 */
		generateEsignRequestTransaction : function(/*String*/ operation,/*String*/ action){
			console.debug("Generate Esign Request For Transaction");
			var callBack = function(){
				action = action + "&prodCode=" + m._config.productCode;
				dj.byId("realform_operation").set("value", operation);
				dj.byId("option").set("value", "");
				dj.byId("tnxtype").set("value", "");
				dj.byId("realform").set("action", action);
				dj.byId("realform").submit();
			};
			m.dialog.show("CONFIRMATION",m.getLocalization("generateEsignRequest"),'',callBack);
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for generating proxy authorization
		 * @param {String} operation
		 * @param {String} action
		 * @method proxyAuthoriseTransaction
		 */
		proxyAuthoriseTransaction : function(/*String*/ operation,/*String*/ action){
			console.debug("Proxy Authorise Transaction");
			var callBack = function(){
				action = action + "&prodCode=" + m._config.productCode;
				dj.byId("realform_operation").set("value", operation);
				dj.byId("option").set("value", "");
				dj.byId("tnxtype").set("value", "");
				dj.byId("realform").set("action", action);
				dj.byId("realform").submit();
			};
			m.dialog.show("CONFIRMATION",m.getLocalization("proxyAuthorise"),'',callBack);
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for toggling of bgTypeDetails-editor div 
		 * <h4>Description:</h4> 
		 * Show this div only if bg_type_code is "99"
		 * @method toggleGuaranteeType
		 * 
		 */
		toggleGuaranteeType : function(){
			var bgTypeDetailsDiv = d.byId('bgtypedetails-editor');
			if(this.get("value") === "99") 
			{
				//this.set("disabled", false);
				m.animate("fadeIn", bgTypeDetailsDiv);
			} 
			else 
			{
				m.animate("fadeOut", bgTypeDetailsDiv);
			}
		},
		
		getIncoYear : function(){

			var incoTermYearStore = null;
			var incoTermYearField = dj.byId("inco_term_year");
			var issuingBank =dj.byId("issuing_bank_abbv_name")?dj.byId("issuing_bank_abbv_name").get("value"):"";
			var remittingBank=dj.byId("remitting_bank_abbv_name")?dj.byId("remitting_bank_abbv_name").get("value"):"";
			var advisingBank=dj.byId("advising_bank_abbv_name")?dj.byId("advising_bank_abbv_name").get("value"):"";
			if(issuingBank!="")
					{
					incoTermYearStore = misys._config.incoTermYearMap[issuingBank];
					}
				else if(remittingBank!="")
					{
					incoTermYearStore = misys._config.incoTermYearMap[remittingBank];
					}
				else if(advisingBank!="")
				{
				incoTermYearStore = misys._config.incoTermYearMap[advisingBank];
				}
				else{
					incoTermYearStore = misys._config.incoTermYearMap[misys._config.bankAbbvNamePrefix];
					}
					 var jsonData = {"identifier" :"id", "items" : []};
					 var incoTermYearFieldStore = new dojo.data.ItemFileWriteStore( {data : jsonData });
					 if(incoTermYearStore != undefined && incoTermYearStore != "" )
					 {
						 for(var j = 0; j < incoTermYearStore.length; j++)
						 {
							 incoTermYearFieldStore.newItem( {"id" : incoTermYearStore[j].value, "name" : incoTermYearStore[j].name});
						 }
						 
						 if(incoTermYearField)
					     {
						 incoTermYearField.store = new dojo.data.ItemFileReadStore(
									{
										data :
										{
											identifier : "value",
											label : "name",
											items : incoTermYearFieldStore
										}
									});
							 incoTermYearField.store = incoTermYearFieldStore;
						 incoTermYearField.set('disabled', false);
						 incoTermYearField.fetchProperties =
							{
								sort : [
								{
									attribute : "name"
								} ]
							};
							 }
						
							 }
					 else
						 {

						 incoTermYearField.store = new dojo.data.ItemFileReadStore(
									{
									 data :
										{
											identifier : "value",
											label : "name",
											items : incoTermYearFieldStore
										}
									});
						 
						 
						 }
					// dijit.byId("inco_term_year").set("value",dijit.byId("inco_term_year")._lastQuery);
					 var incoYearValue = dijit.byId("inco_term_year")?dijit.byId("inco_term_year").get("value"):"";
					 var arrayLineItems = incoTermYearField.store._arrayOfAllItems;
						var flag = false;
						for(var i=0;i<arrayLineItems.length;i++) {
							if(arrayLineItems[i] && arrayLineItems[i].name!="" && arrayLineItems[i].name==incoYearValue) {
								flag=true;
								break;
							}
						}	
						if(!flag)
							{
							dijit.byId("inco_term_year").set("value", "");
							dj.byId("inco_term").set("value", "");
							}
	},
	
	getDeliveryTo : function(){

		var deliveryToStore = null;
		var deliveryToField = dj.byId("delivery_to");
		var issuingBank =dj.byId("issuing_bank_abbv_name")?dj.byId("issuing_bank_abbv_name").get("value"):"";
		var remittingBank=dj.byId("remitting_bank_abbv_name")?dj.byId("remitting_bank_abbv_name").get("value"):"";
		var advisingBank=dj.byId("advising_bank_abbv_name")?dj.byId("advising_bank_abbv_name").get("value"):"";
		if(issuingBank!="")
				{
				deliveryToStore = misys._config.deliveryToMap[issuingBank];
				}
			else if(remittingBank!="")
				{
				deliveryToStore = misys._config.deliveryToMap[remittingBank];
				}
			else if(advisingBank!="")
			{
				deliveryToStore = misys._config.deliveryToMap[advisingBank];
			}
			else{
				deliveryToStore = misys._config.deliveryToMap[misys._config.bankAbbvNamePrefix];
				}
				 var jsonData = {"identifier" :"id", "items" : []};
				 var deliveryToFieldStore = new dojo.data.ItemFileWriteStore( {data : jsonData });
				 if(deliveryToStore != undefined && deliveryToStore != "" )
				 {
					 for(var j = 0; j < deliveryToStore.length; j++)
					 {
						 deliveryToFieldStore.newItem( {"id" : deliveryToStore[j].value, "name" : deliveryToStore[j].name});
					 }
					 
					 if(deliveryToField)
				     {
						 deliveryToField.store = new dojo.data.ItemFileReadStore(
								{
									data :
									{
										identifier : "value",
										label : "name",
										items : deliveryToFieldStore
									}
								});
						 deliveryToField.store = deliveryToFieldStore;
						 deliveryToField.set('disabled', false);
						 deliveryToField.fetchProperties =
						{
							sort : [
							{
								attribute : "name"
							} ]
						};
						 }
					
						 }
				 else
					 {

					 deliveryToField.store = new dojo.data.ItemFileReadStore(
								{
								 data :
									{
										identifier : "value",
										label : "name",
										items : deliveryToFieldStore
									}
								});
					 
					 
					 }
				// dijit.byId("inco_term_year").set("value",dijit.byId("inco_term_year")._lastQuery);
				 var deliveryToValue = dijit.byId("delivery_to")?dijit.byId("delivery_to").get("value"):"";
				 var arrayLineItems = deliveryToField.store._arrayOfAllItems;
					var flag = false;
					for(var i=0;i<arrayLineItems.length;i++) {
						if(arrayLineItems[i] && arrayLineItems[i].id!="" && arrayLineItems[i].id==deliveryToValue) {
							flag=true;
							break;
						}
					}	
					if(!flag)
						{
						dijit.byId("delivery_to").set("value", "");
						dj.byId("delivery_to").set("value", "");
						}
},
		
		getIncoTerm : function(){
			
			var incoTermDataStore = null;
			var incoTermDataField = dj.byId("inco_term");
			var bankAndYear;
			var issuingBank =dj.byId("issuing_bank_abbv_name")?dj.byId("issuing_bank_abbv_name").get("value"):"";
			var remittingBank=dj.byId("remitting_bank_abbv_name")?dj.byId("remitting_bank_abbv_name").get("value"):"";
			var advisingBank=dj.byId("advising_bank_abbv_name")?dj.byId("advising_bank_abbv_name").get("value"):"";
			if(issuingBank!="")
					{
					   bankAndYear =issuingBank +":"+dj.byId("inco_term_year").get("value");
						
					}
				else if(remittingBank!="")
				{
					   bankAndYear =remittingBank +":"+dj.byId("inco_term_year").get("value");
						
				}
				else if(advisingBank!="")
				{
					bankAndYear =advisingBank +":"+dj.byId("inco_term_year").get("value");
				}
				else
					{
					 bankAndYear =misys._config.bankAbbvNamePrefix +":"+dj.byId("inco_term_year").get("value");
					}
			incoTermDataStore = misys._config.incoTermProductMap[bankAndYear];
			 var jsonData = {"identifier" :"id", "items" : []};
			 var incoTermDataFieldStore = new dojo.data.ItemFileWriteStore( {data : jsonData });
			 if(incoTermDataStore != undefined && incoTermDataStore != "" )
			 {
				 for(var j = 0; j < incoTermDataStore.length; j++)
				 {
					 incoTermDataFieldStore.newItem( {"id" : incoTermDataStore[j].value, "name" : incoTermDataStore[j].name});
					 
				 }
			 incoTermDataField.store = new dojo.data.ItemFileReadStore(
				{
				 data :
					{
						identifier : "value",
						label : "name",
						items : incoTermDataFieldStore
					}
				});
				if(incoTermDataField)
			    {
					 incoTermDataField.store = incoTermDataFieldStore;
			    }
				incoTermDataField.set('disabled', false);
				incoTermDataField.fetchProperties =
				{
					sort : [
					{
						attribute : "name"
					} ]
				};
			}
			 else
				 {
				 incoTermDataField.store = new dojo.data.ItemFileReadStore(
							{
							 data :
								{
									identifier : "value",
									label : "name",
									items : incoTermDataFieldStore
								}
							});
				 }
    if(dj.byId("inco_term_year").get("value")!==dj.byId("org_term_year").get("value"))
    	{
    	dj.byId("inco_term").set("value","");
    	dj.byId("org_term_year").set("value",dj.byId("inco_term_year").get("value"));
    	}
		},

		/**
		 * <h4>Summary:</h4>
		 *  Check which attachments have been added or deleted.
		 * @method checkForAttachments
		 */
		checkForAttachments : function() {

		    //  summary:
		    //        Check which attachments have been added or deleted.
		    //  tags:
		    //        private
			
			console.debug('[common] Checking for attachments');
			var attIdsField = dj.byId('attIds');
			var numOfFiles = false;
			var count = 0;
			if(attIdsField)
			{
					var grids = [dj.byId(attFile)];
					d.forEach(grids, function(gridContainer){
						if(gridContainer &&  gridContainer.grid) {
							var arr = gridContainer.grid.store._arrayOfAllItems;
							d.forEach(arr, function(attachment, i){
								if(attachment != null) {
									numOfFiles = true;
									count++;
								}
							});
						}
					});
			}
			if (dj.byId(attFile) && dj.byId(attFile).store) {
				if(dj.byId(attFile).store._arrayOfAllItems.length > 0) {
		    		return true; 
		    	}
			}
			m._config.onSubmitErrorMsg = m.getLocalization("mandatoryMinimumFileUploadTypeError");
			return numOfFiles;
		},
		/**
		 * <h4>Summary:</h4>
		 * Check whether documents are attached or not
		 * @method hasAttachments
		 */
		hasAttachments : function() {

		    //  summary:
		    //        Check whether documents are attached or not
		    //  tags:
		    //        private
			
			console.debug('[common] has attachments check');
			var attIdsField = dj.byId('attIds');
			var numOfFiles = false;
			var count = 0;
			if(attIdsField)
			{
					var grids = [dj.byId(attFile)];
					d.forEach(grids, function(gridContainer){
						if(gridContainer &&  gridContainer.grid) {
							var arr = gridContainer.grid.store._arrayOfAllItems;
							d.forEach(arr, function(attachment, i){
								if(attachment != null) {
									numOfFiles = true;
									count++;
								}
							});
						}
					});
			}
			return numOfFiles;
		},
		/**
		 * <h4>Summary:</h4>
		 * This method is to handle toggling of MT798 fields
		 * <h4>Description:</h4> 
		 * This method handles toggling of MT798 fields depending on whether MT798 is enabled or not
		 * @method toggleMT798Fields
		 */
		toggleMT798Fields : function(mainBankWidjetId){
			var mainBankAbbvName = dj.byId(mainBankWidjetId).get('value');
			var advSendMode ="";
			if(dj.byId("adv_send_mode"))
			{
				advSendMode = dj.byId("adv_send_mode").get("value");
			}
			var isMT798Enable = m._config.customerBanksMT798Channel[mainBankAbbvName] === true && advSendMode === "01";
			m.toggleFields(isMT798Enable, ["delivery_channel","transport_mode_nosend", "transport_mode"], null, false, false);
			// Toggle required fields
			m.toggleFields(isMT798Enable && m.hasAttachments(), null, ["delivery_channel"], false, false);
			if(isMT798Enable){
				if (dj.byId("delivery_channel")){
					m.animate("fadeIn", "delivery_channel_row");
					m.connect("delivery_channel", "onChange",  function(){
						if(dj.byId(attFile))
						{
							if(dj.byId("delivery_channel").get('value') === 'FACT')
							{
								dj.byId(attFile).displayFileAct(true);
							}
							else
							{
								dj.byId(attFile).displayFileAct(false);
							}
						}
					});
					dj.byId("delivery_channel").onChange();
				}
				if (dj.byId("transport_mode")){
					m.animate("fadeIn", "transport_mode_nosend_row");
					m.animate("fadeIn", "transport_mode_text_nosend_row");
				}
				
			} 
			else {
				if (dj.byId("delivery_channel")){
					m.animate("fadeOut", "delivery_channel_row");
				}
				if (dj.byId("transport_mode")){
					m.animate("fadeOut", "transport_mode_nosend_row");
					m.animate("fadeOut", "transport_mode_text_nosend_row");
				}
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * This method is for renewal of final expiry date.
		 * <h4>Description:</h4> 
		 * In this method depending on "renew_on_code" we do renewal of renewal of expiry method
		 * @method setRenewalFinalExpiryDate
		 * 
		 */
		setRenewalFinalExpiryDate : function()
		{
			var calcFinalExpDate = calculateRenewalFinalExpiryDate();
			
			if(calcFinalExpDate){
				dj.byId("final_expiry_date").set("value",calcFinalExpDate);
			}
	            
	            //Code for calculation of final expiry date after rolling renewal. Can be used later for MPSSC-4449
	            
	            /*if(isPreCondStsfd && renewalInterval !=null && renewalIntervalUnit!=null && numOfRenewals!= null)
	            {
		            if(!rollingRenewalOn || rollingRenewalOn !== "03") {
		                  switch (renewalIntervalUnit) {
							case "D":	 
								milliSecTillLastRenewal =  d.date.add(firstRenewalDateObj, "day", numOfRenewals * renewalInterval);
								break;
							case "W":	
								milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "week", numOfRenewals * renewalInterval);		
								break;
							case "M":	
								milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "month", numOfRenewals * renewalInterval);
								break;
							case "Y":	
								milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "year", numOfRenewals * renewalInterval);		
								break;
							default:
								break;
						}
		                  //Last active date of the trade product
		                  //Last active date of the trade product
		                  var lastActiveDateObj = new Date(milliSecTillLastRenewal.getTime());
		                  dj.byId("final_expiry_date").set("value",lastActiveDateObj);
		            }
		                  
		            else if(rollingRenewalOn === "03" && rollingRenewalIntervalUnit !== "" && rollingRenewalInterval !== "")
		            {    
		            	switch (renewalIntervalUnit) {
						case "D":	 
							milliSecTillLastRenewal =  d.date.add(firstRenewalDateObj, "day", renewalInterval);
							break;
						case "W":	
							milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "week", renewalInterval);		
							break;
						case "M":	
							milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "month", renewalInterval);
							break;
						case "Y":	
							milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "year", renewalInterval);		
							break;
						default:
							break;
		            	}
		                  var finalExpiryOnFirstRenewal = new Date(milliSecTillLastRenewal.getTime());
		                  
	                	  switch (rollingRenewalIntervalUnit) {
							case "D":	 
								milliSecTillLastRollingRenewal =  d.date.add(finalExpiryOnFirstRenewal, "day", (numOfRenewals-1) * rollingRenewalInterval);
								break;
							case "W":	
								milliSecTillLastRollingRenewal = d.date.add(finalExpiryOnFirstRenewal, "week", (numOfRenewals-1) * rollingRenewalInterval);		
								break;
							case "M":	
								milliSecTillLastRollingRenewal = d.date.add(finalExpiryOnFirstRenewal, "month", (numOfRenewals-1) * rollingRenewalInterval);
								break;
							case "Y":	
								milliSecTillLastRollingRenewal = d.date.add(finalExpiryOnFirstRenewal, "year", (numOfRenewals-1) * rollingRenewalInterval);		
								break;
							default:
								break;
	                	  }
	                	  var finalExpiryOnRollingRenewal = new Date(milliSecTillLastRollingRenewal.getTime());
	                	  dj.byId("final_expiry_date").set("value",finalExpiryOnRollingRenewal);
		            }
	            }*/
	            if(!isPreCondStsfd) {
	            	var rollingFinalExpiryDate = dj.byId("final_expiry_date");
	    			if(rollingFinalExpiryDate && rollingFinalExpiryDate.get("value") !== ""){
	    				rollingFinalExpiryDate.set("value",new Date().getHours());
	    			}
	            }
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This method is to calculate and set the renewal of final expiry date.
		 * <h4>Description:</h4> 
		 * In this method depending on "renew_on_code", "renew_for_nb", "renew_for_period" and the final expiry date is calculated.
		 * If renew_on_code = 01, i.e. on expiry, calculate the new date based on existing expiry date, the renew for data, and the number of renewals.
		 * If renew_on_code = 02, i.e. on calendar date, calculate the new date based on existing expiry date, the renew for data, and the number of renewals.
		 * @method calculateRenewalFinalExpiryDate
		 * 
		 */
		calculateRenewalFinalExpiryDate : function(){
            var renewalOn = dj.byId("renew_on_code")?dj.byId("renew_on_code").get("value"):"";                        //Whether the first renewal is on "Expiry('01')" or "Calendar Date('02')"
            var renewalCalDate = dj.byId("renewal_calendar_date")?dj.byId("renewal_calendar_date").get("value"):"";        //Date String, if first renewal is on a "Calendar Date('02')"
            var renewalInterval = dj.byId("renew_for_nb")?dj.byId("renew_for_nb").get("value"):"";                   //Interval between subsequent renewals (number) 
            var renewalIntervalUnit = dj.byId("renew_for_period")?dj.byId("renew_for_period").get("value"):"";       //Unit of interval i.e., whether it is "Days"/"Weeks"/"Months"/"Years".This along with the interval forms the frequency of renewal.
                                                                                          //For ex. Once in 10(renewalInterval) months (renewalIntervalUnit)
            var numOfRenewals = dj.byId("rolling_renewal_nb")?dj.byId("rolling_renewal_nb").get("value"):"";                  //Number of renewals allowed
            var milliSecTillLastRenewal = null;
            var firstRenewalDateObj = null;
            var isPreCondStsfd = true;
            var calcFinalExpDate = null;
            if(renewalOn === "01") {
                  firstRenewalDateObj = dj.byId("exp_date")?dj.byId("exp_date").get("value"):"";
                  var orgExpDate = dj.byId("org_exp_date")?dj.byId("org_exp_date"):"";
                  if(!firstRenewalDateObj && orgExpDate)
                	{
                	  firstRenewalDateObj = dojo.date.locale.parse(orgExpDate.get("value"),{locale:dojo.config.locale, formatLength:"short", selector:"date" });
                	}
                  if(firstRenewalDateObj == null) {
                        isPreCondStsfd = false;
                  }
            }
            else if(renewalOn === "02") {
                  firstRenewalDateObj = renewalCalDate;
                  if(firstRenewalDateObj == null)
                  {
                        isPreCondStsfd = false;
                  }
            }
            else{
                  isPreCondStsfd = false;
            }
            if(renewalInterval == null || renewalInterval === "" || isNaN(renewalInterval))
            {
            	isPreCondStsfd = false;
            }
            if(renewalIntervalUnit == null || renewalIntervalUnit === "")
            {
            	isPreCondStsfd = false;
            }
            if(numOfRenewals == null || numOfRenewals === "" || isNaN(numOfRenewals))
            {
            	isPreCondStsfd = false;
            }
            	            
            if(isPreCondStsfd && numOfRenewals) {
                  switch (renewalIntervalUnit) {
					case "D":	 
						milliSecTillLastRenewal =  d.date.add(firstRenewalDateObj, "day", numOfRenewals * renewalInterval);
						break;
					case "W":	
						milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "week", numOfRenewals * renewalInterval);		
						break;
					case "M":	
						milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "month", numOfRenewals * renewalInterval);
						break;
					case "Y":	
						milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "year", numOfRenewals * renewalInterval);		
						break;
					default:
						break;
				}
                  if(milliSecTillLastRenewal)
                	  {
	                	  calcFinalExpDate = new Date(milliSecTillLastRenewal.getTime());
	                      calcFinalExpDate = calcFinalExpDate.getDate() + '/' + (calcFinalExpDate.getMonth() + 1) + '/' +  calcFinalExpDate.getFullYear();
	                      var finalExpiryOnRollingRenewal = new Date(milliSecTillLastRenewal.getTime());
	                	  dj.byId("final_expiry_date").set("value",finalExpiryOnRollingRenewal);
                	  }
            }
            
            return calcFinalExpDate;
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This method is to calculate renewal of final expiry date.
		 * <h4>Description:</h4> 
		 * In this method depending on "renew_on_code", "renew_for_nb", "renew_for_period" and the final expiry date is calculated.
		 * If renew_on_code = 01, i.e. on expiry, calculate the new date based on existing expiry date, the renew for data, and the number of renewals.
		 * If renew_on_code = 02, i.e. on calendar date, calculate the new date based on existing expiry date, the renew for data, and the number of renewals.
		 * @method calculateRenewalFinalExpiryDate
		 * 
		 */
		calculateFinalExpiryDate : function(){
            var renewalOn = dj.byId("renew_on_code")?dj.byId("renew_on_code").get("value"):"";                        //Whether the first renewal is on "Expiry('01')" or "Calendar Date('02')"
            var renewalCalDate = dj.byId("renewal_calendar_date")?dj.byId("renewal_calendar_date").get("value"):"";        //Date String, if first renewal is on a "Calendar Date('02')"
            var renewalInterval = dj.byId("renew_for_nb")?dj.byId("renew_for_nb").get("value"):"";                   //Interval between subsequent renewals (number) 
            var renewalIntervalUnit = dj.byId("renew_for_period")?dj.byId("renew_for_period").get("value"):"";       //Unit of interval i.e., whether it is "Days"/"Weeks"/"Months"/"Years".This along with the interval forms the frequency of renewal.
                                                                                          //For ex. Once in 10(renewalInterval) months (renewalIntervalUnit)
            var numOfRenewals = dj.byId("rolling_renewal_nb")?dj.byId("rolling_renewal_nb").get("value"):"";                  //Number of renewals allowed
            var milliSecTillLastRenewal = null;
            var firstRenewalDateObj = null;
            var isPreCondStsfd = true;
            if(renewalOn === "01") {
                  firstRenewalDateObj = dj.byId("exp_date")?dj.byId("exp_date").get("value"):"";
                  var orgExpDate = dj.byId("org_exp_date")?dj.byId("org_exp_date"):"";
                  if(!firstRenewalDateObj && orgExpDate)
                	{
                	  firstRenewalDateObj = dojo.date.locale.parse(orgExpDate.get("value"),{locale:dojo.config.locale, formatLength:"short", selector:"date" });
                	}
                  if(firstRenewalDateObj == null) {
                        isPreCondStsfd = false;
                  }
            }
            else if(renewalOn === "02") {
                  firstRenewalDateObj = renewalCalDate;
                  if(firstRenewalDateObj == null)
                  {
                        isPreCondStsfd = false;
                  }
            }
            else{
                  isPreCondStsfd = false;
            }
            if(renewalInterval == null || renewalInterval === "" || isNaN(renewalInterval))
            {
            	isPreCondStsfd = false;
            }
            if(renewalIntervalUnit == null || renewalIntervalUnit === "")
            {
            	isPreCondStsfd = false;
            }
            if(numOfRenewals == null || numOfRenewals === "" || isNaN(numOfRenewals))
            {
            	isPreCondStsfd = false;
            }
            	            
            if(isPreCondStsfd && numOfRenewals) {
                  switch (renewalIntervalUnit) {
					case "D":	 
						milliSecTillLastRenewal =  d.date.add(firstRenewalDateObj, "day", numOfRenewals * renewalInterval);
						break;
					case "W":	
						milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "week", numOfRenewals * renewalInterval);		
						break;
					case "M":	
						milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "month", numOfRenewals * renewalInterval);
						break;
					case "Y":	
						milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "year", numOfRenewals * renewalInterval);		
						break;
					default:
						break;
				}
                  if(milliSecTillLastRenewal)
                	  {
	                      var finalExpiryOnRollingRenewal = new Date(milliSecTillLastRenewal.getTime());
                	  }
            }
            
            return finalExpiryOnRollingRenewal;
		},
		/**
		 * <h4>Summary:</h4>
		 * This method is for Marking a widget as loading
		 * <h4>Description:</h4> 
		 * Mark as loading if icon is not there
		 * @param {String} idField
		 * @param {Boolean} isLoading
		 * @method markWidgetAsLoading
		 */
		markWidgetAsLoading : function(/*String*/ idField, /*Boolean*/ isLoading)
		{
			var spanId = idField + "_id_loading_span";
			if (dj.byId(idField))
			{
				var loadingIconDomNode;
				if (isLoading)
				{
					if (!d.byId(spanId)) //Do not add another icon if there is one already 
					{
						dj.byId(idField).set("disabled", true);
						var loadingIcon = '<img src="' + m._config["context"] + m._config["imagesSrc"] + 'loading.gif"/>';
						loadingIconDomNode = d.create("span", {innerHTML: loadingIcon, id:spanId}, dj.byId(idField).domNode, "after");
						dj.byId(idField).set("loadingIconDomNode", loadingIconDomNode);
					}
				}
				else
				{
					loadingIconDomNode = dj.byId(idField).get("loadingIconDomNode");
					dj.byId(idField).set("loadingIconDomNode", null);
					d.destroy(loadingIconDomNode);
					dj.byId(idField).set("disabled", false);
				}
			}
		},
		/**
		 * <h4>Summary:</h4>
		 *  Populate a select box based on the content of the current bank, entity and Customer reference.
		 *  @param {Object} referenceWidget
		 * @method populateFacilityReference
		 * 
		 */
		populateFacilityReference : function(referenceWidget)
		{
			 //  summary:
		    //        Populate a select box based on the content of the current bank, entity and Customer reference 
			//        selection.

			// Retrieve the prefix and set the name value;
			var customerReference 		= referenceWidget.get("value"),
		    	splitter				= "_",
		    	tokens 					= referenceWidget.id.split(splitter),
		    	prefix					= tokens[0] + splitter + tokens[1],
		    	bankAbbvName			= dj.byId(prefix + "_abbv_name") ? dj.byId(prefix + "_abbv_name").get("value") : "",
		    	entityName				= dj.byId("entity") ? dj.byId("entity").get("value") : "",
		    	facilityWidget			= dj.byId("facility_id"),
		        facilityReferenceStore	= [],
		    	facilityDetailsDivId 	= d.byId("facilityLimitDetail");
				
		    	
				
	    	if(customerReference + "S" !== "S" && m._config.facilityReferenceCollection && m._config.facilityReferenceCollection[customerReference] && facilityWidget && facilityDetailsDivId && m._config.facilityReferenceCollection[customerReference][bankAbbvName + "_" + entityName])
    		{
	    		facilityWidget.set("displayedValue","");
	    		facilityReferenceStore = m._config.facilityReferenceCollection[customerReference][bankAbbvName + "_" + entityName];
	    		if(facilityReferenceStore)
    			{
	    			console.debug("[misys.form.common] Set Facility Reference Store ");
	    			facilityWidget.store = new dojo.data.ItemFileReadStore(
	    					{
	    						data :
	    						{
	    							identifier : "value",
	    							label : "name",
	    							items : facilityReferenceStore
	    						}
	    					});
	    			m.animate("wipeIn",facilityDetailsDivId);
	    			if(dj.byId("facility_mandatory") && dj.byId("facility_mandatory").get("value") === "true")
	    			{
	    				m.toggleRequired("facility_id", true);
	    			}
	    			if(m._config.limitFieldIdCollection)
	    			{
	    				_resetLimitDetails();
	    				dj.byId("limit_id").set("displayedValue","");
	    				if(!m._config.isLoading && dj.byId("limit_reference") && dj.byId("limit_reference").get("value")+"S" !== "S")
    					{
	    					dj.byId("limit_reference").set("value","");
    					}
	    			}
    			}
    		}
	    	else
    		{
	    		m.animate("wipeOut",facilityDetailsDivId);
				m.toggleRequired("facility_id", false);
				
    		}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for getting limit details for a specific facility.
		 * @method getLimitDetails
		 */
		getLimitDetails : function(/*boolean*/ isAmendment)
		{
		//  summary:
			// Set facility review date based on Facility Reference
			
			var faclilityDate 			= dj.byId("facility_date"),
				facilityReferenceWidget = dj.byId("facility_reference"),
				facilityIdWidget 		= dj.byId("facility_id");
			
			if(faclilityDate && facilityIdWidget)
			{
				console.debug("[misys.form.common] Facility Date for "+facilityIdWidget.get("displayedValue") );
				if(m._config.facilityReviewDateCollection && m._config.facilityReviewDateCollection[facilityIdWidget.get("displayedValue")])
				{
					faclilityDate.set("displayedValue", m._config.facilityReviewDateCollection[facilityIdWidget.get("displayedValue")]);
				}
				else 
				{
					faclilityDate.set("displayedValue","");
				}
			}
			if(facilityReferenceWidget)
			{
				facilityReferenceWidget.set("value",dj.byId("facility_id").get("displayedValue"));
			}
			var entity 				= dj.byId("entity") ? dj.byId("entity").get("value") : "",
				productTypeCodeId 	= m._config.productCode.toLowerCase()+"_type_code",
				facilityId 			= facilityIdWidget ? facilityIdWidget.get("value") : "",
				facilityReference 	= facilityReferenceWidget ? facilityReferenceWidget.get("displayedValue") : "",
				productTypeCode 	= dj.byId(productTypeCodeId) ? dj.byId(productTypeCodeId).get("value") : "",
				country 			= dj.byId("beneficiary_country") ? dj.byId("beneficiary_country").get("value") : "";
				
			if(isAmendment || (country !== ""))
			{
				console.debug("[misys.form.common] Fetching Available Limit for "+facilityReferenceWidget.get("value") );
				m.xhrPost( {
					url : m.getServletURL("/screen/AjaxScreen/action/GetLimitsJSONDataAction"),
					handleAs 	: "json",
					sync 		: true,
					content : {
						facility : facilityReference ,
						facilityId :  facilityId,
						productCode : m._config.productCode,
						entity : entity,
						subProduct : "",
						productTypeCode : productTypeCode,
						beneficiary :  "",
						beneficiaryCountry : country
					},
					load : _setLimitCollection
				});
			
				var limitIdWidget 				= dj.byId("limit_id"),
					limitReference				= dj.byId("limit_reference");
				//set limit id from hidden field while form is loading
				if(limitReference && limitIdWidget && limitIdWidget.get("value") + "S" === "S")
				{
					limitIdWidget.set("displayedValue",limitReference.get("value"));
				}
				else if(limitIdWidget)
				{
					limitIdWidget.set("displayedValue","");
				}
				_resetLimitDetails();
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * This method is for setting Limit details from collection
		 * @method  setLimitFieldsValue
		 */
		setLimitFieldsValue : function()
		{
			
			//Summary
			//Method to set limit details from Collection
			  var limitReference 		= this.get("displayedValue"),
			  		fieldIds 			= m._config.limitFieldIdCollection,
			  		limitFieldValues 	= m._config.limitCollection[limitReference];
			  
			  if(dj.byId("limit_reference"))
			  {
				  dj.byId("limit_reference").set("value",this.get("displayedValue"));
			  }
			  console.debug("[misys.form.common] Setting Limit Field Values ");
			  d.forEach(fieldIds, function(id, index){
				  var obj = dj.byId(id);
				  if(obj && limitFieldValues) 
				  {
					  if(obj.declaredClass === "dijit.form.DateTextBox")
					  {
						  obj.set("displayedValue", limitFieldValues[index]);
					  }
					  else
					  {
					  	obj.set("value", limitFieldValues[index]);
					  }
				  }
				  else if(obj)
				  {
					  obj.set("displayedValue","");
				  }
			  });
		},
		/**
		 * <h4>Summary:</h4>
		 * Method to validate Booking amount against outstanding amounts
		 * Tnx amount is converted based on limit currency
		 * @method validateLimitBookingAmount
		 */
		validateLimitBookingAmount : function(event)
		{
			//Summary
			//Method to validate Booking amount against outstanding amounts
			//Tnx amount is converted based on limit currency
			var	transactionAmtWidget 	= dj.byId(m._config.productCode.toLowerCase()+"_amt"),
				tnxCurrencyWidget 	= dj.byId(m._config.productCode.toLocaleLowerCase()+"_cur_code"),
				limitCurrencyWidget 		= dj.byId("limit_outstanding_cur_code"),
				limitAmtWidget		= dj.byId("limit_outstanding_amount"),
				facilityCurrencyWidget		= dj.byId("facility_outstanding_cur_code"),
				facilityAmtWidget 	= dj.byId("facility_outstanding_amount"),
				bookingAmountWidget 		= dj.byId("booking_amt"),
				requestCurrency = "";
			if(!m._config.isLoading)
			{
				if(this.id && this.id !== "booking_amt" && bookingAmountWidget)
				{
					bookingAmountWidget.set("value","");
				}
				console.debug("[misys.form.common] Validating Limit Booking Amount ");
				if(transactionAmtWidget && tnxCurrencyWidget && limitCurrencyWidget && limitAmtWidget && facilityCurrencyWidget && facilityAmtWidget && bookingAmountWidget)
				{
					var trasactionAmt	= transactionAmtWidget.get("value"),
						limitAmt		= limitAmtWidget.get("value"),
						facilityAmt		= facilityAmtWidget.get("value"),
						limitCurrency	= limitCurrencyWidget.get("value"),
						tnxCurrency		= tnxCurrencyWidget.get("value"),
						facilityCurrency = 	facilityCurrencyWidget.get("value"),
						bookingAmount 	= bookingAmountWidget.get("value"),
						isValid			= true,
						isValidTnxAmt	= true,
						errorMessage	= "";
					//If cross currency get mid rates and validate
					if(limitCurrency !== "" && tnxCurrency !== "" && facilityCurrency !== "")
					{
						if(limitCurrency !== tnxCurrency)
						{
							requestCurrency = tnxCurrency+"_"+limitCurrency+"_limit,";
						}
						if(facilityCurrency !== limitCurrency)
						{
							requestCurrency = requestCurrency+facilityCurrency+"_"+limitCurrency+"_facility";
						}
						if(requestCurrency+"S" !== "S")
						{
							m.getCurrencyRateForFacility(requestCurrency);
							if(isNaN(bookingAmount) || bookingAmount === "" || (event !== undefined && event === "true"))
							{
								if(m._config.limitRate)
								{
									bookingAmount = trasactionAmt*m._config.limitRate;
									bookingAmountWidget.attr("value",bookingAmount,false);
									dj.byId("tol_booking_amt").attr("value",bookingAmount,false);
								}
								if(isNaN(bookingAmount) || bookingAmount === "" || (event !== undefined && event === "true" && trasactionAmt < bookingAmount))
								{
									bookingAmountWidget.attr("value",bookingAmount,false);
									dj.byId("tol_booking_amt").attr("value",bookingAmount,false);
								}
								if(dj.byId("pstv_tol_pct") && (!isNaN(dj.byId("pstv_tol_pct").get("value"))))
								{
								bookingAmount = bookingAmount + bookingAmount * (dj.byId("pstv_tol_pct").get("value")/100.0);
								bookingAmountWidget.attr("value",bookingAmount,false);
								dj.byId("tol_booking_amt").attr("value",bookingAmount,false);
								}
							}
							
							if(bookingAmount > dj.byId("tol_booking_amt") ? dj.byId("tol_booking_amt").get('value') : 0)
							{
							isValid = false;
							errorMessage = m.getLocalization("invalidBookingAmountTnx");
							
							}
							
							if(isValid && bookingAmount > limitAmt)
							{
								isValid = false;
								if(m._config.limitRate !== 1)
								{
									errorMessage = m.getLocalization("invalidBookingAmountCurrency", ["Limit",tnxCurrency+"/"+limitCurrency]);
								}
								else
								{
									errorMessage = m.getLocalization("invalidBookingAmount", ["Limit"]);
								}
							}
							if(isValid && bookingAmount > facilityAmt*m._config.facilityRate)
							{
								isValid = false;
								if(m._config.facilityRate !== 1)
								{
									errorMessage = m.getLocalization("invalidBookingAmountCurrency", ["Facility",facilityCurrency+"/"+limitCurrency]);
								}
								else
								{
									errorMessage = m.getLocalization("invalidBookingAmount", ["Limit"]);
								}
							}
							
							if(m._config.validate_tnxamt_with_limit_outstanding)
							{
								if(isValid && dj.byId("tol_booking_amt").get('value') > limitAmt) //MPS-40477
								{
									isValid = false;
									isValidTnxAmt = false;
									errorMessage = m.getLocalization("invalidTnxAmount");
								}
							}
						}
						else
						{
							if(isNaN(bookingAmount) || bookingAmount === "" || (event !== undefined && event === "true"))
							{
								if(isNaN(bookingAmount) || bookingAmount === "" || (event !== undefined && event === "true" && trasactionAmt < bookingAmount))
								{
									bookingAmount = trasactionAmt;
									if(dj.byId("pstv_tol_pct") && (!isNaN(dj.byId("pstv_tol_pct").get("value"))))
									{
									bookingAmount = bookingAmount + bookingAmount * (dj.byId("pstv_tol_pct").get("value")/100.0);
									}
									bookingAmountWidget.attr("value",bookingAmount,false);
									dj.byId("tol_booking_amt").attr("value",bookingAmount,false);
								}
								if(dj.byId("pstv_tol_pct") && (!isNaN(dj.byId("pstv_tol_pct").get("value"))))
								{
								bookingAmount = trasactionAmt;
								bookingAmount = bookingAmount + bookingAmount * (dj.byId("pstv_tol_pct").get("value")/100.0);
								bookingAmountWidget.attr("value",bookingAmount,false);
								dj.byId("tol_booking_amt").attr("value",bookingAmount,false);
								}
							}
							if(bookingAmount > dj.byId("tol_booking_amt") ? dj.byId("tol_booking_amt").get('value') : 0)
							{
							isValid = false;
							errorMessage = m.getLocalization("invalidBookingAmountTnx");
							
							}
							if(isValid && bookingAmount > limitAmt)
							{
								isValid = false;
								errorMessage = m.getLocalization("invalidBookingAmount", ["Limit"]);
							}
							if(isValid && bookingAmount > facilityAmt)
							{
								isValid = false;
								errorMessage = m.getLocalization("invalidBookingAmount", ["Facility"]);
							}
							if(m._config.validate_tnxamt_with_limit_outstanding)
							{
								if(isValid && dj.byId("tol_booking_amt").get('value') > limitAmt) //MPS-40477
								{
									isValid = false;
									isValidTnxAmt = false;
									errorMessage = m.getLocalization("invalidTnxAmount");
								}
							}							
						}
					}
					if(!isValid)
					{
						var onErrorCallback1;
						if(!isValidTnxAmt)
						{
							dj.hideTooltip(transactionAmtWidget.domNode);
							onErrorCallback1 = function(){
								transactionAmtWidget.focus();
								transactionAmtWidget.set("state","Error");
								dj.showTooltip(errorMessage, transactionAmtWidget.domNode, 0);								
								};						
						}
						else
						{
							dj.hideTooltip(bookingAmountWidget.domNode);
							onErrorCallback1 = function(){
								bookingAmountWidget.focus();
								bookingAmountWidget.set("state","Error");
								dj.showTooltip(errorMessage, bookingAmountWidget.domNode, 0);
								
								};
						}
						m.dialog.show("ERROR", errorMessage, "", onErrorCallback1);
						return false;
					}
				}
			}
			else if(this.id === "limit_id")
			{
				m._config.isLoading = false;
			}
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This method is for getting currency rate for facility.
		 * <h4>Description:</h4> 
		 * Fetching currency rate for limit validation.
		 * @method {Object} requestCurrency
		 */
		getCurrencyRateForFacility : function(requestCurrency)
		{
			console.debug("[misys.form.common] Fetching MidRates for Limit Validation ");
			var recipientBankAbbvName = dijit.byId('recipient_bank_abbv_name');
			m.xhrPost( {
				url : m.getServletURL("/screen/AjaxScreen/action/GetMidRateForLimitAction"),
				handleAs 	: "json",
				sync 		: true,
				content 	: {
								currency  : requestCurrency,
								bank_abbv_name : recipientBankAbbvName
							  },
				load		: function(response, args){
								m._config.limitRate 	= 	response.limit ? response.limit : 1;
								m._config.facilityRate 	= 	response.facility ? response.facility : 1;
								m._config.rateType 		=	response.rateType ? response.rateType : 1;
								}
			});
			
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This method is used to fetch user details auto populate the selected users
		 *
		 */
		getUserDetails : function(/*String*/loginName, /* String*/userId)
		{
			console.debug("[misys.form.common] Fetching selected user details ");
			var formXml = m.formToXML({
				selector: ".validate",
				xmlRoot: m._config.xmlTagName,
				ignoreDisabled: true
			});
			m.xhrPost( {
				url : m.getServletURL("/screen/AjaxScreen/action/GetUserDetails"),
				handleAs 	: "json",
				sync 		: true,
				content 	: {
								login_id : loginName,
								user_id  : userId,
								xmlString : formXml
							  },
				load		: _PopulateCloneUserDetails

			});
		},
		/**
		 * <h4>Summary:</h4>
		 * This method is used to fetch phrase content dynamically from the form
		 * and set in the text area field. 
		 */
		getDynamicNarrativeText : function(/*Node*/ widgetNode,/*String*/phraseId )
		{
			console.debug("[misys.form.common] Fetching Dynamic Text ");
			var formXml = m.formToXML({
				selector: ".validate",
				xmlRoot: m._config.xmlTagName,
				ignoreDisabled: true
			});
			var prodCode = dijit.byId("product_code")? dijit.byId("product_code").get("value") :"";
			m.xhrPost( {
				url : m.getServletURL("/screen/AjaxScreen/action/GetDynamicNarrativeText"),
				handleAs 	: "json",
				sync 		: true,
				content 	: {
								phrase_id  : phraseId,
								field : widgetNode,
								xmlString : formXml,
								product_code : prodCode
							  },
				load		: _showDynamicNarrativeText
			});
		},
		/**
		 * <h4>Summary:</h4>
		 * This method is used to toggle products list when phrase type is changed.
		 */
		togglePhraseProducts : function()
		{
			console.debug("[misys.form.common] Toggling product fields. ");
			var phraseType = dj.byId("phrase_type") ? dj.byId("phrase_type").get("value") : dj.byId("type").get("value"), 
				existingProductSelectWidget = dj.byId("productcode") ? dj.byId("productcode") : dj.byId("product"), 
				productDataStore = m._config.phraseTypesProductMap[phraseType];
	
			// Remove the existing product and sub product entries
			if(!misys._config.isModified)
			{
				existingProductSelectWidget.set("value", "");
			}
	
			if (productDataStore)
			{
				// Load sub product items based on the newly selected Area (sorted by
				// name)
				existingProductSelectWidget.store = new dojo.data.ItemFileReadStore(
				{
					data :
					{
						identifier : "value",
						label : "name",
						items : productDataStore
					}
				});
				existingProductSelectWidget.fetchProperties =
				{
					sort : [
					{
						attribute : "name"
					} ]
				};
				existingProductSelectWidget.set("value", "");
				existingProductSelectWidget.focus();
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * This method is used to toggle category list when product is changed.
		 */
		togglePhraseCategory : function()
		{
			console.debug("[misys.form.common] Toggling phrase category. ");
			var productCode = dj.byId("productcode")? dj.byId("productcode").get("value") : dj.byId("product").get("value"), 
				existingCategoryWidget = dj.byId("category"), 
				categoryStore = m._config.productCategoryMap[productCode];
				
			if(productCode !== "")
			{
				if (categoryStore)
				{
					// Load sub product items based on the newly selected Area (sorted by
					// name)
					existingCategoryWidget.store = new dojo.data.ItemFileReadStore(
					{
						data :
						{
							identifier : "value",
							label : "name",
							items : categoryStore
						}
					});
					existingCategoryWidget.fetchProperties =
					{
						sort : [
						{
							attribute : "value"
						} ]
					};
					existingCategoryWidget.set("value", "");
					existingCategoryWidget.focus();
					existingCategoryWidget.set("state", "Error");
				}
				else
				{
					categoryStore = m._config.productCategoryMap["ALL"];
					existingCategoryWidget.store = new dojo.data.ItemFileReadStore(
					{
						data :
						{
							identifier : "value",
							label : "name",
							items : categoryStore
						}
					});
					existingCategoryWidget.fetchProperties =
					{
						sort : [
						{
							attribute : "value"
						} ]
					};
				}
			}
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This method is used to make ajax call for fetching data from search pop up form
		 * for the search fields (fieldsArray) and option (opt).
		 * The id passed is the store id where the ajax response is set. The widget id is the id used for the 
		 * setting the callback if required in the grid items.
		 */
		getAjaxSearchData : function (/*Store id*/ id, /*search fields*/ fieldsArray, /*option*/ opt, /*widget */ widgetId)
		{
			console.debug("[misys.form.common] getAjaxSearchData : Ajax call from search fields");
			
			var count = 0;
			// get the product code from the form
			var prodCode = dijit.byId("product_code")? dijit.byId("product_code").get("value") :"";
			var arrString = "[";
			dojo.forEach(fieldsArray, function(field){
				var widget = dj.byId(field);
				if(widget && widget.state === "Error")
				{
					return;
				}
				if(count !== 0) {
					arrString = arrString + ",";
				}
				count++;
				if(widget)
				{
					arrString = arrString +"'" + widget.get("value") + "'";
					
				}
				else {
					arrString = arrString + "''";
				}
			});
			arrString = arrString + "]";
			var widgetString = "[";
			count= 0;
			while(count!=(widgetId.length-1))
			{
				widgetString = widgetString +"'" + widgetId[count] + "',";
				count++;
			}
			widgetString = widgetString +"'" + widgetId[count] + "']";
				
			
			m.xhrPost( {
				url : m.getServletURL("/screen/AjaxScreen/action/GetStaticDataSearchAction"),
				handleAs 	: "json",
				sync 		: true,
				content 	: {
								option : opt,
								store_id  : id,
								"widget[]" : widgetString,
								productcode : prodCode,
								"fields[]" : arrString
							  },
				load		: _showAjaxSearchData
			});
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This method is used to toggle the fields on mutual exclusive principle
		 * for the fields (fieldsArray).
		 */
		toggleMutuallyExclusiveFields : function ( /*fields */ fieldsArray) {
			console.debug("[misys.form.common] toggleMutuallyExclusiveFields : toggle fields");
			var emptyFlag = true;
			var enabled = false;
			dojo.forEach(fieldsArray, function(field) {
				var widget = dj.byId(field);
				if((widget.declaredClass === 'dijit.form.NumberTextBox') || (widget.declaredClass === 'misys.form.CurrencyTextBox')) {
					if(widget && !enabled && widget.get("value")+"" !== "NaN") {
						widget.set("disabled",false);
						enabled = true;
						emptyFlag = false;
					}
					else {
						widget.set("disabled",true);
					}
				}
				else {
					if(widget && !enabled && widget.get("value") !== "" ) {
						widget.set("disabled",false);
						enabled = true;
						emptyFlag = false;
					}
					else {
						widget.set("disabled",true);
					}
				}
				
			});
			if(emptyFlag) {
				dojo.forEach(fieldsArray, function(field) {
					var widget = dj.byId(field);
					if(widget) {
						widget.set("disabled",false);
					}
				});
			}
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This method is used to toggle the mandatory fields on mutual exclusive principle
		 * for the fields (fieldsArray). It disables the fields as well as makes them non mandatory.
		 */
		toggleMutuallyExclusiveMandatoryFields : function ( /*fields */ fieldsArray) {
			console.debug("[misys.form.common] toggleMutuallyExclusiveMandatoryFields : toggle fields");
			var emptyFlag = true;
			var enabled = false;
			dojo.forEach(fieldsArray, function(field) {
				var widget = dj.byId(field);
				if((widget.declaredClass === 'dijit.form.NumberTextBox') || (widget.declaredClass === 'misys.form.CurrencyTextBox')) {
					if(widget && !enabled && widget.get("value")+"" !== "NaN") {
						widget.set("disabled",false);
						widget.set("required", true);
						enabled = true;
						emptyFlag = false;
					}
					else {
						widget.set("disabled",true);
						widget.set("required", false);
					}
				}
				else {
					if(widget && !enabled && widget.get("value") !== "" ) {
						widget.set("disabled",false);
						widget.set("required", true);
						enabled = true;
						emptyFlag = false;
					}
					else {
						widget.set("disabled",true);
						widget.set("required", false);
					}
				}
				
			});
			if(emptyFlag) {
				dojo.forEach(fieldsArray, function(field) {
					var widget = dj.byId(field);
					if(widget) {
						widget.set("disabled",false);
						widget.set("required", true);
					}
				});
			}
		},
		getPrgmCpty: function(/*String*/program_id) {
			misys.showProgramCptyDialog('programCounterparty',"['abbv_name','name']",program_id,'','width:400px;height:400px',m.getLocalization("TABLE_PROGRAM_CPTY_LIST"),'legal' === 'popup');
		},
		
		/**
		 * <h4>Summary:</h4>
		 * When action === "required" : This method is used to toggle the mutual inclusive principle
		 * for the fields.If one widget is present, mandate the other and vice versa.
		 *  When action === "disabled" : This method is used to toggle enable/disbale one field based on the value of another field. 
		 */
		toggleMutuallyInclusiveFields : function (/*field*/ field1,/*field*/ field2,/*String*/ action) {
			var widget1 = dj.byId(field1);
			var widget2 = dj.byId(field2);
			if(action === "required"){
				if(widget1 &&  widget1.value !== "" && widget2)
				{
					widget2.set("required",true);
				}
				else if(widget1 &&  widget1.value === "" && widget2)
				{
					widget2.set("required",false);
				}
			}
			else if(action === "disabled"){
				if(widget1 && widget1.disabled === true){
					widget2.set("disabled", true);
					widget2.set("value","");
				}
				else if(widget1 && widget1.disabled === false){
					widget2.set("disabled", false);
				}
			}
		},
		toggleTransferIndicatorFlag : function( /*Boolean*/ keepFieldValues) {
			if(dj.byId("ntrf_flag").get("checked"))
				{
					dj.byId("narrative_transfer_conditions").set("disabled", true);
					dj.byId("narrative_transfer_conditions").set("value", "");
					document.getElementById("narrative_transfer_conditions_img").style.display = "none";
				}
			else
				{
					dj.byId("narrative_transfer_conditions").set("disabled", false);
					dj.byId("narrative_transfer_conditions").set("value", "");
					document.getElementById("narrative_transfer_conditions_img").style.display = "block";
				}
		},
		toggleDeliverMode : function( /*Boolean*/ keepFieldValues) {
			if(dj.byId("delv_org").get("value") === "99")
				{
					dj.byId("delv_org_text").set("disabled", false);
				}
			else
				{
					dj.byId("delv_org_text").set("disabled", true);
					dj.byId("delv_org_text").set("value", "");
				}
		},
		
		
		/**
		 * <h4>Summary:</h4>
		 * This function is to clear the date array
		 */
		clearDateCache : function()
		{
			misys._config.dateCache=[];
		},
		
		setDraweeDetailBankName : function()
		{
			if( (dj.byId("cr_avl_by_code_2") && dj.byId("cr_avl_by_code_2").get("checked")) || (dj.byId("cr_avl_by_code_3") && dj.byId("cr_avl_by_code_3").get("checked")))
			{
				dj.byId("drawee_details_bank_name").set("value",dj.byId("drawee_details_bank_name")._resetValue);
			}
		},
		
		
		escapeHtml: function(/*String*/str){
			//	summary:
			//		Utility function to escape XML special characters in an HTML string.
			//	description:
			//		Utility function to escape XML special characters in an HTML string.
			//
			//	str:
			//		The string to escape
			//	returns:
			//		HTML String with special characters (<,>,&, ", etc,) escaped.
			return str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;").replace(/'/gm, "&#39;"); // String
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is for showing fscm program for finance request, in a dialog.
		 * 
		 * @param String
		 * @param String[]
		 * @param String
		 * @param String
		 * @param String
		 * @param String
		 * @param boolean
		 * @method showFSCMProgramFinanceRequestDialog
		 */
		showFSCMProgramIPCollectionDialog : function( /*String*/ type,
								 	 	  /*String[]*/ fields, 
								 	 	  /*String*/ parameter, 
								 	 	  /*String*/ screen,
								 	 	  /*String*/ dimensions, 
								 	 	  /*String*/ title, 
								 	 	  /*Boolean*/ isInPopup){
							
			var url = [],
				query = {},
				contentURL = ajaxActionUrl,
				queryStore = {},
				urlAction = "GetStaticData", 
				urlScreen = screen || ajaxStaticDPopup, 
				onLoadCallback, childDialog;

			// Check that the dimensions have a trailing
			// semi-colon
			// as it will be appended to other rules later
			if (dimensions.slice(dimensions.length - 1) !== ";") {
				dimensions += ";";
			}

			contentURL += urlAction;
			queryStore.option = type;
			queryStore.fields = fields;
			d.mixin(queryStore, parameter);

			url.push("/screen/", urlScreen);
			
			query.option = type;
			query.fields = fields;
			d.mixin(query, parameter);
			query.dimensions = dimensions;
			query.popupType = "LIST_DATA";

			console.debug(messageGridContent, contentURL);

			// Load data
			onLoadCallback = function() {
				var grid = dj.byId(type + "data_grid");
				grid.showMessage(grid.loadingMessage);
				m.grid.setStoreURL(grid, m.getServletURL(contentURL), queryStore);
				m.connect("CurrencyName", "onKeyPress", function(evnt){
					if(evnt.keyCode === dojo.keys.ENTER){
						m.grid.filter(dj.byId('currencydata_grid'), ['NAME'], ['CurrencyName']);
				  }
				});
				
			};

			if (isInPopup) 
			{
				console.debug(chilDialog, url.join(""));
				childDialog = dj.byId("childXhrDialog") || new dj.Dialog({
																	title : title,
																	id : "childXhrDialog",
																	href : m.getServletURL(url.join("")),
																	ioMethod: misys.xhrPost,
																	ioArgs: { content: query }
																});

				m.dialog.connect(childDialog, "onLoad", onLoadCallback);
				m.dialog.connect( childDialog, "onHide", 
						function() {
										setTimeout(function() {
											m.dialog.disconnect(childDialog);
											childDialog.destroyRecursive();
										}, 2000);
									}
				);

				// Offset the dialog from the parent window
				var co = d.coords("xhrDialog");
				childDialog._relativePosition = {
					x : co.x + 30,
					y : co.y + 30
				};

				childDialog.show();
			} 
			else 
			{
				m.dialog.show("URL", "", title, null, onLoadCallback, m.getServletURL(url.join("")), null, null, query);
			}
		},
		clearDataOnclicTenortype2or3 : function() {
			dj.byId("tenor_maturity_date").set("displayedValue", "");
			dj.byId("tenor_days").set("value", "");
			dj.byId("tenor_period").set("value", "");
			dj.byId("tenor_from_after").set("value", "");
			dj.byId("tenor_days_type").set("value", "");
			dj.byId("tenor_type_details").set("value", "");
			dj.byId("tenor_base_date").set("displayedValue", "");			
		}
	});

	// Onload/Unload/onWidgetLoad Events
	d.ready(function(){
		// TODO Probably shouldn't be in _config
		d.mixin(m._config, {
			advisingBank : advBank,
			anyBank: "Any Bank",
			issuingBank : "Issuing Bank",
			other : "Other",
			namedBank : "Named Bank",
			firstPageLoad : false
		}); 
	});
})(dojo, dijit, misys);


}

if(!dojo._hasResource["misys.form.file"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.form.file"] = true;
dojo.provide("misys.form.file");


// Copyright (c) 2000-2011 Misys (http://www.misys.com),
// All Rights Reserved. 
//
// Summary: 
//  Scripts for file uploads
//
//
// version:   1.1
// date:      20/04/11
// author:    Cormac Flynn


(function(/*Dojo*/d, /*Dijit*/dj, /*Misys*/m) {

	 // ECMA5 Strict Mode
	
	// Private functions & variables

	var 
		// File extensions for which we have an icon
		_extensions = ["txt", "doc", "pdf", "gif", "zip"],	
		
		// The string prefix for all file extension icons 
		_filePrefix = "file_",
		
		// The default file extension icon name
		_defaultFileExtension = "file_ext",
		
		// File type of extension icons
		_defaultFileExtensionType = ".gif",
	
		// The download file icon
		_downloadImg,
		
		// The delete file icon
		_trashImg;

	function _uploadFile( /*String*/ dialogId) {
		// summary:
		//
		
		var dialog = dj.byId(dialogId);
		if(dialog && dialog.validate()) {
			dialog.execute();
			dialog.hide();
			m.isFormDirty = true;
		}
	}
	
	function _getValidationType()
	{
		
		if(dj.byId("validation_type"))
		{
			if(dj.byId("validation_type").get("value") === "")
			{
				return "none";
			}
			else
			{
				return dj.byId("validation_type").get("value");
			}
		}
	}
	/**
	 * get the selected entity which is to be passed for file upload
	 */
	function _getSelectedEntity()
	{
		
		if(dj.byId("entity"))
		{
			if(dj.byId("entity").get("value") === "")
			{
				return "none";
			}
			else
			{
				return dj.byId("entity").get("value");
			}
		}
		else 
        {
            return "";
        }
	}
	/**
	 * get the selected file type which is to be passed for file upload
	 */
	function _getFileTypes()
	{
		
		if(dj.byId("upload_file_type"))
		{
			if(dj.byId("upload_file_type").get("value") === "")
			{
				return "none";
			}
			else
			{
				return dj.byId("upload_file_type").get("value");
			}
		}
	}

	d.mixin(m, {
		formatFileActions : function( /*String*/ value, /* String */groupAttachment) {
			//  summary:
			//          Generate the HTML containing the different possible actions in a grid.
			
			console.debug('[file] start formatFileActions');
			var outer = d.create("div"),
			    container = d.create("div", {"class" : "gridActions", "style": "text-align:center"}),
			    
			    attachmentGroup = groupAttachment;
			
			if(!_downloadImg) {
				_downloadImg = m.getContextualURL(m._config.imagesSrc +
						m._config.imageStore.downloadIcon);
			}
			if(!_trashImg) {
				_trashImg = m.getContextualURL(m._config.imagesSrc +
						m._config.imageStore.deleteIcon);
			}
			
			
			d.create("img", {
				src: _downloadImg,
				alt: m.getLocalization("view_label"),
				// TODO Change to a proper function
				onclick: "misys.downloadFile(" + value + ", '" + attachmentGroup + "')"
			}, container);
			d.create("img", {
				src: _trashImg,
				alt: m.getLocalization("delete_label"),
				type: "remove"
			}, container);
			d.place(container, outer);

			console.debug('[file] end formatFileActions');
			return outer.innerHTML;
			
		}, 
		
		formatFileViewActions : function( /*String*/ value, /* String */groupAttachment) {
			//  summary:
			//          Generate the HTML containing the different possible actions in a grid.
			console.debug('[file] start formatFileActions');
			
			var outer = d.create("div"),
			    container = d.create("div", {"class" : "gridActions", "style": "text-align:center"}),
				attachmentGroup = groupAttachment;

			if(!_downloadImg) {
				_downloadImg = m.getContextualURL(m._config.imagesSrc +
						m._config.imageStore.downloadIcon);
			}
			if(!_trashImg) {
				_trashImg = m.getContextualURL(m._config.imagesSrc +
						m._config.imageStore.deleteIcon);
			}
			
			d.create("img", {
				src: _downloadImg,
				alt: m.getLocalization("view_label"),
				// TODO Change to a proper function
				onclick: "misys.downloadFile(" + value + ", '" + attachmentGroup + "')"
			}, container);
			d.place(container, outer);
			console.debug('[file] end formatFileActions');
			return outer.innerHTML;
		}, 
		
		getFileIcon : function( /*String*/ fileName){
			//  summary:
		    //        Get the image icon.
			
			var outer = d.create("div"),
			    container = d.create("div", {"style": "text-align:center"}),
			    found = false, ext,
			    fileImg = d.create("img", {
			    	alt: m.getLocalization("download")
			    });
			
			var _extensions = m._config.uploadservice_extensions_allowed;
			if((fileName.lastIndexOf(".") !== -1) &&
			        (fileName.lastIndexOf(".") !== fileName.length - 1)) {
				ext = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
				// TODO Switch to a dojo.every/some loop
				for(var x = 0, len = _extensions.length; x < len; x++){
					if(ext === _extensions[x]) {
						found = true;
						d.attr(fileImg, "src", m.getContextualURL(m._config.imagesSrc) + 
												_filePrefix + ext + _defaultFileExtensionType);
						break;
					}
				}
			}
			if (!found) {
				d.attr(fileImg, "src", m.getContextualURL(m._config.imagesSrc) + 
												_defaultFileExtension + _defaultFileExtensionType);
			}
			d.place(fileImg, container);
			d.place(container, outer);
			return outer.innerHTML;
		}, 
		
		uploadFile : function( /*String*/ dialogId,
							   /*String*/ attachmentGroup){
			// summary: 
			//		Upload a file
			
			var fileField = dj.byId("file" + attachmentGroup) ? 
								dj.byId("file" + attachmentGroup).domNode : 
								d.byId("file"+ attachmentGroup),
				fileFieldValue = dj.byId("file" + attachmentGroup) ? 
									dj.byId("file" + attachmentGroup).get("value") : 
									fileField.value,
				attachedFiles,
				errorMessage;
				
				if (dj.byId("file_name")){
				var fileName = fileFieldValue.replace(/^.*(\\|\/|\:)/, '');
				dj.byId("file_name").set("value", fileName);
				}
									
            if(dj.byId("file_title") && dj.byId("file_title").get("value") == "")									
            {
            	return false;
            }
									
			if(!fileFieldValue) {
			   m.showTooltip(m.getLocalization("mandatoryPathToFileError"), fileField);
			   return false;
			}
			
			console.warn("[misys.form.file] Sending the request, with attachmentGroup '",attachmentGroup, +"'");	
			m.dialog.show("PROGRESS", m.getLocalization("uploadingFile"));
			
			var encodedFileName = (document.getElementById("file" + attachmentGroup) && document.getElementById("file" + attachmentGroup).files && document.getElementById("file" + attachmentGroup).files[0] && document.getElementById("file" + attachmentGroup).files[0] .name) ? encodeURIComponent(document.getElementById("file" + attachmentGroup).files[0].name): "";
			if ("" === encodedFileName ) {
				encodedFileName = encodeURIComponent(fileFieldValue); 
			}

			d.io.iframe.send( {
				url : m.getServletURL("/screen/GTPUploadScreen"),
				method : "post",
				handleAs : "json",
				content: {
					operation: "UPLOAD",
					identifier: "file" + attachmentGroup,
					file_name: encodedFileName,
					//file_name: encodeURIComponent(document.getElementById("file" + attachmentGroup).files[0].name),
					att_ref_id: dj.byId("ref_id")? dj.byId("ref_id").get("value") : "",
					att_tnx_id: dj.byId("tnx_id")? dj.byId("tnx_id").get("value") : "",
					att_item_id: dj.byId("item_id")? dj.byId("item_id").get("value"): "",
					attachment_type: dj.byId("attachment_type") && 
							dj.byId("attachment_type").get("value") !== "" ? dj.byId("attachment_type").get("value") : "",
					validation_type: _getValidationType(),
					entity: _getSelectedEntity(),
					fileType: _getFileTypes(),
					token : document.getElementById("_token").getAttribute('value'),
					attachmentgroup: attachmentGroup
				},
				form : d.byId("sendfiles" + attachmentGroup),
				handle : function(data, ioArgs){
					console.warn("[misys.form.file] Data response is", data);
					console.warn("[misys.form.file] io args are", ioArgs);
					console.warn("[misys.form.file] data.status is", data.status);
					
					if(data && data.details && data.details.file_name)
					{
						data.details.file_name = data.details.file_name.replace(/^.*(\\|\/|\:)/, '');
					}
					else if (data.details !== undefined && data.details !== null)
					{
						data.details.file_name = fileFieldValue.replace(/^.*(\\|\/|\:)/, '');
					}
					
					dj.byId("alertDialog").hide();
				    
					// TODO We should probably return a boolean
					if(data.status === "success") {
						dj.byId("attachment_id" + attachmentGroup).set("value", data.details.id);
						dj.byId("file_type" + attachmentGroup).set("value", data.details.type);
						dj.byId("file_name" + attachmentGroup).set("value", data.details.file_name);
						dj.byId("file_title" + attachmentGroup).set("value", data.details.title);
						_uploadFile(dialogId);
					}  
					else 
					{
						// Sometimes the underlay is not correctly hidden
						var underlay = d.byId("alertDialog_underlay");
						if(underlay) {
							d.style(underlay, "display", "none");
						}
						
						if (data.details && data.details.message && data.details.message.length > 0) {
							// TODO Should we dump the error message untreated to the user?
							m.dialog.show("ERROR", data.details.message);
						} else if (data.details === undefined || data.details === null) {
							//Scenario where iframe is unable to load files above 10 MB so to handle error this message is shown
							errorMessage = m.getLocalization("fileSizeExceeded");
							m.dialog.show("ERROR", errorMessage);
						}
						
						console.warn("[misys.form.file] File upload error, response status = " + 
												data.status);
					}
				}
			 });

		    return true;
		}, 
		
		downloadFile: function( /*String*/ file_id, 
								/*String*/ group){
			// summary:
			//		Download a file
			var attachmentGroup = group || "",
				attachmentid = d.create("input"),
				type;
			
			if(!dj.byId("downloadfiles" + attachmentGroup)) {
				d.parser.parse(d.byId("downloadfiles-container" + +attachmentGroup));
			}

			attachmentid.type = "hidden";
			attachmentid.name = "attachmentid";
			attachmentid.id = "attachmentid";
			attachmentid.value = file_id;
			
		    d.byId("downloadfiles" + attachmentGroup).appendChild(attachmentid);
			
			if (dj.byId("item_id")) {
				type = d.doc.createElement("input");
				type.type = "hidden";
				type.name = "attachment_type";
				type.id = "attachment_type";
				type.value = "news";
		        d.byId("downloadfiles" + attachmentGroup).appendChild(type);
			}

			dojo.parser.parse(dojo.byId("downloadfiles" + attachmentGroup));
			dj.byId("downloadfiles" + attachmentGroup).submit();

			d.destroy(d.byId("attachmentid"));
			if (d.byId("attachment_type") && dj.byId("item_id")) {
				d.destroy(d.byId("attachment_type"));
			}
		}, 
		
		clearFilePath : function(){
		// summary: 
		//		Clear file path
		
		var x = document.getElementById('file');
		if(x){
			x.setAttribute("type", "file");
			x.setAttribute("type", "text");
			x.setAttribute("type", "file");
		}
		var y = document.getElementById('fileinvoice');
		if(y){
			y.setAttribute("type", "file");
			y.setAttribute("type", "text");
			y.setAttribute("type", "file");
		}		
		},
		
		addFileItem : function( /*String*/ id) {
			// summary:
			//		Add a file item to a grid
			var attachmentType = d.byId('attachment_type');
			var fullId = "attachment-file" + id;
			if(!dj.byId(fullId)) {
				d.style("noFilesNotice" + id, "display", "none");
				d.parser.instantiate([d.byId(fullId)]);
			}
			if(d.byId('file'))
				{
					d.byId('file').value="";
				}
				
				if(id !== ""){
				var fullFilename = "file" + id;
				if(fullFilename){
					d.byId(fullFilename).value="";
				}
				
			}
			dj.byId(fullId).addItem();
		},
		/**
		 * As addFileItem Cannot be overridden in the screen specific JS,
		 * based on the file attachment type invoke the following JS.
		 * Here Bulk file upload - need to do additional validation before showing 
		 * file upload dialog and setting few additional values required for upload
		 * validation like entity name is required while uploading a file
		 */
		addBulkFileItem : function( /*String*/ id) {
			// summary:
			//		Add a file item to a grid
			
			var attachmentType = d.byId('attachment_type'),
			    entity = dj.byId("entity") ? dj.byId("entity").get("value") : "";
			var fullId = "attachment-file" + id;
			if(!dj.byId(fullId)) {
				d.style("noFilesNotice" + id, "display", "none");
				d.parser.instantiate([d.byId(fullId)]);
			}
			if( dj.byId("entity") && entity === "")
			{
				var displayMessage = m.getLocalization("selectEntityForFileUpload");
				//focus on the widget and set state to error and display a tooltip indicating the same
				entity.focus();
				entity.set("state","Error");
				dijit.hideTooltip(entity.domNode);
				dijit.showTooltip(displayMessage, entity.domNode, 0);
			}else{
				if(d.byId('file')){
					d.byId('file').value="";
				}
				dj.byId(fullId).addItem();
			}
			
		}, 
		
		showUploadDialog : function( /*String*/ attachmentGroup) {
			//  summary:
			//          Open the upload dialog
			
		    var fileUploadDialog = dj.byId("fileUploadDialog"),
		    	group = attachmentGroup || "",
		    	maxFiles = d.byId("max-files" + group).value || 1,
		    	file = dj.byId("file");

		    if(!fileUploadDialog) {
			   d.parser.parse("fileUploadFields");
			   fileUploadDialog = dj.byId("fileUploadDialog");
		    }
		   
		    // TODO We previously set a global param GROUP here that was used
		    // elsewhere. We should instead put it in _config, if we can't get
		    // rid of it entirely.
		    
			// Set the group so that we know it on server side
			dj.byId("group").set("value", group);
			
		   // control upload files limit.
		    dj.byId("uploadButton").set("disabled", (m._config.attachedFiles[group] >= maxFiles));
		    dj.byId("title").set("value", "");
		    file.set("readOnly", false);
		    file.set("value", "");
		    fileUploadDialog.show();
		}
	});

	// Onload/Unload/onWidgetLoad Events

	d.ready(function(){
		// TODO There is, for the moment, a dependency between these files
		// and the functions in misys.form.file
		d.require("misys.product.widget.AttachmentFiles");
		d.require("misys.product.widget.AttachmentFile");
	});
})(dojo, dijit, misys);

}

if(!dojo._hasResource["dojox.validate.regexp"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.validate.regexp"] = true;
dojo.provide("dojox.validate.regexp");



dojo.mixin(dojox.validate.regexp, {
	
	ipAddress: function(/*Object?*/flags){
		// summary: Builds a RE that matches an IP Address
		//
		// description:
		//  Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
		//  Supports 2 formats for Ipv6.
		//
		// flags  An object.  All flags are boolean with default = true.
		//    flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
		//    flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
		//    flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
		//    flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
		//    flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
		//      Case insensitive.  Zero padding allowed.
		//    flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
		//	FIXME: ipv6 can be written multiple ways IIRC
		//    flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
		//      followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.allowDottedDecimal != "boolean"){ flags.allowDottedDecimal = true; }
		if(typeof flags.allowDottedHex != "boolean"){ flags.allowDottedHex = true; }
		if(typeof flags.allowDottedOctal != "boolean"){ flags.allowDottedOctal = true; }
		if(typeof flags.allowDecimal != "boolean"){ flags.allowDecimal = true; }
		if(typeof flags.allowHex != "boolean"){ flags.allowHex = true; }
		if(typeof flags.allowIPv6 != "boolean"){ flags.allowIPv6 = true; }
		if(typeof flags.allowHybrid != "boolean"){ flags.allowHybrid = true; }
		
		// port number RE
		var portRE = flags.allowPort ? "(\\:\\d+)?" : "";

		// decimal-dotted IP address RE.
		var dottedDecimalRE =
			// Each number is between 0-255.  Zero padding is not allowed.
			"((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";

		// dotted hex IP address RE.  Each number is between 0x0-0xff.  Zero padding is allowed, e.g. 0x00.
		var dottedHexRE = "(0[xX]0*[\\da-fA-F]?[\\da-fA-F]\\.){3}0[xX]0*[\\da-fA-F]?[\\da-fA-F]";

		// dotted octal IP address RE.  Each number is between 0000-0377.
		// Zero padding is allowed, but each number must have at least 4 characters.
		var dottedOctalRE = "(0+[0-3][0-7][0-7]\\.){3}0+[0-3][0-7][0-7]";

		// decimal IP address RE.  A decimal number between 0-4294967295.
		var decimalRE =  "(0|[1-9]\\d{0,8}|[1-3]\\d{9}|4[01]\\d{8}|42[0-8]\\d{7}|429[0-3]\\d{6}|" +
			"4294[0-8]\\d{5}|42949[0-5]\\d{4}|429496[0-6]\\d{3}|4294967[01]\\d{2}|42949672[0-8]\\d|429496729[0-5])";

		// hexadecimal IP address RE.
		// A hexadecimal number between 0x0-0xFFFFFFFF. Case insensitive.  Zero padding is allowed.
		var hexRE = "0[xX]0*[\\da-fA-F]{1,8}";

		// IPv6 address RE.
		// The format is written as eight groups of four hexadecimal digits, x:x:x:x:x:x:x:x,
		// where x is between 0000-ffff. Zero padding is optional. Case insensitive.
		var ipv6RE = "([\\da-fA-F]{1,4}\\:){7}[\\da-fA-F]{1,4}";

		// IPv6/IPv4 Hybrid address RE.
		// The format is written as six groups of four hexadecimal digits,
		// followed by the 4 dotted decimal IPv4 format. x:x:x:x:x:x:d.d.d.d
		var hybridRE = "([\\da-fA-F]{1,4}\\:){6}" +
			"((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";

		// Build IP Address RE
		var a = [];
		if(flags.allowDottedDecimal){ a.push(dottedDecimalRE); }
		if(flags.allowDottedHex){ a.push(dottedHexRE); }
		if(flags.allowDottedOctal){ a.push(dottedOctalRE); }
		if(flags.allowDecimal){ a.push(decimalRE); }
		if(flags.allowHex){ a.push(hexRE); }
		if(flags.allowIPv6){ a.push(ipv6RE); }
		if(flags.allowHybrid){ a.push(hybridRE); }

		var ipAddressRE = "";
		if(a.length > 0){
			ipAddressRE = "(" + a.join("|") + ")";
		}
		return ipAddressRE+portRE; // String
	},

	host: function(/*Object?*/flags){
		// summary: Builds a RE that matches a host
		// description: A host is a named host (A-z0-9_- but not starting with -), a domain name or an IP address, possibly followed by a port number.
		// flags: An object.
		//	  flags.allowNamed Allow a named host for local networks. Default is false.
		//    flags.allowIP  Allow an IP address for hostname.  Default is true.
		//    flags.allowLocal  Allow the host to be "localhost".  Default is false.
		//    flags.allowPort  Allow a port number to be present.  Default is true.
		//    flags in regexp.ipAddress can be applied.

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};

		if(typeof flags.allowIP != "boolean"){ flags.allowIP = true; }
		if(typeof flags.allowLocal != "boolean"){ flags.allowLocal = false; }
		if(typeof flags.allowPort != "boolean"){ flags.allowPort = true; }
		if(typeof flags.allowNamed != "boolean"){ flags.allowNamed = false; }

		//TODO: support unicode hostnames?
		// Domain name labels can not end with a dash.
		var domainLabelRE = "(?:[\\da-zA-Z](?:[-\\da-zA-Z]{0,61}[\\da-zA-Z])?)";
		var domainNameRE = "(?:[a-zA-Z](?:[-\\da-zA-Z]{0,6}[\\da-zA-Z])?)"; // restricted version to allow backwards compatibility with allowLocal, allowIP

		// build host RE
		var hostNameRE = "((?:" + domainLabelRE + "\\.)+" + domainNameRE + "\\.?)";
		if(flags.allowIP){ hostNameRE += "|" +  dojox.validate.regexp.ipAddress(flags); }
		if(flags.allowLocal){ hostNameRE += "|localhost"; }
		if(flags.allowNamed){ hostNameRE += "|^[^-][a-zA-Z0-9_-]*"; }
		return "(" + hostNameRE + ")"; // String

	},

	url: function(/*Object?*/flags){
		// summary: Builds a regular expression that matches a URL
		//
		// flags: An object
		//    flags.scheme  Can be true, false, or [true, false].
		//      This means: required, not allowed, or match either one.
		//    flags in regexp.host can be applied.
		//    flags in regexp.ipAddress can be applied.

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};
		if(!("scheme" in flags)){ flags.scheme = [true, false]; }

		// Scheme RE
		var protocolRE = dojo.regexp.buildGroupRE(flags.scheme,
			function(q){ if(q){ return "(https?|ftps?)\\://"; } return ""; }
		);

		// Path and query and anchor RE
		var pathRE = "(/(?:[^?#\\s/]+/)*(?:[^?#\\s/]+(?:\\?[^?#\\s/]*)?(?:#[A-Za-z][\\w.:-]*)?)?)?";

		return protocolRE + dojox.validate.regexp.host(flags) + pathRE;
	},

	emailAddress: function(/*Object?*/flags){

		// summary: Builds a regular expression that matches an email address
		//
		//flags: An object
		//    flags.allowCruft  Allow address like <mailto:foo@yahoo.com>.  Default is false.
		//    flags in regexp.host can be applied.
		//    flags in regexp.ipAddress can be applied.

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};
		if (typeof flags.allowCruft != "boolean") { flags.allowCruft = false; }
		//flags.allowPort = false; // invalid in email addresses

		// user name RE per rfc5322
		var usernameRE = "([!#-'*+\\-\\/-9=?A-Z^-~]+[.])*[!#-'*+\\-\\/-9=?A-Z^-~]+";

		// build emailAddress RE
		var emailAddressRE = usernameRE + "@" + dojox.validate.regexp.host(flags);

		// Allow email addresses with cruft
		if ( flags.allowCruft ) {
			emailAddressRE = "<?(mailto\\:)?" + emailAddressRE + ">?";
		}

		return emailAddressRE; // String
	},

	emailAddressList: function(/*Object?*/flags){
		// summary: Builds a regular expression that matches a list of email addresses.
		//
		// flags: An object.
		//    flags.listSeparator  The character used to separate email addresses.  Default is ";", ",", "\n" or " ".
		//    flags in regexp.emailAddress can be applied.
		//    flags in regexp.host can be applied.
		//    flags in regexp.ipAddress can be applied.

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.listSeparator != "string"){ flags.listSeparator = "\\s;,"; }

		// build a RE for an Email Address List
		var emailAddressRE = dojox.validate.regexp.emailAddress(flags);
		var emailAddressListRE = "(" + emailAddressRE + "\\s*[" + flags.listSeparator + "]\\s*)*" +
			emailAddressRE + "\\s*[" + flags.listSeparator + "]?\\s*";

		return emailAddressListRE; // String
	},
	
	numberFormat: function(/*Object?*/flags){
		// summary: Builds a regular expression to match any sort of number based format
		// description:
		//  Use this method for phone numbers, social security numbers, zip-codes, etc.
		//  The RE can match one format or one of multiple formats.
		//
		//  Format
		//    #        Stands for a digit, 0-9.
		//    ?        Stands for an optional digit, 0-9 or nothing.
		//    All other characters must appear literally in the expression.
		//
		//  Example
		//    "(###) ###-####"       ->   (510) 542-9742
		//    "(###) ###-#### x#???" ->   (510) 542-9742 x153
		//    "###-##-####"          ->   506-82-1089       i.e. social security number
		//    "#####-####"           ->   98225-1649        i.e. zip code
		//
		// flags:  An object
		//    flags.format  A string or an Array of strings for multiple formats.

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.format == "undefined"){ flags.format = "###-###-####"; }

		// Converts a number format to RE.
		var digitRE = function(format){
			// escape all special characters, except '?'
			return dojo.regexp.escapeString(format, "?")
				// Now replace '?' with Regular Expression
				.replace(/\?/g, "\\d?")
				// replace # with Regular Expression
				.replace(/#/g, "\\d")
			;
		};

		// build RE for multiple number formats
		return dojo.regexp.buildGroupRE(flags.format, digitRE); //String
	}
	
});

dojox.validate.regexp.ca = {
	
	postalCode: function(){
		// summary: String regular Express to match Canadain Postal Codes
		return "([A-Z][0-9][A-Z] [0-9][A-Z][0-9])";
	},

	province: function(){
		// summary: a regular expression to match Canadian Province Abbreviations
		return "(AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT)";
	}
	
};

dojox.validate.regexp.us = {
	
	state: function(/*Object?*/flags){
		// summary: A regular expression to match US state and territory abbreviations
		//
		// flags  An object.
		//    flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
		//    flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.

		// assign default values to missing paramters
		flags = (typeof flags == "object") ? flags : {};
		if(typeof flags.allowTerritories != "boolean"){ flags.allowTerritories = true; }
		if(typeof flags.allowMilitary != "boolean"){ flags.allowMilitary = true; }

		// state RE
		var statesRE =
			"AL|AK|AZ|AR|CA|CO|CT|DE|DC|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|" +
			"NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY";

		// territories RE
		var territoriesRE = "AS|FM|GU|MH|MP|PW|PR|VI";

		// military states RE
		var militaryRE = "AA|AE|AP";

		// Build states and territories RE
		if(flags.allowTerritories){ statesRE += "|" + territoriesRE; }
		if(flags.allowMilitary){ statesRE += "|" + militaryRE; }

		return "(" + statesRE + ")"; // String
	}
	
};


}

if(!dojo._hasResource["dojox.validate._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.validate._base"] = true;
dojo.provide("dojox.validate._base");
dojo.experimental("dojox.validate");

		// dojo core expressions
		// dojo number expressions
 	// additional expressions

dojox.validate.isText = function(/*String*/value, /*Object?*/flags){
	// summary:
	//	Checks if a string has non whitespace characters.
	//	Parameters allow you to constrain the length.
	//
	// value: A string
	// flags: {length: Number, minlength: Number, maxlength: Number}
	//    flags.length  If set, checks if there are exactly flags.length number of characters.
	//    flags.minlength  If set, checks if there are at least flags.minlength number of characters.
	//    flags.maxlength  If set, checks if there are at most flags.maxlength number of characters.
	
	flags = (typeof flags == "object") ? flags : {};
	
	// test for text
	if(/^\s*$/.test(value)){ return false; } // Boolean
	
	// length tests
	if(typeof flags.length == "number" && flags.length != value.length){ return false; } // Boolean
	if(typeof flags.minlength == "number" && flags.minlength > value.length){ return false; } // Boolean
	if(typeof flags.maxlength == "number" && flags.maxlength < value.length){ return false; } // Boolean
	
	return true; // Boolean

}

dojox.validate._isInRangeCache = {};
dojox.validate.isInRange = function(/*String*/value, /*Object?*/flags){
	// summary:
	//	Validates whether a string denoting a number
	//	is between a max and min.
	//
	// value: A string
	// flags: {max:Number, min:Number, decimal:String}
	//    flags.max  A number, which the value must be less than or equal to for the validation to be true.
	//    flags.min  A number, which the value must be greater than or equal to for the validation to be true.
	//    flags.decimal  The character used for the decimal point.  Default is ".".
	
	value = dojo.number.parse(value, flags);
	if(isNaN(value)){
		return false; // Boolean
	}
    
	// assign default values to missing paramters
	flags = (typeof flags == "object") ? flags : {};
	var max = (typeof flags.max == "number") ? flags.max : Infinity,
		min = (typeof flags.min == "number") ? flags.min : -Infinity,
		dec = (typeof flags.decimal == "string") ? flags.decimal : ".",
	
		cache = dojox.validate._isInRangeCache,
		cacheIdx = value + "max" + max + "min" + min + "dec" + dec
	;
	if(typeof cache[cacheIdx] != "undefined"){
		return cache[cacheIdx];
	}

	cache[cacheIdx] = !(value < min || value > max);
	return cache[cacheIdx]; // Boolean

}

dojox.validate.isNumberFormat = function(/* String */value, /* Object? */flags){
	// summary: Validates any sort of number based format
	//
	// description:
	//		Validates any sort of number based format. Use it for phone numbers,
	//		social security numbers, zip-codes, etc. The value can be validated
	//		against one format or one of multiple formats.
	//
	// Format Definition
	// |   #        Stands for a digit, 0-9.
	// |   ?        Stands for an optional digit, 0-9 or nothing.
	//    All other characters must appear literally in the expression.
	//
	// example:
	// |  "(###) ###-####"       ->   (510) 542-9742
	// |  "(###) ###-#### x#???" ->   (510) 542-9742 x153
	// |  "###-##-####"          ->   506-82-1089       i.e. social security number
	// |  "#####-####"           ->   98225-1649        i.e. zip code
	//
	// value: A string
	//
	// flags: Object?
	//		FIXME: make pseudo-object for this
	//		format: String
	//
	//    flags.format  A string or an Array of strings for multiple formats.
	//
	// example:
	// | // returns true:
	// | dojox.validate.isNumberFormat("123-45", { format:"###-##" });
	//
	// example:
	// 		Check Multiple formats:
	// |	dojox.validate.isNumberFormat("123-45", {
	// |		format:["### ##","###-##","## ###"]
	// |	});
	//

	var re = new RegExp("^" + dojox.validate.regexp.numberFormat(flags) + "$", "i");
	return re.test(value); // Boolean
}

dojox.validate.isValidLuhn = function(/* String */value){
	// summary: Validate a String value against the Luhn algorithm.
	// description:
	//		Validate a String value against the Luhn algorithm to verify
	//		its integrity.
	
	var sum = 0, parity, curDigit;
	if(!dojo.isString(value)){
		value = String(value);
	}
	value = value.replace(/[- ]/g,''); //ignore dashes and whitespaces
	parity = value.length % 2;

	for(var i = 0; i < value.length; i++){
		curDigit = parseInt(value.charAt(i));
		if(i % 2 == parity){
			curDigit *= 2;
		}
		if(curDigit > 9){
			curDigit -= 9;
		}
		sum += curDigit;
	}
	return !(sum % 10); // Boolean
}


}

if(!dojo._hasResource["dojox.validate.web"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.validate.web"] = true;
dojo.provide("dojox.validate.web");


dojox.validate.isIpAddress = function(/*String*/value, /*Object?*/flags) {
	// summary: Validates an IP address
	//
	// description:
	//  Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
	//  Supports 2 formats for Ipv6.
	//
	// value  A string.
	// flags  An object.  All flags are boolean with default = true.
	//    flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
	//    flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
	//    flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
	//    flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
	//    flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
	//      Case insensitive.  Zero padding allowed.
	//    flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
	//    flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
	//      followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d

	var re = new RegExp("^" + dojox.validate.regexp.ipAddress(flags) + "$", "i");
	return re.test(value); // Boolean
}


dojox.validate.isUrl = function(/*String*/value, /*Object?*/flags) {
	// summary: Checks if a string could be a valid URL
	// value: A string
	// flags: An object
	//    flags.scheme  Can be true, false, or [true, false].
	//      This means: required, not allowed, or either.
	//    flags in regexp.host can be applied.
	//    flags in regexp.ipAddress can be applied.
	//    flags in regexp.tld can be applied.

	var re = new RegExp("^" + dojox.validate.regexp.url(flags) + "$", "i");
	return re.test(value); // Boolean
}

dojox.validate.isEmailAddress = function(/*String*/value, /*Object?*/flags) {
	// summary: Checks if a string could be a valid email address
	//
	// value: A string
	// flags: An object
	//    flags.allowCruft  Allow address like <mailto:foo@yahoo.com>.  Default is false.
	//    flags in regexp.host can be applied.
	//    flags in regexp.ipAddress can be applied.
	//    flags in regexp.tld can be applied.

	var re = new RegExp("^" + dojox.validate.regexp.emailAddress(flags) + "$", "i");
	return re.test(value); // Boolean
}

dojox.validate.isEmailAddressList = function(/*String*/value, /*Object?*/flags) {
	// summary: Checks if a string could be a valid email address list.
	//
	// value  A string.
	// flags  An object.
	//    flags.listSeparator  The character used to separate email addresses.  Default is ";", ",", "\n" or " ".
	//    flags in regexp.emailAddress can be applied.
	//    flags in regexp.host can be applied.
	//    flags in regexp.ipAddress can be applied.
	//    flags in regexp.tld can be applied.

	var re = new RegExp("^" + dojox.validate.regexp.emailAddressList(flags) + "$", "i");
	return re.test(value); // Boolean
}

dojox.validate.getEmailAddressList = function(/*String*/value, /*Object?*/flags) {
	// summary: Check if value is an email address list. If an empty list
	//  is returned, the value didn't pass the test or it was empty.
	//
	// value: A string
	// flags: An object (same as dojo.validate.isEmailAddressList)

	if(!flags) { flags = {}; }
	if(!flags.listSeparator) { flags.listSeparator = "\\s;,"; }

	if ( dojox.validate.isEmailAddressList(value, flags) ) {
		return value.split(new RegExp("\\s*[" + flags.listSeparator + "]\\s*")); // Array
	}
	return []; // Array
}

}

if(!dojo._hasResource['misys.client.validation.common_client']){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource['misys.client.validation.common_client'] = true;
dojo.provide('misys.client.validation.common_client');
(function(/*Dojo*/d, /*Dijit*/dj, /*Misys*/m) {
'use strict'; // ECMA5 Strict Mode

})(dojo, dijit, misys);

}

if(!dojo._hasResource["misys.validation.common"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.validation.common"] = true;
dojo.provide("misys.validation.common");



//
// Copyright (c) 2000-2011 Misys (http://www.misys.com), All Rights Reserved.
// version:   1.3
// date:      08/04/11
// author:    Cormac Flynn
//
/**
 * <h4>Summary:</h4> Common Javascript Validations (validations used across forms)
 * 
 * <h4>Description:</h4>  Note: Previously, validations were required to match a certain
 * code template. This is no longer the case - consult the functions
 * misys.setValidation and _wrapValidation in misys.common for an explanation.
 * 
 * Validation functions should take no parameters. If you have to pass
 * parameters, you should probably find another way to do it.
 * 
 * Note that in each validation, "this" always refers to the field itself
 * 
 * @class common(Validation)
 
 */
(function(/* Dojo */d, /* Dijit */dj, /* Misys */m) {
	
	 // ECMA5 Strict Mode
	
	/**
	 * <h4>Summary:</h4>
	 * This function is to validate the content of the specified field against the given character set.
	 * In this we have a string of valid characters we validate all of our characters passed.
	 * @param {Widget} field
	 * Field to validate
	 * @param {String} strValidCharachters
	 * A string of valid characters.
	 * @method _validateChar
	 */
	var falseMessage="message is false";
	var chkPoRefAct=m.getServletURL("/screen/AjaxScreen/action/CheckPoReferenceAction");
	var currISOCode=m.getServletURL("/screen/AjaxScreen/action/GetCurrencyISOCodes");
	var custmNoCancel="CUSTOM-NO-CANCEL";
	var failedMandatoryField="[Could not validate mandatory field] ";
	var currntDatevalue="[misys.validation.common] Current Date Value = ";
	var ExpDateValue="[misys.validation.common] Validating Expiry Date. Value = ";
	var ExpDateCurrntDate="[misys.validation.common] Days difference between expiry date and current date = ";
	var validateCurrError="[misys.validation.common] validateCurrency error";
	var validateAbbNameFormat="[misys.validation.common] Validating Abbv Name Format, Value =";
	var validateCurrValue="[misys.validation.common] Validating Currency. Value";
	var appJson ="application/json; charset=utf-8";
	function _validateChar( /*Widget*/ field, 
							/*String*/ strValidCharacters) {
		if(!strValidCharacters){
			strValidCharacters = 
				" 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/-?:().,+_";
		}
		
		return d.every(field.get("value"), function(theChar){
			return strValidCharacters.indexOf(theChar) >= 0;
		});
	}
	
	function validateBusinessDate(dateField)
	{
		var bDate="";
		if(dijit.byId('issuing_bank_abbv_name') && dijit.byId('issuing_bank_abbv_name').get('value') !== '' && misys && misys._config && misys._config.businessDateForBank &&[dijit.byId('issuing_bank_abbv_name').get('value')][0] &&[dijit.byId('issuing_bank_abbv_name').get('value')][0].name !== "")
		{
			bDate = misys._config.businessDateForBank[dijit.byId('issuing_bank_abbv_name').get('value')][0].name;
		}
		else if(dijit.byId('remitting_bank_abbv_name') && dijit.byId('remitting_bank_abbv_name').get('value') !== '' && misys && misys._config && misys._config.businessDateForBank && misys._config.businessDateForBank &&[dijit.byId('remitting_bank_abbv_name').get('value')][0] && misys._config.businessDateForBank &&[dijit.byId('remitting_bank_abbv_name').get('value')][0].name !== "")
		{
			bDate = misys._config.businessDateForBank[dijit.byId('remitting_bank_abbv_name').get('value')][0].name;
		}
		else if(dijit.byId('recipient_bank_abbv_name') && dijit.byId('recipient_bank_abbv_name').get('value') !== '' && misys && misys._config && misys._config.businessDateForBank && [dijit.byId('recipient_bank_abbv_name').get('value')][0] && [dijit.byId('recipient_bank_abbv_name').get('value')][0].name !== "")
		{
			bDate = misys._config.businessDateForBank[dijit.byId('recipient_bank_abbv_name').get('value')][0].name;
		}
		else if(dijit.byId('advising_bank_abbv_name') && dijit.byId('advising_bank_abbv_name').get('value') !== '' && misys && misys._config && misys._config.businessDateForBank &&[dijit.byId('advising_bank_abbv_name').get('value')][0] && [dijit.byId('advising_bank_abbv_name').get('value')][0].name !== "")
		{
			bDate = misys._config.businessDateForBank[dijit.byId('advising_bank_abbv_name').get('value')][0].name;
		}
		else if(dijit.byId('bank_abbv_name') && dijit.byId('bank_abbv_name').get('value') !== '' && misys && misys._config && misys._config.businessDateForBank [dijit.byId('bank_abbv_name').get('value')][0] && [dijit.byId('bank_abbv_name').get('value')][0].name !== "")
		{
			bDate = misys._config.businessDateForBank[dijit.byId('bank_abbv_name').get('value')][0].name;
		}
		else if(misys && misys._config && misys._config.bankBusinessDate && misys._config.bankBusinessDate !== "")
		{
			bDate = misys._config.bankBusinessDate;
		}
		var date=dateField.get("value");
		if(bDate!=="")
		{
			var yearServer = parseInt(bDate.substring(0,4), 10);
			var monthServer = parseInt(bDate.substring(5,7), 10);
			var dateServer = parseInt(bDate.substring(8,10), 10);
			var currentDate = new  Date(yearServer, monthServer - 1, dateServer);	
			currentDate.setHours(0, 0, 0, 0);
			var days = dojo.date.compare(date,currentDate, "date");
		    return days;
		}
	}
	
	// Private functions & variables
	/**
	 * <h4>Summary:</h4> Returns a localized display date for a date field.
	 * 
	 * <h4>Description:</h4> 
	 * Return the date of the field in a standard format, for
	 * comparison. If the field is hidden, we convert it to a standardized
	 * format for comparison, otherwise we simply return the value.
	 * Internally it uses dojo functions to do this
	 * @param {dijit._Widget} dateField
	 * 	Date field which we want to format to localise date.
	 * @method _localizeDisplayDate
	 */
	function _localizeDisplayDate( /*dijit._Widget*/ dateField) {
		
		if(dateField.get("type") === "hidden") {
			return d.date.locale.format(m.localizeDate(dateField), {
				selector :"date",
				datePattern : m.getLocalization("g_strGlobalDateFormat")
			});
		}
		
		return dateField.get("displayedValue");
	}
	
	/**
	 * this methods changes the field status to either error or valid based on the result of ValidateEmailAddress action
	 * 
	 */
	function _setEmailIdfieldStatus(response, error){

		var isValid = response.items.valid;	
		var field;
		if(dj.byId("email"))
		{
			field = dj.byId("email");
		}
		var displayMessage = '';
			if(response.items.valid === false)
			{
				if(field!=undefined){
				field.focus();
				displayMessage = m.getLocalization("invalidEmailAddressError", [field.get("value")]);
				field.set("state", "Error");
				dj.hideTooltip(field.domNode);
				dj.showTooltip(displayMessage,field.domNode, 0);
				}

			}else
			{
				console.debug("Valid email Address");
			}
	
	}
/**
 * <h4>Summary:</h4>
 * Returns a date from a DateTermField Widget when a code is use (ex: 3d).
 * 
 * @param {dijit._Widget || DomNode || String} node
 * @param {Date} startDate
 * Todays date
 * @method _normalizeDate
 */
	function _normalizeDate( /*dijit._Widget || DomNode || String*/ node, 
							 /*Date*/ startDate) {
		
		var myWidget = dj.byId(node);
		if (myWidget) {
			if(!(/Date/.test(myWidget.get("declaredClass")))){
				return -1;
			}
			if (myWidget.isValidDate()) {
				return myWidget.getDate();
			}
			if (myWidget.getCode() === "SPOT") {
				//return toDay;
				return -1;
			}
			if (myWidget.getCode() === "" || myWidget.getNumber() === "") {
				return -1;
			}
			
			var amount = parseInt(myWidget.getNumber(), 10),
				newDate = null,
				today = startDate || new Date();
			
			if (myWidget.getCode() === "d") {
				return d.date.add(today, "day", amount);
			}
			else if (myWidget.getCode() === "w") {
				return d.date.add(today, "week", amount);
			}
			else if (myWidget.getCode() === "m") {
				return d.date.add(today, "month", amount);
			}
			else if (myWidget.getCode() === "y") {
				return d.date.add(today, "year", amount);
			}
		}
		else {
			return -1;
		}
	}
/**
 * <h4>Summary:</h4>
 * Function to get an IBAN checksum. Landcode can be empty, but then, the landcode
 * must be included in the first two characters of sIban, followed by two zeros
 * @param {Object} sIban
 *  iban code 
 * @param {Object} landcode
 *  land code 
 * @method _getIBANchecksum
 * @return {object}
 *  IBAN check sum
 */
	
	function _getIBANchecksum(sIban, landcode)
	{
		var skipChars = " .-_,/", 
			sIbanDigits = "",
			sIbanMixed	= "",
			sLCCS		= "",
			curChar		= "";
		if (sIban.length < 5 || sIban.length > 35)
		{
			return -1;
		}

		if (landcode == null || landcode === "")
		{
		    sLCCS = sIban.substring(0,4);
		    sIbanMixed = sIban.substring(4, sIban.length) + sLCCS.toUpperCase();
		}
		else
		{
			sLCCS = landcode + "00";
			sIbanMixed = sIban + sLCCS.toUpperCase();
		}

		for (var i=0; i<sIbanMixed.length; i++)
		{
			curChar = sIbanMixed.charAt(i);
			if (!isNaN(curChar))
			{
				sIbanDigits += "" + curChar;
			}
			else if (skipChars.indexOf(curChar) > 0)
			{
				continue;
			}
			else if (curChar.charCodeAt(0) < 65 || curChar.charCodeAt(0) > 90)
			{
				return -1;
			}
			else
			{
				sIbanDigits +=  curChar.charCodeAt(0) - 55;
			}
		}

	    return (_largeModulus(sIbanDigits, 97));
	}

	/**
	 * <h4>Summary:</h4>
	 * Calculates the modulus of large integers that are actually strings.
	 * @param {Object} sNumber
	 * @param {Object} modulus
	 * @method _largeModulus
	 */
	function _largeModulus(sNumber, modulus)
	{
	    var i = 0, j = 0, sRebuild = new Array(), r = "";
	    for (i=0; i<sNumber.length+6;i+=6)
	    {
	    	var sItem = sNumber.substring(i, i+6);
	    	if (sItem!=="")
	    	{
	        	sRebuild[j++] = sNumber.substring(i, i+6);
	        }
	    }
	    for (i=0; i<sRebuild.length;i++)
	    {
	        r = (r + "" + sRebuild[i]) % modulus;
	    }
	    return r;
	}
	
	//Format the date to send through ajax
	/**
	 * <h4>Summary:</h4>
	 * This function is to format holiday and cutoff date.
	 * <h4>Description:</h4> 
	 * First it checks if passed object is an instance of date or not.If it is formats it and returns the same.
	 * @param {DateNode} dateNode
	 *  Date node passed
	 * @method _formatHolidaysAndCutOffDate
	 * @return {Object} 
	 *   Formatted date object
	 */
	function _formatHolidaysAndCutOffDate(/*Date Node*/dateNode)
	{
		var objDate = dateNode.get("value") !== null ?  dateNode.get("value") : "";
		if(objDate === "" || !(objDate instanceof Date))
		{
			return objDate;
		}
		else if(dateNode.get("displayedValue")) 
		{
			return dateNode.get("displayedValue");
		}
		else
		{
			var month = objDate.getMonth();
			month = month + 1;
			var year = objDate.getFullYear(); 
			var day = objDate.getDate();
			return day +"/"+month+"/"+year;
		}
	}
	

	// <h4>Summary:</h4>
    // Validate an Abbreviated Name, testing if the Abbreviated Name entered is existing in the database.
	// If already exists clear the entered Abbreviated Name and prompt for Abbreviated Name.
	/**
	 * <h4>Summary:</h4>
	 * This function is to validate abbreviated name if already exists in the database.
	 * <h4>Description:</h4> 
	 * If abbreviated name already exists clear the entered Abbreviated name and prompt for Abbreviated name
	 * @param {Object} response
	 * @method _showExistingAbbvNameMsg
	 */
	function _showExistingAbbvNameMsg(response){
		
		console.debug("[Validate] Validating Abbreviated Name");
		
		var field;
		if(dj.byId("abbv_name"))
		{
			field = dj.byId("abbv_name");
		}
		var displayMessage = '';
			if(response.items.valid === true)
			{
				if(field!=undefined){
				field.focus();
				displayMessage = m.getLocalization("abbvNameExists", [field.get("value")]);
				field.set("value", "");
				field.set("state", "Error");
				dj.hideTooltip(field.domNode);
				dj.showTooltip(displayMessage,field.domNode, 0);
				}

			}else
			{
				console.debug(falseMessage);
			}
	}
	
	// summary:
    // Validate an Abbreviated Name, testing if the Abbreviated Name entered is existing in the database.
	// If already exists clear the entered Abbreviated Name and prompt for Abbreviated Name.
	/**
	 * <h4>Summary:</h4>
	 * This function is to validate claim reference if it already exists in the database.
	 * <h4>Description:</h4> 
	 * If claim reference already exists clear the entered claim reference and prompt for claim reference.
	 * @param {Object} response
	 * @method _showExistingClaimRefMsg
	 */
	function _showExistingClaimRefMsg(response){
		
		console.debug("[Validate] Validating Claim Reference");
		
		var field;
		if(dj.byId("claim_reference"))
		{
			field = dj.byId("claim_reference");
		}
		var displayMessage = '';
			if(response.items.valid === false)
			{
				console.debug("Claim Reference invalid");
				if(field!=undefined){
				displayMessage = m.getLocalization("claimReferenceExists", [field.get("value")]);
				}
				var callback = function() {
					field.focus();
					field.set("state","Error");
				};
				m.dialog.show("ERROR", displayMessage, '', function(){
					setTimeout(callback, 500);
				});

			}else
			{
				console.debug("Claim Reference validated");
			}
	}
	/**
	 * <h4>Summary:</h4>
	 * This function is to validate PO reference if it already exists in the database.
	 * <h4>Description:</h4> 
	 * If PO reference already exists clear the entered PO reference and prompt for PO reference.
	 * @param {Object} response
	 * @method _showExistingPoRefMsg
	 */
	function _showExistingPoRefMsg(response){
		
		console.debug("[Validate] Validating PO Reference");
		
		var field;
		if(dj.byId("issuer_ref_id"))
		{
			field = dj.byId("issuer_ref_id");
		}
		var displayMessage = '';
			if(response.items.valid === false)
			{
				console.debug("PO Reference invalid");
				if(field!=undefined){
				displayMessage = m.getLocalization("poReferenceExists", [field.get("value")]);
				field.focus();
				field.set("state","Error");
				field.set("value","");
				dj.hideTooltip(field.domNode);
				dj.showTooltip(displayMessage,field.domNode, 0);
				}
				
			}else
			{
				console.debug("PO Reference validated");
			}
	}
	/**
	 * <h4>Summary:</h4>
	 * This function is to validate Invoice reference if it already exists in the database.
	 * <h4>Description:</h4> 
	 * If Invoice reference already exists clear the entered Invoice reference and prompt for Invoice reference.
	 * @param {Object} response
	 * @method _showExistingInvoiceRefMsg
	 */
	function _showExistingInvoiceRefMsg(response){
		
		console.debug("[Validate] Validating Invoice Reference");
		
		var field;
		if(dj.byId("issuer_ref_id"))
		{
			field = dj.byId("issuer_ref_id");
		}
		var displayMessage = '';
			if(response.items.valid === false && field!=undefined)
			{
				console.debug("Invoice Reference invalid");
				displayMessage = m.getLocalization("invoiceReferenceExists", [field.get("value")]);
				field.focus();
				field.set("state","Error");
				field.set("value","");
				dj.hideTooltip(field.domNode);
				dj.showTooltip(displayMessage,field.domNode, 0);
			}else
			{
				console.debug("Invoice Reference validated");
			}
	}
	/**
	 * <h4>Summary:</h4>
	 * This function is to validate Customer reference if it already exists in the database.
	 * <h4>Description:</h4> 
	 * If customer reference already exists clear the entered customer reference and prompt for customer reference.
	 * @param {Object} response
	 * @method _showExistingPoRefMsg
	 */
	function _showExistingCustRefMsg(response){
		
		console.debug("[Validate] Validating PO Reference");
		
		var field;
		if(dj.byId("cust_ref_id"))
		{
			field = dj.byId("cust_ref_id");
		}
		var displayMessage = '';
			if(response.items.valid === false)
			{
				console.debug("Customer Reference invalid");
				if(field!=undefined){
				displayMessage = m.getLocalization("custReferenceExists", [field.get("value")]);
				field.focus();	
				field.set("state","Error");
				field.set("value","");
				dj.showTooltip(displayMessage,field.domNode, 0);
				}
			}else
			{
				console.debug("Customer Reference validated");
			}
	}
	/**
	 * <h4>Summary:</h4>
	 * This function is to validate CN reference if it already exists in database.
	 * <h4>Description:</h4> 
	 * If CN reference already exists clear the entered CN reference and prompt for CN reference.
	 * @param {Object} response
	 * @method _showExistingCnRefMsg
	 * 
	 */
	function _showExistingCnRefMsg(response){
		
		console.debug("[Validate] Validating CN Reference");
		
		var field;
		if(dj.byId("cn_reference"))
		{
			field = dj.byId("cn_reference");
		}
		var displayMessage = '';
			if(response.items.valid === false)
			{
				console.debug("CN Reference invalid");
				if(field!=undefined){
				displayMessage = m.getLocalization("cnReferenceExists", [field.get("value")]);
				field.focus();
				field.set("state","Error");
				dj.hideTooltip(field.domNode);
				dj.showTooltip(displayMessage,field.domNode, 0);
				}
			}else
			{
				console.debug("CN Reference validated");
			}
	}
	/**
	 * <h4>Summary:</h4> This function is to validate Report name if it already exists in
	 * database. <h4>Description:</h4>  If Report name reference already exists clear the
	 * entered report name and prompt for report name reference.
	 * 
	 * @param {Object} response
	 * @method _showExistingReportNameMsg
	 */
	function _showExistingReportNameMsg(response){
			
			console.debug("[Validate] Validating Report Name");
			
			var field;
			if(dj.byId("report_name"))
			{
				field = dj.byId("report_name");
			}
			var displayMessage = '';
				if(response.items.valid === true)
				{
					if(field!=undefined){
					field.focus();
					displayMessage = m.getLocalization("reportNameExists", [response.items.reportName]);
					field.set("value", "");
					field.set("state", "Error");
					dj.hideTooltip(field.domNode);
					dj.showTooltip(displayMessage,field.domNode, 0);
					}
	
				}else
				{
					console.debug(falseMessage);
				}
	}
	/**
	 * <h4>Summary:</h4> 
	 * This function is to validate LS name if it already exists in
	 * database. <h4>Description:</h4>  If LS name already exists clear the
	 * entered LS name and prompt for LS name.
	 * 
	 * @param {Object} response
	 * @method _showExistingLsNameMsg
	 */
	function _showExistingLsNameMsg(response){
		
		console.debug("[Validate] Validating License Name");
		
		var field;
		var lsName = dj.byId("ls_name");
		if(lsName)
		{
			field = lsName;
		}
		var displayMessage = '';
			if(response.items.valid === false)
			{
				console.debug("License Name invalid");
				if(field!=undefined){
				displayMessage = m.getLocalization("lsNameExists", [field.get("value")]);
				field.focus();
				field.set("state","Error");
				dj.hideTooltip(field.domNode);
				dj.showTooltip(displayMessage,field.domNode, 0);
				}
			}else
			{
				console.debug("License Name validated");
			}
	}
	
	/**
	 * <h4>Summary:</h4> 
	 * This function is to validate Facility reference if it already exists in
	 * database. <h4>Description:</h4>  If Facility reference already exists clear the
	 * entered Facility reference and prompt for Facility reference.
	 * 
	 * @param {Object} response
	 * @method _showExistingFacilityReferenceMsg
	 */
	function _showExistingFacilityReferenceMsg(response){
		
		console.debug("[Validate] Validating facility Refernce");
		
		var field;
		if(dj.byId("facility_reference"))
		{
			field = dj.byId("facility_reference");
		}
		var displayMessage = '';
			if(response.items.valid === true)
			{
				if(field!=undefined){
				field.focus();
				displayMessage = m.getLocalization("facilityRefExists", [field.get("value")]);
				field.set("value","");
				field.set("state", "Error");
				dj.hideTooltip(field.domNode);
				dj.showTooltip(displayMessage,field.domNode, 0);
				}

			}else
			{
				console.debug(falseMessage);
			}
		}
	/**
	 * <h4>Summary:</h4> 
	 * This function is to validate Employee number if it already exists in
	 * database. <h4>Description:</h4>  If Employee number already exists clear the
	 * entered Employee number and prompt for Employee number.
	 * 
	 * @param {Object} response
	 * @method _showExistingEmployeeNoMsg
	 */
	function _showExistingEmployeeNoMsg(response){
		
		console.debug("[Validate] Validating Employee No");
		
		var field;
		if(dj.byId("employee_no"))
		{
			field = dj.byId("employee_no");
		}
		var displayMessage = '';
			if(response.items.valid === true)
			{
				if(field!=undefined){
				field.focus();
				displayMessage = m.getLocalization("employeeNoExists", [field.get("value")]);
				field.set("value", "");
				field.set("state", "Error");
				dj.hideTooltip(field.domNode);
				dj.showTooltip(displayMessage,field.domNode, 0);
				}
	
			}else
			{
				console.debug(falseMessage);
			}
	}
	
	
	/**
	 * <h4>Summary:</h4> 
	 * This function is to prompt an error message to the user if the 
	 * structure code exists 	
	 * 
	 * @param {Object} response
	 * @method _showExistingEmployeeNoMsg
	 */
	function _showExistingCodeMsg(response){
		
		console.debug("[Validate] Validating structure Code");
		
		var field;
		if(dj.byId("structure_code"))
		{
			field = dj.byId("structure_code");
		}
		var displayMessage = '';
			if(response.items.exists === true)
			{
				dj.byId('structure_code').set("state", "Error");
				if(field!=undefined){
				displayMessage = m.getLocalization("structureCodeExists", [field.get("value")]);
				}
				dj.showTooltip(displayMessage, dj.byId("structure_code").domNode, 0);
	
			}else
			{
				console.debug(falseMessage);
			}
	}
	
	/**
	 * <h4>Summary:</h4> 
	 * This function is to prompt an error message to the user if the 
	 * structure code exists 	
	 * 
	 * @param {Object} response
	 * @method _showExistingEmployeeNoMsg
	 */
	function _showExistingEffectiveDate(response){
		
		console.debug("[Validate] Validating effective Date");
		
		var field;
		if(dj.byId("effective_date"))
		{
			field = dj.byId("effective_date");
		}
		var displayMessage = '';
			if(response.items.exists === true)
			{
				dj.byId('effective_date').set("state", "Error");
				dj.showTooltip(m.getLocalization("effectiveDateExists"), dj.byId("effective_date").domNode, 0);
	
			}else
			{
				console.debug(falseMessage);
			}
	}
	
	
	
	/**
	 * <h4>Summary:</h4> 
	 * This function is for marking a field as required field.
	 * @param {Object} field
	 * @param _markFieldAsRequired
	 */
	function _markFieldAsRequired(field)
	{
		var displayMessage = misys.getLocalization('uploadTemplateValueRequired');
		field.set("state","Error");
		dj.hideTooltip(field.domNode);
		if(dojo.query('html') && dojo.query('html')[0] && dojo.query('html')[0].dir === 'rtl')
		{
			dj.showTooltip(displayMessage, field.domNode,['before']);
		}
		else
		{
			dj.showTooltip(displayMessage, field.domNode, 0);
		}
		var hideTT = function() {
			dj.hideTooltip(field.domNode);
		};
		setTimeout(hideTT, 5000);
		}
	
	//Holidays And CutOffTime Error Dialog With Auto Forward Operation
	/**
	 * <h4>Summary:</h4>
	 * This method is for showing error dialog for the holiday and cutoff time error.
	 * @param {String} mode
	 * @param {boolean} autoFormwardEnabled
	 * @method _showHolidaysNCutOffTimeErrorDialog
	 */
	function _showHolidaysNCutOffTimeErrorDialog(/*String*/mode,/*boolean*/autoForwardEnabled)
	{
		//if holidayCutOffDialog not defined
		if(!dj.byId("holidayCutOffDialog"))
		{
			d.require('misys.widget.Dialog');
			d.require('dijit.form.Button');
			
			//Create a dialog
			var dialog = new dj.Dialog({id: 'holidayCutOffDialog',
			    title: 'Error',draggable: false});
			
			//Create dialog content
			var dialogContent = d.create("div", { id: "holidayCutOffDialogContent"});
			var dialogText = d.create("div", {id:"dialogHolidayText"},dialogContent,'first');
			var dialogButtons =   d.create("div",{id:"holidayCutOffDialogButtons",style:"text-align:center;"},dialogContent,'last');
			
			//Buttons
			var rejectButton  = new dj.form.Button({label:m.getLocalization("returnMessage"),id:"rejectHolidayButtonId"});
			var autoForwardButton  = new dj.form.Button({label:m.getLocalization("autoForwardMessage"),id:"forwardHolidayButtonId"});
			var cancelButton  = new dj.form.Button({label:m.getLocalization("cancelMessage"),id:"cancelHolidayButtonId"});
			
			//UNSIGNED mode will have reject
			if(mode === "UNSIGNED")
			{
				d.place(rejectButton.domNode,dialogButtons);
			}
			//Only if AutoForward Enabled for User's Entity
			if(autoForwardEnabled === true)
			{
				d.place(autoForwardButton.domNode,dialogButtons);
			}
			d.place(cancelButton.domNode,dialogButtons);
			
			dialog.set("content", dialogContent);
		}
			
		if(mode !== "UNSIGNED" && !autoForwardEnabled) {
			m._config.onSubmitErrorMsg = m.getLocalization('failedSingleSubmissionFromDraft');
		}

		var holidayDialog = dj.byId("holidayCutOffDialog");
		
		//Set the Error into the Dialog
		if(d.byId("dialogHolidayText"))
		{
			d.byId("dialogHolidayText").innerHTML = m._config.onSubmitErrorMsg;
		}
		// Disable window closing by using the escape key
		m.dialog.connect(holidayDialog, 'onKeyPress', function(evt) {
			if (evt.keyCode === d.keys.ESCAPE) {
				d.stopEvent(evt);
			}
		});
		
		//Dialog Connects
		m.dialog.connect(dj.byId('forwardHolidayButtonId'), 'onClick', function(){
			holidayDialog.hide();
			setTimeout(function(){
				m.submit("AUTO_FORWARD_SUBMIT");
			}, 500);
		}, holidayDialog.id);
		
		
		m.dialog.connect(dj.byId('rejectHolidayButtonId'), 'onClick', function(){
			//Reject mode is handled as Return Transaction only for FT
			var submitType = "REJECT";
			if(dj.byId("productcode") && dj.byId("productcode").get("value") ==='FT' || 'TD' && mode === "UNSIGNED" )
			{
				submitType = "RETURN_TRANSACTION";
			}
			m.submit(submitType);
			m.dialog.hide();
			holidayDialog.hide();
		}, holidayDialog.id);
		
		m.dialog.connect(dj.byId('cancelHolidayButtonId'), 'onClick', function(){
			 m.dialog.hide();
			holidayDialog.hide();
			//MPG-10582-mandatory error field message is not shown after clicking on cancelHolidayButtonId 
			if(d.byId("dialogHolidayText"))
			{
				d.byId("dialogHolidayText").innerHTML = "";
				m._config.onSubmitErrorMsg = d.byId("dialogHolidayText").innerHTML;
			}
		}, holidayDialog.id);
		
		//On Hide of Dialog
		m.dialog.connect(holidayDialog, 'onHide', function() {
			m.dialog.disconnect(holidayDialog);
			m.dialog.hide();
		});
		
		//Show the Dialog
		holidayDialog.show();
	}
	
	//AJAX call to validate Holidays and Cut-Off Time and Load back response and error msg if any
	/**
	 * This method has an ajax call to validate Holidays and cutoff time and Load back message 
	 * and error message if any
	 * @param {String} bankAbbvname
	 * @param {String} productCode
	 * @param {String} subProductCode
	 * @param {String} mode
	 * @param {Array of date names} dateNames
	 * @param {Array of date values} dateValues
	 * @param {String} entityValue
	 * @param {String} currencyOcde
	 * @param {String} amountValue
	 * @method _validateHolidayAndCutOffTime
	 * @return {boolean}
	 *  True if valid otherwise false.
	 */
	function _validateHolidayAndCutOffTime(/*String*/bankAbbvNameValue,/*String*/productCode,/*String*/subProductCode,/*String*/mode,
				/*Array of Date Names*/dateNames,/*Array of Date values*/dateValues,/*String*/entityValue,/*String*/currencyCode,/*String*/amountValue,/*String*/clearingCodeValue)
	{
		var status = true;	
		//AJAX Call
			m.xhrPost({
					url : misys.getServletURL("/screen/AjaxScreen/action/GetBusinessDateAndCutOffTimeStatus"),
					sync : true,
					handleAs : "json",
					content : {
						date_names : dateNames,
						date_values : dateValues,
						bankAbbvName : bankAbbvNameValue,
						entity_abbv_name : entityValue,
						product_code : productCode,
						sub_product_code : subProductCode,
						cur_code : currencyCode,
						amount : amountValue,
						clearingCode :clearingCodeValue
					},
					load : function(response, args){
						//Response 
						var isValid = response.valid;
						var autoForwardEnabled = response.autoForwardEnabled;
						if(isValid === false)
						{
							status = false;
							//Set Error Msg
							m._config.onSubmitErrorMsg = response.errorMessage;
							//Dialog show
							_showHolidaysNCutOffTimeErrorDialog(mode,autoForwardEnabled);
						}
					},
					customError : function(response, args){
						console.error('[misys.validation.common] Technical error while validating business days and cut-off time');
						console.error(response);
						status = false;
						
						//Set Error Msg
						m._config.onSubmitErrorMsg = m.getLocalization("technicalErrorWhileValidatingBusinessDays");
						//Set Holidays Disabled to show non custom error
						m._config = m._config || {};
						dojo.mixin(m._config,{holidayCutOffEnabled:false});
					}
			});
		return status;
	}
	
	//
	// Public functions & variables
	//
	d.mixin(m, {
		
		//Function to check on an IBAN
		/**
		 * <h4>Summary:</h4>
		 * This function is to check on IBAN.
		 * @method isIBAN
		 */
		isIBAN : function (sIban) {
			//  summary:
		    //        Validate a value is an IBAN
			//  description:
			//        Validate a value is an IBAN by checking modulus
			return _getIBANchecksum(sIban) === 1;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is display the localize display date it internally calls psuedo private function to display the localize siaplay date
		 * @param {dijit._Widget} dateField 
		 * @method getLocalizeDisplayDate
		 */
		getLocalizeDisplayDate : function(/*dijit._Widget*/ dateField){
			return _localizeDisplayDate(dateField);
		},
						/**
						 * <h4>Summary:</h4> This function is to validate the required
						 * field <h4>Description:</h4>  This function internally calls
						 * pseudo private function to mark field as required
						 * 
						 * @method validateRequiredField
						 */
		validateRequiredField : function() {
				if(this.get("value") ==="")
					{
					 _markFieldAsRequired(this);
					}
		},
						/**
						 * <h4>Summary:</h4> This function is to validate the template id
						 * 
						 * <h4>Description:</h4>  description: The set of characters is
						 * the same as the default ones, with the accentuated
						 * characters and no "&". return
						 * validateCharacter(theObj,
						 * "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/-?:().,+");
						 * allow all characters but quote
						 * @method validateTemplateId
						 * @return {boolean}
						 *  True if valid otherwise false.
						 */
		validateTemplateId : function() {
			//  summary:
		    //        Validates the template id.
			//  description:
			//        The set of characters is the same as the default ones, with the accentuated
		    //        characters and no "&". return validateCharacter(theObj,
			//        "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/-?:().,+");
		    //        allow all characters but quote
			
			//var invalidCharacters = "\\'`";
			var character;
			var isValid = d.every(this.get("value"), function(theChar){
				character = theChar;
				return true;
			});
			
			if(!isValid) {
				this.invalidMessage = m.getLocalization("illegalCharError", [ character ]);
			}
			else if(this.get("value").length===1 && this.get("value")==="-")
			{
				this.invalidMessage = m.getLocalization("singleHyphenError");
				isValid=false;
			}


			return isValid;
	   }, 
	   /**
	    * <h4>Summary:</h4>
	    * This function is to validate if Abbreviated name already exist in DataBase
	    * <h4>Description:</h4> 
	    * Internally calls a pseudo private function to show the error
	    * @method checkAbbvNameExists
	    */
		checkAbbvNameExists : function()
		{
			var newAbbvName;
			if(dj.byId('abbv_name'))
			{
				newAbbvName = dj.byId('abbv_name').get('value');
			}
			if(newAbbvName !== "") {
		
				m.xhrPost( {
					url : m.getServletURL("/screen/AjaxScreen/action/CheckAbbvNameAction"),
					handleAs 	: "json",
					sync 		: true,
					content : {
						abbv_name : newAbbvName	
					},
					load : _showExistingAbbvNameMsg
				});
			}
		},
		
		/**
		 * Validates extended narrative sizes based on swift 2018 configurations (only initiation)
		 */
		
		validateExtNarrativeSwiftInit2018 : function(/*String*/ allNarratives, /*boolean*/ isSingleNarrative) {
			var trimmed = allNarratives.trim();
			var message = trimmed.split(/\n/);
			var rowcount = message == "" ? 0 : message.length;
			return rowcount > (isSingleNarrative ? 800 : 1000) ? false : true;
		},
		
		/**
		 * Validates extended narrative row count and character count sizes based on swift 2018 configurations (only initiation)
		 */
		
		validateRowExtNarrativeSwiftInit2018 : function(/*String*/ allNarratives, /*boolean*/ isSingleNarrative) {
			var trimmed = allNarratives.trim();
			var message = trimmed.split(/\r*\n/);
			var rowcount = message == "" ? 0 : message.length;
			var numCharTrimmed = allNarratives.trim().length;
			var numChar = numCharTrimmed == "" ? 0 : numCharTrimmed;
			var lineCount = rowcount > (isSingleNarrative ? 800 : 1000) ? true : false;
			var charCount = numChar > (isSingleNarrative ? 52000 : 65000) ? true : false;
			return (lineCount) || (charCount);
		},
		
		
		/**
		 * Validates extended narrative sizes based on swift 2018 configurations
		 */
		
		validateExtendedNarrativeSwift2018 : function(/*String*/ allNarratives,
														/*String*/msgRows, 
														/*Boolean*/ is798,
														/*boolean*/ isSingleNarrative) {
			var trimmed = allNarratives.trim();
			var message = trimmed.split(/\n/);
			var rowcount = message == "" ? 0 : message.length + (msgRows ? msgRows : 0);
			var messageSizeLimit = misys._config.swiftExtendedNarrativeEnabled ? (isSingleNarrative ? (is798 ? 792 : 800) : (is798 ? 992 : 1000)) : 100;
			return rowcount > messageSizeLimit ? false : true;
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if claim reference already exist in DataBase
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkClaimReferenceExists
		 * 
		 */
		checkClaimReferenceExists : function()
		{
				var claimRef, prodCode, companyId;
				if(dj.byId('claim_reference'))
				{
					claimRef = dj.byId('claim_reference').get('value');
				}
				if(dj.byId('product_code'))
				{
					prodCode = dj.byId('product_code').get('value');
				}
				if(dj.byId('company_id'))
				{
					companyId = dj.byId('company_id').get('value');
				}
				
				if(claimRef !== "") {
			
					m.xhrPost( {
						url : m.getServletURL("/screen/AjaxScreen/action/CheckClaimReferenceAction"),
						handleAs 	: "json",
						sync 		: true,
						content : {
							claim_ref : claimRef,	
							product_code : prodCode,
							company_id : companyId
						},
						load : _showExistingClaimRefMsg
					});
				}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if PO reference already exist in DataBase
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkPoReferenceExists
		 * 
		 */
		checkPoReferenceExists : function()
		{
				var poRef, prodCode, buyerAbbvName, sellerAbbvName, refId;
				if(dj.byId('issuer_ref_id'))
				{
					poRef = dj.byId('issuer_ref_id').get('value');
				}
				if(dj.byId('product_code'))
				{
					prodCode = dj.byId('product_code').get('value');
				}
				if(dj.byId('buyer_abbv_name'))
				{
					buyerAbbvName = dj.byId('buyer_abbv_name').get('value');
				}
				if(dj.byId('seller_abbv_name'))
				{
					sellerAbbvName = dj.byId('seller_abbv_name').get('value');
				}
				if(dj.byId('ref_id'))
				{
					refId = dj.byId('ref_id').get('value');
				}
				
				if(poRef !== "" && buyerAbbvName !== "" && sellerAbbvName !== "") {
			
					m.xhrPost( {
						url : chkPoRefAct,
						handleAs 	: "json",
						sync 		: true,
						content : {
							poRef : poRef,	
							productCode : prodCode,
							buyerAbbvName : buyerAbbvName,
							sellerAbbvName : sellerAbbvName,
							refId : refId
						},
						load : _showExistingPoRefMsg
					});
				}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if Invoice reference already exist in DataBase
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkInvoiceReferenceExists
		 * 
		 */
		checkInvoiceReferenceExists : function()
		{
				var poRef, prodCode, buyerAbbvName, sellerAbbvName, refId;
				if(dj.byId("issuer_ref_id"))
				{
					poRef = dj.byId("issuer_ref_id").get("value");
				}
				if(dj.byId('product_code'))
				{
					prodCode = dj.byId('product_code').get('value');
				}
				if(dj.byId('buyer_abbv_name'))
				{
					buyerAbbvName = dj.byId('buyer_abbv_name').get('value');
				}
				if(dj.byId('seller_abbv_name'))
				{
					sellerAbbvName = dj.byId('seller_abbv_name').get('value');
				}
				if(dj.byId('ref_id'))
				{
					refId = dj.byId('ref_id').get('value');
				}
				
				if(poRef !== "" && buyerAbbvName !== "" && sellerAbbvName !== "") {
			
					m.xhrPost( {
						url : chkPoRefAct,
						handleAs 	: "json",
						sync 		: true,
						content : {
							poRef : poRef,	
							productCode : prodCode,
							buyerAbbvName : buyerAbbvName,
							sellerAbbvName : sellerAbbvName,
							refId : refId
						},
						load : _showExistingInvoiceRefMsg
					});
				}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if PO customer reference already exist in DataBase
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkPoCustReferenceExists
		 * 
		 */
		checkInvoiceCustReferenceExists : function()
		{
				var custRef, prodCode, buyerAbbvName, sellerAbbvName, refId;
				if(dj.byId("issuer_ref_id"))
				{
					custRef = dj.byId("cust_ref_id").get("value");
				}
				if(dj.byId('product_code'))
				{
					prodCode = dj.byId('product_code').get('value');
				}
				if(dj.byId('buyer_abbv_name'))
				{
					buyerAbbvName = dj.byId('buyer_abbv_name').get('value');
				}
				if(dj.byId('seller_abbv_name'))
				{
					sellerAbbvName = dj.byId('seller_abbv_name').get('value');
				}
				if(dj.byId('ref_id'))
				{
					refId = dj.byId('ref_id').get('value');
				}
				
				if(custRef !== "" && buyerAbbvName !== "" && sellerAbbvName !== "") {
			
					m.xhrPost( {
						url : m.getServletURL("/screen/AjaxScreen/action/CheckCustReferenceAction"),
						handleAs 	: "json",
						sync 		: true,
						content : {
							custRef : custRef,	
							productCode : prodCode,
							buyerAbbvName : buyerAbbvName,
							sellerAbbvName : sellerAbbvName,
							refId : refId
						},
						load : _showExistingCustRefMsg
					});
				}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if CN reference already exist in DataBase
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkCnReferenceExists
		 */
		checkCnReferenceExists : function()
		{
				var cnRef, prodCode, buyerAbbvName, sellerAbbvName, fscmProg, refId;
				if(dj.byId("cn_reference"))
				{
					cnRef = dj.byId("cn_reference").get("value");
				}
				if(dj.byId("product_code"))
				{
					prodCode = dj.byId("product_code").get("value");
				}
				else if(dj.byId("productCode"))
				{
					prodCode = dj.byId("productCode").get("value");
				}
				if(dj.byId("buyer_abbv_name"))
				{
					buyerAbbvName = dj.byId("buyer_abbv_name").get("value");
				}
				if(dj.byId("seller_abbv_name"))
				{
					sellerAbbvName = dj.byId("seller_abbv_name").get("value");
				}
				if(dj.byId("fscm_programme_code"))
				{
					fscmProg = dj.byId("fscm_programme_code").get("value");
				}
				if(dj.byId("ref_id"))
				{
					refId = dj.byId("ref_id").get("value");
				}
				
				if(cnRef !== "") {
			
					m.xhrPost( {
						url : m.getServletURL("/screen/AjaxScreen/action/CheckCnReferenceAction"),
						handleAs 	: "json",
						sync 		: true,
						content : {
							cnReference : cnRef,	
							productCode : prodCode,
							buyerAbbvName : buyerAbbvName,
							sellerAbbvName : sellerAbbvName,
							fscmProgram : fscmProg,
							refId : refId
						},
						load : _showExistingCnRefMsg
					});
				}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if PO reference already exist in DataBase for IO
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkPoReferenceExistsIO
		 */
		checkPoReferenceExistsIO : function()
		{
				var poRef, prodCode, buyerAbbvName, sellerAbbvName, refId;
				if(dj.byId('issuer_ref_id'))
				{
					poRef = dj.byId('issuer_ref_id').get('value');
				}
				if(dj.byId('product_code'))
				{
					prodCode = dj.byId('product_code').get('value');
				}
				if(dj.byId('buyer_abbv_name'))
				{
					buyerAbbvName = dj.byId('buyer_abbv_name').get('value');
				}
				if(dj.byId('seller_abbv_name'))
				{
					sellerAbbvName = dj.byId('seller_abbv_name').get('value');
				}
				if(dj.byId('ref_id'))
				{
					refId = dj.byId('ref_id').get('value');
				}
				
				if(poRef !== "") {
			
					m.xhrPost( {
						url : chkPoRefAct,
						handleAs 	: "json",
						sync 		: true,
						content : {
							poRef : poRef,	
							productCode : prodCode,
							buyerAbbvName : buyerAbbvName,
							sellerAbbvName : sellerAbbvName,
							refId : refId
						},
						load : _showExistingPoRefMsg
					});
				}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if a Report name already exist in DataBase 
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkReportNameExists
		 */
		checkReportNameExists : function()
		{
			//Checks for Duplicate report name.			
			var newReportName;
			var repId;
			if(dj.byId('report_name'))
			{
				newReportName = dj.byId('report_name').get('value');
			}
			if(dj.byId('report_id')){
				repId = dj.byId('report_id').get('value');
			}
			
			if(newReportName !== "") {
		
				m.xhrPost( {
					url : m.getServletURL("/screen/AjaxScreen/action/CheckReportNameAction"),
					handleAs 	: "json",
					sync 		: true,
					content : {
						report_name : newReportName ,
						report_id : repId
					},
					load : _showExistingReportNameMsg
				});
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if a License name already exist in DataBase 
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkLicenseNameExists
		 */
		checkLicenseNameExists : function()
		{
				var lsName;
				if(dj.byId('ls_name'))
				{
					lsName = dj.byId('ls_name').get('value');
				}
				
				if(lsName !== '') {
			
					m.xhrPost( {
						url : m.getServletURL("/screen/AjaxScreen/action/CheckLsNameAction"),
						handleAs 	: "json",
						sync 		: true,
						content : {
							ls_Name : lsName
						},
						load : _showExistingLsNameMsg
					});
				}
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if a Facility refernce already exist in DataBase 
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkFacilityReferenceExists
		 */
		checkFacilityReferenceExists : function()
		{
			var newFacilityRef;
			var facilityId;
			var bankAbbvName;
			var compAbbvName;
			if(dj.byId('facility_reference'))
			{
				newFacilityRef = dj.byId('facility_reference').get('value');
			}
			if(dj.byId('facility_id')){
				facilityId = dj.byId('facility_id').get('value');
			}
			if(dj.byId('company_abbv_name')){
				compAbbvName = dj.byId('company_abbv_name').get('value');
			}
			if(dj.byId('bank_abbv_name')){
				bankAbbvName = dj.byId('bank_abbv_name').get('value');
			}
			
			if(newFacilityRef !== "") {
		
				m.xhrPost( {
					url : m.getServletURL("/screen/AjaxScreen/action/CheckFacilityReferenceAction"),
					handleAs 	: "json",
					sync 		: true,
					content : {
						facility_reference : newFacilityRef ,
						facility_id : facilityId,
						company_abbv_name : compAbbvName,
						bank_abbv_name : bankAbbvName
					},
					load : _showExistingFacilityReferenceMsg
				});
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if a Employee name already exist in DataBase 
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkEmployeeNoExists
		 */
		checkEmployeeNoExists : function()
		{
			//Checks for Duplicate Employee No name.			
			var newEmployeeNo;
			var companyId;
			var loginId;
			var NewLoginId;
			if(dj.byId('employee_no'))
			{
				newEmployeeNo = dj.byId('employee_no').get('value');
			}
			if(dj.byId('company_id'))
			{
				companyId = dj.byId('company_id').get('value');
			}
			if(dj.byId('login_id_hidden'))
			{
				loginId = dj.byId('login_id_hidden').get('value');
			}
			if(dj.byId('login_id'))
				{
				NewLoginId = dj.byId('login_id').get('value');
				}
			
			
			if(newEmployeeNo !== "") {
		
				m.xhrPost( {
					url : m.getServletURL("/screen/AjaxScreen/action/CheckEmployeeNoAction"),
					handleAs 	: "json",
					sync 		: true,
					content : {
						employee_no : newEmployeeNo,
						company_id : companyId,
						login_id_hidden : loginId,
						login_id : NewLoginId
					},
					load : _showExistingEmployeeNoMsg
				});
			}
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if a Bank reference (BO_REF_ID) already exist in DataBase 
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkBankReference
		 */
		checkBankReference : function()
		{
			//Checks for Duplicate Bank reference.			
			var bo_ref, refId;
			var isValidRef = true;
			if(dj.byId('bo_ref_id'))
			{
				bo_ref = dj.byId('bo_ref_id').get('value');
			}
			if(dj.byId('ref_id'))
			{
				refId = dj.byId('ref_id').get('value');
			}
			
			if(bo_ref !== "") {
				m.xhrPost({
					url : m.getServletURL("/screen/AjaxScreen/action/ValidateDuplicateBankReference"),
					sync : true,
					handleAs : "json",
					content: {
						bo_ref_id: bo_ref,
						refId: refId
						},
					load : function(response, args){
						if(response.responseFlag == false)
						{
							console.debug("Dublicate Bank Reference");
							isValidRef = false;
						}else
						{
							console.debug("bo_ref_id is unique");
						}
					},
					error : function(response, args){
						console.error("checkBankReference AJAX error", response);
					}
				});
			}
			return isValidRef;
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if a RM Group already exist in DataBase 
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkEmployeeNoExists
		 */
		checkRMGroupExists : function()
		{
			//Checks for Duplicate Employee No name.			
			var rmGroup;
			var isValid=true;
			

			if(dj.byId('rmGroup'))
			{
				rmGroup = dj.byId('rmGroup').get('value');
			}
			var companyId = dj.byId('company_id').get('value');
			if(rmGroup !== "") {
		
				m.xhrPost( {
					url : m.getServletURL("/screen/AjaxScreen/action/CheckRMGroupExistsAction"),
					handleAs 	: "json",
					sync 		: false,
					content : {
						rm_group : rmGroup,
						companyid: companyId
					},
					load : function(response, args){
						console.debug("[Validate] Validating RMGroup ");
						
						var field;
						if(dj.byId("rmGroup"))
						{
							field = dj.byId("rmGroup");
						}
						var displayMessage = '';
							if(response.items.valid === false)
							{
								if(field!=undefined){
								field.focus();
								displayMessage = m.getLocalization("rmGroupNoExists", [response.items.rmGroup]);
								field.set("value", "");
								field.set("state", "Error");
								dj.hideTooltip(field.domNode);
								dj.showTooltip(displayMessage,field.domNode, 0);
								}
								isValid = false;
					
							}else
							{
								console.debug(falseMessage);
							}
					},
					error : function(response, args){
						isValid = false;
						console.error(" processRepricingOfRecords error", response);
					}
				});
			}
			return isValid;
		},	
		
		validateFeeAccount : function (){
			var entityField="";
			var isValidFeeAccount = false;
			var feeAccount = "";
			if(dj.byId("fee_act_no")){
				feeAccount = feeAccount = dj.byId("fee_act_no").get('value');	
			}

			if (dj.byId("entity"))
			{
				entityField = dj.byId("entity").get('value');			
			}
			m.xhrPost({
				url : m.getServletURL("/screen/AjaxScreen/action/GetStaticData"),
				sync : true,
				handleAs : "json",
				content: {
					option: "account",
					fields: "['fee_act_no']",
					productcode: "SI",
					entity: entityField
					},
				load : function(response, args){
					for (var i = 0; i < response.items.length; i++) {
					    if(response.items[i].ACCOUNTNO==feeAccount)
				    	{
					    	isValidFeeAccount = true;
					    	console.debug("validate Fee Account is true");
					    	break;
				    	}
					}
				},
				error : function(response, args){
					console.error("validateFeeAccount AJAX error", response);
				}
			});	
			return isValidFeeAccount;
		},
		
		validateApplDate : function (bankAbbvName){
			var valid= true;
			var applDate;
			if(dj.byId("appl_date")){
				 applDate=dj.byId("appl_date").get('value');	
			}
			m.xhrPost({
				url : m.getServletURL("/screen/AjaxScreen/action/ValidateApplDate"),
				sync : true,
				handleAs : "json",
				content: {
					bankAbbvName: bankAbbvName,
					applDate: applDate
					},
				load : function(response, args){
					if(response.items.valid == false)
					{
						valid= false;
						 if(dj.byId("appl_date"))
							{
								dj.byId("appl_date").set("value",response.items.bDate);
								dojo.byId("appl_date_view_row").childNodes[1].innerHTML=dj.byId("appl_date").get("value");
							}
					}
				}
			});	
			return valid;
		},
		goToTop : function (){
		var target = d.byId("body");
		if(d.isIE <= 6) 
		{
			d.window.scrollIntoView(target);
	    }
		else
		{
			dojox.fx.smoothScroll({
				node: target, 
				win: window
				}).play();
		}
		},
		validatePricipleAccount : function (){
			var entityField="";
			var productCode = "";
			var isValidPrincipleAccount = false;
			var principleAccount = "";
			if(dj.byId("principal_act_no")){
				principleAccount = dj.byId("principal_act_no").get('value');
			}

			if (dj.byId("entity"))
			{
				entityField = dj.byId("entity").get('value');			
			}
			if (dj.byId("product_code"))
			{
				productCode = dj.byId("product_code").get('value');			
			}
			m.xhrPost({
				url : m.getServletURL("/screen/AjaxScreen/action/GetStaticData"),
				sync : true,
				handleAs : "json",
				content: {
					option: "account",
					fields: "['principal_act_no']",
					productcode: productCode,
					entity: entityField
					},
				load : function(response, args){
					for (var i = 0; i < response.items.length; i++) {
					    if(response.items[i].ACCOUNTNO==principleAccount)
				    	{
					    	isValidPrincipleAccount = true;
					    	console.debug("validate Principle Account is true");
					    	break;
				    	}
					}
				},
				error : function(response, args){
					console.error("validatePrincipleAccount AJAX error", response);
				}
			});	
			return isValidPrincipleAccount;
		},
		
		checkEntityIdExists : function()
		{
			var newAbbvName;
			var companyId;
			if(dj.byId('abbv_name'))
			{
				newAbbvName = dj.byId('abbv_name').get('value');
				
			}
			if(dj.byId('company_abbv_name'))
			{
				companyId = dj.byId('company_id').get('value');
				
			}
			
			if(newAbbvName !== "") {
		
				m.xhrPost( {
					url : m.getServletURL("/screen/AjaxScreen/action/CheckEntityIdAction"),
					handleAs 	: "json",
					sync 		: true,
					content : {
						abbv_name : newAbbvName,	
						companyId : companyId
					},
					load : _showExistingAbbvNameMsg
				});
			}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if structure code already exist in DataBase
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkStructureCodeExists
		 */
		checkStructureCodeExists : function()
		{
				var structCode;
				if(dj.byId('structure_code'))
				{
					structCode = dj.byId('structure_code').get('value');
				}			
				
				if(structCode !== "") {
			
					m.xhrPost( {
						url : m.getServletURL("/screen/AjaxScreen/action/CheckStructureCodeExistsAction"),
						handleAs 	: "json",
						sync 		: true,
						content : {
							structureCode : structCode	
						},
						load : _showExistingCodeMsg
					});
				}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate if effectiveDate already exist in DataBase
		 * <h4>Description:</h4> 
		 * Have an AJAX call inside it
		 * @method checkEffectiveDateExists
		 */
		checkEffectiveDateExists : function()
		{
				var effDate;
				if(dj.byId('effective_date'))
				{
					 effDate = dj.byId("effective_date").get("displayedValue");
					
					
				}			
				
				if(effDate !== "") {
			
					m.xhrPost( {
						url : m.getServletURL("/screen/AjaxScreen/action/CheckEffectiveDateExistsAction"),
						handleAs 	: "json",
						sync 		: true,
						content : {
							effective_date : effDate	
						},
						load : _showExistingEffectiveDate
					});
				}
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates that request date is greater than or equal to the processing date and application date.
		 * @method validateCashRequestDate
		 * @return {booelan}
		 *  True if valid otherwise false.
		 */
	   validateCashRequestDate : function() {
			// Test that the request_date is greater than or equal to
			// the processing_date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("requestDateLessThanAppDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				return false;
			}
			var issueDate = dj.byId("iss_date");
			if(!m.compareDateFields(issueDate, this)) {
				this.invalidMessage = m.getLocalization("requestDateLessThanProcessingDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(issueDate)]);
				return false;
			}
			return true;
	   },
	   
	   /**
		 * <h4>Summary:</h4>
		 * This function validates that Alert from date is greater than Alert to date.
		 * @method validateCashRequestDates
		 * @return {boolean}
		 *  True if valid otherwise false.
		 */
	   validateAlertDates : function() {
			// Test that the request_date is greater than or equal to
			// the processing_date

			var fromDate = dj.byId("alert_date");
			var toDate = dj.byId("alert_date2");
			if(fromDate && fromDate.get("value")!=="" && toDate && toDate.get("value")!=="" && (!m.compareDateFields(fromDate, toDate)))
			{
				this.invalidMessage = m.getLocalization("alertToDateLessThanFromError", [
								_localizeDisplayDate(toDate),
								_localizeDisplayDate(fromDate)]);
				toDate.set("state", "Error");
				dj.showTooltip(this.invalidMessage,toDate.domNode, 0);
				return false;
			}
			return true;
	   },
	   
	   /**
		 * Validate the transaction type drop down for Screens 
		 * related to Loan Product
		 *  
		 */
	   validateLoanTransactionTypeDropDown : function() {	
		   
			dj.byId("tnx_type_code_parameter").set("value", "");
			dj.byId("sub_tnx_type_code_parameter").set("value", "");
			dj.byId("sub_product_code_parameter").set("value", "");
			
			var tnx_sub_tnx_combine = (dj.byId("tnx_type_code_dropdown").get("value")).split(":");
			if(dj.byId("tnx_type_code_dropdown") && dj.byId("tnx_type_code_dropdown") != " "){
				var tnx_type_code = dj.byId("tnx_type_code_parameter");
				var sub_tnx_type_code = dj.byId("sub_tnx_type_code_parameter");
				var sub_product_code = dj.byId("sub_product_code_parameter") ;
				if(tnx_sub_tnx_combine.length > 1)
				{
					tnx_type_code.set('value',tnx_sub_tnx_combine[0]);
					sub_tnx_type_code.set('value',tnx_sub_tnx_combine[1]);
					sub_product_code.set('value',"");
				}
				else
				{
					tnx_type_code.set('value',tnx_sub_tnx_combine[0]);
					sub_product_code.set('value',"LNRPN");
					sub_tnx_type_code.set('value',"");
				}
			}
	},
	   
	validateLoanTransactionStatusDropDown : function()
	{
		dj.byId("tnx_stat_code_parameter").set("value","");
		if(dj.byId("sub_tnx_stat_code_parameter")){
			dj.byId("sub_tnx_stat_code_parameter").set("value", "");
		}
		
		
	   if(dj.byId("tnx_stat_code_dropdown") && dj.byId("tnx_stat_code_dropdown") != " "){
		   var tnx_sub_tnx_combine = (dj.byId("tnx_stat_code_dropdown").get("value")).split(":");
		   var tnx_stat_code_parameter = dj.byId("tnx_stat_code_parameter");
			var sub_tnx_stat_code_parameter = dj.byId("sub_tnx_stat_code_parameter");
			if(tnx_sub_tnx_combine.length > 1)
			{
				tnx_stat_code_parameter.set('value',tnx_sub_tnx_combine[0]);
				sub_tnx_stat_code_parameter.set('value',tnx_sub_tnx_combine[1]);
				
			}
			else
			{
				tnx_stat_code_parameter.set('value',tnx_sub_tnx_combine[0]);
				if(sub_tnx_stat_code_parameter){
					sub_tnx_stat_code_parameter.set('value',"");
				}
				
			}
		   
	   }
	},
	   
	isLegalTextAcceptedForAuthorizer : function() {	
		
		 var isValid = false, 
		errorMsg;
		m.xhrPost({
		url : m.getServletURL("/screen/AjaxScreen/action/ValidateAuthorizer"),
		handleAs : "json",
		sync : true,
		preventCache: true,
		content : {
			productCode : dj.byId("product_code") ? dj.byId("product_code").get("value") : misys._config.productCode,
			subProductCode : dijit.byId('sub_product_code') ? dijit.byId('sub_product_code').get('value') : '',
			tnxtype : dijit.byId('tnxtype').get('value') ? dijit.byId('tnxtype').get('value') : dijit.byId('tnx_type_code').get('value'),
			option : dj.byId("option") ? dj.byId("option").get("value") : '',
			subtnxtypeCode :  dj.byId("sub_tnx_type_code") ? dj.byId("sub_tnx_type_code").get("value") : '',
			xml : misys.formToXML({ignoreDisabled: true}),
			mode : dj.byId("mode") ? dj.byId("mode").get("value") : '',
			operation : dj.byId("realform_operation") ? dj.byId("realform_operation").get("value") : ""
			
		},		
		load : function(response, ioArgs)
		{   
			isValid = response.isValid;
			errorMsg = response.errorMsg;
		},
		customError : function(response, ioArgs)
		{
			console.error(" processRepricingOfRecords error", response);
			m._config = m._config || {};
			dojo.mixin(m._config,{legalTextEnabled:false});
		}

		});
	if(isValid){
//		return true when there is no dialog box, added this to accomodate new changes to legal text
		var legalDialog = dijit.byId("legalDialog");
		if(!legalDialog){
			return true;
		}
		if(legalDialog.open === false ){
				dj.byId("accept_legal_text").set("checked", false);
				dijit.byId('submitlegal').set('disabled',true);
				
		}
		m.dialog.connect(dj.byId('submitlegal'), 'onClick', function(){
			
			legalDialog.hide();
			setTimeout(function(){
				m.acceptLegalText();
			}, 500);
		}, legalDialog.id);
		
		m.dialog.connect(dj.byId('cancel'), 'onClick', function(){
			 m.dialog.disconnect(legalDialog);
		}, legalDialog.id);
		
		m.dialog.connect(d.byId('legalDialog_close'), 'onClick', function(){
			m.dialog.disconnect(legalDialog);
		});
		
		dijit.byId("alertDialog").hide();
		
		legalDialog.show();
		return false;
		
	}else{
		//Remove these fields from form if current user is not a valid authorizer
		dojo.destroy("authorizer_id");
		dojo.destroy("legal_text_value");
		return true;
	}
	} ,
	   /**
	    * <h4>Summary:</h4>
	    * This fuction validates that processing date should be greater than the application date
	    * also request date should be ore than processing date.
	    * @method validateCashProcessingDate
	    * @return {boolean}
	    *  True if valid otherwise false.
	    */
	   validateCashProcessingDate : function() {
		   if(!this.get("value")) {
				return true;
			}
			// Test that the request_date is greater than or equal to
			// the processing_date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("processingDateLessThanAppDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				return false;
			}
			var processingDate = dj.byId("iss_date");
			if(!m.compareDateFields(processingDate, this)) {
				this.invalidMessage = m.getLocalization("requestDateLessThanProcessingDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(processingDate)]);
				return false;
			}
			// validate for current date
			// For Customer End, processing date should not be less than the current date
			// validate only at customer side
			if(this.get("value") !== "")
			{
				 var isValid;
				console.debug("[misys.validation.common] Begin Validating processing Date with current date. Value = ",
						this.get("value"));	
				var currentDate, customer_bank;
			    if(dj.byId("customer_bank"))
				{
					customer_bank = dj.byId("customer_bank").get("value"); 
				}
			    else if(dj.byId("bank_abbv_name"))
				{
					customer_bank = dj.byId("bank_abbv_name").get("value"); 
				}
				else
				{
					customer_bank = dj.byId("issuing_bank_abbv_name").get("value"); 
				}
			    var yearServer, monthServer, dateServer;
			    if(customer_bank !== "" && misys && misys._config && misys._config.businessDateForBank && misys._config.businessDateForBank[customer_bank] && misys._config.businessDateForBank[customer_bank][0] && misys._config.businessDateForBank[customer_bank][0].value !== "")
			    {
			    	yearServer = parseInt(misys._config.businessDateForBank[customer_bank][0].value.substring(0,4), 10);
					monthServer = parseInt(misys._config.businessDateForBank[customer_bank][0].value.substring(5,7), 10);
					dateServer = parseInt(misys._config.businessDateForBank[customer_bank][0].value.substring(8,10), 10);
					currentDate = new  Date(yearServer, monthServer - 1, dateServer);
			    }
			    else if(misys && misys._config && misys._config.bankBusinessDate && misys._config.bankBusinessDate !== "")
			    {
			    	yearServer = parseInt(misys._config.bankBusinessDate.substring(0,4), 10);
					monthServer = parseInt(misys._config.bankBusinessDate.substring(5,7), 10);
					dateServer = parseInt(misys._config.bankBusinessDate.substring(8,10), 10);
					currentDate = new  Date(yearServer, monthServer - 1, dateServer);
			    }
			    else
			    {
			    	currentDate = new Date();
			    }
				// set the hours to 0 to compare the date values
				currentDate.setHours(0, 0, 0, 0);
				// get the localized value in standard format.
				console.debug(currntDatevalue,
						currentDate);	
				// compare the values of the current date and transfer date
				isValid = d.date.compare(m.localizeDate(this), currentDate) < 0 ? false : true;
				if(!isValid)
				{
					 this.invalidMessage = m.getLocalization("processingDateGreaterThanCurrentDateError", [_localizeDisplayDate(this)]);
					 return false;
				}
				console.debug("[misys.validation.common] End Validating processing Date with current date. Value = ",
						this.get("value"));
			}
			return true;
	   },
	   /**
	    * <h4>Summary:</h4>
	    * This function validates that end date should be greater than the system's date
	    * @method validateEndDateWithCurrentDate
	    * @return {boolean}
	    *   True if valid otherwise false.
	    */
	   validateEndDateWithCurrentDate : function()
	   {
	    //  summary:
	    //Validates the end date.
		//Test that the end date is greater than or equal to the system's date.
		   
		   if(!this.get("value")) {
				return true;
			}

		console.debug("[misys.validation.common] Validating end Date, Value = ", 
				this.get("value"));
	    var endDate = this.get("value");
	    var currentDate, customer_bank;
	    if(dj.byId("customer_bank"))
		{
			customer_bank = dj.byId("customer_bank").get("value"); 
		}
	    else if(dj.byId("bank_abbv_name"))
		{
			customer_bank = dj.byId("bank_abbv_name").get("value"); 
		}
		else if(dj.byId("issuing_bank_abbv_name"))
		{
			customer_bank = dj.byId("issuing_bank_abbv_name").get("value"); 
		}
	    var yearServer, monthServer, dateServer;
	    if(customer_bank !== "" && misys && misys._config && misys._config.businessDateForBank && misys._config.businessDateForBank[customer_bank] && misys._config.businessDateForBank[customer_bank][0] && misys._config.businessDateForBank[customer_bank][0].value !== "")
	    {
	    	yearServer = parseInt(misys._config.businessDateForBank[customer_bank][0].value.substring(0,4), 10);
			monthServer = parseInt(misys._config.businessDateForBank[customer_bank][0].value.substring(5,7), 10);
			dateServer = parseInt(misys._config.businessDateForBank[customer_bank][0].value.substring(8,10), 10);
			currentDate = new  Date(yearServer, monthServer - 1, dateServer);
	    }
	    else if(misys && misys._config && misys._config.bankBusinessDate && misys._config.bankBusinessDate !== "")
	    {
	    	yearServer = parseInt(misys._config.bankBusinessDate.substring(0,4), 10);
			monthServer = parseInt(misys._config.bankBusinessDate.substring(5,7), 10);
			dateServer = parseInt(misys._config.bankBusinessDate.substring(8,10), 10);
			currentDate = new  Date(yearServer, monthServer - 1, dateServer);
	    }
	    else
	    {
	    	currentDate = new Date();
	    }
		// set the hours to 0 to compare the date values
		currentDate.setHours(0, 0, 0, 0);
		// get the localized value in standard format.
		console.debug(currntDatevalue,
						currentDate);	
		// compare the values of the current date and end date
		var isValid = d.date.compare(m.localizeDate(this), currentDate) < 0 ? false : true;
		if(!isValid)
		{
			 this.invalidMessage = m.getLocalization("endDateSmallerThanCurrentDate", [_localizeDisplayDate(this)]);
			 return false;
		}
		
		return true;
	   },
	   /**
	    * <h4>Summary:</h4>
	    * This function validates the Expiry date
	    * 
	    * <h4>Description:</h4> 
	    * Expiry date should be greater than the Application date,
	    * Expiry date should be greater than the issue date.
	    * @method validateTradeExpiryDate
	    * @return {boolean}
	    *  True if valid otherwise false.
	    */
	   validateTradeExpiryDate : function() {
			//  summary:
		    //        Validates the data entered as the Expiry Date.
		    // 
		    // TODO Add business logic explanation here
		   
			// This validation is for non-required fields
			if(!this.get("value")) {
				return true;
			}

			console.debug(ExpDateValue,
					this.get("value"));
			
			// Test that the expiry date is greater than or equal to
			// the application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("expiryDateLessThanAppDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				return false;
			}
			
			// Test that the expiry date is greater than or equal to the issue date 
			var issueDate = dj.byId("iss_date");
			if((issueDate) && (!m.compareDateFields(issueDate, this)))
			{
					this.invalidMessage = m.getLocalization("issueDateGreaterThanExpiryDateError",[
									_localizeDisplayDate(issueDate),
									_localizeDisplayDate(this)]);
					return false;
			}
			
			var orgExpDate = dj.byId("org_previous_exp_date");
			if((orgExpDate) && (!m.compareDateFields(orgExpDate, this)))
			{
					this.invalidMessage = m.getLocalization("orgExpDateGreaterThanExpiryDateError",[
									_localizeDisplayDate(this),
									_localizeDisplayDate(orgExpDate)]);
					return false;
			}
			
			// Test that the expiry date is greater than or equal to the Amendment date 
			var amdDate = dj.byId("amd_date");
			if((amdDate) && (!m.compareDateFields(amdDate, this)))
			{
					this.invalidMessage = m.getLocalization("ExpiryDateLessThanamendDate",[
									_localizeDisplayDate(this),
									_localizeDisplayDate(amdDate)]);
					return false;
			}
			
			
			
			// Test that the expiry date is greater than or equal to the last shipment detail
			var lastShipDate = dj.byId("last_ship_date");
			if((lastShipDate) && (!m.compareDateFields(lastShipDate, this)))
			{
					this.invalidMessage = m.getLocalization("expiryDateLessThanLastShipmentError",[
							        _localizeDisplayDate(this),
									_localizeDisplayDate(lastShipDate)
									]);
					return false;
			}
			
			var oldLastShipDate = dj.byId("org_last_ship_date");
			if((lastShipDate && lastShipDate.get("value") == null) && (oldLastShipDate && !m.compareDateFields(oldLastShipDate, this)))
				{
					this.invalidMessage = m.getLocalization("newexpiryDateLessThanOldShipmentError",[
									_localizeDisplayDate(oldLastShipDate),
									_localizeDisplayDate(this)]);
					return false;
	   		}
				
			var renewalCalDate = dj.byId("renewal_calendar_date");
			if(renewalCalDate)
				{
				if(renewalCalDate.get("value") != null && this.get("value") != null && (renewalCalDate.get("value") > this.get("value"))) {
					var localizedCalendarDate = dojo.date.locale.format(renewalCalDate.get("value"), {selector:"date", formatLength:"short", locale:dojo.config.locale});
					var localizedExpiryDate = dojo.date.locale.format(this.get("value"), {selector:"date", formatLength:"short", locale:dojo.config.locale});
					renewalCalDate.invalidMessage = m.getLocalization("calendarDateLessThanSystemDate", [localizedCalendarDate,localizedExpiryDate]);
					renewalCalDate.set("state","Error");
				}
				else if(renewalCalDate.get("value") != null && this.get("value") != null && renewalCalDate.get("value") <= this.get("value"))
				{
					renewalCalDate.set("state","");
				}
				}
			
			var nextRevolveDate = dj.byId("next_revolve_date");
			if(nextRevolveDate && !m.compareDateFields(nextRevolveDate, this)) 
			{
				this.invalidMessage = m.getLocalization("expDateLessThanNextRevolveDateError", [
									_localizeDisplayDate(nextRevolveDate),
									_localizeDisplayDate(this)]);
				return false;
			}
			
			// Test that the expiry date is greater than or equal to the Business date
			if(!m._config.isBank){

				var expDate = this.get("value");

				var days = validateBusinessDate(this);
				if(days < 0)
				{
				console.debug(ExpDateCurrntDate, days);
					this.invalidMessage = m.getLocalization("expiryDateSmallerThanSystemDate",[
					                                               						         _localizeDisplayDate(this)
					                                               								]);
					return false;
				}	
			}
			return true;
		}, 
		
		/**
		 * <h4>Summary:</h4>  This method validates the maturity date with the current date.
		 * <h4>Description</h4> : This method validates the maturity date with the current date.
		 * Validation - The maturity date should be greater than the current date else an error will be thrown.
		 *
		 * @method validateEnteredDateGreaterThanCurrentDate
		 */
		validateEnteredDateGreaterThanCurrentDate : function() {
				
			if(!m._config.isBank || (m._config.isBank && dj.byId("prod_stat_code") && dj.byId("prod_stat_code").get("value") === '03' || dj.byId("prod_stat_code").get("value") === '08'))
			{	
		
				var maturityDate = dj.byId("maturity_date");
				if(this.get("value")!=null)
					{
				var days = validateBusinessDate(this);
				if(days < 0)
				{					
					console.debug("[misys.binding.trade.message_bg] Result of comparison = ", m.getLocalization("lessthanCurrentDate"));					
					m.dialog.show("ERROR", m.getLocalization("lessthanCurrentDate"));					
					maturityDate.set("value", " ");
					return false;
				}
					}
			}
			return true;												
		},
		   /**
		    * <h4>Summary:</h4>
		    * This function validates the Amend Expiry date onChange
		    * 
		    * <h4>Description:</h4> 
		    * Expiry date should be greater than the Application date,
		    * Expiry date should be greater than the issue date.
		    * @method validateAmendBGTradeExpiryDate
		    */
		   validateAmendBGTradeExpiryDate : function() {
				//  summary:
			    //        Validates the data entered as the Expiry Date.
			    // 
			    // TODO Add business logic explanation here
			   

				console.debug(ExpDateValue,
						this.get("value"));
								
				// Test that the expiry date is greater than or equal to the Amendment date 
				var amdDate = dj.byId("amd_date");
				if((amdDate) && (!m.compareDateFields(amdDate, this)))
				{
					this.invalidMessage =m.getLocalization("ExpiryDateLessThanamendDate",[_localizeDisplayDate(this),_localizeDisplayDate(amdDate)]);
					return false;
				}
									
				
				// Test that the expiry date is greater than or equal to the current date

				var expDate = this.get("value");
				var days = validateBusinessDate(this);
			if(days < 0)
				{
				this.invalidMessage = m.getLocalization("expiryDateSmallerThanSystemDate",[_localizeDisplayDate(this)]);
				return false;
				}
				
				//Test that the expiry date is more than the renewal calendar date(if renewal calendar date is there).
				var renewalCalDate = dj.byId("renewal_calendar_date");
				if(renewalCalDate)
				{
					if(renewalCalDate.get("value") != null && this.get("value") != null && (renewalCalDate.get("value") > this.get("value"))) 
					{
						this.invalidMessage =m.getLocalization("expiryDateLessThanRenewalDate", [_localizeDisplayDate(renewalCalDate)]);
						return false;
					}
				}	
				return true;
			},
		
		/**
		 * <h4>Summary:</h4>
		 * This function validates the data enetered as the contract date.
		 * <h4>Description:</h4> 
		 * This checks for the following scenarios
		 * The new contract date should be before the application date.
		 * @method validateContractDate
		 * @return {booelan}
		 *   True if valid otherwise false.
		 */
		validateContractDate : function(){
			
			
			if(!this.get("value")) {
				return true;
			}

			console.debug("[misys.validation.common] Validating Contract Date. Value = ",
					this.get("value"));
			
			// Test that the contract date is less than or equal to
			// the application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields( this, applDate)) {
				this.invalidMessage = m.getLocalization("contractDateGreaterThanApplicationDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				return false;
			}
			
			return true;
			
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates the data enetered as the Base date.
		 * <h4>Description:</h4> 
		 * This checks for the following scenarios
		 * The new contract date should be before the application date.
		 * @method validateBaseDate
		 * @return {booelan}
		 *   True if valid otherwise false.
		 */
		validateBaseDate : function(){
			
			
			if(!this.get("value")) {
				return true;
			}

			console.debug("[misys.validation.common] Validating base Date. Value = ",
					this.get("value"));
			
			// Test that the contract date is less than or equal to
			// the application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields( this, applDate)) {
				this.invalidMessage = m.getLocalization("baseDateGreaterThanApplicationDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				return false;
			}
			
			return true;
			
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates the data enetered as the document date.
		 * <h4>Description:</h4> 
		 * This checks for the following scenarios
		 * The new document date should be before the application date.
		 * @method validateDocumentDate
		 * @return {booelan}
		 *   True if valid otherwise false.
		 */
		validateDocumentDate : function(){
			
			
			if(!this.get("value")) {
				return true;
			}

			console.debug("[misys.validation.common] Validating Contract Date. Value = ",
					this.get("value"));
			
			// Test that the contract date is less than or equal to
			// the application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields( this, applDate)) {
				this.invalidMessage = m.getLocalization("documentDateGreaterThanApplicationDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				
				m._config.errorField.push(this);
				return false;
			}
			if(!(this.get("state") === "Error")) {
				m._config.errorField = [];
			}
			
			return true;
			
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function validates the data enetered as the tender expiry date.
		 * <h4>Description:</h4> 
		 * This checks for the following scenarios
		 * The tender expiry date should be after the application date.
		 * @method validateTenderExpiryDate
		 * @return {booelan}
		 *   True if valid otherwise false.
		 */
		validateTenderExpiryDate : function(){
			
			
			if(!this.get("value")) {
				return true;
			}

			console.debug("[misys.validation.common] Validating Tender Expiry Date. Value = ",
					this.get("value"));
			
			// Test that the contract date is greater than or equal to
			// the application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("tenderExpDateLessThanApplicationDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				return false;
			}
			
			// Test that the contract date is less than or equal to
			// the expiry date
			var expDate = dj.byId("exp_date");
			if((expDate) && (!m.compareDateFields(this, expDate)))
			{
					this.invalidMessage = m.getLocalization("expDateGreaterThanTenderExpiryDateError",[
									_localizeDisplayDate(this),
									_localizeDisplayDate(expDate)]);
					return false;
			}
			
			return true;
			
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function validates the data enetered as the Expiry date.
		 * <h4>Description:</h4> 
		 * This checks for the following scenarios
		 * The new expiry date should be after the original expiry date.
		 * The new expiry date should be after the issue date.
		 * @method validateMessageTradeExpiryDate
		 * @return {booelan}
		 *   True if valid otherwise false.
		 */
		validateMessageTradeExpiryDate : function() {
			//  summary:
		    //        Validates the data entered as the Expiry Date.
		    // 
		    // TODO Add business logic explanation here
		   
			// This validation is for non-required fields
			if(!this.get("value")) {
				return true;
			}

			// Test that the expiry date is greater than or equal to the original expiry date (hidden fields)
			var thisObject  = dj.byId(this.id);
			var orgExpDateDate = dj.byId("org_exp_date");
			
			if(!m.compareDateFields(orgExpDateDate, thisObject)) {
				this.invalidMessage = m.getLocalization("expiryDateSmallerThanOrgExpiryDate",[
								_localizeDisplayDate(thisObject),
								_localizeDisplayDate(orgExpDateDate)]);
				return false;
			}
			
			
			// Test that the Next revolve date is greater than or equal to the issue date 
			var issueDate = dj.byId("iss_date");
			if(!m.compareDateFields(issueDate, thisObject)) {
				this.invalidMessage = m.getLocalization("expiryDateSmallerThanIssueDate",[
								_localizeDisplayDate(thisObject),
								_localizeDisplayDate(issueDate)]);
				return false;
			}
			
			// Test that the expiry date is greater than or equal to the current date
			
		var days = validateBusinessDate(this);
			if(days < 0)
					{
					console.debug(ExpDateCurrntDate, days);
				this.invalidMessage = m.getLocalization("expiryDateSmallerThanSystemDate",[
				                                               						         _localizeDisplayDate(thisObject)
				                                               								]);
			return false;
			}
			
			return true;
		}, 
		
		/**
		 * <h4>Summary:</h4>
		 * This function validates the message transfer expiry date 
		 * <h4>Description:</h4> 
		 * Expiry date should be greater than the issue date
		 * @method validateMessageTransferTradeExpiryDate
		 * @return {boolean}
		 *  True if valid otherwise false.
		 */
		validateMessageTransferTradeExpiryDate : function() {
			//  summary:
		    //        Validates the data entered as the Expiry Date.
		    // 
		    // TODO Add business logic explanation here
		   
			// This validation is for non-required fields
			if(!this.get("value")) {
				return true;
			}

			// Test that the expiry date is greater than or equal to the original expiry date (hidden fields)
			var thisObject  = dj.byId(this.id);
			var orgExpDateDate = dj.byId("org_exp_date");
			
			if(!m.compareDateFields(thisObject, orgExpDateDate)) {
				this.invalidMessage = m.getLocalization("expiryDateBiggerThanOrgExpiryDate",[
								_localizeDisplayDate(thisObject),
								_localizeDisplayDate(orgExpDateDate)]);
				return false;
			}
			
			
			// Test that the expiry date is greater than or equal to the issue date (hidden fields)
			var issueDate = dj.byId("iss_date");
			if(!m.compareDateFields(issueDate, thisObject)) {
				this.invalidMessage = m.getLocalization("expiryDateSmallerThanIssueDate",[
								_localizeDisplayDate(thisObject),
								_localizeDisplayDate(issueDate)]);
				return false;
			}
			
			// Test that the expiry date is greater than or equal to the Business date
			var days = validateBusinessDate(this);
			if(days < 0)
			{
				console.debug(ExpDateCurrntDate, days);
				this.invalidMessage = m.getLocalization("expiryDateSmallerThanSystemDate",[
				                                               						         _localizeDisplayDate(thisObject)
				                                               								]);
			return false;
			}
			
			return true;
		}, 

		/**
		 * <h4>Summary:</h4>
		 * This function validates Free format message if it is null. 
		 * <h4>Description:</h4> 
		 * Free format message should'nt be null.
		 * @method validateFreeFormatMessage
		 * @return {boolean}
		 *  True if valid otherwise false.
		 */
		validateFreeFormatMessage : function(){
			if(dj.byId("free_format_text").get("value")==="" || dj.byId("free_format_text").get("value") ===null){
				console.debug("[misys.validation.common] validating 'Customer Instructions' of 'Free Formate Message' if it is null");
				this.invalidMessage = m.getLocalization("requiredToolTip");
				return false;
			}else{
				return true;
			}
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This fucntion validates the data entered as the Maturity date
		 * <h4>Description:</h4> 
		 * Maturity date sholud be greater than the application date
		 * @method validateTradeMaturityDate
		 * @return {boolean}
		 *  True if valid otherwise false.
		 */
		validateTradeMaturityDate : function() {
			//  summary:
		    //        Validates the data entered as the Expiry Date.
		    // 
		    // TODO Add business logic explanation here
		   
			// This validation is for non-required fields
			if(!this.get("value")) {
				return true;
			}

			console.debug(ExpDateValue,
					this.get("value"));
			
			// Test that the expiry date is greater than or equal to
			// the application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("maturityDateLessThanAppDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				return false;
			}

			
			return true;
		}, 
		/**
		 * <h4>Summary:</h4>
		 * This function validates the data entered as the BL On board or AWB issue date.
		 * <h4>Description:</h4> 
		 * Awb Issue date should be greater than application date
		 * @method validateAWBIssueDate
		 * @return {boolean}
		 *  True if valid otherwise false.
		 */
		validateAWBIssueDate : function() {
			//  summary:
		    //        Validates the data entered as the BL On Board/AWB Issue Date.
		    // 
			// This validation is for non-required fields
			if(!this.get("value")) {
				return true;
			}

			console.debug("[misys.validation.common] Validating AWB Issue Date. Value = ",
					this.get("value"));
			
			// Test that the Awb Issue date is greater than or equal to
			// the application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("awbIssueDateLessThanAppDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				return false;
			}
			
			return true;
		}, 		
		/**
		 * <h4>Summary:</h4>
		 * This function validates the data enteredin date field.
		 * @method validateOrderedDates
		 */
		validateOrderedDates : function ( /*Boolean*/ isFocused, 
										  /*String*/ earlierDateId,
										  /*String*/ laterDateId,
										  /*String*/ localizationString) {
			//  summary:
		    //        Validates the data entered as the Last Shipment Date.
			// TODO Refactor once update committed, no need for this call to be as complicated as 
			//      it is

			// Return true for empty values
			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Start date. Value = ",
					this.get("value"));
			
			// Test that the last shipment date is greater than or equal to
			// the application date
			var endDate = dj.byId(laterDateId);
			if(!m.compareDateFields(this,endDate)) {
				this.invalidMessage = m.getLocalization(localizationString, [
								_localizeDisplayDate(this),
								_localizeDisplayDate(endDate)]);
				return false;
			}
			
			var startDate = dj.byId(earlierDateId);
			if(!m.compareDateFields(startDate, this)) {
				this.invalidMessage = m.getLocalization(localizationString, [
								_localizeDisplayDate(startDate),
								_localizeDisplayDate(this)]);
				
				return false;
			}

			return true;
		}, 
		
		// TODO Refactor once update committed, no need for this call to be as complicated as it is
		// TODO Also, the name of the function makes no sense. Greater than what?
		/**
		 * Sunmmary:
		 * This function validates that the date entered is greater than the date passed as argument.
		 * @param {boolean} isFocussed
		 * @param {String} earlierDateName
		 * @param {String} errorMessage
		 * @method validateDateGreaterThan
		 */
		validateDateGreaterThan : function( /*Boolean*/ isFocused,
				                            /*String*/ earlierDateName,
				                            /*String*/ errorMessage) {
			//  summary:
		    //        Validates the date entered as greater than the date passed on argument.
			//        earlierDateName can be equals to "" or be null. In this case,
			//        comparison will be made relative to the current date.
			//        

			// Return true for empty values
			if(!this.get("value")){
				return true;
			}
			
			// retrieve the earlier date
			var earlierDate;
			if (!earlierDateName) {
				// TODO: modify to get the real date of the day (not the appl_date)
				earlierDate = dj.byId("appl_date");
			}
			else {
				earlierDate = dj.byId(earlierDateName);
			}
			
			console.debug("[misys.validation.common] Validating Date (", this.get("value"),
					") Greater than earlier date ", earlierDate.get("value"));
			// Test that the far date is greater than or equal to the earlier date
			if(!m.compareDateFields(earlierDate, this)) {
				this.invalidMessage = m.getLocalization(errorMessage, [
								_localizeDisplayDate(this),
								_localizeDisplayDate(earlierDate)]);
				return false;
			}

			return true;
		},
		
		// TODO Refactor once update committed, no need for this call to be as complicated as it is
		// TODO Also, the name of the function makes no sense.Smaller than what?
		/**
		 * <h4>Summary:</h4>
		 * This function validates that the date entered is smaller than the date passed as argument.
		 * @param {Boolean} isFocused
		 * @param {String} lateDateName
		 * @param {String} errorMessage
		 * @method validateDateSmallerThan
		 */
		validateDateSmallerThan : function( /*Boolean*/ isFocused,
				                            /*String*/ laterDateName, 
				                            /*String*/ errorMessage) {
			//  summary:
		    //        Validates the data entered as smaller than the date passed on argument.
		  
			// Return true for empty values
			if(!this.get("value")){
				return true;
			}

			// Test that the far date is greater than or equal to
			// the value date
			var laterDate = dj.byId(laterDateName);
			console.debug("[misys.validation.common] Validating Date (", this.get("value"), 
					") smaller than later date ", laterDate.get("value"));
			if(!m.compareDateFields(this, laterDate)) {
				this.invalidMessage = m.getLocalization(errorMessage, [
								_localizeDisplayDate(this),
								_localizeDisplayDate(laterDate)]);
				return false;
			}

			return true;
		}, 
		/**
		 * <h4>Summary:</h4>
		 * This function validates the data entered as the Last shipment date
		 * @method validateLastShipmentDate
		 * <h4>Description:</h4> 
		 * </br>Last shipment date should be greater than the application date
		 * </br>Last shipment date should be  less than the expiry date
		 * </br>Last shipment date should be less than the Amend date 
		 * </br>Last shipment date should be less than due date
		 * @method validateLastShipmentDate
		 * @return {booelan} 
		 *  True if valid otherwise false.
		 */
		validateLastShipmentDate : function() {
			//  summary:
		    //        Validates the data entered as the Last Shipment Date.
			// 
			// TODO Add business logic explanation
			
			//Do not validate for Close event
			/*if((dj.byId("tnxtype") && (dj.byId("tnxtype").get("value") === "38")) || 
			    	(dj.byId("close_tnx") && (dj.byId("close_tnx").get("checked") === true)))
			{
				  return true;
			}*/
						// Return true for empty values
			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Last Ship Date. Value = ", 
					this.get("value"));
			
			// Test that the last shipment date is greater than or equal to
			// the application date
//			var applDate = dj.byId("appl_date");
//			if(!m.compareDateFields(applDate, this)) {
//				this.invalidMessage = m.getLocalization("lastShipmentDateLessThanAppDateError",[
//								_localizeDisplayDate(this),
//								_localizeDisplayDate(applDate)]);
//				return false;
//			}
			
			// Test that the Latest Ship Date is greater than or
			// equal to the issue date
			/*var issueDate = dj.byId("iss_date");
			if (issueDate && issueDate.get("value"))
			{
				if (d.date.compare(this.get("value"), m.localizeDate(issueDate)) < 0)
				{
					this.invalidMessage = m.getLocalization(
							"issDateSmallerThanLatestShipDate", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(issueDate) ]);
					return false;
				}
			}*/
			// Test that the last shipment date is less than or equal to the 
			// expiry date.
			var expDate = dj.byId("exp_date");

			if(!m.compareDateFields(this, expDate)) {
				this.invalidMessage = m.getLocalization("expiryDateLessThanLastShipmentError",[
								_localizeDisplayDate(expDate),
								_localizeDisplayDate(this)]);
				return false;
			}
			
			// this is moved to OpenAccount validation
			/*var maxBpoExpiryDate = m.getMaxBPOExpiryDate();
				if(this.get("value") !== "" && maxBpoExpiryDate && maxBpoExpiryDate !== "") {
					if(d.date.compare(this.get("value"), maxBpoExpiryDate) > 0 ) {
						this.invalidMessage = m.getLocalization("lastShipmentDateGreaterThanBpoExpiryDateError",[
	                                _localizeDisplayDate(this),
	                                dojo.date.locale.format(maxBpoExpiryDate,{locale:dojo.config.locale, formatLength:"short", selector:"date" })]);
						return false;
				}
			
			if(expDate && !m.compareDateFields(this, expDate)) {
				this.invalidMessage = m.getLocalization("latestShipDateLessThanExpiryDateError",[
				                _localizeDisplayDate(this),
								_localizeDisplayDate(expDate)]);
				return false;
			}*/
			
			//Test if there is no new exp date then shipmnet date should check with old exp date
			if(expDate && expDate.get("value") == null)
			{
				var oldExpDate = dj.byId("org_exp_date");
				if(oldExpDate && !m.compareDateFields(this, oldExpDate)) {
					this.invalidMessage = m.getLocalization("originalexpiryDateLessThanLastShipmentError",[
									_localizeDisplayDate(oldExpDate),
									_localizeDisplayDate(this)]);
					return false;
				}
			}		
			
			
			// Test that the last shipment date is less than or equal to the 
			// amendment date.
			//Removed test for amendment date and shipment date as per suggestion by BA MPS-54646
			
			
			// Test that the last shipment date is less than or equal to the 
			// due date (used in IN product).
			var dueDate = dj.byId("due_date");
			if(!m.compareDateFields(this, dueDate)) {
				this.invalidMessage = m.getLocalization("dueDateLessThanLastShipmentError",[
								_localizeDisplayDate(dueDate),
								_localizeDisplayDate(this)]);
				return false;
			}
			
			// this is moved to OpenAccount validation
			/*
			// Test that the last ship date is greater than the
			// Earliest Ship Date
			var earliestShipDate = dj.byId("earliest_ship_date");
			if (earliestShipDate && earliestShipDate.get("value") !== null)
			{
				if (d.date.compare(this.get("value"), m.localizeDate(earliestShipDate)) < 0)
				{
					this.invalidMessage = m.getLocalization(
							"lastShipDateLessThanEarliestShipDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(earliestShipDate) ]);
					return false;
				}
			}
			
			// Test that the line item latest ship date is greater than the
			// line item Earliest Ship Date
			var lineItemEarliestShipDate = dj.byId("line_item_earliest_ship_date");
			if (lineItemEarliestShipDate && lineItemEarliestShipDate.get("value") !== null)
			{
				if (d.date.compare(this.get("value"), m.localizeDate(lineItemEarliestShipDate)) < 0)
				{
					this.invalidMessage = m.getLocalization(
							"lastShipDateLessThanEarliestShipDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(lineItemEarliestShipDate) ]);
					return false;
				}
			}
			
			// Test that the line item shipment sub schedule latest ship date is greater than the
			// line item shipment sub schedule Earliest Ship Date
			var scheduleEarliestShipDate = dj.byId("schedule_earliest_ship_date");
			var schedule = dj.byId("line_item_shipment_schedules");
			if(schedule && schedule.store  && schedule.store._arrayOfTopLevelItems.length > 0 && scheduleEarliestShipDate && scheduleEarliestShipDate.get("value") !== null) 
			{
				if (d.date.compare(this.get("value"), m.localizeDate(scheduleEarliestShipDate)) < 0)
				{
					this.invalidMessage = m.getLocalization(
							"lastShipDateLessThanEarliestShipDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(scheduleEarliestShipDate) ]);
					return false;
				}
			}			*/
			return true;
		}, 
		
		/**
		 * <h4>Summary:</h4>
		 * Validates the data entered as the Last shipment date 
		 * <h4>Description:</h4> 
		 * It checks for the following scenarios
		 * </br>The Last Shipment Date must be greater than or equal to the Application Date.
		 * </br>The Expiry Date must be greater than or equal to the Last Shipment Date.
		 * </br>The new last shipment date should not exceed the original last shipment date.
		 * @method validateMessageTransferLastShipmentDate
		 * @return {boolean}
		 *   True if valid otherwise false.
		 */
		validateMessageTransferLastShipmentDate : function() {
			//  summary:
		    //        Validates the data entered as the Last Shipment Date.
			// 
			// TODO Add business logic explanation
			
			// Return true for empty values
			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Last Ship Date. Value = ", 
					this.get("value"));
			
			// Test that the last shipment date is greater than or equal to
			// the application date
//			var applDate = dj.byId("appl_date");
//			if(!m.compareDateFields(applDate, this)) {
//				this.invalidMessage = m.getLocalization("lastShipmentDateLessThanAppDateError",[
//								_localizeDisplayDate(this),
//								_localizeDisplayDate(applDate)]);
//				return false;
//			}
			
			// Test that the last shipment date is less than or equal to the 
			// expiry date.
			var expDate = dj.byId("exp_date");
			if(!m.compareDateFields(this, expDate)) {
				this.invalidMessage = m.getLocalization("expiryDateLessThanLastShipmentError",[
								_localizeDisplayDate(expDate),
								_localizeDisplayDate(this)]);
				return false;
			}
			
			var thisObject  = dj.byId(this.id);
			var orgLastShipDate = dj.byId("org_last_ship_date");
			
			if(!m.compareDateFields(thisObject, orgLastShipDate)) {
				this.invalidMessage = m.getLocalization("lastShipDateBiggerThanOrgLastShipDate",[
								_localizeDisplayDate(thisObject),
								_localizeDisplayDate(orgLastShipDate)]);
				return false;
			}
			
			return true;
		}, 
		/**
		 * <h4>Summary:</h4>
		 * This function checks if the renew for no field contains a decimal value if so display a specific error message.
		 * <h4>Description:</h4> 
		 * Value should be integer and it should be greater than zero.
		 * @method validateRenewFor
		 * @return {boolean}
		 *   True if valid otherwise false.
		 */
		validateRenewFor : function() {
			//  summary:
		    //  test if the field contains a decimal value if so display a specific error message   

			console.debug("[misys.validation.common] Validating Renew For Value");

			// If renew contain value
			if(!isNaN(dj.byId("renew_for_nb").get("value")))
			{
				var renewFor = dj.byId("renew_for_nb").get("value")+"";
				if(renewFor.indexOf(".")!== -1)
					{
						dj.byId("renew_for_nb").invalidMessage  = m.getLocalization("valueShouldBeInteger");
						return false;
					}
				if(renewFor <= 0) {
					dj.byId("renew_for_nb").invalidMessage  = m.getLocalization("valueShouldBeGreaterThanZero");
					return false;
				}
			}				
			return true;
		},
						/**
						 * <h4>Summary:</h4> This function checks if the advice renewal
						 * days no field contains a decimal value if so display
						 * a specific error message
						 * <h4>Description:</h4> 
						 * Value sholud be an integer and it should be greater than zero.
						 * @method validateDaysNotice
						 * @return {boolean}
						 *  True if valid otherwise false.
						 */
		validateDaysNotice : function() {
			//  summary:
		    //  test if the field contains a decimal value if so display a specific error message   

			console.debug("[misys.validation.common] Validating Days Notice Value");

			// If renew contain value
			if(!isNaN(dj.byId("advise_renewal_days_nb").get("value")))
			{
				var renewFor = dj.byId("advise_renewal_days_nb").get("value")+"";
				if(renewFor.indexOf(".")!== -1)
					{
						dj.byId("advise_renewal_days_nb").invalidMessage  = m.getLocalization("valueShouldBeInteger");
						return false;
					}
				if(renewFor <= 0) {
					dj.byId("renew_for_nb").invalidMessage  = m.getLocalization("valueShouldBeGreaterThanZero");
					return false;
				}
			}
			return true;
		},
		
		/**
		 * <h4>Summary:</h4> This function checks if the Frequency
		 * field contains a decimal value if so display
		 * a specific error message
		 * <h4>Description:</h4> 
		 * Value sholud be an integer and it should be greater than zero.
		 * @method validateRollingFrequency
		 * @return {boolean}
		 *  True if valid otherwise false.
		 */
		validateRollingFrequency : function() {
			// summary:
			// test if the field contains a decimal value if so
			// display a specific error message

			console.debug("[misys.validation.common] Validating Frquency Value");

			// If renew contain value
			if (!isNaN(dj.byId("rolling_renew_for_nb").get("value"))) {
				var renewFor = dj.byId("rolling_renew_for_nb").get("value")+ "";
				if (renewFor.indexOf(".") !== -1) {
					dj.byId("rolling_renew_for_nb").invalidMessage = m.getLocalization("valueShouldBeInteger");
					return false;
				}
				if (renewFor <= 0) {
					dj.byId("rolling_renew_for_nb").invalidMessage = m.getLocalization("valueShouldBeGreaterThanZero");
					return false;
				}
			}
			return true;
		},
		/**
		 * <h4>Summary:</h4> This function checks if the rolling renewal
		 * days number field contains a decimal value if so display
		 * a specific error message.
		 * <h4>Description:</h4> 
		 * Value should be an integer and it should be greater than zero.
		 * @method validateNumberOfRenewals
		 * @return {boolean}
		 *  True if valid otherwise false.
		 */
		validateNumberOfRenewals : function() {
			//  summary:
		    //  test if the field contains a decimal value if so display a specific error message   

			console.debug("[misys.validation.common] Validating Number Of Renewals Value");

			// If renew contain value
			if(!isNaN(dj.byId("rolling_renewal_nb").get("value")))
			{
				var renewFor = dj.byId("rolling_renewal_nb").get("value")+"";
				if(renewFor.indexOf(".")!== -1)
					{
						dj.byId("rolling_renewal_nb").invalidMessage  = m.getLocalization("valueShouldBeInteger");
						return false;
					}
				if(renewFor <= 0) {
					dj.byId("renew_for_nb").invalidMessage  = m.getLocalization("valueShouldBeGreaterThanZero");
					return false;
				}
			}				
			return true;
		},
		/**
		 * <h4>Summary:</h4> This function checks if the rolling cancellation 
		 * days field contains a decimal value if so display
		 * a specific error message
		 * <h4>Description:</h4> 
		 * It checks for the following scenarios
		 * Value enetered should be an integer
		 * Vlaue should be greater than zero.
		 * @method validateCancellationNotice
		 * @return {boolean}
		 *  True if valid otherwise false
		 */
		validateCancellationNotice : function() {
			//  summary:
		    //  test if the field contains a decimal value if so display a specific error message   

			console.debug("[misys.validation.common] Validating Cancellation Notice days Value");

			// If renew contain value
			if(!isNaN(dj.byId("rolling_cancellation_days").get("value")))
			{
				var renewFor = dj.byId("rolling_cancellation_days").get("value")+"";
				if(renewFor.indexOf(".")!== -1)
					{
						dj.byId("rolling_cancellation_days").invalidMessage  = m.getLocalization("valueShouldBeInteger");
						return false;
					}
				if(renewFor <= 0) {
					dj.byId("renew_for_nb").invalidMessage  = m.getLocalization("valueShouldBeGreaterThanZero");
					return false;
				}
			}				
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * Validates the positive tolerance of varitaion in drawing.
		 * <h4>Description:</h4> 
		 * It checks for the following scenarios 
		 * Mutual exclusion of Positive or Negative Tolerances and the Maximum Credit Amount.
		 * Value of tolerance should be greater than zero.
		 * @method validateTolerance
		 * @return {boolean}
		 *  True if Tolerance is valid otherwise false.
		 */
		validateTolerance : function() {
			//  summary:
		    //        Validates the positive tolerance of the variation in drawing.
			
			var DrawingTolerenceSpl = (dj.byId("DrawingTolerence_spl") && dj.byId("DrawingTolerence_spl").get("value")==='true');
			var maxCrDescCodeexceed = dj.byId("max_cr_desc_code")? dj.byId("max_cr_desc_code").get("value") : "";
			if(DrawingTolerenceSpl && maxCrDescCodeexceed == 3){
				if(dj.byId("pstv_tol_pct").get("value")!= 0){
					dj.byId("pstv_tol_pct").set("value","0");
				}
				if(dj.byId("neg_tol_pct").get("value")!= 5){
					dj.byId("neg_tol_pct").set("value","5");
				}
			
				dj.byId("pstv_tol_pct").set('readOnly',true);
				dj.byId("neg_tol_pct").set('readOnly',true); 
				if(!isNaN(this.get("value")) && this.get("value") < 0){
					return false;
				}
				console.debug("[misys.validation.common] Validating Tolerence. Value = ",
						this.get("value"));
				return true;
			}else{
			console.debug("[misys.validation.common] Validating Tolerence. Value = ", 
					this.get("value"));

			// If Max Credit Amt has a value, we're in error
			var maxCrDescCode = dj.byId("max_cr_desc_code");
			if(!(isNaN(this.get("value"))|| this.get("value")=="") && maxCrDescCode && maxCrDescCode.get("value")){
				this.invalidMessage = m.getLocalization("toleranceExclusivityError");
				return false;
			}
			else if(!isNaN(this.get("value")) && this.get("value") < 0)
			{
				return false;
			}
			else if(dj.byId("pstv_tol_pct").displayedValue === "." && this.id !=="neg_tol_pct"){  
				this.invalidMessage = m.getLocalization("invalidMessage"); 
				return false;
			}else if(dj.byId("neg_tol_pct").displayedValue === "." && this.id !=="pstv_tol_pct"){
				this.invalidMessage = m.getLocalization("invalidMessage"); 
				return false;
			}

			return true;
			}
		}, 
		/**
		 * <h4>Summary:</h4>
		 * This function validates the maximum credit term of variation in drawing.
		 * @method validateMaxCreditTerm
		 * @retrun {booelan}
		 *  True if valid otherwise false
		 */
		validateMaxCreditTerm : function() {
			//  summary:
		    //        Validates the maximum credit term of the variation in drawing.
			//  <h4>Description:</h4> 
		    //        Note that this shouldn't be wrapped with the standard validation as it 
			//        interferes with the operation of the field.
			
			var DrawingTolerenceSplexceed = dj.byId("DrawingTolerence_spl").get("value")==='true';
			var maxCrDescCodeexceed = dj.byId("max_cr_desc_code");
			if(DrawingTolerenceSplexceed && maxCrDescCodeexceed==3){
				d.forEach(dj.byId("max_cr_desc_code").store.root.children, function(widget){
					if((dj.byId("max_cr_desc_code").get("displayedValue") === widget.text)) {
						status = true;
					}
				});
				dj.byId("pstv_tol_pct").set("value","0");
				dj.byId("neg_tol_pct").set("value","5");
				dj.byId("pstv_tol_pct").set('readOnly',true);
				dj.byId("neg_tol_pct").set('readOnly',true);
				return true;
			}else{
				dj.byId("pstv_tol_pct").set('readOnly',false);
				dj.byId("neg_tol_pct").set('readOnly',false);
				
			console.debug("[misys.validation.common] Validating Max Credit Term. Value = ",
					this.get("value"));
			
			if(this.get("value") &&
					((!isNaN(dj.byId("pstv_tol_pct").get("value")) ||
							!isNaN(dj.byId("neg_tol_pct").get("value")))&& 
							!(dj.byId("pstv_tol_pct").get("value")=="" && 
									dj.byId("neg_tol_pct").get("value")=="") )){
				this.invalidMessage = m.getLocalization("toleranceExclusivityError");
				return false;
			} else {
				var status = false;
				d.forEach(dj.byId("max_cr_desc_code").store.root.children, function(widget){
					if((dj.byId("max_cr_desc_code").get("displayedValue") === widget.text)) {
						status = true;
					}
				});
			}
				return status;
			}
		}, 
		/**
		 * <h4>Summary:</h4>
		 * This function validates the currency.
		 * <h4>Description:</h4> 
		 * Currency code's length should be 3
		 * It should be a valid currency supported in portal
		 * @method validateCurrency
		 * @return {boolean}
		 *  True if valid otherwise false
		 */
		validateCurrency : function() {
			//  summary:
		    //        Validates the currency.
			//        Cache currencies to improve performance

			var currency = this.get("value"),
				isValid = true,
				that = this;
			
			// For non-required empty values, just return true
			if(!currency){
				return true;
			}

			console.debug(validateCurrValue, currency);
			
			// Currency code must be at 3 chars in length
			if(currency.length !== 3){
				return false;
			}		
			if(!m._config.currencyCodes || m._config.currencyCodes.length < 1)
			{
				m._config = m._config || {};
				d.mixin(m._config,{
					currencyCodes : []
				});
	
			m.xhrGet({
					url : currISOCode,
					handleAs :"json",
					contentType : appJson,
				content:{bank_abbv_name:(dj.byId("bank_abbv_name") && misys._config.isMultiBank===true)?dj.byId("bank_abbv_name").get("value"):""},
				preventCache : true,
				sync : true,
				load : function(response, args){
						m._config.currencyCodes = response.currencyCodesJsonArray;
				},
				error : function(response, args){
					console.error(validateCurrError, response);
				}
			});
			}
			if(d.indexOf(m._config.currencyCodes, currency)=== -1)
			{
				that.invalidMessage = m.getLocalization("invalidCurrencyError", 
						[that.get("displayedValue")]);
				isValid = false;
			}
			return isValid;
		},
		
		validateCurrencyObj : function(currencyObj) {
			//  summary:
		    //        Validates the currency.
			//        Cache currencies to improve performance

			var currency = currencyObj.get("value");
			var	isValid = true;
			var	that = currencyObj;
			var displayMessage = "";
			
			// For non-required empty values, just return true
			if(!currency){
				return true;
			}

			console.debug(validateCurrValue, currency);
			
			// Currency code must be at 3 chars in length
			if(currency.length !== 3){
				displayMessage = m.getLocalization("invalidCurrencyError", 
						[that.get("value")]);
				that.focus();
				that.set("value", "");
				dijit.hideTooltip(that.domNode);
				dijit.showTooltip(displayMessage,that.domNode, 0);
				setTimeout(function() {
					dijit.hideTooltip(that.domNode);
				}, 2000);
				return false;
			}		
			if(!m._config.currencyCodes || m._config.currencyCodes.length < 1)
			{
				m._config = m._config || {};
				d.mixin(m._config,{
					currencyCodes : []
				});
	
			m.xhrGet({
					url : currISOCode,
					handleAs :"json",
					contentType : appJson,
				content:{bank_abbv_name:(dj.byId("bank_abbv_name") && misys._config.isMultiBank===true)?dj.byId("bank_abbv_name").get("value"):""},
				preventCache : true,
				sync : true,
				load : function(response, args){
						m._config.currencyCodes = response.currencyCodesJsonArray;
				},
				error : function(response, args){
					console.error(validateCurrError, response);
				}
			});
			}
			if(d.indexOf(m._config.currencyCodes, currency)=== -1)
			{
				displayMessage = m.getLocalization("invalidCurrencyError", 
						[that.get("value")]);
				that.focus();
				that.set("value", "");
				dijit.hideTooltip(that.domNode);
				dijit.showTooltip(displayMessage,that.domNode, 0);
				setTimeout(function() {
					dijit.hideTooltip(that.domNode);
				}, 2000);
				isValid = false;
			}
			return isValid;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates the Account Number field
		 * <h4>Description:</h4> 
		 * Account number should be an alpha numeric characters.
		 * No special characters are allowed. 
		 * @method validateAccountNumber
		 * @return {booelan}
		 *  True if valid otherwise false
		 */
		validateUserAccountNumber : function() {
			if(misys._config.userAccountValidationEnabled === "false")
			{
				return true;
			}
			else
			{
				var accountNumber = this.get("value"),
				isValid = true,
				that = this;
	           var accountRegExp = new RegExp(misys._config.userAccountValidationRegex);
	        
	           if(accountNumber !== "" && accountNumber !== null)
	           {                                         
	        	   	  isValid = accountRegExp.test(accountNumber);                         
	           }
				console.debug("[misys.validation.common] Validating Account Number. Value", accountNumber);

				if(!isValid)
				{
					var fieldDispValue = that.get("displayedValue");
					if(fieldDispValue) {
						fieldDispValue = fieldDispValue.replace(/</g, "&lt;");
						fieldDispValue = fieldDispValue.replace(/>/g, "&gt;");
					}
					that.invalidMessage = m.getLocalization("invalidUserAccountNumber", 
							[fieldDispValue]);
					isValid = false;
				}
				return isValid;
			}
		},
				 
		
		/**
		 * <h4>Summary:</h4>
		 * This function validates the currency passed.
		 * <h4>Description:</h4> 
		 * Currency code's length should be 3
		 * It should be a valid currency supported in portal
		 * @method validateCurrencyCode
		 * @return {boolean}
		 *  True if valid otherwise false
		 */
		validateCurrencyCode : function( currencyCode ) {
			//  summary:
		    //        Validates the currency.
			//        Cache currencies to improve performance

			var currency = currencyCode,
				isValid = true,
				that = this;
			
			// For non-required empty values, just return true
			if(!currency){
				return true;
			}

			console.debug(validateCurrValue, currency);
			
			// Currency code must be at 3 chars in length
			if(currency.length !== 3){
				return false;
			}		
			if(!m._config.currencyCodes || m._config.currencyCodes.length < 1)
			{
				m._config = m._config || {};
				d.mixin(m._config,{
					currencyCodes : []
				});
	
			m.xhrGet({
					url : currISOCode,
					handleAs :"json",
					contentType : appJson,
				preventCache : true,
				sync : true,
				load : function(response, args){
						m._config.currencyCodes = response.currencyCodesJsonArray;
				},
				error : function(response, args){
					console.error(validateCurrError, response);
				}
			});
			}
			if(d.indexOf(m._config.currencyCodes, currency)=== -1)
			{
				isValid = false;
			}
			return isValid;
		}, 
		/**
		 * <h4>Summary:</h4>
		 * This function validates the country code field
		 * <h4>Description:</h4> 
		 * Country code lenght should be equal to 2
		 * Also It should be a valid country code
		 * @method validateCountry
		 * @return {booelan}
		 *  True if valid otherwise false
		 */
		validateCountry : function() {
			//  summary:
		    //        Validates the country.

			var country = this.get("value"),
				isValid = true,
				that = this;
			
			// For non-required empty values, just return true
			if(!country){
				return true;
			}

			console.debug("[misys.validation.common] Validating Country. Value", country);
			
			// country code must be at 3 chars in length
			if(country.length !== 2){
				return false;
			}
			
			if(!m._config.countryCodes || m._config.countryCodes.length < 1)
			{
				m._config = m._config || {};
				d.mixin(m._config,{
					countryCodes : []
				});
				
				m.xhrGet({
					url : m.getServletURL("/screen/AjaxScreen/action/GetCountryCodes"),
					handleAs : "json",
					contentType : appJson,
					preventCache : true,
					sync : true,
					load : function(response, args){
						m._config.countryCodes = response.countryCodesJsonArray;
					},
					error : function(response, args){
						console.error("[misys.validation.common] validateCountry error", response);
					}
				});
			}
			if(d.indexOf(m._config.countryCodes, country)=== -1)
			{
				that.invalidMessage = m.getLocalization("invalidCountryError", 
						[that.get("displayedValue")]);
				isValid = false;
			}
			return isValid;
		}, 
		/**
		 * <h4>Summary:</h4>
		 *  Validates the data entered as the Execution/Issue Date.
		 * <h4>Description:</h4> 
		 * This method checks for the following scenarios .
		 * The Execution Date must be greater than or equal to the Application Date.
		 * Shows an error message in case if not valid.
		 *  @method validateExecDate
		 *  @return {boolean}
		 *   True if date is valid otherwise false
		 */
		validateExecDate : function() {
			//  summary:
		    //       Validates the data entered as the Execution/Issue Date.
			//
			// TODO Check this against v3
			
			
			console.debug("[misys.validation.common] Validating Exec Date, Value", 
					this.get("value"));
			
			// Test that the execution date is greater than or equal to the
			// application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(this, applDate)) {
				this.invalidMessage = m.getLocalization("executionDateLessThanAppDateError",
						[_localizeDisplayDate(this),
		                 _localizeDisplayDate(applDate)]);
				return false;
			}

			return true;
		}, 
		/**
		 * <h4>Summary:</h4>
		 * This function validates the issue date 
		 * <h4>Description:</h4> 
		 * This will check for the following scenarios  
		 * </br>The Issue Date must be greater than or equal to the Application Date.
		 * </br>The Issue Date must be less than or equal to the Maturity Date.
		 * </br>The Issue Date must be less than or equal to the Expiry Date.
		 * </br>The Issue Date must be less than or equal to the Valid From Date.
		 * </br>The Issue Date must be less than or equal to the Latest Payment Date.
		 * @method validateIssueDate
		 * @return {booelan}
		 *  True if date is valid otherwise false
		 */
		validateIssueDate : function() {
			//  summary:
		    //       Validates the issue date.

			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Issue Date, Value", 
					this.get("value"));
			
			// Test that the issue date is greater than the application date
			var productCode = dj.byId("product_code");
			if(productCode && productCode.get("value") !== "SR" && productCode.get("value") !== "BR" && productCode.get("value") !== "EL" && productCode.get("value") !== "LS") 
			{

				var applDate = dj.byId("appl_date");
				if(!m.compareDateFields(applDate, this)) {
					this.invalidMessage = m.getLocalization("issueDateLessThanAppDateError",
							[_localizeDisplayDate(this),
							 _localizeDisplayDate(applDate)]);
					return false;
				}
			}
			if(dj.byId("tenor_maturity_date") && dj.byId("tenor_maturity_date").get("value") != null){
				var tenorDate = dj.byId("tenor_maturity_date");
				if(!m.compareDateFields(this, tenorDate)) {
					this.invalidMessage = m.getLocalization("IssueDateGreaterThanMaturityDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(tenorDate)]);
					return false;
				}
				}
			if(dj.byId("exp_date") && dj.byId("exp_date").get("value") != null){
			var expDate = dj.byId("exp_date");
			if(!m.compareDateFields(this, expDate)) {
				this.invalidMessage = m.getLocalization("issueDateGreaterThanExpiryDateError",
						[_localizeDisplayDate(this),
			             _localizeDisplayDate(expDate)]);
				return false;
			}
			}
			if(dj.byId("product_code") && dj.byId("product_code").get("value")==="LS"){
				
				var bankDate=dj.byId("bankDate") && dj.byId("bankDate").get("value") != null?dj.byId("bankDate").get("value") : "";
				var days = validateBusinessDate(this);
				if(days > 0)
				{
					this.invalidMessage = m.getLocalization("issueDateGreaterThanCurrentDateError",[
				                                               						         _localizeDisplayDate(this)
					                                               								]);
					return false;
				}
				if(dj.byId("reg_date")) 
				{
					var regDate = dj.byId("reg_date");
					if(!m.compareDateFields(regDate, this)) {
						this.invalidMessage = m.getLocalization("issDateLessThanRegDateError",
								[_localizeDisplayDate(this),
								 _localizeDisplayDate(regDate)]);
						return false;
					}
				}
				}
			if(dj.byId("valid_from_date") && dj.byId("valid_from_date").get("value")!=null){
				var validFromDate = dj.byId("valid_from_date");
				if(!m.compareDateFields(this, validFromDate)) {
					this.invalidMessage = m.getLocalization("issueDateGreaterThanValidFromDateError",
							[_localizeDisplayDate(this),
				             _localizeDisplayDate(validFromDate)]);
					return false;
				}
				}
			if(dj.byId("valid_to_date") && dj.byId("valid_to_date").get("value")!=null){
				var validToDate = dj.byId("valid_to_date");
				if(!m.compareDateFields(this, validToDate)) {
					this.invalidMessage = m.getLocalization("issueDateGreaterThanValidToDateError",
							[_localizeDisplayDate(this),
				             _localizeDisplayDate(validToDate)]);
					return false;
				}
				}
			if(dj.byId("latest_payment_date") && dj.byId("latest_payment_date").get("value")!=null){
				var latestPaymentDate = dj.byId("latest_payment_date");
				if(!m.compareDateFields(this, latestPaymentDate)) {
					this.invalidMessage = m.getLocalization("issueDateGreaterThanLatestPaymentDateError",
							[_localizeDisplayDate(this),
				             _localizeDisplayDate(latestPaymentDate)]);
					return false;
				}
				}
			 if((dj.byId("tnxtype") && (dj.byId("tnxtype").get("value") !== "38")) || 
				    	(dj.byId("close_tnx") && (dj.byId("close_tnx").get("checked") === false)))
			 {
				if(dj.byId("product_code") && (dj.byId("product_code").get("value")==="IO" || dj.byId("product_code").get("value") === "EA")){
					var lastMatchDate = dj.byId("last_match_date");
					if((lastMatchDate && lastMatchDate.get("value") != null) && (!m.compareDateFields(this, lastMatchDate)))
							{
							this.invalidMessage = m.getLocalization("issueDateLessThanLastMatchDateError",
									[_localizeDisplayDate(this),
						             _localizeDisplayDate(lastMatchDate)]);
							return false;						
						}					
				}
			 }
			return true;
		},
		
		validateEffectiveIssueDate :function(){
			if(!this.get("value")){
				return true;
			}
			if(dj.byId("exp_date") && dj.byId("exp_date").get("value") != null){
				var expDate = dj.byId("exp_date");
				if(!m.compareDateFields(this, expDate)) {
					this.invalidMessage = m.getLocalization("effectiveDateGreaterThanExpiryDateError",
							[_localizeDisplayDate(this),
				             _localizeDisplayDate(expDate)]);
					return false;
				}
			}
			var applDate = dj.byId("appl_date");
			if(applDate && applDate.get("value") != null){
			if(!m.compareDateFields(applDate,this)) {
				this.invalidMessage = m.getLocalization("AppDateMoreThanEffectiveDateError",
						[_localizeDisplayDate(this),
			             _localizeDisplayDate(applDate)]);
				return false;
			}}
			return true;
		},
		validatePaymentDueDate : function() {
			
			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Payment Due Date, Value", 
					this.get("value"));
			
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("paymentDueDateDateLessThanAppDateError",
						[_localizeDisplayDate(this),
						 _localizeDisplayDate(applDate)]);
				return false;
			}
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates the issue date for Products initiated from middle office(SR,BR).
		 * @method validateMOProdIssueDate
		 */
		validateMOProdIssueDate : function() {
			//  summary:
		    //       Validates the issue date for Products initiated from middle office(SR,BR).

			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validate Issue Date, Value", 
					this.get("value"));
			
			// Test that the issue date is before or equal to the application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(this, applDate)) {
				this.invalidMessage = m.getLocalization("issueDateMoreThanAppDateError",
						[_localizeDisplayDate(this),
			             _localizeDisplayDate(applDate)]);
				return false;
			}
			if(dj.byId("tenor_maturity_date") && dj.byId("tenor_maturity_date").get("value")!=null){
				var tenorDate = dj.byId("tenor_maturity_date");
				if(!m.compareDateFields(this, tenorDate)) {
					this.invalidMessage = m.getLocalization("IssueDateGreaterThanMaturityDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(tenorDate)]);
					return false;
				}
				}
			if(dj.byId("exp_date") && dj.byId("exp_date").get("value")!= null){
			var expDate = dj.byId("exp_date");
			if(!m.compareDateFields(this, expDate)) {
				this.invalidMessage = m.getLocalization("issueDateGreaterThanExpiryDateError",
						[_localizeDisplayDate(this),
			             _localizeDisplayDate(expDate)]);
				return false;
			}
			}
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates the issue date for Products initiated from middle office(EL).
		 * @method validateMOProdIssueDate
		 */
		validateMOProdELIssueDate : function() {
			//  summary:
		    //       Validates the issue date for Products initiated from middle office(EL).

			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating EL Issue Date, Value", 
					this.get("value"));

			if(dj.byId("tenor_maturity_date") && dj.byId("tenor_maturity_date").get("value")!=null){
				var tenorDate = dj.byId("tenor_maturity_date");
				if(!m.compareDateFields(this, tenorDate)) {
					this.invalidMessage = m.getLocalization("IssueDateGreaterThanMaturityDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(tenorDate)]);
					return false;
				}
				}
			if(dj.byId("exp_date") && dj.byId("exp_date").get("value")!= null){
			var expDate = dj.byId("exp_date");
			if(!m.compareDateFields(this, expDate)) {
				this.invalidMessage = m.getLocalization("issueDateGreaterThanExpiryDateError",
						[_localizeDisplayDate(this),
			             _localizeDisplayDate(expDate)]);
				return false;
			}
			}
			return true;
		},
		/**
		 * <h4>Summary:</h4> This function validates the maturity date
		 * @method validateMaturityDate
		 */
		validateMaturityDate : function() {
			

			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Maturtiy Date, Value", 
					this.get("value"));
			
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("maturityDateLessThanAppDateError",
						[_localizeDisplayDate(this),
			             _localizeDisplayDate(applDate)]);
				return false;
			}
			if(dj.byId("iss_date") && dj.byId("iss_date").get("value")!= null){
			var issDate = dj.byId("iss_date");
			if(!m.compareDateFields(issDate, this)) {
				this.invalidMessage = m.getLocalization("maturityDateLessThanIssueDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(issDate)]);
				return false;
			}
			}
			
			return true;
			
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validate the latest answer date.
		 * @method validateLatestAnswerDate
		 */
		validateLatestAnswerDate : function() {
			//  summary:
		    //       Validates the latest answer date

			// For non-required empty values, just return true
			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Last Answer Date, Value", 
					this.get("value"));

			// Test that the last answer date is greater than the issue date
			var issDate = dj.byId("iss_date");
			if(!m.compareDateFields(issDate, this)) {
				this.invalidMessage = m.getLocalization("lastAnwerDateLessThanIssDateError",
						[_localizeDisplayDate(this),
			             _localizeDisplayDate(issDate)]);
				return false;
			}
			// Test that the last answer date is less than the expiry date
			var expDate = dj.byId("exp_date");
			if(!m.compareDateFields(this, expDate)) {
				this.invalidMessage = m.getLocalization("lastAnswerDateGreaterThanExpDateError",
						[_localizeDisplayDate(this),
			             _localizeDisplayDate(expDate)]);
				return false;
			}

			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validate the LC Available Amt.
		 * @method validateLcAvailableAmt
		 */
		validateLCAvailableAmt : function() {
			//  summary:
		    //       Validates the LC Available Amt
			var callback ;
			console.debug("[misys.validation.common] Validating LC Available Amt for EL, Value", 
					this.get("value"));	
			if(dj.byId("lc_available_amt").get("value") > 0){
			if(dj.byId("lc_amt") && dj.byId("lc_available_amt") && dj.byId("prod_stat_code") && dj.byId("prod_stat_code").get('value')=="03" && (dj.byId("lc_amt").get("value") != dj.byId("lc_available_amt").get("value")))
			{
				callback = function() {
					var widget = dijit.byId("lc_available_amt");
					widget.focus();
				 	widget.set("state","Error");
				};
				m.dialog.show("ERROR", m.getLocalization("AvailLCAmtNotEqualToTranAmt"), '', function(){
						setTimeout(callback, 500);
					});
			}
			else if(dj.byId("lc_amt") && dj.byId("lc_available_amt") && (dj.byId("lc_amt").get("value") < dj.byId("lc_available_amt").get("value")))
			{
				callback = function() {
					var widget = dijit.byId("lc_available_amt");
					widget.focus();
				 	widget.set("state","Error");
				};
				m.dialog.show("ERROR", m.getLocalization("AvailLCamtcanNotMoreThanTranAmt"), '', function(){
						setTimeout(callback, 500);
					});
			}
			}
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function validate the LC Liab Amt.
		 * @method validateLCLiabAmt
		 */
		validateLCLiabAmt : function() {
			//  summary:
		    //       Validates the LC Liab Amt
			var callback ;
			console.debug("[misys.validation.common] Validating LC Liab Amt for EL, Value", 
					this.get("value"));	
			if(dj.byId("lc_liab_amt").get("value") > 0){
			if (dj.byId("lc_amt") && dj.byId("prod_stat_code") && dj.byId("prod_stat_code").get("value") === '03' &&
					(dj.byId("lc_amt").get("value") > dj.byId("lc_liab_amt").get("value")))
			{
				callback = function() {
						var widget = dijit.byId("lc_liab_amt");
						widget.focus();
					 	widget.set("state","Error");
					};
					m.dialog.show("ERROR", m.getLocalization("LiabLCAmtcanNotLessThanTranAmt"), '', function(){
							setTimeout(callback, 500);
						});
			}
			/*else if(dj.byId("lc_amt") && (dj.byId("lc_amt").get("value") < dj.byId("lc_liab_amt").get("value")))
			{
				callback = function() {
						var widget = dijit.byId("lc_liab_amt");
						widget.focus();
					 	widget.set("state","Error");
					};
					m.dialog.show("ERROR", m.getLocalization("LiabLCAmtcanNotMoreThanTranAmt"), '', function(){
							setTimeout(callback, 500);
						});
			}*/
			}
		},
		/**
		 * <h4>Summary:</h4>
		 *   Validates the Maturity Date (Finance request only)
		 *  @method validateTFMaturityDate
		 */
		validateTFMaturityDate : function() {
			//  summary:
		    //       Validates the Maturity Date (TF only)

			console.debug("[misys.validation.common] Validating TF Maturity Date, Value = ", 
					this.get("value"));
			
			// Test that the maturity date is greater than or equal to the
			// application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("maturityDateLessThanAppDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				return false;
			}
			
			// Test that the maturity date is greater than or equal to the issue
			// date
			var issDate = dj.byId("iss_date");
			if(!m.compareDateFields(issDate, this)) {
				this.invalidMessage = m.getLocalization("issueDateGreaterThanMaturityError", [
								_localizeDisplayDate(issDate),
								_localizeDisplayDate(this)]);
				return false;
			}

			return true;
		},
		
		// TODO Refactor
		// TODO Remove passing of product code
						/**
						 * <h4>Summary:</h4> This function validates the amendment
						 * amount. <h4>Description:</h4>  Format the eventual
						 * increase/decrease of amount, set the transaction
						 * amount and compute the new LC amount.
						 */
		validateAmendAmount : function( /*Boolean*/ isFocused,
										/*dijit._Widget || DomNode || String*/ node, 
										/*String*/ productCode) {
			//  summary:
		    //       Validates the amendment amount.
			//  description:
			//        Format the eventual increase/decrease of amount, set the transaction amount
		    //        and compute the new LC amount.
			
			var widget = dj.byId(node);
			widget.invalidMessage = widget.messages.invalidMessage;
			if(!widget.validator(widget.textbox.value, widget.constraints)){
				return false;
			}
			if(widget && widget.get("value") < 0) {
				return false;
				}
			// Validate only when the field is onfocussed or focussed but in error
			var isValid = (widget.state === "Error") ? false : true;
			if(false === isFocused || (true === isFocused && !isValid)){
				console.debug("[misys.validation.common] Validating Amendment Amount, Value = ", 
						widget.get("value"));
				
				isValid = true;
				var fieldId = widget.id;
				var orgAmtVal = d.number.parse(dj.byId("org_" + productCode + "_amt").get("value"));
				
				if(fieldId === "inc_amt") {
					var incValue = widget.get("value");
					if((!isNaN(incValue)) && ((incValue + orgAmtVal) > Number.MAX_VALUE))
					{
							widget.invalidMessage = m.getLocalization("maximumValueError");
							isValid = false;
					}
				}
				else if(fieldId === "dec_amt") {
					var decValue = widget.get("value");
					if((!isNaN(decValue)) && ((orgAmtVal - decValue) < 0))
					{
							widget.invalidMessage = 
								m.getLocalization("amendAmountLessThanOriginalError");
							isValid = false;
					}
					
				}
			}
			
			return isValid;
		}, 
		/**
		 * <h4>Summary:</h4>
		 *  Validates the transfer amount. Must be applied to an input field of
		 *   dojoType misys.form.CurrencyTextBox.
		 *   @method validateTransferAmount
		 */
		validateTransferAmount : function(){
			//  summary:
		    //       Validates the transfer amount. Must be applied to an input field of 
			//       dojoType misys.form.CurrencyTextBox.
			
			var value = this.get("value"),
				orgValue = d.number.parse(dj.byId("org_lc_amt").get("value"));
			
			console.debug("[misys.validation.common] Validating Transfer Amount, Value = ", 
					value);			

			if(value && orgValue && orgValue < value){
				this.invalidMessage = m.getLocalization("transferAmtGreaterThanLCAmtError");
				return false;
			}
		
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates the data entered as the start Date.
		 * @method validateStartDate
		 */
		validateStartDate : function() {
				//  summary:
			    //        Validates the data entered as the start Date.
			    // 
			    
			   // This validation is for non-required fields
				if(!this.get("value")) {
					return true;
				}
				
				console.debug("[misys.validation.common] Validating Start Date. Value = ",
						this.get("value"));

				// Test that the start date is greater than or equal to
				// the application date
				var applDate = dj.byId("appl_date");
				if(!m.compareDateFields(applDate, this)) {
					this.invalidMessage = m.getLocalization("startDateLessThanAppDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(applDate)]);
					return false;
				}
				
				// Test that the start date is smaller than or equal to
				// the end date
				var endDate = dj.byId("end_date");
				if(!m.compareDateFields(this, endDate)) {
					this.invalidMessage = m.getLocalization("startDateGreaterThanEndDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(endDate)]);
					return false;
				}
				
				// Validates if the start date is smaller than registered end date.
				// returns true if the start date is smaller than registered end date.
				var registeredEndDate = dj.byId("registered_end_date");
				if(!m.compareDateFields(this, registeredEndDate)) {
					this.invalidMessage = m.getLocalization("startDateGreaterThanRegisteredEndDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(registeredEndDate)]);
					return false;
				}						
				return true;
			},	
			/**
			 * <h4>Summary:</h4>
			 * This function validates the data entered as the end date
			 * @method validateEndDate
			 */
		validateEndDate : function() {
				//  summary:
			    //        Validates the data entered as the end Date.
			    // 
			
				// This validation is for non-required fields
				if(!this.get("value")) {
					return true;
				}
				
				console.debug("[misys.validation.common] Validating End Date. Value = ",
						this.get("value"));
				
				var startDate = dj.byId("start_date");
				if(!m.compareDateFields(startDate, this)) {
						this.invalidMessage = m.getLocalization("endDateLessThanStartDateError", [
										_localizeDisplayDate(this),
										_localizeDisplayDate(startDate)]);
						return false;
				}

				// Validates if the end date is smaller than registered end date.
				// returns true if the end date is smaller than registered end date.
				var registeredEndDate = dj.byId("registered_end_date");
				if(!m.compareDateFields(this, registeredEndDate)) {
					this.invalidMessage = m.getLocalization("endDateGreaterThanRegisteredEndDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(registeredEndDate)]);
					return false;
				}				
								
				return true;
			},
			
			/**
			 * <h4>Summary:</h4>
			 * This function validates the data entered for the News Start Date.
			 * 
			 * @method validateNewsStartDate
			 */
			validateNewsStartDate : function()
			{
				// This validation is for non-required fields
				if (!this.get("value"))
				{
					return true;
				}

				console.debug("[misys.validation.common] Validating News Start Date. Value = ",
						this.get("value"));

				// Test that the start date is earlier than or equal to	the end date
				var startDate = dj.byId("start_display_date");
				var endDate = dj.byId("end_display_date");
				if (!m.compareDateFields(this, endDate))
				{
					this.invalidMessage = m.getLocalization(
							"newsStartDateGreaterThanEndDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(endDate) ]);
					return false;
				}
				var currentDate,
			 	isValid;
			 	if ((startDate) && (startDate.get("value") !== ""))
			 	{
			 		currentDate = new Date();
					// set the hours to 0 to compare the date values
					currentDate.setHours(0, 0, 0, 0);
					// get the localized value in standard format.
					console.debug(currntDatevalue,
							currentDate);	
					// compare the values of the current date and transfer date
					isValid = d.date.compare(m.localizeDate(startDate), currentDate) < 0 ? false : true;
					if(!isValid)
					{
						startDate.state = "Error"; 
						startDate.set("focusonerror", true);
						startDate.invalidMessage = m.getLocalization("startDateGreaterThanCurrentDateError", [_localizeDisplayDate(startDate)]);
						startDate._setStateClass();
						dj.setWaiState(startDate.focusNode, "invalid", "true");
						return false;
					}
				 }
				return true;
			},
			/**
			 * <h4>Summary:</h4>
			 * This function validates the data entered as the news End Date.
			 * 
			 * @method validateNewsEndDate
			 */
			validateNewsEndDate : function()
			{
				// This validation is for non-required fields
				if (!this.get("value"))
				{
					return true;
				}

				console.debug("[misys.validation.common] Validating News End Date. Value = ",
						this.get("value"));

				// Test that the News End date is later than or equal to the News Start date
				var startDate = dj.byId("start_display_date");
				var endDate = dj.byId("end_display_date");
				if (!m.compareDateFields(startDate, this))
				{
					this.invalidMessage = m.getLocalization("newsEndDateLesserThanStartDateError",
							[ _localizeDisplayDate(this), _localizeDisplayDate(startDate) ]);
					return false;
				}
				var currentDate,
			 	isValid;
			 	if((endDate) && (endDate.get("value") !== ""))
			 	{
			 		currentDate = new Date();
					// set the hours to 0 to compare the date values
					currentDate.setHours(0, 0, 0, 0);
					// get the localized value in standard format.
					console.debug(currntDatevalue,
							currentDate);	
					// compare the values of the current date and end date
					isValid = d.date.compare(m.localizeDate(endDate), currentDate) < 0 ? false : true;
					if(!isValid)
					{
						endDate.state = "Error"; 
						endDate.set("focusonerror", true);
						endDate.invalidMessage = m.getLocalization("endDateGreaterThanCurrentDateError", [_localizeDisplayDate(endDate)]);
						endDate._setStateClass();
						dj.setWaiState(endDate.focusNode, "invalid", "true");
						return false;
					}
				 }
				return true;
			},
			/**
			 * <h4>Summary:</h4>
			 * This fucntion validates the data entered as the transfer date
			 * <h4>Description:</h4> 
			 *Transfer date sholud not be lesser than application date.
			 *Transfer date should not be greater than the end date.
			 *Transfer date shoul not be less than current date
			 *@method validateTransferDateCustomer
			 */
	 validateTransferDateCustomer : function() {
			//  summary:
		    //        Validates the data entered as the transfer Date.
		    // 
		    // TODO Add business logic explanation here
			// This validation is for non-required fields

			 var currentDate,
			    isValid;
			if(!this.get("value")) {
				return true;
			}
			console.debug("[misys.validation.common] Validating Transfer Date. Value = ",
					this.get("value"));
			var customer_bank = "";
			if(dj.byId("customer_bank"))
			{
				customer_bank = dj.byId("customer_bank").get("value"); 
			}
			if(customer_bank === "")
			{
				customer_bank = dj.byId("issuing_bank_abbv_name").get("value"); 
			}
			// Test that the expiry date is greater than or equal to
			// the application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("transferDateLessThanAppDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				return false;
			}
			// Bill Payment specific: Validates if the transfer date is smaller than registered end date.
			// returns true if the transfer date is smaller than registered end date.
			if(dj.byId("sub_product_code").get("value") === "BILLP" || dj.byId("sub_product_code").get("value") === "BILLS") {
				var registeredEndDate = dj.byId("registered_end_date");
				if(!m.compareDateFields(this, registeredEndDate)) {
					this.invalidMessage = m.getLocalization("transferDateGreaterThanRegisteredEndDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(registeredEndDate)]);
					return false;
				}				
			}
			// validate for current date
			// For Customer End, transfer date should not be less than the current date
			// validate only at customer side
			if(this.get("value") !== "")
			{
				console.debug("[misys.validation.common] Begin Validating Transfer Date with current date. Value = ",
						this.get("value"));
				var yearServer = parseInt(misys._config.businessDateForBank[customer_bank][0].value.substring(0,4), 10);
				var monthServer = parseInt(misys._config.businessDateForBank[customer_bank][0].value.substring(5,7), 10);
				var dateServer = parseInt(misys._config.businessDateForBank[customer_bank][0].value.substring(8,10), 10);
				currentDate = new  Date(yearServer, monthServer - 1, dateServer);
				// set the hours to 0 to compare the date values
				currentDate.setHours(0, 0, 0, 0);
				// get the localized value in standard format.
				console.debug(currntDatevalue,
						currentDate);	
				// compare the values of the current date and transfer date
				isValid = d.date.compare(m.localizeDate(this), currentDate) < 0 ? false : true;
				if(!isValid)
				{
					 this.invalidMessage = m.getLocalization("transferDateGreaterThanCurrentDateError", [_localizeDisplayDate(this)]);
					 return false;
				}
				console.debug("[misys.validation.common] End Validating Transfer Date with current date. Value = ",
						this.get("value"));
			}
			return true;
		},	
		/**
		 * <h4>Summary:</h4>
		 * This function validates transfer date with the current date
		 * @param {widget} transferDate
		 * @method validateTransferDateWithCurrentDate
		 */
	 validateTransferDateWithCurrentDate : function(/**widget**/transferDate){
			 var currentDate,
			 isValid;
			if((transferDate) && (transferDate.get("value") !== ""))
			{
					console.debug("[misys.validation.common] Begin Validating Transfer Date with current date. Value = ",
							transferDate.get("value"));	
					currentDate = new Date();
					// set the hours to 0 to compare the date values
					currentDate.setHours(0, 0, 0, 0);
					// get the localized value in standard format.
					console.debug(currntDatevalue,
							currentDate);	
					// compare the values of the current date and transfer date
					isValid = d.date.compare(m.localizeDate(transferDate), currentDate) < 0 ? false : true;
					if(!isValid)
					{
						transferDate.state = "Error"; 
						transferDate.set("focusonerror", true);
						transferDate.invalidMessage = m.getLocalization("transferDateGreaterThanCurrentDateError", [_localizeDisplayDate(transferDate)]);
						transferDate._setStateClass();
						dj.setWaiState(transferDate.focusNode, "invalid", "true");
						return false;
					}
					console.debug("[misys.validation.common] End Validating Transfer Date with current date. Value = ",
							transferDate.get("value"));					
			}
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This fuction validates the data entered as the transer date
		 * @method validateTransferDate
		 */
		validateTransferDate : function() {
			//  summary:
		    //        Validates the data entered as the transfer Date.
		    // 
		    // TODO Add business logic explanation here
			// This validation is for non-required fields
			if(!this.get("value")) {
				return true;
			}

			console.debug("[misys.validation.common] Validating Transfer Date. Value = ",
					this.get("value"));
			
			// Test that the expiry date is greater than or equal to
			// the application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("transferDateLessThanAppDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				return false;
			}
			// Bill Payment specific: Validates if the transfer date is smaller than registered end date.
			// returns true if the transfer date is smaller than registered end date.
			if(dj.byId("sub_product_code").get("value") === "BILLP" ||dj.byId("sub_product_code").get("value") === "BILLS") {
				var registeredEndDate = dj.byId("registered_end_date");
				if(!m.compareDateFields(this, registeredEndDate)) {
					this.invalidMessage = m.getLocalization("transferDateGreaterThanRegisteredEndDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(registeredEndDate)]);
					return false;
				}				
			}
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates the data entered as the transfer expiry date.
		 * @method validateTransferExpiryDate
		 */
		validateTransferExpiryDate : function(){
			//  summary:
		    //        Validates the data entered as the transfer expiry date.
			
			// Return true for empty values
			if(!this.get("value")){
				return true;
			}

			console.debug("[misys.validate.common] Validating Transfer expiry date. Value", 
							this.get("value"));
			
			// Test that the transfer expiry date is smaller than the LC issue date
			var issueDate = dj.byId("iss_date");
			if(!m.compareDateFields(issueDate, this)) {
				//this is smaller, issueDate is greater
				this.invalidMessage = m.getLocalization(
						"transferExpiryDateLessThanIssueDateError",
						[_localizeDisplayDate(this), _localizeDisplayDate(issueDate)]);
				return false;		
			}
			
			// Test that the transfer expiry date is greater than the LC expiry date
			var expDate = dj.byId("exp_date");
			if(!m.compareDateFields(this, expDate)) {
				//this is greater, expDate is smaller
				this.invalidMessage = m.getLocalization(
						"transferExpiryDateGreaterThanExpiryDateError",
						[_localizeDisplayDate(this), _localizeDisplayDate(expDate)]);
				return false;	
				
			}
			
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates  the data entered as the transfer last shipment date.
		 * @method validateTransferLastShipmentDate
		 */
		validateTransferLastShipmentDate : function(){
			//  summary:
		    //        Validates the data entered as the transfer last shipment date.
			
			if(!this.get("value")){
				return true;
			}

			console.debug("[misys.validate.common] Validating Transfer Last Shipment date. Value",
								this.get("value"));
			
			// Test that the last shipment date is greater than or equal to
			// the application date
//			var applDate = dj.byId("iss_date");
//			if(!m.compareDateFields(applDate, this)) {
//				this.invalidMessage = m.getLocalization("lastShipmentDateLessThanAppDateError", [
//								_localizeDisplayDate(this),
//								_localizeDisplayDate(applDate)]);
//				return false;
//			}
			
			var trfExpDate = dj.byId("transfer_expiry_date");
			
			if(!m.compareDateFields(this, trfExpDate)) {
				this.invalidMessage = m.getLocalization(
						"transferLastShipmentDateLessThanTransferExpiryDateError",
						[_localizeDisplayDate(this),_localizeDisplayDate(trfExpDate)]);
				return false;	
				
			}
			
			return true;
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function validates the data entered as the Value date and Application date.
		 * @method validateValueApplicationDate
		 */
		validateValueApplicationDate : function(){
				//  summary:
			    //        Validates the data entered as the value and Application date.
			console.debug("[misys.validation.common] Start Validating Value Date with Application date.");
				var valueDate = this;
				if(valueDate && !valueDate.get("value")){
					return true;
				}
				var applDate = dj.byId("appl_date");
				// compare the values of the Value date and Application date
				var isValid = d.date.compare(m.localizeDate(valueDate), m.localizeDate(applDate)) < 0 ? false : true;
				if(!isValid)
				{
					valueDate.state = "Error"; 
					valueDate.set("focusonerror", true);
					valueDate.invalidMessage = m.getLocalization("valueDateIsLessThanApplDateError",
													[_localizeDisplayDate(valueDate),
													_localizeDisplayDate(applDate)]);
					valueDate._setStateClass();
					dj.setWaiState(valueDate.focusNode, "invalid", "true");
					return false;
				}
				console.debug("[misys.validation.common] End Validating Value Date with Application date. Value = ",
						valueDate.get("value"));					
				
				return true;
			},		
		/**
		 * <h4>Summary:</h4>
		 * this funtion validates the data entered as the Transfer presentation period or Insurance coverage percentage.
		 * @method validateTransferNumbers
		 */
		validateTransferNumbers : function(){
			//  summary:
		    //        Validates the data entered as the Transfer presentation period or Insurance coverage percentage.
			
			// Return true for empty values
			if(!this.get("value")){
				return true;
			}

			console.debug("[misys.validate.common] Validating", this.get("name"), 
								". Value", this.get("value"));
			
			
			if(this.get("value") < 0 || this.get("value") > 999) {
				this.invalidMessage = m.getLocalization("invalidTransferNumbers");
				return false;	
				
			}
			
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates the data entered as the Transfer presentation period or Insurance coverage percentage.
		 * @method validateBlankEndorsedPercentage
		 */
		validateBlankEndorsedPercentage : function(){
			//  summary:
		    //        Validates the data entered as the Transfer presentation period or Insurance coverage percentage.
			
			// Return true for empty values
			if(!this.get("value")){
				return true;
			}

			console.debug("[misys.validate.common] Validating", this.get("name"), 
								". Value", this.get("value"));
			
			
			if(this.get("value") < 110 || this.get("value") > 999) {
				this.invalidMessage = m.getLocalization("invalidBlankEndorsedPercentage");
				return false;	
				
			}
			
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates the amendment date
		 * <h4>Description:</h4> 
		 * Amendment date should be greater than the current date
		 * Amend date sholud be less than the shipment date
		 * @method validateAmendmentDate
		 */
		validateAmendmentDate : function() {
			//  summary:
		    //       Validates the amendment date.
			//Test that the amendment date is greater than or equal to the system's date.
			console.debug("[misys.validation.common] Validating Amendment Date, Value = ", 
					this.get("value"));
		    var amendDate = this.get("value");

	    if(!m._config.isBank || (m._config.isBank && dj.byId("prod_stat_code") && (dj.byId("prod_stat_code").get("value") === '03' || dj.byId("prod_stat_code").get("value") === '08')))
		  {

			if(amendDate != null)
			{
				
				var days = validateBusinessDate(this);
				if(days < 0)
				{
					 this.invalidMessage = m.getLocalization("amdDateSmallerThanCurrentDate", [_localizeDisplayDate(this)]);
					 return false;
				}
				
				
				//Test if amendment date is before the shipment date.
				
				//	Removed test for amendment date and shipment date as per suggestion by BA MPS-54646
			}
			
			//Test if amendment date is less than expiry date.
			if(dj.byId("amd_date") && dj.byId("amd_date").get("value") != null && dj.byId("exp_date") && dj.byId("exp_date").get("value") != null)
			{
				var amdDate = dj.byId("amd_date");
				var expdate = dj.byId("exp_date");
				console.debug("[misys.validation.common] Amendment Date Value = ",
						amdDate.get("value"));
				var isValid = d.date.compare(m.localizeDate(amdDate), m.localizeDate(expdate)) >= 0 ? false : true;
				if(!isValid)
				{
					 this.invalidMessage = m.getLocalization("amdDateGreaterThanExpiryDate", [_localizeDisplayDate(amdDate), _localizeDisplayDate(expdate)]);
					 return false;
				}
			}
		}

			return true;
		}, 
		
		/**
		 * <h4>Summary:</h4>
		 * This function validates the amendment date
		 * <h4>Description:</h4> 
		 * Amendment date should be greater than the current date
		 * Amend date sholud be less than the shipment date
		 * @method validateBGAmendmentDate
		 */
		validateBGAmendmentDate : function() {
			//  summary:
		    //       Validates the amendment date.
			//Test that the amendment date is greater than or equal to the system's date.
			console.debug("[misys.validation.common] Validating Amendment Date, Value = ", 
					this.get("value"));
		    var amendDate = this.get("value");
			var currentDate = new Date();
			var that = this;
			// set the hours to 0 to compare the date values
			currentDate.setHours(0, 0, 0, 0);
			// get the localized value in standard format.
			console.debug(currntDatevalue,
							currentDate);	
			if(amendDate != null)
			{
				var days = validateBusinessDate(this);
				if(days < 0)
				{
					this.invalidMessage = m.getLocalization("amdDateSmallerThanCurrentDate", [_localizeDisplayDate(this)]);
					return false;
				}	
			}
			
			//Test if amendment date is less than expiry date.
			if(dj.byId("amd_date") && dj.byId("amd_date").get("value") != null && dj.byId("exp_date") && dj.byId("exp_date").get("value") != null)
			{
				var amdDate = dj.byId("amd_date");
				var expdate = dj.byId("exp_date");
				console.debug("[misys.validation.common] Amendment Date Value = ",
						amdDate.get("value"));
				var isValid = d.date.compare(m.localizeDate(amdDate), m.localizeDate(expdate)) >= 0 ? false : true;
				if(!isValid)
				{
					this.invalidMessage =m.getLocalization("amdDateGreaterThanExpiryDate", [_localizeDisplayDate(amdDate), _localizeDisplayDate(expdate)]);
					return false;
				}
			}
			return true;
		}, 
		/**
		 * <h4>Summary:</h4>
		 *  Validates the data entered as the Expiry Date (bank side).
		 *  @method validateBankExpiryDate
		 */
		validateBankExpiryDate : function() {
			//  summary:
		    //       Validates the data entered as the Expiry Date (bank side).

			// This test is for non-required fields
			if(!this.get("value")){
				return true;
			}

			console.debug("[misys.validation.common] Validating Bank Expiry Date, Value =", 
					this.get("value"));
			
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("expiryDateLessThanAppDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(applDate)]);
				return false;
			}
			
			var issDate = dj.byId("iss_date");
			if(!m.compareDateFields(issDate, this)) {
				this.invalidMessage = m.getLocalization("expiryDateLessThanIssueDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(issDate)]);
				return false;
			}
			
			
			var orgDate = dj.byId("org_previous_exp_date");
			if(!m.compareDateFields(orgDate, this)) {
				this.invalidMessage = m.getLocalization("orgExpDateGreaterThanExpiryDateError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(orgDate)]);
				return false;
			}

			var lastShipDate = dj.byId("last_ship_date");
			if(!m.compareDateFields(lastShipDate, this)) {
				this.invalidMessage = m.getLocalization("expiryDateLessThanLastShipmentError", [
								_localizeDisplayDate(this),
								_localizeDisplayDate(lastShipDate)]);
				return false;
			}
			
			var nextRevolveDate = dj.byId("next_revolve_date");
			if(nextRevolveDate && !m.compareDateFields(nextRevolveDate, this)) 
			{
				this.invalidMessage = m.getLocalization("expDateLessThanNextRevolveDateError", [
									_localizeDisplayDate(nextRevolveDate),
									_localizeDisplayDate(this)]);
				return false;
			}
			if((!m._config.isBank && (null == dj.byId("prod_stat_code") || null!=dj.byId("prod_stat_code") && dj.byId("prod_stat_code").get("value") != "10")) || (m._config.isBank && null!=dj.byId("prod_stat_code") && dj.byId("prod_stat_code") && dj.byId("prod_stat_code").get("value") === '03' || dj.byId("prod_stat_code").get("value") === '08'))
			{
				if(dj.byId("product_code") && (dj.byId("product_code").get("value")==="BG" || dj.byId("product_code").get("value")==="LC" || dj.byId("product_code").get("value")==="EL" || dj.byId("product_code").get("value")==="SI"))
				{
					// Test that the expiry date is greater than or equal to the Business date

				var days = validateBusinessDate(this);
					if(days < 0)
					{
					console.debug(ExpDateCurrntDate, days);
						this.invalidMessage = m.getLocalization("expiryDateSmallerThanSystemDate",[
						                                               						         _localizeDisplayDate(this)
						                                               								]);
						return false;
					}		
				}
			}
			
			return true;
		}, 
			/**
			 * <h4>Summary:</h4>
			 * Validates that only one of the fields has been populated.
			 * @method validateLink 
			 */
		validateLink : function() {
			//  summary:
		    //       Validates that only one of the fields has been populated.
			
			console.debug("[misys.validation.common] Validating Link, Value =", this.get("value"));
			
			if(dj.byId("link").get("value") !== "" &&
					dj.byId("file_name").get("value") !== ""){
				this.invalidMessage = m.getLocalization("tooManyNewsLinksError");
				return false;
			}
			
			return true;
		}, 
		/**
		 * <h4>Summary:</h4>
		 *   Validates the BIC code.
		 *   @method validateBICFormat 
		 */
		validateBICFormat : function() {
			//  summary:
		    //       Validates the BIC code.
			var bic = this.get("value"),
			regex = new RegExp(dj.byId("swiftBicCodeRegexValue") ? dj.byId("swiftBicCodeRegexValue").get("value") : "");
		
			if(!dj.byId("swiftBicCodeRegexValue")){
				console.debug("[misys.validation.common] Validating BIC Format, swiftBicCodeRegexValue not available on the screen");
				this.invalidMessage = m.getLocalization("invalidBICError", [ bic ]);
				return false;
			}
			if(bic) {
				console.debug("[misys.validation.common] Validating BIC Format, Value", bic);
				if(!regex.test(bic)){
					this.invalidMessage = m.getLocalization("invalidBICError", [ bic ]);
					return false;
				}
			}

			return true;
		},
		
		/**
		 * <h4>Summary:</h4>
		 *   Validates Liquidity branch reference selected
			 and shows error if it's already in use.
		 *   @method validateLiquidityBranchReference 
		 */
		validateLiquidityBranchReference : function() {
			// summary:
			// Validates Liquidity branch reference selected
			// and shows error if it's already in use.
			var LBORef = dj.byId("liquidity_branch_reference");
			if(LBORef && LBORef.get('value') !== ''){
				var LBOReferences = misys._config.liquidityBranchReferences;
				for(var itr = 0; itr < LBOReferences.length; itr++){
					if(misys._config.liqBranchRef === LBORef.get('value')){
						return true;
					}
					else if(LBORef.get('value') === LBOReferences[itr].fi_code && LBOReferences[itr].in_use === 'Y'){
						this.invalidMessage = m.getLocalization("invalidLBORefError");
						return false;
					}
				}
			}
			return true;
		},		

		/**
		 * <h4>Summary:</h4>
			 *   Checks for uniqueness of the email
			 *   @method checkEmailExistence 
			 */
			checkEmailExistence : function() {
			
			var thisField = dj.byId("email");
			var login = dj.byId("login_id");
			var company = dj.byId("company_abbv_name");
			var field = dijit.byId("email");
			var org_email = dj.byId("org_email") ? dj.byId("org_email").get("value"): "" ;
			var user_id = dj.byId("user_id") ? dj.byId("user_id").get("value"): "" ;
			var emailValue = thisField ? thisField.get("value"):"";
			var loginValue = login ? login.get("value"):"";
			var companyValue = company ? company.get("value"):"";
			var fieldStateValid =  (field && (field.get("state") === "Error" || field.get("state") === "Incomplete" || field.readOnly || field.disabled)) ? false: true;
			if(emailValue)
			{
				m.xhrPost({
					url : m.getServletURL("/screen/AjaxScreen/action/CheckEmailUniquenessAction"),
					handleAs : "json",
					sync : true,
					content : {
						emailInContext : emailValue,
						loginInContext : loginValue,
						companyInContext : companyValue,
						orgEmail : org_email,
						userID : user_id
					},
					load : function(response){
						var displayMessage = "";
						if(response.items.isEmailUnique === false && fieldStateValid)
						{
							fieldStateValid = false;
							displayMessage = m.getLocalization("emailIdExists", [ emailValue ]);
							
							m.dialog.show("CUSTOM-NO-CANCEL", displayMessage, "Email Error", function(){
								field.focus();
								field.set("state", "Error");
								dj.hideTooltip(thisField.domNode);
								dj.showTooltip(displayMessage, thisField.domNode, 0);
							});
							setTimeout(function(){
								dj.hideTooltip(thisField.domNode);
								}, 5000);
							
						}
						else
							{
								fieldStateValid = true;
								field.set("state","");
							}
					}
				});
			}
			
			else
				{
					fieldStateValid = true;
				}
				
			return fieldStateValid;
		},

		/**
		 * <h4>Summary:</h4>
		 *   Checks for the existence of the BIC code in the system.
		 *   @method checkBICExistence 
		 */
		checkBICExistence : function() {
			
			//var thisField = this.id?dijit.byId(this.id):dijit.byId(fieldId);
			var thisField = dijit.byId(this.id);
			var validBICValue = thisField ? thisField.get("value"):"";
			var fieldStateValid =  (thisField && (thisField.get("state") === "Error" || thisField.get("state") === "Incomplete" || thisField.readOnly || thisField.disabled)) ? false: true;
			//Call validation only if BIC format is valid and is not one of the above conditions.
			if(validBICValue && fieldStateValid)
			{
				var prodCode = dijit.byId("product_code")? dijit.byId("product_code").get("value"): "";
				
				m.xhrPost({
					url : m.getServletURL("/screen/AjaxScreen/action/CheckSwiftBICAction"),
					handleAs : "json",
					sync : true,
					content : {
						productCode : prodCode,
						bicInContext : validBICValue
					},
					load : function(response){
						var displayMessage = "";
						if(!response.items.bankDataExists)
						{
							fieldStateValid = true;
							displayMessage = m.getLocalization("nonExistentBICWarning", [ validBICValue ]);
							
							m.dialog.show(custmNoCancel, displayMessage, "BIC Error", function(){
								dj.hideTooltip(thisField.domNode);
								dj.showTooltip(displayMessage, thisField.domNode, 0);
							});
							setTimeout(function(){
								dj.hideTooltip(thisField.domNode);
								}, 5000);
							
						}
						else if(!response.items.isValidBic)
						{
							fieldStateValid = false;
							displayMessage = m.getLocalization("nonExistentBICError", [ validBICValue ]);

							m.dialog.show(custmNoCancel, displayMessage, "BIC Error", function(){
								thisField.focus();
								thisField.set("state","Error");
								dj.hideTooltip(thisField.domNode);
								dj.showTooltip(displayMessage,thisField.domNode, 0);
							});
							setTimeout(function(){
								dj.hideTooltip(thisField.domNode);
								}, 5000);
						}
					}
				});
			}
			
			return fieldStateValid;
		},
		
		/**
		 * <h4>Summary:</h4>
		 *   Checks for the existence of the BIC code in the system.
		 *   @method checkBICExistenceForWidgets 
		 */
		checkBICExistenceForWidgets : function() {
						
			var thisField = dijit.byId(this.id);
			var validBICValue = thisField ? thisField.get("value"):"";
			var fieldStateValid =  (thisField && (thisField.get("state") === "Error" || thisField.get("state") === "Incomplete" || thisField.readOnly || thisField.disabled)) ? false: true;
			
			//Call validation only if BIC format is valid and is not one of the above conditions.
			if(validBICValue && fieldStateValid)
			{
				var prodCode = dijit.byId("product_code")? dijit.byId("product_code").get("value"): "";
				
				m.xhrPost({
					url : m.getServletURL("/screen/AjaxScreen/action/CheckSwiftBICAction"),
					handleAs : "json",
					sync : true,
					content : {
						productCode : prodCode,
						bicInContext : validBICValue
					},
					load : function(response){
						var displayMessage = "";
						if(!response.items.bankDataExists)
						{
							fieldStateValid = true;
							displayMessage = m.getLocalization("nonExistentBICWarning", [ validBICValue ]);
							
							m.dialog.show(custmNoCancel, displayMessage, "BIC Error", function(){
								dj.hideTooltip(thisField.domNode);
								dj.showTooltip(displayMessage, thisField.domNode, 0);
							});
							setTimeout(function(){
								dj.hideTooltip(thisField.domNode);
								}, 5000);
							
						}
						else if(!response.items.isValidBic)
						{
							fieldStateValid = false;
							displayMessage = m.getLocalization("nonExistentBICError", [ validBICValue ]);

							m.dialog.show(custmNoCancel, displayMessage, "BIC Error", function(){
								thisField.set("value", "");
								thisField.focus();
								thisField.set("state","Error");
								dj.hideTooltip(thisField.domNode);
								dj.showTooltip(displayMessage,thisField.domNode, 0);
							});
							setTimeout(function(){
								dj.hideTooltip(thisField.domNode);
								}, 5000);
						}
					}
				});
			}
			
			return fieldStateValid;
		},
		
		/**
		 * <h4>Summary:</h4>
		 * Validates the BEI format
		 * @method validateBEIFormat
		 */
		validateBEIFormat : function() {
			//  summary:
		    //       Validates the BEI code.

			// Not required, so return
			var swiftRegex= "^[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9][A-Z2-9]([A-Z0-9]{3,3}){0,1}$";
			var bei = this.get("value"),
				regex = (dj.byId("swiftBicCodeRegexValue") && dj.byId("swiftBicCodeRegexValue").get("value") && dj.byId("swiftBicCodeRegexValue").get("value")!== "") ?  new RegExp(dj.byId("swiftBicCodeRegexValue").get("value"),"g") : new RegExp(swiftRegex,"g");
			if(bei) {
				console.debug("[misys.validation.common] Validating BEI Format, Value", bei);
				if(!regex.test(bei)) {
					this.invalidMessage = m.getLocalization("invalidBEIError", [ bei ]);
					return false;
				}
			}

			return true;
		},
	  /**
	   * <h4>Summary:</h4>
	   * Validates that no invalid characters are present.
	   * @method validateCharacters
	   */
		validateCharacters : function() {
			//  summary:
		    //       Validates that no invalid characters are present.
				
			console.debug(validateAbbNameFormat, 
					this.get("value"));

			var strValidCharacters = 
				" 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/-?.,+_";
			var character;
			var isValid = d.every(this.get("value"), function(theChar){
				character = theChar;
				return (strValidCharacters.indexOf(theChar) < 0) ? false : true;
			});
			
			if(!isValid) {
				this.invalidMessage = m.getLocalization("illegalCharError", [ character ]);
			}

			return isValid;
		},
	  /**
	   * <h4>Summary:</h4>
	   * Validates that no invalid characters are present in role creation.
	   * @method validateCharacters
	   */
		validateCharsInRolesCreation : function() {
			//  summary:
			//       Validates that no invalid characters are present.
					
			console.debug(validateAbbNameFormat, 
						this.get("value"));

			var strValidCharacters = 
				"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-()/'  ";
			var character;
			var isValid = d.every(this.get("value"), function(theChar){
				character = theChar;
				return (strValidCharacters.indexOf(theChar) < 0) ? false : true;
			});
				
			if(!isValid) {
				this.invalidMessage = m.getLocalization("illegalCharError", [ character ]);
			}

			return isValid;
		}, 
		/**
		 * <h4>Summary:</h4>
		 * Validates that no invalid SWIFT Address characters are present.
		 * @method validateSwiftAddressCharacters
		 */
		validateSwiftAddressCharacters : function() {
			//  summary:
		    //       Validates that no invalid SWIFT Address characters are present.
				
			console.debug("[misys.validation.common] Validating Swift Characters, Value =", 
					this.get("value"));
			
			
			var regexStr =dj.byId("swiftregexValue").get("value");
			var swiftchar = this.get("value"),
			swiftregexp = new RegExp(regexStr);
		
			var isValid=false;
			
			isValid=swiftregexp.test(swiftchar);
			
			if(!isValid) {
				this.invalidMessage = m.getLocalization("invalidSWIFTTransactionError");
			}

			return isValid;
		}, 
		/**
		 * <h4>Summary:</h4>
		 *  Validates that no invalid characters are present excluding space.
		 *  @method validateCharactersExcludeSpace
		 */				
		validateCharactersExcludeSpace : function() {
			//  summary:
		    //       Validates that no invalid characters are present.
				
			console.debug(validateAbbNameFormat, 
					this.get("value"));

			var strValidCharacters = 
				" 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ/-?.,+_";
			var character;
			var isValid = d.every(this.get("value"), function(theChar){
				character = theChar;
				return (strValidCharacters.indexOf(theChar) < 0) ? false : true;
			});
			
			if(!isValid) {
				this.invalidMessage = m.getLocalization("illegalCharError", [ character ]);
			}

			return isValid;

		}, 
		
		/**
		 * <h4>Summary:</h4>
		 *  Validates specified char shoudn't be allowed.
		 *  @method validateBlackListChar
		 */				
		validateBlackListChar : function() {

			var regexStr = dijit.byId("blacklistspecialcharregexvalue").get("value");
			var blacklistspecialcharregexStr = new RegExp(regexStr);
			var isValid = blacklistspecialcharregexStr.test(this.get("value"));//.test(this.get("value"));
			if(isValid) {
				this.invalidMessage = m.getLocalization("blacklistCharError");
			}
			return isValid;
		},
		
		validateBlackListCharInDynamicRTE: function(field) {
			var fieldValue = field ? field.get('value') : "";
			var encodeValue = dojo.trim(dojox.html.entities.encode(fieldValue, dojox.html.entities.html));
			var regexStr = dijit.byId("blacklistspecialcharregexvalue").get("value");
			var blacklistspecialcharregexStr = new RegExp(regexStr);
			var isValid = blacklistspecialcharregexStr.test(encodeValue);
			if(isValid) {
				this.invalidMessage = m.getLocalization("blacklistCharError");
			}
			return isValid;
		},
				
		/**
		 * Summary;
		 * Validates single email address
		 * @method validateEmailAddr
		 */
		validateSingleEmailAddr : function() {
			//  summary:
		    //       Validates single email address

			// Not required, so return
			var fieldValue = this.get("value");
			var isValid = true;
			if(fieldValue === ""){
				return isValid;
			}

			console.debug("[misys.validation.common] Validating Single Email Addr, Value =", fieldValue);

			if(!dojox.validate.isEmailAddress(fieldValue)){
				isValid = false;
			}
			
			if(!isValid){
				this.invalidMessage = m.getLocalization("invalidEmailAddressError");
				return false;
			}
			return true;
		},

		
		/**
		 * Summary;
		 * Validates an email address
		 * @method validateEmailAddr
		 */
		validateEmailAddr : function() {
			//  summary:
		    //       Validates an email address

			// Not required, so return
			var fieldValue = this.get("value");
			if(fieldValue === ""){
				return true;
			}

			console.debug("[misys.validation.common] Validating Email Addr, Value =", fieldValue);

			var multiemail = fieldValue.split(";");
			var validemail = [];
			var j = 0;
			for( var i=(multiemail.length-1); i>=0; i--)
			{
				if(!dojox.validate.isEmailAddress(multiemail[i])){
					validemail[j] = multiemail[i];
					j++;
				}
		     }
			
			if(i>j){
				this.invalidMessage = m.getLocalization("invalidEmailAddressError");
				return false;
			}
			
			for( var k=(validemail.length-1); k>=0; k--)
			{
				if(!dojox.validate.isEmailAddress(validemail[k])){
					this.invalidMessage = m.getLocalization("invalidEmailAddressError");
					return false;
				}
				
			}
			
			return true;
		},
		
		validateNoOfEmails :  function(){
			
			var email_1 = dj.byId("notify_beneficiary_email").get("value");
			var res = email_1.split(";");
				
				if(res.length > 10){
					var errorMessage =  m.getLocalization("checkEmailId");
					dj.byId("notify_beneficiary_email").set("state","Error");
					dj.hideTooltip(dj.byId("notify_beneficiary_email").domNode);
					dj.showTooltip(errorMessage, dj.byId("notify_beneficiary_email").domNode, 0);
				}
			},
		/**
		 * <h4>Summary:</h4>
		 * Validates a web address.
		 */
		validateWebAddr : function() {
			//  summary:
		    //       Validates a web address.

			// Not required, so return
			var fieldValue = this.get("value");
			if(fieldValue === ""){
				return true;
			}
				
			console.debug("[misys.validation.common] Validating Web Addr, Value =", fieldValue);
			
			if(!dojox.validate.isUrl(fieldValue)){
				this.invalidMessage = m.getLocalization("invalidWebAddressError");
				return false;
			}

			return true;
		}, 
		/**
		 * Summary;
		 *  Validates a password.
		 *  @method validatePassword
		 */
		validatePassword : function() {
			//  summary:
		    //       Validates a password.


			// Uncomment the following to have the password length checked
			// First Implementation: between 4 to 10 characters
			/*
			 * if((4>theObj.value.length) || (10<theObj.value.length)){
			 * fncShowError(34, "4", "10"); theObj.focus(); return false; }
			 */

			// Second implementation : minimum 6 chars
			/*
			 * if(6>theObj.value.length){ fncShowError(35, "6"); theObj.focus();
			 * return false; }
			 */

			//
			// Uncomment the following to check there is at least one digit and one
			// letter character
			/*
			 * strDigitCharacters = "0123456789"; strLetterCharacters =
			 * "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; boolDigitFound =
			 * false; boolLetterFound = false; for(var i = 0; i < theObj.value.length; i++){
			 * if(strDigitCharacters.indexOf(theObj.value.charAt(i)) > -1){
			 * boolDigitFound = true; } if
			 * (strLetterCharacters.indexOf(theObj.value.charAt(i)) > -1){
			 * boolLetterFound = true; } } if(!(boolDigitFound && boolLetterFound)){
			 * fncShowError(35, "6"); theObj.focus(); return false; }
			 */

			return true;
		}, 
		/**
		 * <h4>Summary:</h4>
		 *  Validates a monthly date value
		 *  @method validateMonthly
		 */
		validateMonthly: function() {
			//  summary:
		    //       Validates a monthly date value

			console.debug("[misys.validation.common] Validating monthly date value");

			// check if monthly frequency is selected
			if(!dj.byId("frequency_2").get("checked")) {
				this.set("value", "");
		    }
		   
			var value = this.get("value");
		    if(value === "29" || value === "30" || value === "31") {
		    	this.invalidMessage = m.getLocalization("monthDayWarningMessage");
		    	return false;
		    }

		    return true;
		 }, 
		 /**
		  * <h4>Summary:</h4>
		  *  Validates that the format of the rate field is correct
		  *  <h4>Description:</h4> 
		  *  Basically checks for the number of digits before and after the comma.
		  *  @method validateRateFormat
		  */
		 validateRateFormat : function() {
		 	//  summary:
		     //       Validates that the format of the rate field is correct 
			 //       (number of digits before and after the comma).	

			var isValid = true;
		 	var rate = this.get("value");
		 	if(rate < 0 || rate === 0)
		 	{
		 		isValid = false;
		 		return isValid;
		 	}		 	
		 	var rateString = (rate + "");
		 	
		 	console.debug("[misys.validation.common] Validating  Rate Field, Value =", rate);
		 	
		 	var l_intCounterNumbersBeforeComma = 0;
		     var l_intCounterNumbersAfterComma = 0;
		     var foundNumbersBeforeComma = false;
		     var foundstrDecimalDelimiter = false;
		
		     // todo change to .every()
		 	d.forEach(rateString, function(theChar){
		       console.debug("[misys.validation.common] Character is", theChar);
		       
		       if (((theChar >= "0" || theChar <= "9") && 
		    		   theChar !== m.getLocalization("g_strDecimalDelimiter"))) {
		     	  if (!foundNumbersBeforeComma) {
		     		  l_intCounterNumbersBeforeComma= l_intCounterNumbersBeforeComma+1;
		     	  }
		     	  else {
		     		  l_intCounterNumbersAfterComma = l_intCounterNumbersAfterComma +1; 
		     	  }
		       }
		       else if (theChar === m.getLocalization("g_strDecimalDelimiter")) {
		     	  foundNumbersBeforeComma = true;
		     	  foundstrDecimalDelimiter = true;

		     	  if (l_intCounterNumbersBeforeComma > m.getLocalization("g_numbersBeforeComma"))
		     	  {
		     		  this.invalidMessage = 
		     			  m.getLocalization("rateMessageNumbersBeforeAndAfterComma",
		     					  [m.getLocalization("g_numbersBeforeComma"), 
		     					   m.getLocalization("g_numbersAfterComma") ]);
		     		  isValid = false;
		     	  }
		       }
		     });
		 	
		 	// check the rest of the rate
		     if (l_intCounterNumbersAfterComma > m.getLocalization("g_numbersAfterComma")) {
		     	this.invalidMessage = 
		     		m.getLocalization("rateMessageNumbersBeforeAndAfterComma", 
		     				[ m.getLocalization("g_numbersBeforeComma"), 
		     				  m.getLocalization("g_numbersAfterComma") ]);
		     	isValid = false;
		 	 }
			     var numberBeforeComma = m.getLocalization("g_numbersBeforeComma");
			     
			     var parsedNumberBeforeComma = parseInt(numberBeforeComma, 10);
			     //var x = round(m);
			     if(!foundstrDecimalDelimiter && rateString.length > parsedNumberBeforeComma) {
			     	this.invalidMessage = 
			     		m.getLocalization("rateMessageNumbersBeforeComma", 
			     				[m.getLocalization("g_numbersBeforeComma")]);
			     	isValid = false;
			     }
		 	return isValid;
		 }, 
		 
		 /**
		  * <h4>Summary:<h4> Validates the number entered in the widget
		  * misys.form.DateOrTermField.js. This function has to be hitch with
		  * the widget DateOrTermField before to be use.
		  * 
		  * @param {String} errorMessage  
		  * error message which will be displayed in 'this'
		  */
		 validateTermNumberField : function(/*String*/ errorMessage) {
				
			 // if this is not a DateTermField Widget
			if(!(/Date/.test(this.get("declaredClass")))){
				return false;
			}
			// Return true for empty values
			if(!this.isCorrectlyFilled()){
				return true;
			}
			
			if (!this.isValidNumber()) {
				this.get("_numberField").invalidMessage = m.getLocalization(errorMessage);
				return false;
			}
			
			return true;
		 },
		 
		 // TODO Refactor, this shouldn"t receive parameters
		 /**
			 * <h4>Summary:</h4> Validates the date entered in the widget
			 * misys.form.DateTermField.js. This function has to be hitch with
			 * the widget DateTermField before to be use.
			 * 
			 * @param {Boolean} isFocused
			 * @param {String} comparedWidgetId  
			 * id of the misys.form.DateTermField widget with which 'this' will be compared
			 * @param {String} errorMessage  
			 *  error message which will be displayed in 'this'
			 * @param {Boolean} smaller  
			 *  true if the comparison is 'smaller than'
			 * @param {date} startdate
			 * @method 
			 */
		 validateDateTermField : function( /*Boolean*/ isFocused,
				 						   /*String*/ comparedWidgetId,
				 						   /*String*/ errorMessage,
				 						   /*Boolean*/ smaller,
				 						   /*Date*/ startdate) {
				// summary:
			    //		Validates the date entered in the widget misys.form.DateTermField.js.
				//		This function has to be hitch with the widget DateTermField before to be use.
				//		Four validations are possible :
				//		_ compared to date of day (greater or smaller).
				//		_ compared to another misys.form.DateTermField widget (greater or smaller).
				//
				//		NOTE: This function have to be in the scope of widget which is validate.
				//
				//      comparedWidgetId
				//		 id of the misys.form.DateTermField widget with which 'this' will be 
			    //       compared
				//
				//      errorMessage
				//		 error message which will be displayed in 'this'
				//
				//      smaller
				//		 true if the comparison is 'smaller than' 
				
				// if this is not a DateTermField Widget
				if(!(/Date/.test(this.get("declaredClass")))){
					return false;
				}
				
				this.get("_calendarWidget").invalidMessage = 
					this.get("_calendarWidget").messages.invalidMessage;
				if(!this.get("_calendarWidget").validator(this.get("_calendarWidget").textbox.value, 
						this.get("_calendarWidget").constraints)){
					return false;
				}
				
				// Return true for empty values
				if(!this.isCorrectlyFilled()){
					return true;
				}
				var isValid = true;
				if (!smaller){
					smaller = false;
				}
				
				// retrive the first date 
				var firstDate;
				if (this.isValidDate()) {
					firstDate = this.getFormalValueDate();
					if (!firstDate){
						return true;
					}
				}
				else {
					firstDate = _normalizeDate(this.get("id"));
					if (firstDate < 0){
						return true;
					}
				}
				// if firstDate is null, return true ?
				if (!firstDate){
					return true;
				}
				
				// retrieve the second date
				var secondDate;
				var compareWidget = dj.byId(comparedWidgetId);
				if (!comparedWidgetId) {
					// date of the day
					secondDate = new Date();
				}
				else
				{
					//second date is date field 
					if (!(/Date/.test(compareWidget.get("declaredClass")))){
						
						secondDate = m.localizeDate(compareWidget);
						if (!secondDate){
							return true;
						}
					} else {
						if (compareWidget.isValidDate()) {
							secondDate = compareWidget.getFormalValueDate();
							if (!secondDate){
								return true;
							}
						}
				
						else{
							if (startdate) {
								secondDate = _normalizeDate(comparedWidgetId, firstDate);								
							}
							else {
								secondDate = _normalizeDate(comparedWidgetId);								
							}
							
							if (secondDate < 0){
								return true;
							}	
						}
					}
				}
				// set hour, minutes ... to 0 for comparison
				firstDate.setHours(0);
				firstDate.setMinutes(0);
				firstDate.setSeconds(0);
				firstDate.setMilliseconds(0);
				if(secondDate !== undefined){
				secondDate.setHours(0);
				secondDate.setMinutes(0);
				secondDate.setSeconds(0);
				secondDate.setMilliseconds(0);
				}
				
				console.debug("[misys.validation.common] Validate date.");
				console.debug("[misys.validation.common] First date", firstDate);
				console.debug("[misys.validation.common] Second date", secondDate);
				// Test that the far date is greater than or equal to the earlier date
				if(smaller) {
					isValid = d.date.compare(firstDate, secondDate) <= 0 ? true : false;
				}
				else {
					isValid = d.date.compare(firstDate, secondDate) >= 0 ? true : false;
				}
				if (!isValid) {
					this.get("_calendarWidget").invalidMessage = m.getLocalization(errorMessage, 
							[d.date.locale.format(firstDate, {selector :"date"}),
							 d.date.locale.format(secondDate, {selector :"date"})]);
				}

				return isValid;
		}, 
		


						/**
						 * <h4>Summary:</h4> This function validates the order type
						 * <h4>Description:</h4>  Its displayed value should not be empty
						 * 
						 * @method validateOrderType
						 */
		validateOrderType : function() {
			// summary:
			//		TODO
			
			var orderCheckBox = dj.byId("order_list_by_default");
			if(orderCheckBox && orderCheckBox.get("checked")) {
				return this.get("displayedValue") !== '';
			}
			return true;
		},
						/**
						 * Summary; This function validates the axis value
						 * 
						 * @method validateAxisScale
						 */
		validateAxisScale: function() {
			// summary:
			//		TODO
			
			var axisXValue = dj.byId("chart_axis_x");
			if((axisXValue && axisXValue.get("value") && arrColumn) && (arrColumn[axisXValue][0] === "Date"))
			{
				// test the column type if is date we can validate.
					return this.get("displayedValue");
			}
			return true;
		},

		validateGroupingColumn: function() {
			// summary:
			//		TODO
			
			var orderCheckBox = dj.byId("grouping_enable");
			if(this.get('value')=='' && this.get('displayedValue')!=''){
				return false;
			}
			if(orderCheckBox && orderCheckBox.get("checked")) {
				return this.get("displayedValue") !== "";
			}
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * Validate outstanding amount
		 * <h4>Description:</h4> 
		 * Checks for the following senerios
		 * The outstanding amount should be zero before the purge event can be processed.
		 * @method validateOutstandingAmount
		 * @return {boolean}
		 *  True if amount is valid otherwise false
		 * 
		 */
		validateOutstandingAmount : function() {
			// TODO This class is added via the appendClass attribute in XSL, but
			// originally on the row rather than the input, for a specific case in
			// the Summit code. This needs to be addressed.
			
			// TODO We should really just change the ID of the field (keeping the original
			// name). Check for dependencies elsewhere
			
			var fields = d.query(".outstanding");
			if(fields.length === 1) {
				var outstandingAmount = 
					dj.byId(d.attr(fields[0], "widgetid")).get("value") || 0;
				if (outstandingAmount > 0 && this.get("value") === "10") {
					this.invalidMessage = m.getLocalization("outstandingAmountShouldBeZero");
					return false;
				}
			}

			// TODO CF It is likely here where the standard validation should be invoked,
			// For DR to check as I don't know the purpose behind the original change
			
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates the shipment date
		 * <h4>Description:</h4> 
		 *  Called as a pre-submit validation in LC-forms, to verify that one or other
		 *  of last_ship_date or narrative_shipment_period have a value 
		 *  User must have choose atleast latest shipment date or shipment period.
		 *  @method validateShipmentDates
		 *  @return {boolean}
		 *   True if date or period  is valid otherwise false
		 */
		validateShipmentDates : function() {
			//  summary:
		    //        Called as a pre-submit validation in LC-forms, to verify that one or other 
			//        of last_ship_date or narrative_shipment_period have a value
			
			var lastShipDate = dj.byId("last_ship_date"),
			    narrativeShipmentPeriod = dj.byId("narrative_shipment_period");
			if(lastShipDate && narrativeShipmentPeriod && !lastShipDate.get("value") &&
					narrativeShipmentPeriod.get("value") === ""){
				m._config.onSubmitErrorMsg = m.getLocalization("shipmentPeriodOrDateMissingError");
				return false;
			}
			
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates holidaye abd cutoff time
		 * <h4>Description:</h4> 
		 * Called as a pre-submit validation in all forms, to verify for holidays and cutoff time
		 * @method validateHolidaysAndCutOffTime
		 * 
		 */
		validateHolidaysAndCutOffTime : function(/*String*/bankAbbvNameWidgetId,/*String*/subProductCodeWidgetId,/*String*/mode,
													/*Array of Date Names*/dateNames,/*Array of date widgetId's*/dateWidgetIds,/*String*/entityWidgetId,
													/*String*/currencyCodeWidgetId,/*String*/amountWidgetId){
				//  summary:
			    //        Called as a pre-submit validation in all forms, to verify for holidays and cutoff time
			
				var productCode = misys._config.productCode ? misys._config.productCode : "" ;
				var bankAbbvName = dj.byId(bankAbbvNameWidgetId) ? dj.byId(bankAbbvNameWidgetId).get("value") : "";
				var subProductCode = dj.byId(subProductCodeWidgetId) ? dj.byId(subProductCodeWidgetId).get("value") : ""; 
				//IAFT same n different currency check for holiday cutoff
				if(subProductCode === 'IAFT')
				{
					if(mode === "UNSIGNED")
					{
						if(dj.byId(currencyCodeWidgetId).get("value") === dj.byId("applicant_act_cur_code_unsigned").get("value"))
						{
							subProductCode = "IAFTS";
						}
						else
						{
							subProductCode = "IAFTD";
						}
					}
					else
					{
						if(dj.byId(currencyCodeWidgetId).get("value") === dj.byId("applicant_act_cur_code").get("value"))
						{
							subProductCode = "IAFTS";
						}
						else
						{
							subProductCode = "IAFTD";
						}
					}
				}
				
				var curCode = dj.byId(currencyCodeWidgetId) ? dj.byId(currencyCodeWidgetId).get("value") : ""; 
				var amount = dj.byId(amountWidgetId) ? dj.byId(amountWidgetId).get("value") : ""; 
				//Set flag to indicate Holiday Validation
				m._config = m._config || {};
				dojo.mixin(m._config,{holidayCutOffEnabled:true});
				
				//Get All date values from respective widgets
				var dateValueArray = new Array();
				var enityValue = dj.byId(entityWidgetId) ? dj.byId(entityWidgetId).get("value") : "" ;
				dojo.forEach(dateWidgetIds,function(node,index){
					var date = _formatHolidaysAndCutOffDate(dj.byId(node));
					dateValueArray.push(date);	
				});
				//m.dialog.hide();
				
				//referenceid and tnxid are not required in draft mode
				//AJAX call
				return  _validateHolidayAndCutOffTime(bankAbbvName,productCode,subProductCode,mode,dateNames,dateValueArray,enityValue,curCode,amount,null);
		},
		
		/**
		 * <h4>Summary:</h4>
		 * This function validates holiday and cutoff time for India Payment
		 * <h4>Description:</h4> 
		 * Called as a pre-submit validation in all forms, to verify for holidays and cutoff time with clearingCode
		 * @method validateHolidaysAndCutOffTimeForMUPS
		 * 
		 * 
		 * 
		 */
		validateHolidaysAndCutOffTimeForMUPS : function(/*String*/bankAbbvNameWidgetId,/*String*/subProductCodeWidgetId,/*String*/mode,
													/*Array of Date Names*/dateNames,/*Array of date widgetId's*/dateWidgetIds,/*String*/entityWidgetId,
													/*String*/currencyCodeWidgetId,/*String*/amountWidgetId,/*String*/clearingCodeWidgetId){
				//  summary:
			    //        Called as a pre-submit validation in all forms, to verify for holidays and cutoff time
			
				var productCode = misys._config.productCode ? misys._config.productCode : "" ;
				var bankAbbvName = dj.byId(bankAbbvNameWidgetId) ? dj.byId(bankAbbvNameWidgetId).get("value") : "";
				var subProductCode = dj.byId(subProductCodeWidgetId) ? dj.byId(subProductCodeWidgetId).get("value") : ""; 
				var clearingCode = dj.byId(clearingCodeWidgetId) ? dj.byId(clearingCodeWidgetId).get("value") : "";
				//IAFT same n different currency check for holiday cutoff
				if(subProductCode === 'IAFT')
				{
					if(mode === "UNSIGNED")
					{
						if(dj.byId(currencyCodeWidgetId).get("value") === dj.byId("applicant_act_cur_code_unsigned").get("value"))
						{
							subProductCode = "IAFTS";
						}
						else
						{
							subProductCode = "IAFTD";
						}
					}
					else
					{
						if(dj.byId(currencyCodeWidgetId).get("value") === dj.byId("applicant_act_cur_code").get("value"))
						{
							subProductCode = "IAFTS";
						}
						else
						{
							subProductCode = "IAFTD";
						}
					}
				}
				
				var curCode = dj.byId(currencyCodeWidgetId) ? dj.byId(currencyCodeWidgetId).get("value") : ""; 
				var amount = dj.byId(amountWidgetId) ? dj.byId(amountWidgetId).get("value") : ""; 
				//Set flag to indicate Holiday Validation
				m._config = m._config || {};
				dojo.mixin(m._config,{holidayCutOffEnabled:true});
				
				//Get All date values from respective widgets
				var dateValueArray = new Array();
				var enityValue = dj.byId(entityWidgetId) ? dj.byId(entityWidgetId).get("value") : "" ;
				dojo.forEach(dateWidgetIds,function(node,index){
					var date = _formatHolidaysAndCutOffDate(dj.byId(node));
					dateValueArray.push(date);	
				});
				//m.dialog.hide();
				
				//referenceid and tnxid are not required in draft mode
				//AJAX call
				return  _validateHolidayAndCutOffTime(bankAbbvName,productCode,subProductCode,mode,dateNames,dateValueArray,enityValue,curCode,amount,clearingCode);
		},
		
			/**
			 * <h4>Summary:</h4>
			 *  check the account status for cash FTs and bulk.
			 *  <h4>Description:</h4> 
			 *  it will check the from account status for particular transaction
			 *  Shows an error message in case if status is inactive.
			 *  @method checkAccountStatus
			 */
		checkAccountStatus : function(/*String*/accNo){

			var isAccountActive = true;
			m.xhrPost( {
				url : m.getServletURL("/screen/AjaxScreen/action/CheckAccountStatus"),
				handleAs 	: "json",
				sync 		: true,
				content : {
					accNo : accNo
				},
				load : function(response, args){
					isAccountActive = response.isAccountActive;
				},
				error : function(response, args){
					console.error("Checking Account status  error ", response);
				}
			});
			return isAccountActive;
		},
		
		/**
		 * <h4>Summary:</h4>
		 *  Validates that no invalid characters and spaces are present.
		 *  <h4>Description:</h4> 
		 *  It has a string of valid alphanumeric characters,passed value is tested against it.
		 *  Shows an error messgae in case if invalid charcters passed.
		 *  @method validateAlphaNumeric
		 */
		validateAlphaNumeric : function(){
				//  summary:
			    //       Validates that no invalid characters and spaces are present.
				
			var regexStr = dijit.byId("userNameRegexValue").get("value");
			var userNameRegexStr = new RegExp(regexStr);
			var isValid = userNameRegexStr.test(this.get("value"));
			if(!isValid) {
				this.invalidMessage = m.getLocalization("userIdillegalCharError");
			}

			return isValid;
		},
		/**
		 * <h4>Summary:</h4>
		 *  Validates that no invalid characters and spaces are present.
		 * It has a string of valid alphanumeric characters,passed value is tested against it.
		 *  Shows an error messgae in case if invalid charcters passed.
		 *  @method validateGroupId
		 */
			validateGroupId : function(){
				//  summary:
			    //       Validates that no invalid characters and spaces are present.
				
			var regexStr = dijit.byId("groupIdRegexValue").get("value");
			var groupIdRegexStr = new RegExp(regexStr);
			var isValid = groupIdRegexStr.test(this.get("value"));
			if(!isValid) {
				this.invalidMessage = m.getLocalization("userIdillegalCharError");
			}
	
			return isValid;
		},
		/**
		 * <h4>Summary:</h4>
		 *  Validates that no invalid characters and spaces are present.
		 * It has a string of valid alphanumeric characters,passed value is tested against it.
		 *  Shows an error messgae in case if invalid charcters passed.
		 *  @method validateGroupId
		 */
			validateGroupName : function(){
				//  summary:
			    //       Validates that no invalid characters and spaces are present.
				
			var regexStr = dijit.byId("groupNameRegexValue").get("value");
			var groupNameRegexStr = new RegExp(regexStr);
			var isValid = groupNameRegexStr.test(this.get("value"));
			if(!isValid) {
				this.invalidMessage = m.getLocalization("userIdillegalCharError");
			}
		
			return isValid;
		},
		/**
		 * <h4>Summary:</h4>
		 *  Validates that no invalid characters.
		 *  <h4>Description:</h4> 
		 *  It has a string of valid alphanumeric characters,passed value is tested against it.
		 *  Shows an error messgae in case if invalid charcters passed.
		 *  @method validateAlphaNumericRemarks
		 */
		validateAlphaNumericRemarks : function(){
			//	summary:
		    //		Function used to validate the remarks.
			console.debug("[Validate] Validating Remarks, Value = " + this.get('value'));
			if(!_validateChar(this, " 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")){
				var message = m.getLocalization("illegalRemarksCharError", [ this.get('value') ]);
				// TODO:This fix was introduced to replace < characters with &lt; as they were being replaced with a DIV's
				// in subsequent processing.
				// This cased the remarks tool top to only display as far as the first < character.
				// This fix should most likely be removed one a reason is determined for why in some
				// cases the < is interpreted as a div
				message = message.replace(/>/g, "&gt;");
				message = message.replace(/</g, "&lt;");
				this.invalidMessage= message;
				return false;
			}
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * Validates that no invalid characters and spaces are present.
		 * Desciption:
		 * It has string of valid characters,passed value is tested against it.
		 * Checks for the following scenarios .
		 * Invalid character
		 * @method validateNumeric
		 */
		validateNumeric : function(){
			//  summary:
		    //       Validates that no invalid characters and spaces are present.
			
		var strValidCharacters = "0123456789";
		var character;
		var isValid = d.every(this.get("value"), function(theChar){
			character = theChar;
			return (strValidCharacters.indexOf(theChar) < 0) ? false : true;
		});
		
		if(!isValid) {
			this.invalidMessage = m.getLocalization("illegalCharError", [ character ]);
		}

		return isValid;
		},
/**
 * <h4>Summary:</h4>
 * This function is to validate Phone or Fax number
 * <h4>Description:</h4> 
 * It has string of valid characters .Fax number is tested against it.
 * Checks for the following scenarios 
 * Invalid position of character.
 * Invalid character.
 * @method validatePhoneOrFax
 */
		validatePhoneOrFax : function(){
			//  summary:
		    //       Validates phone and fax numbers.
			
			var strValidCharacters = "0123456789- ()";
			var character;
			var isValid = d.every(this.get("value"), function(theChar,index){
				if(index === 0 && theChar === "+")
				{
					return true;
				}
				else
				{
					character = theChar;
					return (strValidCharacters.indexOf(theChar) < 0) ? false : true;
				}
			});
			
			if(!isValid) {
				if(character === "+")
				{
					this.invalidMessage = m.getLocalization("invalidCharacterPosition",[ character ]);
				}
				else
				{
					this.invalidMessage = m.getLocalization("illegalCharErrorContact");
				}
			}
	
			return isValid;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function is to validate  Fax number
		 * <h4>Description:</h4> 
		 * It has string of valid characters .Fax number is tested against it.
		 * Checks for the following scenarios 
		 * Invalid position of character.
		 * Invalid character.
		 * @method validateFax
		 */
				validateFax : function(){
					//  summary:
				    //       Validates phone and fax numbers.
					
					var strValidCharacters = "0123456789- ()";
					var character;
					var isValid = d.every(this.get("value"), function(theChar,index){
						if(index === 0 && theChar === "+")
						{
							return true;
						}
						else
						{
							character = theChar;
							return (strValidCharacters.indexOf(theChar) < 0) ? false : true;
						}
					});
					
					if(!isValid) {
						if(character === "+")
						{
							this.invalidMessage = m.getLocalization("invalidCharacterPosition",[ character ]);
						}
						else
						{
							this.invalidMessage = m.getLocalization("illegalCharErrorContactForFax");
						}
					}
			
					return isValid;
				},
		/**
		 * Summary;
		 *  Validates the IP Invoice date
		 *  <h4>Description:</h4> 
		 *  It checks for the following scenarios 
		 *  The Invoice Date must be less than or equal to the Due Date.
		 *  @method validateIPInvoiceDate
		 *  @return {boolean}
		 *   True if date is valid otherwise false 
		 */
		validateIPInvoiceDate : function() {
			//  summary:
		    //       Validates the latest answer date

			// For non-required empty values, just return true
			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Invoice Date, Value", 
					this.get("value"));

			// Test that the issue date is less than the due date
			var dueDate = dj.byId("due_date");
			if(!m.compareDateFields(this, dueDate)) {
				this.invalidMessage = m.getLocalization("invoiceDateGreaterThanDueDateError",
						[_localizeDisplayDate(this),
			             _localizeDisplayDate(dueDate)]);
				return false;
			}
			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 * This function validates the Invoice payable due date
		 * <h4>Description:</h4> 
		 * It checks for the following scenarios 
		 * The Due Date must be greater than or equal to the Application Date.
		 * The Due Date must be greater than or equal to the Invoice Date.
		 * @method validateIPDueDate
		 * @return {boolean}
		 *  True if date is valid otherwise false
		 */
		validateIPDueDate : function() {
			//  summary:
		    //       Validates the latest answer date

			// For non-required empty values, just return true
			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Invoice Due Date, Value", 
					this.get("value"));

			// Test that the due date is greater than the application date
			var applDate = dj.byId("appl_date");
			if(!m.compareDateFields(applDate, this)) {
				this.invalidMessage = m.getLocalization("dueDateLessThanAppDateError",
						[_localizeDisplayDate(this),
			             _localizeDisplayDate(applDate)]);
				return false;
			}
			// Test that the due date is greater than the issue date
			var issDate = dj.byId("iss_date");
			if(!m.compareDateFields(issDate, this)) {
				this.invalidMessage = m.getLocalization("dueDateLessThanInvoiceDateError",
						[_localizeDisplayDate(this),
			             _localizeDisplayDate(issDate)]);
				return false;
			}

			return true;
		},
		/**
		 * <h4>Summary:</h4>
		 *   Validates the data entered as the Remittance Date.
		 *   <h4>Description:</h4> 
		 *   Its checks for the following scenarios 
		 *   The Remittance Date should not be after the system date.",
		 *   @method validateRemittanceDate
		 *   @return {boolean}
		 *    True if date is valid otherwise false
		 */
	   validateRemittanceDate : function() {
			//  summary:
		    //        Validates the data entered as the Remittance Date.
		    // 
		   
			// This validation is for non-required fields
			if(!this.get("value")) {
				return true;
			}

			console.debug("[misys.validation.common] Validating Remittance Date. Value = ",
					this.get("value"));
			
			
			var remittanceDate = this.get("value");
			var days = validateBusinessDate(this);
			if(days > 0)
			{console.debug("[misys.validation.common] Days difference between remittance date and current date = ", days);
				this.invalidMessage = m.getLocalization("remittanceDateGreaterThanSystemDateError",
						[ _localizeDisplayDate(this) ]);
				return false;
			}
			
			return true;
		}, 

		clearPrincipalAndFeeAccount : function( )
		{
			if(dj.byId("principal_act_name"))
				{
					dj.byId("principal_act_name").set("value", "");
				}
			if(dj.byId("fee_act_name"))
			{
				dj.byId("fee_act_name").set("value", "");
			}
		},
		
		// validate transfer amount should be greater than zero
		/**
		 * <h4>Summary:</h4>
		 * This function validates amount field
		 * <h4>Description:</h4> 
		 * Amount shuould not be zero or negative show an error in both the cases
		 * @method validateAmount
		 * @return {boolean}
		 *  True if amount is correct otherwise false.
		 */
		validateAmount : function(amtId) {
				if(amtId)
				{
					var amt = amtId.get("value");
					var displayMessage,widget;
					if (amt === 0) {
						displayMessage = m.getLocalization("amountcannotzero");
						amtId.set("state","Error");
				 		dj.hideTooltip(amtId.domNode);
				 		dj.showTooltip(displayMessage, amtId.domNode, 0);
				 		amtId.focus();
						return false;
					} 
					else if ((amt < 0) || (amt === undefined)) {
						displayMessage = m.getLocalization("invalidMessage");
						amtId.set("state","Error");
				 		dj.hideTooltip(amtId.domNode);
				 		dj.showTooltip(displayMessage, amtId.domNode, 0);
				 		amtId.focus();
						return false;
					} 
					else
					{
						return true;
					}
			}
				return true;
			},
			
			/**
			 *<h4>Summary:</h4>
			 * Validates the data entered as the Final Expiry Date for rolling renewals of trade products.
			 * @method validateFinalExpiryDate
			 * @return {boolean}
			 *  True if date is valid otherwise false
			 */	
			validateFinalExpiryDate: function() {
				var isValidFinalExpiryDate = true;
				var expDateObj = dj.byId("exp_date").get("value");
				var finalExpiryDate = dj.byId("final_expiry_date").get("value");
				
				if(expDateObj == null || expDateObj == "") {
					isValidFinalExpiryDate = false;
					this.invalidMessage = m.getLocalization("expiryDateReqd");
				}
				else if(finalExpiryDate && finalExpiryDate != "")
				{
					if(finalExpiryDate<expDateObj)
					{
						dj.byId("final_expiry_date").set("value",null);
						isValidFinalExpiryDate = false;
						this.invalidMessage = m.getLocalization("finalExpDateLessThanTransactionExpDtError", [ dj.byId("final_expiry_date").get("displayedValue"), dj.byId("exp_date").get("displayedValue") ]);
					}
				}
			
				return isValidFinalExpiryDate;
			},
			
		/**
		 *<h4>Summary:</h4>
		 * Validates the data entered as the Final Expiry Date for rolling renewals of trade products.
		 * @method validateTradeFinalExpiryDate
		 * @return {boolean}
		 *  True if date is valid otherwise false
		 */	
		validateTradeFinalExpiryDate: function() {
			//  summary:
		    //        Validates the data entered as the Final Expiry Date for rolling renewals of trade products.
		    // 
			var isFinalExpDateValid = true;
			var isPreCondStsfd = true;
			//Since Final Expiry Date is not a mandatory field, it needs to be validated only if it is non-null
			if(this.get("value") != null) {
				// This validation is for non-required fields
				var finalExpDateObj = this.get("value");
				
				var renewalOn = dj.byId("renew_on_code").get("value");					//Whether the first renewal is on "Expiry('01')" or "Calendar Date('02')"
				var renewalCalDate = dj.byId("renewal_calendar_date").get("value");		//Date String if first renewal is on a "Calendar Date('02')"
				var renewalInterval = dj.byId("renew_for_nb").get("value");				//Interval between subsequent renewals (number) 
				var renewalIntervalUnit = dj.byId("renew_for_period").get("value");		//Unit of interval i.e., whether it is "Days"/"Weeks"/"Months"/"Years". 
				var rollingReneNbdays = dj.byId("rolling_renewal_nb").get("value");																		//This along with the interval forms the frequency of renewal.
																		//For ex. Once in 10(renewalInterval) months (renewalIntervalUnit)
				var numOfRenewals = dj.byId("rolling_renewal_nb").get("value");			//Number of renewals allowed
				//var rollingRenewalOn = dj.byId("rolling_renew_on_code").get("value");                      //Whether the rolling renewal is on "Expiry('01')" or "Every('03')"
	            //var rollingRenewalInterval = dj.byId("rolling_renew_for_nb").get("value");                   //Interval between subsequent rolling renewals (number) 
	            //var rollingRenewalIntervalUnit = dj.byId("rolling_renew_for_period").get("value");		//Unit of interval i.e., whether it is "Days"/"Weeks"/"Months"/"Years".
				var milliSecTillLastRenewal = null;
				//var milliSecTillLastRollingRenewal = null;
				var firstRenewalDateObj = null;
				var orgExpDate = null;
				if(renewalOn === "01") {
					firstRenewalDateObj = dj.byId("exp_date").get("value");
					orgExpDate = dj.byId("org_exp_date");
					if(!firstRenewalDateObj && orgExpDate)
					{
						firstRenewalDateObj = dojo.date.locale.parse(orgExpDate.get("value"),{locale:dojo.config.locale, formatLength:"short", selector:"date" });
					}
					if(firstRenewalDateObj == null) {
						isPreCondStsfd = false;
						this.invalidMessage = m.getLocalization("expiryDateReqdForFinExpiryDateError");
					}
				}
				else if(renewalOn === "02") {
					firstRenewalDateObj = renewalCalDate;
					if(firstRenewalDateObj == null)
					{
						isPreCondStsfd = false;
						this.invalidMessage = m.getLocalization("calendarDateReqdForFinExpiryDateError");
					}
				}
				else{
						isPreCondStsfd = false;
						this.invalidMessage = m.getLocalization("renewOnNotSelectedError");
				}
				
				if(rollingReneNbdays == null || isNaN(rollingReneNbdays)) 
				{
					isPreCondStsfd = false;
					this.invalidMessage = m.getLocalization("nbofRenewalsNotSelectedError");
				}
				else if (renewalOn === "01" || renewalOn === "02")
				{
					if(renewalInterval == null || renewalInterval === "" || renewalIntervalUnit == null || renewalIntervalUnit === "")
					{
						isPreCondStsfd = false;
						this.invalidMessage = m.getLocalization("renewForNotSelectedError");
					}
				}
				if(isPreCondStsfd) {
					switch (renewalIntervalUnit) {
						case "D":	
							milliSecTillLastRenewal =  d.date.add(firstRenewalDateObj, "day", numOfRenewals * renewalInterval);
							break;
						case "W":	
							milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "week", numOfRenewals * renewalInterval);		
							break;
						case "M":	
							milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "month", numOfRenewals * renewalInterval);
							break;
						case "Y":	
							milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "year", numOfRenewals * renewalInterval);		
							break;
						default:
							break;
					}
					//Last active date of the trade product
					var lastActiveDateObj;
					if(milliSecTillLastRenewal!=undefined){
						lastActiveDateObj = new Date(milliSecTillLastRenewal.getTime());
					}
					
					//Final expiry date can be any date after the last active date
					if(lastActiveDateObj!=undefined && finalExpDateObj.getTime() < lastActiveDateObj.getTime() ) {
						isFinalExpDateValid = false;
						// Formatting the Date String as per the User Locale
						var localizedLastActiveDate = dojo.date.locale.format(lastActiveDateObj, {selector:"date", formatLength:"short", locale:dojo.config.locale});
						console.log("Final Expiry Date cannot be before Last Active Date: " + localizedLastActiveDate);
						this.invalidMessage = m.getLocalization("finExpiryDateLessThanLastActiveDateError", 
														[ _localizeDisplayDate(this), 
														  localizedLastActiveDate
														]);
					}
				}
				else{								//Cannot validate Final Expiry Date if required fields (Expiry Date/Calendar Date for Renewal) are missing
					isFinalExpDateValid = false;
				}
				
				//Code for validation of final expiry date after rolling renewal. Can be used later for MPSSC-4449
				/*if(isPreCondStsfd) {
					if(!rollingRenewalOn || rollingRenewalOn !== "03")
					{
						switch (renewalIntervalUnit) {
							case "D":	
								milliSecTillLastRenewal =  d.date.add(firstRenewalDateObj, "day", numOfRenewals * renewalInterval);
								break;
							case "W":	
								milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "week", numOfRenewals * renewalInterval);		
								break;
							case "M":	
								milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "month", numOfRenewals * renewalInterval);
								break;
							case "Y":	
								milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "year", numOfRenewals * renewalInterval);		
								break;
							default:
								break;
						}
						//Last active date of the trade product
						var lastActiveDateObj = new Date(milliSecTillLastRenewal.getTime());
						
						//Final expiry date can be any date after the last active date
						if(finalExpDateObj.getTime() < lastActiveDateObj.getTime() ) {
							isFinalExpDateValid = false;
							// Formatting the Date String as per the User Locale
							var localizedLastActiveDate = dojo.date.locale.format(lastActiveDateObj, {selector:"date", formatLength:"short", locale:dojo.config.locale});
							console.log("Final Expiry Date cannot be before Last Active Date: " + localizedLastActiveDate);
							this.invalidMessage = m.getLocalization("finExpiryDateLessThanLastActiveDateError", 
															[ _localizeDisplayDate(this), 
															  localizedLastActiveDate
															]);
						}
					}
					else if(rollingRenewalOn === "03" && rollingRenewalIntervalUnit !== "" && rollingRenewalInterval !== "")
					{
						switch (renewalIntervalUnit) {
						case "D":	 
							milliSecTillLastRenewal =  d.date.add(firstRenewalDateObj, "day", renewalInterval);
							break;
						case "W":	
							milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "week", renewalInterval);		
							break;
						case "M":	
							milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "month", renewalInterval);
							break;
						case "Y":	
							milliSecTillLastRenewal = d.date.add(firstRenewalDateObj, "year", renewalInterval);		
							break;
						default:
							break;
		            	}
		                  var finalExpiryOnFirstRenewal = new Date(milliSecTillLastRenewal.getTime());
		                  
	                	  switch (rollingRenewalIntervalUnit) {
							case "D":	 
								milliSecTillLastRollingRenewal =  d.date.add(finalExpiryOnFirstRenewal, "day", (numOfRenewals-1) * rollingRenewalInterval);
								break;
							case "W":	
								milliSecTillLastRollingRenewal = d.date.add(finalExpiryOnFirstRenewal, "week", (numOfRenewals-1) * rollingRenewalInterval);		
								break;
							case "M":	
								milliSecTillLastRollingRenewal = d.date.add(finalExpiryOnFirstRenewal, "month", (numOfRenewals-1) * rollingRenewalInterval);
								break;
							case "Y":	
								milliSecTillLastRollingRenewal = d.date.add(finalExpiryOnFirstRenewal, "year", (numOfRenewals-1) * rollingRenewalInterval);		
								break;
							default:
								break;
	                	  }
	                	  var finalExpiryOnRollingRenewal = new Date(milliSecTillLastRollingRenewal.getTime());
		                  //Final expiry date can be any date after the last active date
						  if(finalExpDateObj.getTime() < finalExpiryOnRollingRenewal.getTime() ) {
								isFinalExpDateValid = false;
								// Formatting the Date String as per the User Locale
								var localizedFinalExpiryOnRollingRenewal = dojo.date.locale.format(finalExpiryOnRollingRenewal, {selector:"date", formatLength:"short", locale:dojo.config.locale});
								console.log("Final Expiry Date cannot be before Last Active Date: " + localizedFinalExpiryOnRollingRenewal);
								this.invalidMessage = m.getLocalization("finExpiryDateLessThanLastActiveDateError", 
																[ _localizeDisplayDate(this), 
																  localizedFinalExpiryOnRollingRenewal
																]);
							}
					}
				}
				else{								//Cannot validate Final Expiry Date if required fields (Expiry Date/Calendar Date for Renewal) are missing
					isFinalExpDateValid = false;
				}*/
				
			}
			return isFinalExpDateValid;
		},
		/**
		 * Summary:
		 * Validates the Valid From date.(Used in License(LS))
		 * <h4>Description:</h4> 
		 * It checks for the following scenarios  
		 * </br>The Valid From Date must be greater than or equal to the Application Date.
		 * </br>The Valid From Date must be greater than or equal to the Registration Date.
		 * </br>The Valid From Date must be greater than or equal to the Issue Date.
		 * </br>The Valid From Date must be less than or equal to the Valid To Date.
		 * </br>The Valid From Date must be less than or equal to the Latest Payment Date.
		 * </br>In case of error it shows an error popup.
		 * @method validateValidFromDate
		 * @return {boolean}
		 *  True if date is valid otherwise false.
		 */
		validateValidFromDate : function() {
			//  summary:
		    //       Validates the Valid From date.(Used in License(LS))

			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Valid From Date, Value", 
					this.get("value"));
			
			if(dj.byId("reg_date")) 
			{
				var regDate = dj.byId("reg_date");
				if(!m.compareDateFields(regDate, this)) {
					this.invalidMessage = m.getLocalization("validFromDateLessThanRegDateError",
							[_localizeDisplayDate(this),
							 _localizeDisplayDate(regDate)]);
					return false;
				}
			}
			if(dj.byId("iss_date") && dj.byId("iss_date").get("value") !== null)
			{
				var issDate = dj.byId("iss_date");
				if(!m.compareDateFields(issDate, this)) {
					this.invalidMessage = m.getLocalization("validFromDateLessThanIssDateError",
							[_localizeDisplayDate(this),
				             _localizeDisplayDate(issDate)]);
					return false;
				}
			}
			if(dj.byId("valid_to_date") && dj.byId("valid_to_date").get("value") !== null)
			{
				var validToDate = dj.byId("valid_to_date");
				if(!m.compareDateFields(this, validToDate)) {
					this.invalidMessage = m.getLocalization("validFromDateGreaterThanValidToDateError",
							[_localizeDisplayDate(this),
				             _localizeDisplayDate(validToDate)]);
					return false;
				}
			}
			if(dj.byId("latest_payment_date") && dj.byId("latest_payment_date").get("value") !== null)
			{
				var latestPaymentDate = dj.byId("latest_payment_date");
				if(!m.compareDateFields(this, latestPaymentDate)) {
					this.invalidMessage = m.getLocalization("validFromDateGreaterThanLatestPaymntDateError",
							[_localizeDisplayDate(this),
				             _localizeDisplayDate(latestPaymentDate)]);
					return false;
				}
			}
			return true;
		},
		/**
		 * Summary:
		 *  Validates the Valid To date.(Used in License(LS))
		 *  <h4>Description:</h4> 
		 *  It checks for the following scenarios 
		 *  </br>The Valid To Date must be greater than or equal to the Current Date.
		 *  </br>The Valid To Date must be greater than or equal to the Application Date.
		 *  </br>The Valid To Date must be greater than or equal to the Issue Date.
		 *  </br>The Valid To Date must be greater than or equal to the Valid From Date.
		 *  </br>The Valid To Date must be less than or equal to the Latest Payment Date.
		 *  </br> Shows an error dialog in case of error
		 *  @method validateValidToDate
		 *  @return {boolean}
		 *   True if date is valid otherwise false
		 */
		validateValidToDate : function() {
			//  summary:
		    //       Validates the Valid To date.(Used in License(LS))

			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Valid To Date, Value", 
					this.get("value"));
			
			
			var days = validateBusinessDate(this);
			if(days < 0)
			{
				this.invalidMessage = m.getLocalization("validToDateLessThanTodayDateError",
						[_localizeDisplayDate(this)]);
				return false;
			}	
			
			// Test that the Valid To date is greater than the application date
			if(dj.byId("appl_date")) 
			{
				var applDate = dj.byId("appl_date");
				if(!m.compareDateFields(applDate, this)) {
					this.invalidMessage = m.getLocalization("validToDateLessThanAppDateError",
							[_localizeDisplayDate(this),
							 _localizeDisplayDate(applDate)]);
					return false;
				}
			}
			if(dj.byId("iss_date") && dj.byId("iss_date").get("value")!= null)
			{
				var issDate = dj.byId("iss_date");
				if(!m.compareDateFields(issDate, this)) {
					this.invalidMessage = m.getLocalization("validToDateLessThanIssDateError",
							[_localizeDisplayDate(this),
				             _localizeDisplayDate(issDate)]);
					return false;
				}
			}
			if(dj.byId("valid_from_date") && dj.byId("valid_from_date").get("value")!==null)
			{
				var validFromDate = dj.byId("valid_from_date");
				if(!m.compareDateFields(validFromDate, this)) {
					this.invalidMessage = m.getLocalization("validToDateLessThanValidFromDateError",
							[_localizeDisplayDate(this),
				             _localizeDisplayDate(validFromDate)]);
					return false;
				}
			}
			if(dj.byId("latest_payment_date") && dj.byId("latest_payment_date").get("value")!==null)
			{
				var latestPaymentDate = dj.byId("latest_payment_date");
				if(!m.compareDateFields(this, latestPaymentDate)) {
					this.invalidMessage = m.getLocalization("validToDateGreaterThanLatestPaymntDateError",
							[_localizeDisplayDate(this),
				             _localizeDisplayDate(latestPaymentDate)]);
					return false;
				}
			}
			return true;
		},
		/**
		 * Summary:
		 * Validates the Latest Payment date.(Used in License(LS))
		 * <h4>Description:</h4> 
		 * It checks for the following scenarios  
		 * </br>The Latest Payment Date  must be greater than or equal to the Application Date.
		 * </br>The Latest Payment Date must be greater than or equal to the Issue Date.
		 * </br>The Latest Payment Date must be greater than or equal to the Valid From Date.
		 * </br>The Latest Payment Date must be greater than or equal to the Valid To Date.
		 * @method validateLatestPaymentDate
		 */
		validateLatestPaymentDate : function() {
			//  summary:
		    //       Validates the Latest Payment date.(Used in License(LS))

			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Latest Payment Date, Value", 
					this.get("value"));
			
			// Test that the Latest Payment date is greater than the application date
			if(dj.byId("appl_date")) 
			{

				var applDate = dj.byId("appl_date");
				if(!m.compareDateFields(applDate, this)) {
					this.invalidMessage = m.getLocalization("latestPaymentDateLessThanAppDateError",
							[_localizeDisplayDate(this),
							 _localizeDisplayDate(applDate)]);
					return false;
				}
			}
			if(dj.byId("iss_date") && dj.byId("iss_date").get("value")!==null){
			var issDate = dj.byId("iss_date");
			if(!m.compareDateFields(issDate, this)) {
				this.invalidMessage = m.getLocalization("latestPaymentDateLessThanIssDateError",
						[_localizeDisplayDate(this),
			             _localizeDisplayDate(issDate)]);
				return false;
			}
			}
			if(dj.byId("valid_from_date") && dj.byId("valid_from_date").get("value")!==null){
				var validFromDate = dj.byId("valid_from_date");
				if(!m.compareDateFields(validFromDate, this)) {
					this.invalidMessage = m.getLocalization("latestPaymentDateLessThanValidFromDateError",
							[_localizeDisplayDate(this),
				             _localizeDisplayDate(validFromDate)]);
					return false;
				}
				}
			if(dj.byId("valid_to_date") && dj.byId("valid_to_date").get("value")!==null){
				var validToDate = dj.byId("valid_to_date");
				if(!m.compareDateFields(validToDate, this)) {
					this.invalidMessage = m.getLocalization("latestPaymentDateLessThanValidToDateError",
							[_localizeDisplayDate(this),
				             _localizeDisplayDate(validToDate)]);
					return false;
				}
				}
			return true;
		},
		
		/**
		 * Summary:
		 * Validates the Registration date.(Used in License(LS))
		 * <h4>Description:</h4> 
		 * It checks for the following scenarios  
		 * </br>The Registration Date  must be less than or equal to the Issue Date.
		 * @method validateRegDate
		 */
		validateRegDate : function() {
			//  summary:
		    //       Validates the Registration date.(Used in License(LS))

			if(!this.get("value")){
				return true;
			}
			
			console.debug("[misys.validation.common] Validating Registration Date, Value", 
					this.get("value"));
			
			// Test that the Issue date is greater than the Registration date
			if(dj.byId("iss_date")) 
			{
				var issDate = dj.byId("iss_date");
				if(!m.compareDateFields(this, issDate)) {
					this.invalidMessage = m.getLocalization("regDateGreaterThanIssDateError",
							[_localizeDisplayDate(this),
							 _localizeDisplayDate(issDate)]);
					return false;
				}
			}

			var days = validateBusinessDate(this);
			if(days > 0)
			{
				this.invalidMessage = m.getLocalization("RegistrationDateGreaterThanApplicationDateError",
						[_localizeDisplayDate(this)]);
				return false;
			}
			return true;
		},
		
		/**
		 * Summary:
		 * Validate the license settlement date
		 * <h4>Description:</h4> 
		 * License Settlement Amount cannot be greater than the License Amount.
		 * @method validateLicenseSettlementAmt
		 * @return {boolean}
		 *  True if Amount is valid other wise false
		 */
		validateLicenseSettlementAmt : function() {
			if(dj.byId("ls_amt"))
			{
				var lsAmt = d.number.parse(dj.byId("ls_amt").get("value"));
				var lsSettlementAmt = d.number.parse(dj.byId("ls_settlement_amt").get("value"));
				lsAmt = !isNaN(lsAmt) ? lsAmt : 0;
				lsSettlementAmt = !isNaN(lsSettlementAmt) ? lsSettlementAmt : 0;
				if(lsSettlementAmt > lsAmt)
				{
					console.debug("License Settlement Amount cannot be greater than the License Amount.");
					m.showTooltip(m.getLocalization("lsSettlementAmtGreaterThanLSAmtError", [lsSettlementAmt, lsAmt]),
							this.domNode, ["after"]);
					this.state = "Error";
					this._setStateClass();
					dj.setWaiState(this.focusNode, "invalid", "true");
					return false;
				}
			}
			return true;
		},
		/**
		 * Summary:
		 * Validates the license settelment amount 
		 * <h4>Description:</h4> 
		 * Additional Settlement Amount cannot be greater than the Additional License Amount.
		 * @method validateAddLicenseSettlementAmt
		 * @return {boolean}
		 *  True if amount is valid otherwise false
		 */
		validateAddLicenseSettlementAmt : function() {
			if(dj.byId("additional_amt"))
			{
				var additionalAmt = d.number.parse(dj.byId("additional_amt").get("value"));
				var additionalSettlementAmt = d.number.parse(dj.byId("add_settlement_amt").get("value"));
				additionalAmt = !isNaN(additionalAmt) ? additionalAmt : 0;
				additionalSettlementAmt = !isNaN(additionalSettlementAmt) ? additionalSettlementAmt : 0;
				if(additionalSettlementAmt > additionalAmt)
				{
					console.debug("Additional Settlement Amount cannot be greater than the Additional License Amount.");
					m.showTooltip(m.getLocalization("addSettlementAmtGreaterThanAddAmtError", [additionalSettlementAmt, additionalAmt]),
							this.domNode, ["after"]);
					this.state = "Error";
					this._setStateClass();
					dj.setWaiState(this.focusNode, "invalid", "true");
					return false;
				}
			}
			return true;
		},
		/**
		 * Summary: 
		 * Validates the renewal calendar date. Checks
		 * for the expiry date if it is not there show an error
		 * message. Also date selected should be greater than
		 * the system date and less than the expiry date.
		 * 
		 * @method validateRenewalCalendarDate
		 */
		validateRenewalCalendarDate: function() {
			var renewalCalDate = dj.byId("renewal_calendar_date") ?dj.byId("renewal_calendar_date").get("value"):"";
			var renewalOn = dj.byId("renew_on_code")?dj.byId("renew_on_code").get("value"):"";
			var currentDate= new Date();
			var isValidRenewalCalendarDate= true;
			if(renewalOn != null && renewalOn === "02") {
				var expDateObj = dj.byId("exp_date").get("value");
				var orgExpDate = dj.byId("org_exp_date");
				if(!expDateObj && orgExpDate)
				{
					expDateObj = dojo.date.locale.parse(orgExpDate.get("value"),{locale:dojo.config.locale, formatLength:"short", selector:"date" });
				}
				if(expDateObj == null || expDateObj === "") {
					isValidRenewalCalendarDate = false;
					this.invalidMessage = m.getLocalization("expiryDateReqd");
				}
				if(renewalCalDate != null && expDateObj != null && ((renewalCalDate <= currentDate) || (renewalCalDate > expDateObj))) {
					isValidRenewalCalendarDate=false;
					var localizedCurrentDate = dojo.date.locale.format(currentDate, {selector:"date", formatLength:"short", locale:dojo.config.locale});
					var localizedExpiryDate = dojo.date.locale.format(expDateObj, {selector:"date", formatLength:"short", locale:dojo.config.locale});
					this.invalidMessage = m.getLocalization("calendarDateLessThanSystemDate", [localizedCurrentDate,localizedExpiryDate]);
				}
			}
			return isValidRenewalCalendarDate;
		},
		/**
		 * Summary: 
		 * Validates the renewal calendar date. Checks
		 * for the expiry date if it is not there show an error
		 * message. Also date selected should be greater than
		 * the system date and less than the expiry date.
		 * 
		 * @method validateAmendBGRenewalCalendarDate
		 */
		validateAmendBGRenewalCalendarDate: function() {
			var renewalCalDate = dj.byId("renewal_calendar_date") ?dj.byId("renewal_calendar_date").get("value"):"";
			var renewalOn = dj.byId("renew_on_code")?dj.byId("renew_on_code").get("value"):"";
			var currentDate = new Date();
			if(renewalOn != null && renewalOn === "02") {
				var expDateObj = dj.byId("exp_date").get("value");
				var orgExpDate = dj.byId("org_exp_date");
				var that = this;
				if(!expDateObj && orgExpDate)
				{
					expDateObj = dojo.date.locale.parse(orgExpDate.get("value"),{locale:dojo.config.locale, formatLength:"short", selector:"date" });
				}
				if(expDateObj == null || expDateObj === "") {
					m.dialog.show("ERROR", m.getLocalization("expiryDateReqd"), "", function(){
						that.focus();
					});
					this.reset();
				}
				if(renewalCalDate != null && expDateObj != null && ((renewalCalDate <= currentDate) || (renewalCalDate > expDateObj))) {
					var localizedCurrentDate = dojo.date.locale.format(currentDate, {selector:"date", formatLength:"short", locale:dojo.config.locale});
					var localizedExpiryDate = dojo.date.locale.format(expDateObj, {selector:"date", formatLength:"short", locale:dojo.config.locale});
					m.dialog.show("ERROR", m.getLocalization("calendarDateLessThanSystemDate", [localizedCurrentDate,localizedExpiryDate]), "", function(){
						that.focus();
					});
					this.reset();
				}
			}
		},
		/**
		 * Summary:
		 * Validates the data entered as the Transport document date.
		 * Transport document date should be less than the application date.
		 * @method validateTransportDocumentDate
		 * @return {boolean}
		 *  True if Date is valid otherwise false
		 */
		 validateTransportDocumentDate : function() {
			// summary:
			// Validates the data entered as the Transport
			// Document Date.
			//
			 if(!this.get("value")) {
					return true;
				}
			console.debug("[misys.validation.common] Validating Transport Document Date. Value = ",
								this.get("value"));

				// Test that the Transport Document date is greater
				// than or equal to
				// the application date
				var applDate = dj.byId("appl_date");
				if (d.date.compare(this.get("value"), m.localizeDate(applDate)) >= 0)
				{
					this.invalidMessage = m.getLocalization(
							"TransDocDateGreaterThanApplDateError", [
									_localizeDisplayDate(this),
									_localizeDisplayDate(applDate) ]);
					return false;
				}
				return true;
			},
			/**
			 * Summary:
			 * Validates the Future date
			 * Shows an error message if Furture date is less than issue date or application date.
			 * @method validateFutureDate
			 */
			validateFutureDate : function()
			{

				if(!this.get("value")) {
					return true;
				}
				// Test that the expiry date is greater than or
				// equal to the issue date
				var issueDate = dj.byId("iss_date");
				if ((issueDate && issueDate.get("value")) && (d.date.compare(this.get("value"), m.localizeDate(issueDate)) <= 0))
				{
						this.invalidMessage = m.getLocalization(
								"issDateSmallerThanFutureDate", [
										_localizeDisplayDate(this),
										_localizeDisplayDate(issueDate) ]);
						return false;
				}

				// Test that the expiry date is greater than the
				// application date
				var applDate = dj.byId("appl_date");
				if ((applDate && applDate.get('value')) && (d.date.compare(this.get("value"), m.localizeDate(applDate)) <= 0))
				{
						this.invalidMessage = m.getLocalization(
								"futureDateSmallerThanAppDate", [
										_localizeDisplayDate(this),
										_localizeDisplayDate(applDate) ]);
						return false;
				}
				return true;
			},
			/**
			 * Summary: Validates the transaction amount. It should
			 * not be greater than the guarantee amount and should
			 * not be equal to zero. <h4>Description:</h4>  Must be applied to
			 * an input field of dojoType.Shows an error message in case of error.
			 * dijit.form.CurrencyTextBox.
			 * @method validateTnxAmount
			 * @return {boolean}
			 *  True if transaction amount is valid otherwise false
			 */
			validateTnxAmount : function()
			{
				//  summary:
			    //       Validates the transaction amount. It should not be greater than the guarantee amount and should not be equal to zero.
				//		 Must be applied to an input field of 
				//       dojoType dijit.form.CurrencyTextBox.
				
				var tnxAmt = dj.byId("tnx_amt");
				var claimAmt = dj.byId("claim_amt");
				var tnxAmtValue = dojo.number.parse(dj.byId("tnx_amt").get("value"));
				var amtValue;
				if(dj.byId("lc_amt"))
				{
					amtValue = dojo.number.parse(dj.byId("lc_amt").get("value"));
					console.debug("SI Amount, Value = ", amtValue);
				}
				else if(dj.byId("bg_amt"))
				{
					amtValue = dojo.number.parse(dj.byId("bg_amt").get("value"));
					console.debug("BG Amount, Value = ", amtValue);
				}
				console.debug("Tnx Amount, Value = ", tnxAmtValue);
				
				if(claimAmt)
				{
					var claimAmtValue = dojo.number.parse(claimAmt.get("value"));
					console.debug("Claim Amount, Value = ", claimAmtValue);
				}
				
				if(tnxAmtValue < 0)
				{
					tnxAmt.invalidMessage = m.getLocalization('totalamount');
					return false;
				}

				if(tnxAmt && amtValue && tnxAmtValue > amtValue)
				{
					tnxAmt.invalidMessage = misys.getLocalization('settlementAmtGreaterThanOrigTnxAmtError',[ tnxAmtValue.toFixed(2), amtValue.toFixed(2) ]);
					return false;
				}
				else if(tnxAmt && claimAmt && tnxAmtValue > claimAmtValue)
				{
					tnxAmt.invalidMessage = misys.getLocalization('tnxAmtGreaterThanClaimAmtError',[ tnxAmtValue.toFixed(2), claimAmtValue.toFixed(2) ]);
					return false;
				}
				else if(tnxAmt && tnxAmtValue === 0)
				{
					tnxAmt.invalidMessage = misys.getLocalization('tnxAmtZeroError');
					return false;
				}
				return true;
			},
			
			/**
			 * Summary:
			 * Validates the Finance requested amount
			 * Shows an error message if Finance requested amount is greateer than the intent to pay amount or total net amount.
			 * @method validateFutureDate
			 */
			validateFinanceAmt : function()
			{
				var intentToPayAmt,totalNetAmt;
				var isValid = true;
				
				if(this.get("value") <= 0)
				{
					isValid = false;
					this.invalidMessage = misys.getLocalization("financeRequestAmtError");
				}
				
				else if(dj.byId("intent_to_pay_amt"))
				{
					intentToPayAmt = Number(dj.byId("intent_to_pay_amt").get("value").replace(",",""));
									
					if(intentToPayAmt !="" && this.get("value") > intentToPayAmt)
					{
						isValid = false;
						this.invalidMessage = misys.getLocalization("financeRequestAmtErrorForIntentPayAmt");
					}
				}
				else if(dj.byId("total_net_amt"))
				{
					totalNetAmt =  dj.byId("total_net_amt").get("value");
					
					if(totalNetAmt !== "" && this.get("value") > totalNetAmt)
					{
						isValid = false;
						this.invalidMessage = misys.getLocalization("financeRequestAmtErrorForTotalAmt");
					}
				}
				return isValid;
			},
			/**
			 * Summary:
			 * Validates the value of Parity field while modifying a Rate.
			 * <h4>Description:</h4> 
			 * If the value of parity field is lesser and equal to zero show an error message.
			 * @method validateParity
			 * @return {Boolean} isValid
			 *  Ture if Parity field is valid otherwise false
			 */
			validateParity : function(){
 	           //summary: Validates the value of Parity field while modifying a Rate.
                var parityVal = this.get("value");
                var isValid=true;
				if((parityVal === 0) || (parityVal < 0))
                {
					this.invalidMessage =m.getLocalization("parityError");
				    isValid=false;
				}
				return isValid;
			},
			/**
			 * Summary:
			 * Function used to validate the remarks.
			 * It internally calls function _validateChar to validate the remarks for examples(input_split_remarks)
			 * @method validateRemarks
			 */
			validateRemarks : function() {
				//	summary:
			    //		Function used to validate the remarks.
				console.debug("[Validate] Validating Remarks, Value = " + this.get('value'));
				if(!_validateChar(this, " 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ#$^*_=`~{}|:./[]-")){
					var message = m.getLocalization("illegalRemarksCharError", [ this.get('value') ]);
					// TODO:This fix was introduced to replace < characters with &lt; as they were being replaced with a DIV's
					// in subsequent processing.
					// This cased the remarks tool top to only display as far as the first < character.
					// This fix should most likely be removed one a reason is determined for why in some
					// cases the < is interpreted as a div
					message = message.replace(/>/g, "&gt;");
					message = message.replace(/</g, "&lt;");
					this.invalidMessage= message;
					return false;
				}
				return true;
			},
			/**
			 * <h4>Summary:</h4>
			 * Validates the data entered as the amendment Date.
			 * It shows an error message if loan amendment date is lesser than the Loan effective date
			 * It shows an error message if loan amendment date is greater than the Loan maturity date.
			 * It shows an error message if loan amendment date is greater than the Facility Expiry date.
			 * @method validateLoanIncreaseDate
			 */
			validateLoanIncreaseDate:function(){
			    //  tags:
			    //         public, validation
				
			
				
				// This validation is for non-required fields
				if(this.get('value') == null){
					return true;
				}

				console.debug('[Validate] Validating Loan Amendment Date. Value = ' + this.get('value'));
				var thisObject  = dj.byId(this.id);
				//Current date validation
				// Test that the amendment date is less than  the current system date
				var currentDate = new Date();
				// set the hours to 0 to compare the date values
				currentDate.setHours(0, 0, 0, 0);
				
				// compare the values of the current date and transfer date
				var isValid = d.date.compare(m.localizeDate(this), currentDate) < 0 ? false : true;
				if(!isValid)
				{
					 this.invalidMessage = m.getLocalization("loanEffectiveIncreaseDateLessThanCurrentDate", [_localizeDisplayDate(this)]);
					 return false;
				}
				
				// Test that the amendment date is greater than the loan effective date
				var thisObjLocalized = m.localizeDate(thisObject);
				var effLoanDate = dj.byId('effective_date');
				if(effLoanDate){
					var effLoanDateLocalized = m.localizeDate(effLoanDate);
					if(d.date.compare(effLoanDateLocalized, thisObjLocalized) > 0){
						this.invalidMessage = m.getLocalization('loanAmendDateLesserThanLoanEffectiveDateError', [
									_localizeDisplayDate(this),
									_localizeDisplayDate(effLoanDate)]);
						return false;
					}
				}
				
				// Test that the loan effective date is greater than repricing date
				thisObjLocalized = m.localizeDate(thisObject);
				var flag = dj.byId('sub_product_code');
				var subProductcodeforSwing="SWG";
				if(flag.get("value") === subProductcodeforSwing){
				var effectLoanDate = dj.byId('repricing_date');
					if(effectLoanDate){
						var effectLoanDateLocalized = m.localizeDate(effectLoanDate);
						if(d.date.compare(effectLoanDateLocalized, thisObjLocalized) <= 0){
							this.invalidMessage = m.getLocalization('loanAmendDateLesserThanRepricingDateError', [
										_localizeDisplayDate(this),
										_localizeDisplayDate(effectLoanDate)]);
							return false;
						}
					}
				}
								
				// Test that the amendment date is less than or equal to the maturity date
				var lnMatDate = dj.byId('ln_maturity_date');
				
				if(lnMatDate && lnMatDate.get('value') !== ""){
					var lnMatDateLocalized = m.localizeDate(lnMatDate);
					if(d.date.compare(lnMatDateLocalized, thisObjLocalized) <= 0){
						this.invalidMessage = m.getLocalization('loanAmendDateGreaterThanLoanMatDateError', [
									_localizeDisplayDate(this),
									_localizeDisplayDate(lnMatDate)]);
						return false;
					}
				}
				
				// Test that the amendment date is less than or equal to the facility expiry date
				var facExpDate = dijit.byId('facility_expiry_date');
				if(facExpDate){
					var facExpDateLocalized = m.localizeDate(facExpDate);
					if(d.date.compare(facExpDateLocalized, thisObjLocalized) < 0){
						this.invalidMessage = m.getLocalization('loanAmendDateGreaterThanFacExpDateError', [
									_localizeDisplayDate(this),
									_localizeDisplayDate(facExpDate)]);
						return false;
					}
				}
				
				var applDate = dj.byId('appl_date');
				if(applDate){
					var applDateLocalized = m.localizeDate(applDate);
					if(d.date.compare(applDateLocalized, thisObjLocalized) > 0){
						this.invalidMessage = m.getLocalization('loanAmendDateLesserThanLoanApplDateError', [
									_localizeDisplayDate(this),
									_localizeDisplayDate(applDate)]);
						return false;
					}
				}
					
				return true;
			},
			/**
			 * Summary:
			 * Validates the BIC code for BPO.In this we have defined a regular expression defined.We check our BIC code against this.
			 * If it doesn't pass the test.It displays an error message telling that it is invalid BIC.
			 * @param {Object} id
			 *  Id of the bic code
			 * @method validateBpoBICFormat
			 */
			validateBpoBICFormat : function(id) {
				//  summary:
			    //       Validates the BIC code.

				var bic = id.get("value"),
				regex = new RegExp(
						"^[A-Z0-9]{4,4}[A-Z]{2,2}[A-Z0-9][A-Z2-9]([A-Z0-9]{3,3}){0,1}$", "g");
			
				if(bic) {
					console.debug("[misys.validation.common] Validating BIC Format, Value", bic);
					if(!regex.test(bic)){
						var displayMessage = m.getLocalization("invalidBICError", [bic]);
						id.set("value","");
						id.set("state","Error");
						m.dialog.show("ERROR", m.getLocalization("focusOnErrorAlert"), "", function(){
							id.focus();
							dj.hideTooltip(id.domNode);
							dj.showTooltip(displayMessage,id.domNode, 0);
						});
					}
				}
			},
			
			
			/**
			 * Summary:
			 * Validates that the node date field is greater than current date, and greater than the dates in the array.
			 *  @param {String} node
			 * @param {Array of date nodes} dateNodes
			 * 
			 * @method compareDateIsGreater
			 */
			compareDateIsGreater : function(/* dijit._Widget || DomNode || String */node,/*Array of Nodes*/dateNodes)
			{
				
				var widget = dj.byId(node);
				var date1 = null;
				if(!(widget && widget.get("value"))) {
					return true;
				}else{
					date1 = widget.get("value");
				}
				var currentDate = new Date();
				// set the hours to 0 to compare the date values
				currentDate.setHours(0, 0, 0, 0);
				// Test that the date is greater than or
				// equal to current date.
				if(d.date.compare(m.localizeDate(widget), currentDate) < 0)
				{
					m._config.onSubmitErrorMsg = m.getLocalization(
							"expDateSmallerThanCurrentDate", [
									_localizeDisplayDate(widget)]);
					return false;
				
				}
				// Test that the date is greater than or
				// equal to all the dates in the array.
				for(var i = 0; i < dateNodes.length; i++){
					var toCompareWidget = dj.byId(dateNodes[i]);
					if ((toCompareWidget && toCompareWidget.get("value")) && (d.date.compare(date1, m.localizeDate(toCompareWidget)) <= 0))
					{
							m._config.onSubmitErrorMsg = m.getLocalization(
									"issDateSmallerThanFutureDate", [
											_localizeDisplayDate(widget),
											_localizeDisplayDate(toCompareWidget) ]);
							return false;
					}
				}
				return true;
			},
			
			validateDescriptionGoods : function() {
				//  summary:
			    //  Validates Description of Goods for Licence product.
				//  Will revert this later				
			
				var strInput = this.get("value"),
					isValid = true,
					that = this;
					
					
				if(strInput.length > 35){
					that.invalidMessage = m.getLocalization("invalidLSDescGoodsLength", 
								[that.get("displayedValue")]);
					
					/*m.dialog.show("ERROR", that.invalidMessage, '', function(){
						setTimeout(callback, 500);
					});*/
					isValid = false;
					return false;
						
				}
				return true;
			}, 
			
			/**
			 * <h4>Summary:</h4>
			 * Function to set the renewal amount code for SI and SR.
			 * @method setRenewalAmount
			 * @param renewAmtCode
			 *
			 */
			 setRenewalAmount : function(renewAmtCode){
				var renewAmtCodeVal = renewAmtCode.get("value");
				if(renewAmtCodeVal === "01"){				
					dj.byId("renew_amt_code_1").set("checked", true);
					dj.byId("renew_amt_code_1").set("value", "01");
				}else if(renewAmtCodeVal === "02"){
					dj.byId("renew_amt_code_2").set("checked",true);
					dj.byId("renew_amt_code_2").set("value", "02");
				}
			},
			
			
			
			/**
			 * <h4>Summary:</h4>
			 * Function to set the renewal amount code for SI and SR on form load.
			 * @method setRenewalAmountOnFormLoad
			 *
			 */
			setRenewalAmountOnFormLoad : function(){
				//Radio field template is reading values from all nodes in the input xml.
				// For ones with multiple transactions, (ex:  create, approve, amend, approve.) the tag values from the root node is not being picked, because of radio-value = //*name in form-templates.
				// To overcome this we are overriding "value" and "checked" params from js.
				if(dj.byId("renew_flag") && dj.byId("renew_flag").get("checked") === true)
				{
					var renewAmountCode = dj.byId("renew_amount_code") ? dj.byId("renew_amount_code").get("value") : "02";			
					if(renewAmountCode){
						if(renewAmountCode === "01") {				
							dj.byId("renew_amt_code_1").set("checked", true);
						}else if(renewAmountCode === "02"){
							dj.byId("renew_amt_code_2").set("checked", true);
						}
					}
				}
			},
			
			/**
			 * <h4>Summary:</h4>
			 * Function to validate whether the rolling renewal frequency is lesser than the renew period.
			 * If not, throws an error.
			 * 
			 * @param {DomNode} node
			 * @method validateRollingRenewalFrequency
			 *
			 */
			validateRollingRenewalFrequency : function(/* dijit._Widget || DomNode || String */node){
				var renewPeriod = dj.byId("renew_for_nb").get("value");
				var rollingRenewPeriod = dj.byId("rolling_renew_for_nb").get("value");
				if(renewPeriod !== "" && rollingRenewPeriod !== "" && rollingRenewPeriod > renewPeriod)
				{
					node.set("value","");
					dj.showTooltip(m.getLocalization("rollingFrequencyCannotBeMoreThanRenewalPeriodError"), node.domNode, 0);
					var hideTT = function() {
						dj.hideTooltip(node.domNode);
					};
					setTimeout(hideTT, 1500);
				}
			},
			
			/**
			 * <h4>Summary:</h4>
			 * Validate maturity with current date
			 * 
			 */
			validateEnteredGreaterThanCurrentDate : function() {
				var maturityDate = dj.byId("maturity_date");
				var currentDate = dj.byId("current_date");
				  if(currentDate && !m.compareDateFields(currentDate, maturityDate))
				  {
					  console.debug("[misys.binding.bank.report_el] Result of comparison = ", m.getLocalization("lessthanCurrentDate"));
				      m.dialog.show("ERROR", m.getLocalization("lessthanCurrentDate"));
				      maturityDate.set("value", " ");
				      return false;
				  }
				return true;
			
			},			
			
			/**
			 * <h4>Summary:</h4>
			 * This function checks if the field contains a decimal value if so display a specific error message.
			 * <h4>Description:</h4> 
			 * Value should be integer and it should be greater than zero.
			 * @param {DomNode} node
			 * @method validateRenewFor
			 */
			validateIntegerValue : function(/* dijit._Widget || DomNode || String */node) {
				//  summary:
			    //  test if the field contains a decimal value if so display a specific error message   

				console.debug("[misys.validation.common] Validate whether "+node.get("id")+" Value is an Integer or not.");

				// If renew contain value
				if(!isNaN(node.get("value")))
				{
					var nodeVal = node.get("value")+"";
					var hideTT = function() {
						dj.hideTooltip(node.domNode);
					};
					if(nodeVal.indexOf(".")!== -1)
					{
						dj.showTooltip(m.getLocalization("valueShouldBeInteger"), node.domNode, 0);
						setTimeout(hideTT, 1500);
						node.set("state","Error");
					}
					if(nodeVal <= 0) 
					{
						dj.showTooltip(m.getLocalization("valueShouldBeGreaterThanZero"), node.domNode, 0);
						setTimeout(hideTT, 1500);
						node.set("state","Error");
					}
				}				
			},
			
			 /**
			    * <h4>Summary:</h4>
			    * This function validates the Expiry date/Next Revolve Date
			    * 
			    * <h4>Description:</h4> 
			    * Next Revolve date should be lesser than the Expiry date,
			    * @method validateNextRevolveDate
			    * @return {boolean}
			    *  True if valid otherwise false.
			    */
			   validateNextRevolveDate : function() {
					//  summary:
				    //        Validates the data entered as the Next Revolve Date.
				    // 
				    // TODO Add business logic explanation here
				   
					// This validation is for non-required fields
					if(!this.get("value")) {
						return true;
					}

					console.debug("[misys.validation.common] Validating Next Revolve Date Date. Value = ",
							this.get("value"));
					
					var days = validateBusinessDate(this);
					if(days < 0)
					{
						console.debug("[misys.validation.common] Days difference between Next Revolve Date and current date = ", days);
						this.invalidMessage = m.getLocalization("nextRevolveDateSmallerThanSystemDate",[
						                                						         _localizeDisplayDate(this)
						                                               								]);
						return false;
					}		
					
					// Test that the expiry date is greater than or equal to the issue date 
					var issueDate = dj.byId("iss_date");
					if((issueDate) && (!m.compareDateFields(issueDate, this)))
					{
							this.invalidMessage = m.getLocalization("nextRevolveDateLessThenIssDateError",[_localizeDisplayDate(this),
											_localizeDisplayDate(issueDate)]);
							return false;
					}
					var expDate = dj.byId("exp_date");
					var orgExpDate = dj.byId("org_exp_date");
					if(expDate && !m.compareDateFields(this, expDate)) 
					{
						this.invalidMessage = m.getLocalization("nextRevolveDateGreaterThanExpiryDateError", [
										_localizeDisplayDate(this),
										_localizeDisplayDate(expDate)]);
						return false;
					}
					else if(expDate.get("value")==null && orgExpDate && !m.compareDateFields(this, orgExpDate) )
					{
						this.invalidMessage = m.getLocalization("nextRevolveDateGreaterThanExpiryDateError", [
										_localizeDisplayDate(this),
										_localizeDisplayDate(orgExpDate)]);
						return false;
					}
					return true;
					
			   },
			
			
			/**
			 * <h4>Summary:</h4>
			 * Function to validate whether the last match date is less than the max BPO expiry date.
			 * If not, throws an error.
			 * 
			 * @method validateOpenAccountLastMatchDate
			 *
			 */
			validateOpenAccountLastMatchDate : function () {
				console.debug("[misys.validation.common] Validating Last Match Date, Value", 
						this.get("value"));
				var lastMatchDate = dj.byId("last_match_date");
				var maxBpoExpiryDate = m.getMaxBPOExpiryDate();
				if(lastMatchDate  && lastMatchDate.get("value") != null && maxBpoExpiryDate !== "") {
					if(d.date.compare(lastMatchDate.get("value"), maxBpoExpiryDate) > 0 ) {
						this.invalidMessage = m.getLocalization("lastMatchDateGreaterThanBpoExpiryDateError",[
                                  _localizeDisplayDate(this),
                                  dojo.date.locale.format(maxBpoExpiryDate,{locale:dojo.config.locale, formatLength:"short", selector:"date" })]);
						return false;
					}	
				}
				
				var expDate = dj.byId("exp_date");
				if(lastMatchDate && lastMatchDate.get("value") != null && expDate &&  expDate.get("value") != null) {
					if(d.date.compare(lastMatchDate.get("value"), expDate.get("value")) > 0 ) {
						this.invalidMessage = m.getLocalization("lastMatchDateGreaterThanExpiryDateError",[
                                  _localizeDisplayDate(this),
                                  _localizeDisplayDate(expDate)]);
						return false;
					}	
				}
				
				var issDate = dj.byId("iss_date");
				if(lastMatchDate && lastMatchDate.get("value") != null && issDate &&  issDate.get("value") != null) {
					if(d.date.compare(lastMatchDate.get("value"), issDate.get("value")) < 0 ) {
						this.invalidMessage = m.getLocalization("lastMatchDateLessThanIssueDateError",[
                                  _localizeDisplayDate(this),
                                  _localizeDisplayDate(issDate)]);
						return false;
					}	
				}
				
				var applDate = dj.byId("appl_date");
				if(lastMatchDate && lastMatchDate.get("value") != null && applDate &&  applDate.get("value") != null) {
					if(d.date.compare(lastMatchDate.get("value"), applDate.get("value")) < 0 ) {
						this.invalidMessage = m.getLocalization("lastMatchDateLessThanApplicationDateError",[
                                  _localizeDisplayDate(this),
                                  _localizeDisplayDate(applDate)]);
						return false;
					}	
				}
				
				
				
				return true;
			},
			
			/**
			 * <h4>Summary:</h4>
			 * Function to validate whether the contract percentage is within 12 digit number, 
			 * including decimal precision.
			 * 
			 * @method checkContractPercent
			 * 
			 */
			checkContractPercent : function() {
				if(!this.get("value")) {
					return true;
				}
				var percent = this.get("value");
				var index = percent.toString().indexOf(".");
				var length = percent.toString().length;
				console.debug("Validating Contract percent Value = ", this.get("value"));
				if(percent<=100 && percent >= 0)
				{
					if (index === -1 && length > 12) {
						this.invalidMessage = m.getLocalization("contractPercentMoreThan12DigitError");
						return false;
					}else if(percent.toString().indexOf(".") >= 0){
						var countDecimalPlaces = (length - index -1);
						if(countDecimalPlaces > 2){
							this.invalidMessage = m.getLocalization("contractPercentMoreThan2DecilamError");
							return false;
						}
					}
					return true;
				}
				else
				{
					this.invalidMessage = m.getLocalization("contractPercentMoreThan100Error");
					return false;
				}				
			},
			
			/**
			 * Summary:
			 * This method validates the earliest ship date
			 * @method validateEarliestShipDate
			 * <h4>Description:</h4> 
			 * </br>Earliest shipment date should be greater than the application date
			 * </br>Earliest shipment date should be greater than the issue date
			 * </br>Earliest shipment date should be less than the expiry date
			 * </br>Earliest shipment date should be less than the Amend date 
			 * </br>Earliest shipment date should be less than the latest shipment date
			 * @method validateEarliestShipDate
			 * @return {booelan} 
			 *  True if valid otherwise false.
			 */
			validateEarliestShipDate : function() {

				//Do not validate for close event
				if((dj.byId("tnxtype") && (dj.byId("tnxtype").get("value") === "38")) || 
				    	(dj.byId("close_tnx") && (dj.byId("close_tnx").get("checked") === true)))
				{
					  return true;
				}
				
				if(!this.get("value")) {
					return true;
				}
				// Test that the Earliest Ship Date is greater than or
				// equal to the issue date
				var issueDate = dj.byId("iss_date");
				if ((issueDate && issueDate.get("value")) && (d.date.compare(this.get("value"), m.localizeDate(issueDate)) < 0))
				{
						this.invalidMessage = m.getLocalization(
								"issDateSmallerThanEarliestShipDate", [
										_localizeDisplayDate(this),
										_localizeDisplayDate(issueDate) ]);
						return false;
				}

				// Test that the Earliest Ship Date is greater than the
				// application date
				var applDate = dj.byId("appl_date");
				if ((applDate) && (d.date.compare(this.get("value"), m.localizeDate(applDate)) < 0))
				{
						this.invalidMessage = m.getLocalization(
								"earliestShipDateSmallerThanAppDate", [
										_localizeDisplayDate(this),
										_localizeDisplayDate(applDate) ]);
						return false;
				}
				
				// Test that the early shipment date is less than or equal to the 
				// max BPO expiry date, if present
				// Else test that the last shipment date is less than or equal to the 
				// expiry date.
				var expDate = dj.byId("exp_date");
				
					var maxBpoExpiryDate = m.getMaxBPOExpiryDate();
					if(this.get("value") !== "" && maxBpoExpiryDate && maxBpoExpiryDate !== "") {
						if(d.date.compare(this.get("value"), maxBpoExpiryDate) > 0 ) {
							this.invalidMessage = m.getLocalization("BPOexpiryDateLessThanEarliestShipmentError",[
		                                _localizeDisplayDate(this),
		                                dojo.date.locale.format(maxBpoExpiryDate,{locale:dojo.config.locale, formatLength:"short", selector:"date" })]);
							return false;
						}	
					}
				
				if(expDate && !m.compareDateFields(this, expDate)) {
					this.invalidMessage = m.getLocalization("expiryDateLessThanEarliestShipmentError",[
					                _localizeDisplayDate(this),
									_localizeDisplayDate(expDate)]);
					return false;
				}
				
				// Test that the Earliest Ship Date is less than the
				// last ship date
				var lastShipDate = dj.byId("last_ship_date");
				if ((lastShipDate && lastShipDate.get("value") != null) && (d.date.compare(this.get("value"), m.localizeDate(lastShipDate)) > 0))
				{
						this.invalidMessage = m.getLocalization(
								"earliestShipDateSmallerThanLastShipDate", [
										_localizeDisplayDate(this),
										_localizeDisplayDate(lastShipDate) ]);
						return false;
				}
				
				// Test that the Earliest Ship Date is less than the
				// line item latest ship date
				var lineItemLastShipDate = dj.byId("line_item_last_ship_date");
				if ((lineItemLastShipDate && lineItemLastShipDate.get("value") != null) && (d.date.compare(this.get("value"), m.localizeDate(lineItemLastShipDate)) > 0))
				{
						this.invalidMessage = m.getLocalization(
								"earliestShipDateSmallerThanLastShipDate", [
										_localizeDisplayDate(this),
										_localizeDisplayDate(lineItemLastShipDate) ]);
						return false;
				}
				
				// Test that the line item shipment sub schedule Earliest ship date is greater than the
				// line item shipment sub schedule latest Ship Date
				var scheduleLatestShipDate = dj.byId("schedule_latest_ship_date");
				var schedule = dj.byId("line_item_shipment_schedules");
				if(schedule && schedule.store && schedule.store._arrayOfTopLevelItems.length > 0 && scheduleLatestShipDate && scheduleLatestShipDate.get("value") != null) 
				{
					if (d.date.compare(this.get("value"), m.localizeDate(scheduleLatestShipDate)) > 0)
					{
						this.invalidMessage = m.getLocalization(
								"earliestShipDateSmallerThanLastShipDate", [
										_localizeDisplayDate(this),
										_localizeDisplayDate(scheduleLatestShipDate) ]);
						return false;
					}
				}
				return true;
			
			},

			validateGroupCode : function() {
				var regex = reg_exp_validationCode.value,
				groupCodeValue = dj.byId("group_code").get("value"),
				regexValue = new RegExp(regex);
				if(groupCodeValue) 
				{
					console.debug("[misys.validation.common] Validating Group Code Format, Value", groupCodeValue);
					if(!regexValue.test(groupCodeValue))
					{
						dj.byId('group_code').set("state", "Error");
						misys.dialog.show("ERROR", misys.getLocalization("validateCode"));
						return false;
					}
				}
				return true;
			},
			
			 validateDescription : function() {
				var regex = reg_exp_validationDesc.value,
				groupDescValue = dj.byId("description").get("value"),
				regexValue = new RegExp(regex);
				if(groupDescValue) 
				{
					console.debug("[misys.validation.common] Validating description Format, Value", groupDescValue);
					if(!regexValue.test(groupDescValue))
					{
						dj.byId('description').set("state", "Error");
						misys.dialog.show("ERROR", misys.getLocalization("validateDesc"));
						return false;
					}
				}
				return true;
				
			},
			
			validateLCAvailablelAmount : function(amtId) {
				if(amtId)
				{
					var amt = amtId.get("value");
					var displayMessage,widget;
					if ((amt < 0) || (amt === undefined)) {
						displayMessage = m.getLocalization("invalidMessage");
						amtId.set("state","Error");
				 		dj.hideTooltip(amtId.domNode);
				 		dj.showTooltip(displayMessage, amtId.domNode, 0);
				 		amtId.focus();
						return false;
					} 
					else
					{
						return true;
					}
				}
				return true;
			},
			
			
			 validateSubGroupCode : function() {
				var regex = reg_exp_validationCode.value,
				subGroupCodeValue = dj.byId("sub_group_code").get("value"),
				regexValue = new RegExp(regex);
				if(subGroupCodeValue) 
				{
					console.debug("[misys.validation.common] Validating Sub Group Code Format, Value", subGroupCodeValue);
					if(!regexValue.test(subGroupCodeValue))
					{
						dj.byId('sub_group_code').set("state", "Error");
						misys.dialog.show("ERROR", misys.getLocalization("validateCode"));
						return false;
					}
				}
				return true;
			},
			validateHighTargetBalances: function()
			{
				//Fork Balance
				if(dj.byId("subGrpType").get("value") && dj.byId("subGrpType").get("value")==="1" )
				{
				if(dj.byId("high_target") && dj.byId("low_target")) {					
					var hightgtAmt = dj.byId("high_target").get("value");
					var lowtgtAmt = dj.byId("low_target").get("value");
					if(hightgtAmt < lowtgtAmt ) {
					   var 	errorMessage =  misys.getLocalization("hightargetLesserThanhighTargetError");
						dj.byId("high_target").set("state","Error");
					    dj.hideTooltip(dj.byId("high_target").domNode);
					    dj.showTooltip(errorMessage, dj.byId("high_target").domNode, 0);
					    return false;
					}
					}	
				}
				return true;
			},
			
			validateLowTargetBalances: function()
			{
				//Fork Balance
				if(dj.byId("subGrpType").get("value") && dj.byId("subGrpType").get("value")==="1" )
				{
				if(dj.byId("high_target") && dj.byId("low_target")) {					
					var hightgtAmt = dj.byId("high_target").get("value");
					var lowtgtAmt = dj.byId("low_target").get("value");
					if(lowtgtAmt > hightgtAmt ) {
					   var 	errorMessage =  misys.getLocalization("lowtargetGreaterThanhighTargetError");
						dj.byId("low_target").set("state","Error");
					    dj.hideTooltip(dj.byId("low_target").domNode);
					    dj.showTooltip(errorMessage, dj.byId("low_target").domNode, 0);
					    return false;
					}
					}	
				}
				return true;
			},
			
			 validateSubGrpDescription : function() {
				var regex = reg_exp_validationDesc.value,
				subGroupDescValue = dj.byId("subgrp_description").get("value"),
				regexValue = new RegExp(regex);
				if(subGroupDescValue) 
				{
					console.debug("[misys.validation.common] Validating description Format, Value", subGroupDescValue);
					if(!regexValue.test(subGroupDescValue))
					{
						dj.byId('subgrp_description').set("state", "Error");
						misys.dialog.show("ERROR", misys.getLocalization("validateDesc"));
						return false;
					}
				}
				return true;
			},
			
			/**
			 * <h4>Summary:</h4>
			 * This function is to validate the upload template already exist in DataBase
			 * <h4>Description:</h4> 
			 * Have an AJAX call inside it
			 * @method checkUploadTemplateNameExists
			 * 
			 */
			checkUploadTemplateNameExists : function()
			{
					var name, prodCode,subProdCode,uploadTemplateId;
					var isValid = false;
					if(dj.byId("name"))
					{
						name = dj.byId("name").get("value");
					}
					if(dj.byId("product_code"))
					{
						prodCode = dj.byId("product_code").get("value");
					}
					if(dj.byId("sub_product_code"))
					{
						subProdCode = dj.byId("sub_product_code").get("value");
					}
					if(dj.byId("upload_template_id"))
					{
						uploadTemplateId = dj.byId("upload_template_id").get("value");
					}
					
					
					
					if(name !== "") {
				
						m.xhrPost( {
							url : m.getServletURL("/screen/AjaxScreen/action/CheckFileUploadTemplateAction"),
							handleAs 	: "json",
							sync 		: true,
							content : {
								name : name,	
								productCode : prodCode,
								subProdCode : subProdCode,
								uploadTemplateId: uploadTemplateId
							},
							load : function(response, args){
								isValid = response.items.valid;
							}
						});
					}
					return isValid;
			},
			
			checkNumericOnlyValue: function(){
				var value = this.get("value");
					if(value !== "") 
					{
						console.debug("[misys.validation.common] Validating , Value", value);
						if(value.match(/^[0-9]+$/) === null)
						{
							this.invalidMessage = misys.getLocalization('valueShouldBeInteger');
							this.set("state", "Error");
							dj.hideTooltip(this.domNode);
							dj.showTooltip(misys.getLocalization('valueShouldBeInteger'), this.domNode, 0);
							return false;
						}
					}
					return true;
			},
			
			/**
			 * This function checks if the Period Presentation Days field contains a decimal value
			 * if so display a specific error message. 
			 * Value should be integer.
			 * @method validatePeriodPresentationDays
			 * @return {boolean}
			 *   True if valid otherwise false.
			 */
			validatePeriodPresentationDays : function()
			{
				var periodPresentationDaysField = dj.byId("period_presentation_days");
				var periodPresentationDaysValue = dj.byId("period_presentation_days").get("value");
				if (typeof periodPresentationDaysValue === "undefined")
				{
					console.debug("Invalid Period Presentation Days value.");
			 		this.invalidMessage = m.getLocalization("valueShouldBeInteger");
			 		return false;
				}
				else if(periodPresentationDaysValue <= 0)
				{
					console.debug("Period Presentation Days value is less than or equal to Zero.");
					this.invalidMessage = m.getLocalization("valueShouldBeGreaterThanZero");
					return false;
				}
				console.debug("Valid Period Presentation Days value");
				return true;
			},
			
			/**
			 *  <h4>Summary:</h4>
			 *  Check if the beneficiary is active or not
			 *  @param {dijit._Widget || DomeNode} node 
			 *  Beneficiary name or the node itself
			 *  @method _validateBeneficiaryStatus
			 */
			
			validateBeneficiaryStatus : function() {
				//  summary:
			    //  Check if the beneficiary is active or not, with an AJAX call.
				
				var beneficiaryName = dj.byId("beneficiary_name")? dj.byId("beneficiary_name").get("value") :"";
				var companyId = dj.byId("company_id")? dj.byId("company_id").get("value") :"";
				var active = true;
						
				if(beneficiaryName !== "" && companyId !== "") 
				{
					console.debug("[cash.create_ft_tpt] Checking if the beneficiary is in active state");
					m.xhrPost({
						url : m.getServletURL("/screen/AjaxScreen/action/ValidateBeneficiaryStatus"),
						handleAs : "json",
						sync 	: true,
						content: {
							beneficiary_name	: beneficiaryName,
							company_id 			: companyId
						},
						load : function(response, args){
							console.debug("[Validate] Validating beneficiary status ");
							if(response && response.items && response.items.active === false)
							{
								active = false;
							}
							else
							{
								console.debug(falseMessage);
							}
						},
						error : function(response, args){
							active = false;
							console.error(" Validating beneficiary status error", response);
						}
					});
				}
				return active;
			},

			/**
			 * <h4>Summary:</h4>
			 * This function is to validate the total length of bank name and address fields to be maximum of 1024
			 * <h4>Description:</h4> 
			 * @method validateLength
			 * 
			 */
			
			validateLength : function(bankType)
			{
				var set = true;
                                var maxlength =  m._config.trade_total_combined_sizeallowed;	
				d.forEach(bankType, function(id){
					if(id) {
						var fieldTotalLength=0; 
						var arrayOfBankFields = [id+"_name", id+"_address_line_1", id+"_address_line_2", 
						               id+"_dom", id+"_address_line_4"];
						d.forEach(arrayOfBankFields, function(id){
							var field = dj.byId(id);
							if(field) {
								fieldTotalLength = fieldTotalLength + (field.get("value")).length;
								if(fieldTotalLength>maxlength)
								{
									m._config.onSubmitErrorMsg =  m.getLocalization("invalidBankFieldSizeErrorForTrade");
									set= false;
								}
							}
						});			
					}
				});		
				return set;
			},
			
			/**
			 * <h4>Summary:</h4>
			 * Validates the data entered as the discount expiry date 
			 * <h4>Description:</h4> 
			 * It checks for the following scenarios
			 * </br>The discount expiry date must be less than or equal to the Invoice due Date.
			 * @method validateDiscountExpDate
			 * @return {boolean}
			 *   if valid return TRUE otherwise return FALSE.
			 */
			validateDiscountExpDate : function() {
			//  summary:
			    //        Validates the data entered as the discount expiry date.
				// 
				// Return true for empty values
				if(!this.get("value")){
					return true;
				}
				
				console.debug("[misys.validation.common] Validating discount expiry date, Value = ", 
						this.get("value"));
				
				// Test that the discount expiry date is less than or equal to
				// the due date
					
					var discountDate = dj.byId("due_date");
										
					if(!m.compareDateFields(this, discountDate)) {
						this.invalidMessage = m.getLocalization("expiryDateGraterThanDueDateError",[
										_localizeDisplayDate(this),
										_localizeDisplayDate(discountDate)]);
						return false;
					}
					return true;
				},
				
				/**
				 * <h4>Summary:</h4>
				 * Validates Email address field
				 * <h4>Description:</h4> 
				 * if the email id field is valid then fine if not it changes the state of the 
				 * email id field to error state.
				 */
				validateEmailid : function()
				{
					console.log("[validation]: Validating email address on field.");
					var emailId;
					if(dj.byId('email'))
					{
						emailId = dj.byId('email').get('value');
					}
					if(emailId !== "") {
				
						m.xhrPost( {
							url : m.getServletURL("/screen/AjaxScreen/action/ValidateEmailAddress"),
							handleAs 	: "json",
							sync 		: true,
							content : {
								email : emailId	
							},
							load : _setEmailIdfieldStatus
						});
					}
				},
				
				
				/**
				 * <h4>Summary:</h4>
				 *   Validates the data entered as the Base Date.
				 *   <h4>Description:</h4> 
				 *   Its checks for the following scenarios 
				 *   The Base Date should not be after the system date.",
				 *   @method validateBaseDateWithCurrentSystemDate
				 *   @return {boolean}
				 *    True if date is valid otherwise false
				 */
				validateBaseDateWithCurrentSystemDate : function() {
					//  summary:
				    //        Validates the data entered as the Base Date.
				    // 
				   
					// This validation is for non-required fields
					if(!this.get("value")) {
						return true;
					}

					console.debug("[misys.validation.common] Validating Base Date. Value = ",
							this.get("value"));
					
					// Test that the expiry date is smaller than or equal to the current date
					var baseDate = this.get("value");
					
					var days = validateBusinessDate(this);
					if(days > 0)
					{
					console.debug("[misys.validation.common] Days difference between base date and current date = ", days);
						this.invalidMessage = m.getLocalization("baseDateGreaterThanSystemDateError",[
						                                               						         _localizeDisplayDate(this)
						                                               								]);
						return false;
					}	
									
					return true;
				}, 
				
				/**
				 * <h4>Summary:</h4>
				 *   Validates the data entered as the Base Date.
				 *   <h4>Description:</h4> 
				 *   Its checks for the following scenarios 
				 *   The Maturity Date should not be less the system date.",
				 *   @method validateMaturityDateWithSystemDate
				 *   @return {boolean}
				 *    True if date is valid otherwise false
				 */
				validateMaturityDateWithSystemDate : function() {
					//  summary:
				    //        Validates the data entered as the Maturity Date.
				    // 
				   
					// This validation is for non-required fields
					if(!this.get("value")) {
						return true;
					}

					console.debug("[misys.validation.common] Validating Base Date. Value = ",
							this.get("value"));
					
					// Test that the maturity date is smaller than or equal to the Business date
					var maturityDate = this.get("value");
					var days = validateBusinessDate(this);
								
					if(days < 0)
					{
						console.debug("[misys.validation.common] Days difference between base date and current date = ", days);
						this.invalidMessage = m.getLocalization("maturityDateLessThanSystemDateError",[_localizeDisplayDate(this)]);
						return false;
					}
					
					return true;
				}, 
				
				validateOffset : function(offsetField)
				{
					
					if(offsetField == Math.floor(offsetField))
						{
						return true;
						}
					else
						{
						return false;
						}
				},
				
				/**
				 * <h4>Summary:</h4>
				 * sets the maxlines to bo comment filed as 250 and checks for hyphen validation
				 * <h4>Description:</h4> 
				 * if the initial character is hyphen (_), error state is returned 
				 */
				
				bofunction : function() {
					
					//hyphen validation
					var boComment = dj.byId('bo_comment');
					if(boComment.get("value").charAt(0) == "-")
					{	
						this.invalidMessage = m.getLocalization("hyphenError");
						 return false;
					}
					if(this.rowCount >= this.maxSize){
						this.invalidMessage  = misys.getLocalization('textareaLinesError', [this.maxSize, this.rowCount+1]);
            			return false;
            		} 
					return  true;
					
				},
					getUnitMesureLocalization : function(rowIndex,item){
						console.debug('[m.UniteMesureLocalization]');
						var value = "";
						if(item)
						{
							var unity = item.qty_unit_measr_label[0];
							value = unity;
						}
						return value;
					},
		
					validateMandatoryRemarks : function() {
						var bank_name_field	=	dj.byId("issuing_bank_abbv_name"),
						payment_type_field	=	dj.byId("sub_product_code"),
						credit_currency_field	= 	dj.byId("ft_cur_code"),
						debit_currency_field = dj.byId("applicant_act_cur_code");

						var valid = false;

						m.xhrPost({
							url 		: misys.getServletURL("/screen/AjaxScreen/action/ValidateMandatoryRemarks") ,
							handleAs 	: "json",
							sync 		: true,
							content 	: { bank_name : bank_name_field.get("value"), 
								payment_type : payment_type_field.get("value"), 
								credit_currency: credit_currency_field.get("value") ,
								debit_currency: debit_currency_field.get("value")},
								load : function(response, args)
								{
									var a ="";
									switch (response.items.StatusCode)
									{

									case "OK":

										var indicator_field = response.items.mandatoryIndicator ;
										var credit_curr = response.items.credCur ;
										var debit_cur = response.items.debCur ;
										if(indicator_field && credit_curr && debit_cur){	

											if (indicator_field === "Y" || indicator_field ==="y")
											{

												dj.byId("free_format_text").set("required",true);

												if(document.getElementById('mandatorySpan') == undefined)
												{
													var mandatory = dojo.create('span' ,{'id':'mandatorySpan' , 'class' : 'required-field-symbol' ,'innerHTML' : '*' });
													d.parser.parse(mandatory);
													dojo.place(mandatory , dojo.byId('free_format_text') , "before");
													valid = true;
												}
												else
												{
													a = document.getElementById('mandatorySpan');
													a.setAttribute("style","display:inline-block");							
												}

											}

										}	
										else{

											dj.byId("free_format_text").set("required",false);
											if(document.getElementById('mandatorySpan'))
											{
												a = document.getElementById('mandatorySpan');
												a.setAttribute("style","display:none");
											}
										}
										break;
									default: break;
									}
								},
								error : function(response, args) 
								{
									console.error(failedMandatoryField);
									console.error(response);
								}
						});

						return valid;
					},


					// FD 6 for paymentDetailsBeneficiary MT103  
					MT103DetailsBeneficiary : function() {
						console.log("inside the MT103DetailsBeneficiary :: ");
						var bank_name_field	=	dj.byId("issuing_bank_abbv_name"),
						payment_type_field	=	dj.byId("sub_product_code"),
						credit_currency_field	= 	dj.byId("ft_cur_code"),
						debit_currency_field = dj.byId("applicant_act_cur_code");


						var valid = false;

						m.xhrPost({
							url 		: misys.getServletURL("/screen/AjaxScreen/action/ValidateMandatoryRemarks") ,
							handleAs 	: "json",
							sync 		: true,
							content 	: { bank_name : bank_name_field.get("value"), 
								payment_type : payment_type_field.get("value"), 
								credit_currency: credit_currency_field.get("value") ,
								debit_currency: debit_currency_field.get("value")},
								load : function(response, args)
								{
									var a= "";
									switch (response.items.StatusCode)
									{
									case "OK":

										var indicator_field = response.items.mandatoryIndicator ;

										if (indicator_field) {
											if (indicator_field === "Y" || indicator_field ==="y")
											{

												console.log("inside MT103DetailsBeneficiary indicator_field"+indicator_field);
												dj.byId("payment_details_to_beneficiary").set("required",true);

												m.toggleRequired("payment_details_to_beneficiary", true);


											}

										}	
										else{
											console.log("inside else of MT103DetailsBeneficiary indicator_field"+indicator_field);
											dj.byId("payment_details_to_beneficiary").set("required",false);

											m.toggleRequired("payment_details_to_beneficiary", false);

										}


										break;
									default: break;
									}
								},
								error : function(response, args) 
								{
									console.error(failedMandatoryField);
									console.error(response);
								}
						});

						return valid;
					},


					//FDS 13.7.2
					// Below function checks for the remittance reason mandatory
					validateRemittanceReasonCode : function(){

						var bank_name_field =       dj.byId("issuing_bank_abbv_name"),
						bene_currency_field =          dj.byId("ft_cur_code");
						var valid               = false;

						m.xhrPost({
							url          : misys.getServletURL("/screen/AjaxScreen/action/ValidateRemittanceReasonCode") ,
							handleAs     : "json",
							sync         : true,
							content      : { 
								bank_name : bank_name_field.get("value"), 
								bene_currency: bene_currency_field.get("value")},

								load : function(response, args)
								{
									switch (response.items.StatusCode)
									{
									case "OK":

										var indicator_field = response.items.mandatoryIndicator ;
										valid = true;


										if (indicator_field) {
											if (indicator_field === "Y" || indicator_field ==="y")
											{
												m.toggleRequired("remittance_description", true);	   
											}                                                
										}      
										else{
											m.toggleRequired("remittance_description", false);		
										}
										break;
									default: break;
									}
								},
								error : function(response, args) 
								{
									console.error(failedMandatoryField);
									console.error(response);
								}
						});

						return valid;

					},


					// 9.2	and 9.1 Intermediary Detail Mandatory check and 9.1	Valid Country Code per Transaction Currency FDs
					MT103ValidCountryCode : function() {
						console.log("inside the MT103ValidCountryCode:: ");
						var bank_name_field	=	dj.byId("issuing_bank_abbv_name"),
						currency_code_field	= 	dj.byId("ft_cur_code"),//  ft_cur_code
						country_code_field = dj.byId("cpty_bank_country");

						if(country_code_field.get("value") === "")
						{
							return true;
						}
						var valid = false;

						m.xhrPost({
							url 		: misys.getServletURL("/screen/AjaxScreen/action/ValidateCountryCode") ,
							handleAs 	: "json",
							sync 		: true,
							content 	: { bank_name : bank_name_field.get("value"), 
								currency_code: currency_code_field.get("value") ,
								country_code: country_code_field.get("value")},
								load : function(response, args)
								{
									var a= "";
									switch (response.items.StatusCode)
									{
									case "Mandatory":

										var indicator_field = response.items.mandatoryIndicator ;
										var countrycode = response.items.countryCode;
										valid = true;
										if (indicator_field && countrycode ) {
											if (indicator_field === "Y" || indicator_field ==="y")
											{
												m.toggleRequired("intermediary_bank_swift_bic_code", true);
												m.toggleRequired("intermediary_bank_name", true);
												m.toggleRequired("intermediary_bank_address_line_1", true);
												m.toggleRequired("intermediary_bank_country", true);

											}

										}

										else{
											m.toggleRequired("intermediary_bank_swift_bic_code", false);	
											m.toggleRequired("intermediary_bank_name", false);
											m.toggleRequired("intermediary_bank_address_line_1", false);
											m.toggleRequired("intermediary_bank_country", false);
										
										}


										break;
									case "NotMandatory" : 
										m.toggleRequired("intermediary_bank_swift_bic_code", false);
										m.toggleRequired("intermediary_bank_name", false);
										m.toggleRequired("intermediary_bank_address_line_1", false);
										m.toggleRequired("intermediary_bank_country", false);

										break;

									default: 

										break;
									}
								},
								error : function(response, args) 
								{
									console.error(failedMandatoryField);
									console.error(response);
								}
						});

						return valid;
					},


					// 9.3	Intermediary Detail Mandatory check and 9.1	Valid Country Code per Transaction Currency 
					MT103Intermediarydetailvalidation : function() {
						if(!misys._config.mt103_intermediary_details)
						{
							return true;
						}
						var bank_name_field	=	dj.byId("issuing_bank_abbv_name"),
						currency_code_field	= 	dj.byId("ft_cur_code"),
						country_code_field = dj.byId("intermediary_bank_country"),
						displayMessage = '';

						var valid = true;

						m.xhrPost({
							url 		: misys.getServletURL("/screen/AjaxScreen/action/IntermediaryDetailValidation") ,
							handleAs 	: "json",
							sync 		: true,
							content 	: { bank_name : bank_name_field.get("value"), 
								currency_code: currency_code_field.get("value") ,
								country_code: country_code_field.get("value")},
								load : function(response, args)
								{
									var a= "";
									switch (response.items.StatusCode)
									{
									case "Mandatory":

										var indicator_field = response.items.mandatoryIndicator ;
										var countrycode = response.items.countryCode;
										valid = false;
										if (indicator_field && countrycode ) {
											if (indicator_field === "Y" || indicator_field ==="y")
												{
													displayMessage = country_code_field.value+": is not valid Country Code";
													country_code_field.set("state", "Error");
													m.dialog.show("ERROR", displayMessage);
												}
											}
											else {
											m.toggleRequired("intermediary_bank_country", false);
											valid = true;
											}
										break;
									case "NotMandatory" : 
											m.toggleRequired("intermediary_bank_country", false);
											valid = true;
										break;

									default: 

										break;
									}
								},
								error : function(response, args) 
								{
									console.error(failedMandatoryField);
									console.error(response);
								}
						});

						return valid;
					},
					
					_validateCurrencyCode : function(product_code_field, account_cur_code_field) 
					{
						   var productTypeStr =product_code_field ? product_code_field.get("value") : '';
						   var account_cur_code = account_cur_code_field ? account_cur_code_field.get("value") : '';
						   var displayMessage = "";
						   var valid = true;
						   		if(account_cur_code != "")
						   			{
									m.xhrPost( {
										url : m.getServletURL("/screen/AjaxScreen/action/ValidateCurrencyValid"),
										handleAs 	: "json",
										sync 		: true,
										content : {
											subproductcode : productTypeStr,
											transferCurCode : account_cur_code
											
										},
										load : function(response, args)
										{
											var isValid = response.isValid;
											if(!isValid)
												{
												 
												displayMessage = m.getLocalization("invalidCurrencyConfigured", [account_cur_code_field.get("value")]);
												account_cur_code_field.set("state", "Error");
												dj.showTooltip(displayMessage,account_cur_code_field.domNode, 0);
												valid = false;
												return valid;
												}
											
											
										}
									});
									
						   				}
						   		return valid;
					}					
	});
})(dojo, dijit, misys);
//Including the client specific implementation
       

}

if(!dojo._hasResource["dojox.uuid.generateRandomUuid"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.uuid.generateRandomUuid"] = true;
dojo.provide("dojox.uuid.generateRandomUuid");

dojox.uuid.generateRandomUuid = function(){
	// summary:
	//		This function generates random UUIDs, meaning "version 4" UUIDs.
	// description:
	//		A typical generated value would be something like this:
	//		"3b12f1df-5232-4804-897e-917bf397618a"
	//
	//		For more information about random UUIDs, see sections 4.4 and
	//		4.5 of RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.4
	//
	//		This generator function is designed to be small and fast,
	//		but not necessarily good.
	//
	//		Small: This generator has a small footprint. Once comments are
	//		stripped, it's only about 25 lines of code, and it doesn't
	//		dojo.require() any other modules.
	//
	//		Fast: This generator can generate lots of new UUIDs fairly quickly
	//		(at least, more quickly than the other dojo UUID generators).
	//
	//		Not necessarily good: We use Math.random() as our source
	//		of randomness, which may or may not provide much randomness.
	// examples:
	//		var string = dojox.uuid.generateRandomUuid();
	var HEX_RADIX = 16;

	function _generateRandomEightCharacterHexString(){
		// Make random32bitNumber be a randomly generated floating point number
		// between 0 and (4,294,967,296 - 1), inclusive.
		var random32bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 32) );
		var eightCharacterHexString = random32bitNumber.toString(HEX_RADIX);
		while(eightCharacterHexString.length < 8){
			eightCharacterHexString = "0" + eightCharacterHexString;
		}
		return eightCharacterHexString; // for example: "3B12F1DF"
	}

	var hyphen = "-";
	var versionCodeForRandomlyGeneratedUuids = "4"; // 8 == binary2hex("0100")
	var variantCodeForDCEUuids = "8"; // 8 == binary2hex("1000")
	var a = _generateRandomEightCharacterHexString();
	var b = _generateRandomEightCharacterHexString();
	b = b.substring(0, 4) + hyphen + versionCodeForRandomlyGeneratedUuids + b.substring(5, 8);
	var c = _generateRandomEightCharacterHexString();
	c = variantCodeForDCEUuids + c.substring(1, 4) + hyphen + c.substring(4, 8);
	var d = _generateRandomEightCharacterHexString();
	var returnValue = a + hyphen + b + hyphen + c + d;
	returnValue = returnValue.toLowerCase();
	return returnValue; // String
};

}

if(!dojo._hasResource["misys.grid._ViewManager"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.grid._ViewManager"] = true;
dojo.provide("misys.grid._ViewManager");

dojo.declare("misys.grid._ViewManager",
		[ dojox.grid._ViewManager ],
{
		measureContent: function(){
			console.debug("[MTPViewManager] measureContent");
			var h = 0;
			this.forEach(function(inView){
				var actualHeight = 0;
				if (inView.contentNode.childNodes.length > 0)
				{
					actualHeight = inView.contentNode.childNodes[0].offsetHeight;
					console.debug("[MTPViewManager] h: " + h + "   actualHeight: " + actualHeight);
				}
				h = Math.max(actualHeight, h);
			});
			return h;
		}
});

}

if(!dojo._hasResource["misys.grid._View"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.grid._View"] = true;
dojo.provide("misys.grid._View");
dojo.experimental("misys.grid._View"); 



// our declared class
dojo.declare("misys.grid._View",
	[ dojox.grid._View ],
	// class properties:
	{
		// note: not called in 'view' context
		_getHeaderContent: function(inCell){
			var ret = "";
			if (inCell.grid.showMoveOptions && inCell.field && inCell.field === 'actions')
			{
				ret = [ "<div align='center'>" ];
				ret = ret.concat(
						[ "<img src='" + 
						  	misys.getContextualURL("/content/images/pic_arrowdown.gif") + 
						  	"' alt='Move Down' border='0' type='moveDown'/>" ],
						[ "&nbsp;" ],
						[ "<img src='" + 
						  misys.getContextualURL("/content/images/pic_arrowup.gif") + 
						  		"' alt='Move Up' border='0' type='moveUp'/>" ],
						[ "</div>"]);
				return ret.join('');
			}
			else
			{
				var n = inCell.name || inCell.grid.getCellName(inCell);
				ret = [ '<div class="dojoxGridSortNode' ];
				
				if(inCell.index != inCell.grid.getSortIndex()){
					ret.push('">');
				} else {
					ret = ret.concat([ ' ',
								inCell.grid.sortInfo > 0 ? 'dojoxGridSortUp' : 'dojoxGridSortDown',
								'"><div class="dojoxGridArrowButtonChar">',
								inCell.grid.sortInfo > 0 ? '&#9650;' : '&#9660;',
								'</div><div class="dojoxGridArrowButtonNode" role="'+(dojo.isFF<3 ? "wairole:" : "")+'presentation"></div>' ]);
				}
				ret = ret.concat([n, '</div>']);
				return ret.join('');
			}
		}
	}
);

}

if(!dojo._hasResource["misys.grid.DataGrid"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.grid.DataGrid"] = true;
dojo.provide("misys.grid.DataGrid");
dojo.experimental("misys.grid.DataGrid"); 





// our declared class
dojo.declare("misys.grid.DataGrid",
	[ dojox.grid.DataGrid ],
	// class properties:
	{
		// Whether to show the arrow icons that allow grid items to be moved up and down
		showMoveOptions : true,
		
	    // dojo.publish once a record is deleted from the grid
	    _deleteGridRecord : "deletegridrecord",

		startup: function(){
			console.debug("[misys.grid.DataGrid] startup start");
			this.inherited(arguments);
			
    		// Handle cell click on grid
    		misys.connect(this, 'onCellClick', this, this.handleGridAction);
    		
			console.debug("[DataGrid] startup end");
		},

		handleGridAction: function(event)
    	{
    		console.debug("[misys.grid.DataGrid] handleGridAction start");
    		console.debug("[misys.grid.DataGrid] handleGridAction grid id: " + this.id);
    		if(event.target.tagName === "IMG" && event.target.attributes.type)
    		{
    			var typeValue = event.target.attributes.type.value.toLowerCase();
    			// Edit details
    			if(typeValue === 'edit')
    			{
    				this.onEdit(event);
    			}
    			// Remove row
    			else if(typeValue === 'remove')
    			{
    				this.onDelete(event);
    			}
    			else if(typeValue === 'view')
    			{
    				this.onView(event);
    			}
    			// Move row(s) Up
    			else if(typeValue === "moveup")
    			{
    				this._moveSelectedRowsUp(event.grid);
    			}
    			// Move row(s) down
    			else if (typeValue === "movedown")
    			{
    				this._moveSelectedRowsDown(event.grid);
    			}
    		}
    		console.debug("[misys.grid.DataGrid] handleGridAction end");
    	},
    	
    	onEdit: function(event)
    	{
    		console.debug("[misys.grid.DataGrid] onEdit");
    		
			// Pass in values to dialog
			var store = this.store;
			var id;
			store.fetch(
					{
						query: {store_id: '*'},
						sort: this.getSortProps(),
						onComplete: dojo.hitch(this, function(items, request){
							dojo.forEach(items, function(item, index){
								if(index === event.rowIndex)
								{
									console.debug("Here is the item:", item );
									id = item.store_id[0];
								}
							}, this);
						})
					}
			);
			if(event.grid.gridMultipleItemsWidget.name == "amendments"){
				store.fetch({
					query: {store_id: id},
					onComplete: dojo.hitch(this.gridMultipleItemsWidget, "editGridData")
				});
			}
			else{
				store.fetch({
					query: {store_id: id},
					onComplete: dojo.hitch(this.gridMultipleItemsWidget, "openDialogFromExistingItem")
				});
			}
    	},
    	
    	onView: function(event)
    	{
    		console.debug("[misys.grid.DataGrid] onView");
    		
			// Pass in values to dialog
			var store = this.store;
			var id;
			store.fetch(
					{
						query: {store_id: '*'},
						sort: this.getSortProps(),
						onComplete: dojo.hitch(this, function(items, request){
							dojo.forEach(items, function(item, index){
								if(index === event.rowIndex)
								{
									console.debug("Here is the item:", item );
									id = item.store_id[0];
								}
							}, this);
						})
					}
			);
			
			store.fetch({
				query: {store_id: id},
				onComplete: dojo.hitch(this.gridMultipleItemsWidget, "openDialogFromExistingItem")
			});
    	},
    	
    	onDelete: function(event)
    	{
			console.debug("[misys.grid.DataGrid] onDelete");
			var that = this;
			var callBack = function(){
					// Unselect all rows
		            var items = that.selection.getSelected();
		            if (items.length) {
		                // Iterate through the list of selected items and unselect them
		                dojo.forEach(items, function(selectedItem) {
		                    if (selectedItem !== null) {
		                        // Delete the item from the data store:
		                    	that.selection.setSelected(selectedItem, false);
		                    }
		                }, that);
		            }
		            
					// Then, select row to be removed
		            that.selection.setSelected(event.rowIndex, true);
					// Get all selected items from the Grid:
		            items = that.selection.getSelected();
		            if (items.length) {
		                // Iterate through the list of selected items
		            	// and remove them from the store
		                dojo.forEach(items, function(selectedItem) {
		                    if (selectedItem !== null) {
		                        // Delete the item from the data store:
		                    	that.store.deleteItem(selectedItem);
		                    }
		                }, that);
		                that.store.save();
		            }
		            
		            // Unselect all rows
		            items = that.selection.getSelected();
		            if (items.length) {
		                // Iterate through the list of selected items
		            	// and unselect them
		                dojo.forEach(items, function(selectedItem) {
		                    if (selectedItem !== null) {
		                        // Delete the item from the data store:
		                    	that.selection.setSelected(selectedItem, false);
		                    }
		                }, that);
		            }    
		            
					setTimeout(dojo.hitch(that.gridMultipleItemsWidget, "renderSections"), 100);
					// Publish a deleteGrid Record event to be able to take some actions in the page
					dojo.publish(that._deleteGridRecord);
					if(event.grid.gridMultipleItemsWidget.name == "amendments"){
						that.gridMultipleItemsWidget.deleteData();
					}
			};
			misys.dialog.show("CONFIRMATION",misys.getLocalization("confirmDeletionGridRecord"),'',callBack);
    	},
    	
		// Build custom views
		buildViews: function(){
			console.debug("[misys.grid.DataGrid] buildViews");
			for(var i=0, vs; (vs=this.layout.structure[i]); i++){
				this.createView("misys.grid._View", i).setStructure(vs);
			}
			this.scroller.setContentNodes(this.views.getContentNodes());
		},

		// views
		createViews: function(){
			console.debug("[misys.grid.DataGrid] createViews");
			this.views = new misys.grid._ViewManager(this);
			this.views.createView = dojo.hitch(this, "createView");
		},
		
		postresize: function(){
			// views are position absolute, so they do not inflate the parent
			console.debug("[misys.grid.DataGrid] postresize");
			if(this._autoHeight){
				setTimeout(dojo.hitch(this, "_postresize"), 120);
			}
		},
		
		_postresize: function()
		{
			console.debug("[misys.grid.DataGrid] _postresize");
			// Resize grid view
			if (this.viewsNode)
			{
				var size = Math.max(this.views.measureContent()) + 'px';
				
				dojo.attr(this.viewsNode, 'style', { height: size });
				if (this.views && this.views.views && this.views.views[0].contentNode)
				{
					dojo.attr(this.views.views[0].contentNode, 'style', { height: size });
				}
	
				// Resize header view
				var headerHeight = 0;
				var children = (this.viewsHeaderNode.childNodes ? this.viewsHeaderNode.childNodes : []);
				var regExp = new RegExp('/*dojoxGridHeader*');
				for(var i=0, len = children.length; i < len; i++)
				{
					var child = children[i];					
					if(regExp.test(dojo.attr(child, 'classname')))
					{
						dojo.attr(this.viewsHeaderNode, 'style', { height: child.clientHeight + 'px' });
						break;
					}
				}
			}
		},
		
		onHeaderCellClick: function(event){
			// Move row(s) up
			console.debug("[misys.grid.DataGrid] onHeaderCellClick");
			var typeValue = (event.target.attributes.type) ?
					event.target.attributes.type.value.toLowerCase() : "";
			
			if(typeValue === "moveup")
			{
				this._moveSelectedRowsUp(event.grid);
			}
			// Move row(s) down
			else if(typeValue === "movedown")
			{
				this._moveSelectedRowsDown(event.grid);
			}
			else
			{	
				this.inherited(arguments);
			}
		},

		// Clone function
		_clone: function(obj){
			console.debug("[misys.grid.DataGrid] _clone");
			if(obj == null || typeof(obj) !== "object")
			{
				return obj;
			}
			var temp = new obj.constructor();
			for(var key in obj)
			{
				if(obj.hasOwnProperty(key)) {
					if(key.match('^_') != '_')
					{
						temp[key] = this._clone(obj[key]);
					}
				}
			}
			return temp;
		},
		
		// Move rows up
		_moveSelectedRowsUp: function(grid)
		{
			// If a row or several rows have been selected and
			// the first row of the grid is not selected
			console.debug("[misys.grid.DataGrid] _moveSelectedRowsUp");
			if (grid.selection.selected.length > 0 && !grid.selection.selected[0])
			{
				var targetItems = [];
				for (var i = 0, len = grid.rowCount; i < len; i++)
				{
					var currentItem = this._clone(grid.getItem(i));

					// Build the array of items in the correct order
					if (grid.selection.selected[i+1])
					{
						var j = i+1;
						while(j < len && grid.selection.selected[j])
						{
							var item = this._clone(grid.getItem(j));
							targetItems.push(item);
							j++;
						}
						i = j-1;
					}
					targetItems.push(currentItem);
				}
				
				// Replace the items content in the grid
				var matchInternalProperty, isInternalProperty;
				for (var m = 0, mlen = grid.rowCount; m < mlen; m++)
				{
					var storeId = grid.getItem(m).store_id;
					storeId = dojo.isArray(storeId) ? storeId[0] : storeId;
					grid.store.fetch({
						query: {store_id: storeId},
						onComplete: dojo.hitch(this, function(targetItems, m, items, request){
		    				for(var property in items[0])
		    				{
		    					if(items[0].hasOwnProperty(property)) {
		    						matchInternalProperty = property.match("^_");
		    						isInternalProperty = (dojo.isArray(matchInternalProperty) ? matchInternalProperty[0] : matchInternalProperty) === "_";
			    					if(property !== "store_id" && !isInternalProperty)
			    					{
			    						var value = targetItems[m][property];
			    						value = dojo.isArray(value) ? value[0] : value;
			    						grid.store.setValue(items[0], property, value);
			    					}
		    					}
		    				}
						}, targetItems, m)
					});
				}
				
				// Change the grid selection one row up
				for (var k = 0, klen = grid.rowCount - 1; k < klen; k++)
				{
					grid.selection.selected[k] = grid.selection.selected[k+1];
				}
			}
			for(var l = 0 ; l<grid.rowCount ; l++)
			{
				grid.selection.selected[l] = undefined;
			}
		},
		
		// Move rows down
		_moveSelectedRowsDown: function(grid)
		{
			// If a row or several rows have been selected and
			// the first row of the grid is not selected
			console.debug("[misys.grid.DataGrid] _moveSelectedRowsDown");
			if (grid.selection.selected.length > 0 && !grid.selection.selected[grid.rowCount-1])
			{
				var targetItems = [];
				for (var i = 0, len = grid.rowCount; i < len; i++)
				{
					if (grid.selection.selected[i])
					{
						var j=i;
						while(j < len && grid.selection.selected[j])
						{
							j++;
						}
						targetItems.push(this._clone(grid.getItem(j)));
						for (var k = i; k < j; k++)
						{
							var item = this._clone(grid.getItem(k));
							targetItems.push(item);
						}
						i = j;
					}
					else
					{
						targetItems.push(this._clone(grid.getItem(i)));
					}
				}
				
				// Replace the items content in the grid
				var matchInternalProperty, isInternalProperty;
				for (var n = 0, nlen = grid.rowCount; n < nlen; n++)
				{
					var storeId = grid.getItem(n).store_id;
					storeId = dojo.isArray(storeId) ? storeId[0] : storeId;
					grid.store.fetch({
						query: {store_id: storeId},
						onComplete: dojo.hitch(this, function(targetItems, n, items, request){
		    				for(var property in items[0])
		    				{
		    					if(items[0].hasOwnProperty(property)) {
		    						matchInternalProperty = property.match("^_");
		    						isInternalProperty = (dojo.isArray(matchInternalProperty) ? matchInternalProperty[0] : matchInternalProperty) === "_";
			    					if(property !== "store_id" && !isInternalProperty)
			    					{
			    						var value = targetItems[n][property];
			    						value = dojo.isArray(value) ? value[0] : value;
			    						grid.store.setValue(items[0], property, value);
			    					}
		    					}
		    				}
						}, targetItems, n)
					});
				}
				
				// Change the grid selection one row down
				for (var m = grid.rowCount-1; m >= 0; m--)
				{
					grid.selection.selected[m] = grid.selection.selected[m-1];
				}
			}
			for(var l = 0 ; l<grid.rowCount ; l++)
			{
				grid.selection.selected[l] = undefined;
			}
		}
	}
);

}

if(!dojo._hasResource["misys.grid.GridMultipleItems"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.grid.GridMultipleItems"] = true;
dojo.provide("misys.grid.GridMultipleItems");
dojo.experimental("misys.grid.GridMultipleItems"); 










// our declared class
dojo.declare("misys.grid.GridMultipleItems",
	[ dijit._Widget, dijit._Templated, dijit._Container ],
	// class properties:
	{
		overrideDisplaymode : 'edit',
		widgetsInTemplate: true,
		store: null,
		gridId: '',
		handle: [],
		name: '',
		grid: null,
		dialogId: '',
		dialog: null,
		dialogClassName: null,
		dialogAddItemTitle: '',
		dialogUpdateItemTitle: '',
		dialogViewItemTitle: '',
		requiredField: [],
		xmlTagName: '',
		xmlSubTagName: '',
		noItemLabel: 'null',
		addButtonLabel: 'null',
		openDialogFromExistingItemInitFunction: null,
		data: {},
		propertiesMap: {},
		typeMap: {},
		gridColumns: [],
		layout: [],
		headers: [],
		dataList: [],
		_itemFields: null,
		showMoveOptions : false,
		mandatoryFields: [],
		
		// GridMultipleItems are now silently validated - fields are not highlighted and the
		// user is not blocked from saving. The validation result is stored here and, on form
		// submission, we highlight the grid row in error.
		// note: We use a Y string instead of a boolean, to match the way it is done in the database
		is_valid : "Y",
		state: "",

		getMandatoryProperties: function(item){
			return (this.mandatoryFields ? this.mandatoryFields : []);
		},

		buildRendering: function()
		{
			console.debug("[GridMultipleItems (" + this.declaredClass + ", " + this.id + ")] buildRendering start");
			if(!this.templateString){
				if (this.attachmentGroup && this.attachmentGroup != '')
				{
					this.templateString = dojo.byId('file-attachment-template'+ this.attachmentGroup).innerHTML;
				}
				else if (dojo.byId('file-attachment-template'))
				{
					this.templateString = dojo.byId('file-attachment-template').innerHTML;
				}
			}
			this.inherited(arguments);		
			console.debug("[GridMultipleItems (" + this.declaredClass + ", " + this.id + ")] buildRendering end");
		},
		startup: function(){
			if(this.isWidgetToBeDestroyed(this.id)){ 
				return; 
			}
			if(this._started){ 
				return;
			}
			
			console.debug("[GridMultipleItems (" + this.declaredClass + ", " + this.id + ")] startup start");
			
			// Object with empty names are ignored in forms xml generation.
			this.name = this.id;
			
			// TODO: This is done because GridMultipleItems#createJsonItem does not
			// output the content of the very first level but only of its children
			// To be reviewed!!!
			if(this.dataList.length === 0)
			{
				this.dataList = this.createJsonItem();
			}
			else
			{
				dojo.forEach(this.dataList, function(item){
					var areAllMandatoryFieldsFilled = this.checkMandatoryProperties(item);
					item['is_valid'] = areAllMandatoryFieldsFilled ? "Y" : "N";
				}, this);
			}
			
			this.inherited(arguments);
			
			// Update layout headers
			for(var i=0, len = this.headers.length; i < len; i++) {
				this.layout[i].name = this.headers[i];
			}
			
			// Possibly update labels
			if (this.noItemLabel !== 'null' && this.noItemLabelNode)
			{
				this.noItemLabelNode.innerHTML = this.noItemLabel;
			}
			if (this.overrideDisplaymode === 'view' || this.overrideDisplaymode === 'editonly')
			{
				//this.addButtonNode might be null so test			
				if (this.addButtonNode)
				{
					this.addButtonNode.set('style', 'display:none');
				}
			}
			else 
			{
				if (this.addButtonLabel !== 'null' && this.addButtonNode)
				{
					this.addButtonNode.set('label', this.addButtonLabel);
				}
			}
			// Add store_id to grid columns list
			this.gridColumns.push('store_id');
			this.gridColumns.push('is_valid');
	
			//we instanciate the grid in all case at startup.this fix bug with updatedata without timeout
			if(this.dataList.length > 0)
			{
				// Create data store
				this.createDataStoreFromDataList();
				
				// Create data grid
				this.createDataGrid();
			}
			
			this.renderSections();
			
			this.destroyWidgets();
			
			this.collectRequiredField();
			
			this.setDialogFieldUnrequired();
			
			misys.connect(this.dialog, "onHide", this, "setDialogFieldUnrequired");
			misys.connect(this.dialog, "onShow", this, "setDialogFieldRequired");
			
			// Add the displaymode as a class
			dojo.addClass(this.dialog.domNode, "gridMultipleItems_" + this.overrideDisplaymode);
			console.debug("[GridMultipleItems (" + this.declaredClass + ", " + this.id + ")] startup end");
		},
		
		createDataStoreFromDataList: function()
		{
			console.debug("[GridMultipleItems] createDataStoreFromDataList start");
			this.data.items = this.buildStoreItem(this.dataList);
			this.store = new dojo.data.ItemFileWriteStore({ data: this.data,  typeMap: this.typeMap});
			console.debug("[GridMultipleItems] createDataStoreFromDataList end");
		},
		
		createAmendDataStoreFromText: function(dataItem)
		{
			console.debug("[GridMultipleItems] createDataStoreFromDataList start");
			if(misys._config.editedItemIndex != -1 && misys._config.editedItemIndex != undefined && this.data.items.length != 0){
				var dataItemsClonedArray = this.data.items;
				var dataItemsUpdatedArray = [];
				var counter = 0;
				for(var itr = 0; itr < this.data.items.length+1; itr++){
					if(itr === misys._config.editedItemIndex){
						dataItemsUpdatedArray.push(dojo.mixin({ store_id: dojox.uuid.generateRandomUuid() },dataItem));
					}
					else{
						dataItemsUpdatedArray.push(dojo.mixin({ store_id: dojox.uuid.generateRandomUuid() },dataItemsClonedArray[counter++]));
					}
				}
				this.data.items = dataItemsUpdatedArray;
			}
			else{
				this.data.items.push(dojo.mixin({ store_id: dojox.uuid.generateRandomUuid() }, dataItem));
			}
			this.store = new dojo.data.ItemFileWriteStore({ data: this.data,  typeMap: this.typeMap});
			misys._config.editedItemIndex = -1;
			console.debug("[GridMultipleItems] createDataStoreFromDataList end");
		},
		
		buildStoreItem: function(data)
		{
			var items = [];
			for(var i=0, rows=this.dataList.length; i<rows; i++)
			{
				var dataItem = data[i];
				for(var property in dataItem)
				{
					if(dojo.isArray(dataItem[property]))
					{
						dataItem[property] = this.buildStoreItem(dataItem[property]);
					}
				}
				items.push(dojo.mixin({ store_id: dojox.uuid.generateRandomUuid() }, dataItem));
			}
			return items;
		},

		updateGridFromDataList: function()
		{
			console.debug("[GridMultipleItems] updateGridFromDataList start");

			for(var i = 0, rows = this.dataList.length; i<rows; i++)
			{
				var item = this.dataList[i%l];
				if (!item.store_id)
				{
					item = dojo.mixin({ store_id: dojox.uuid.generateRandomUuid() }, item);
				}

				// TODO: check why this function is called twice when the user clicks on edit in the grid
				// Check if the item already exists in the store
				this.grid.store.fetch({
						query: {store_id: item.store_id},
						onComplete: dojo.hitch(this, function(items, request){
							if (items.length <= 0)
							{
								this.grid.store.newItem(item);
							}
						})
				});
			}
			
			this.grid.store.save();
			this.renderAll();
			console.debug("[GridMultipleItems] updateGridFromDataList end"); 
		},
		
		onGridCreate: function() {
		},
		
		createDataGrid: function()
		{
			var gridId = this.gridId;
			if(!gridId)
			{
				gridId = 'grid-' + 
							(this.xmlTagName ? this.xmlTagName + '-' : '') + 
							dojox.uuid.generateRandomUuid();
			}
			this.grid = new misys.grid.DataGrid({
				jsId: gridId,
				id: gridId,
				store: this.store,
				structure: this.layout,
				autoHeight: true,
				selectionMode: 'multiple',
				columnReordering: true,
				autoWidth: true,
				rowsPerpage: 1000,
				initialWidth: '100%',
				canSort: function(){
					return true;
				},
			 	showMoveOptions:  this.showMoveOptions
			}, document.createElement("div"));
			this.grid.gridMultipleItemsWidget = this;
			
			misys.connect(this.grid, "onStyleRow" , dojo.hitch(this, function(row) {
				var item = this.grid.getItem(row.index);
       
				/*if (!this.checkMandatoryFields(item))
				{
					row.customStyles += "background-color: #F9F7BA !important";
				}*/

				if (item && item.hasOwnProperty("is_valid")) {
                	var isValid = dojo.isArray(item.is_valid) ? item.is_valid[0] : item.is_valid;
                	
                	if(isValid && isValid !== "Y") {
                		// We have to use an inline style, otherwise the row colour 
                		// changes onMouseOver
                		row.customStyles += "background-color: #F9F7BA !important";
                		this.state = "Error";
                	}
                }

                 this.grid.focus.styleRow(row);
                 this.grid.edit.styleRow(row);
            }));
			
			this.addChild(this.grid);
			this.onGridCreate();
		},
		
		/*checkMandatoryFields: function(item)
		{
			var areMandatoryFieldsMissing = dojo.some(this.mandatoryFields, function(mandatoryField){
				var itemValue = item[mandatoryField];
				itemValue = dojo.isArray(itemValue) ? itemValue[0] : itemValue;
				return (itemValue == null || itemValue == '');
			});
			return !areMandatoryFieldsMissing;
		},*/

		renderSections: function()
		{
			try
			{
				if (this.itemsNode)
				{
					var displayGrid = (this.grid && this.grid.rowCount > 0);
					dojo.attr(this.itemsNode, 'style', { display: (displayGrid ? 'block' : 'none') } );
					if(document.getElementById('reporting_popup') )
					{
						dojo.attr(this.itemsNode, 'style', { width : '100%'} );
					}
							
				}
				if (this.noItemLabelNode)
				{
					var displayNoItemLabel = (this.grid && this.grid.rowCount === 0) || (! this.grid);
					dojo.attr(this.noItemLabelNode, 'style', { display: (displayNoItemLabel ? 'block' : 'none') } );
				}
			}
			catch(err)
			{
				console.debug("Error: " + err);
			}
		},
		
		openDialogFromExistingItem: function(items, request)
		{
			console.debug("[GridMultipleItems] openDialogFromExistingItem start");
			
			// Disable dialog events
			misys.dialog.isActive = false;
			
			var item = items[0];
		
			// Check Dialog widget
			this.checkDialog();
		
			// Set dialog title
			if(this.overrideDisplaymode !== "view") {
				this.dialog.set('title', this.dialogUpdateItemTitle);
			} else {
				var viewItemTitle = this.dialogViewItemTitle || this.dialogUpdateItemTitle;
				this.dialog.set('title', viewItemTitle);
			}

			// Reset dialog fields
			this.resetDialog();
			
			// Attach current widget to dialog widget
			this.dialog.gridMultipleItemsWidget = this;
			
			this.dialog.execute = this.dialogExecute;
		
			// Attach current widget and store id to dialog widget
			this.dialog.gridMultipleItemsWidget = this;
			this.dialog.storeId = (dojo.isArray(item.store_id) ? item.store_id[0] : item.store_id);
		
			// Populate the dialog
			var widgets = this.dialog.getChildren();
			for(var property in item)
			{
				var searchedWidgetId = (this.propertiesMap[property] && this.propertiesMap[property]._fieldName ? this.propertiesMap[property]._fieldName : property);
				if(property !== "store_id")
				{					
					dojo.some(widgets, function(widget){
						if(widget.id === searchedWidgetId || widget.name === searchedWidgetId)
						{
							var value = item[property];
							value = dojo.isArray(value) ? value[0] : value;
							
							if (this.overrideDisplaymode === "view") {
								// Being extra safe here in case of strange widget issues
								var displayStyle = (!value && value !== 0) ? "none" : "block";
								if(widget && widget.id && dojo.byId(widget.id + "_row")) {
									dojo.style(widget.id + "_row", "display", displayStyle);
								}
							}
							
							if (widget.isInstanceOf(misys.grid.GridMultipleItems))
	    					{
								// if widget contains grid, destroy it first
								if (widget.grid)
								{
									widget.grid.destroy();
								}
								// Create datalist
								
								if (dojo.isObject(value) && value._values && dojo.isArray(value._values))
								{
									widget.dataList = dojo.clone(value._values);
									widget.createDataStoreFromDataList();
									widget.createDataGrid();
									
									var key = item.store_id+'_'+property;
									if(this.handle && !this.handle[key]){
										this.handle[key] = misys.connect(this.dialog, "onShow", widget, "renderAll");
									}
								}
	    					}
							else
							{
		    					var declaredClass = widget.declaredClass;
		    					switch(declaredClass)
		    					{
		    						case 'dijit.form.DateTextBox':
		    							widget.set('displayedValue', value);
		    							break;
		    						case 'dijit.form.CheckBox':
		    							widget.set('checked', value === 'Y' ? true : false);
		    							break;
		    						case 'dijit.form.RadioButton':
		    							var radioDomNodes = dojo.query("[name='" + widget.name + "']", this.dialog.domNode);
		    							dojo.some(radioDomNodes, function(radioDomNode){
		    								var radioWidget = dijit.byNode(radioDomNode.parentNode);
		    								if (radioWidget.params.value === value)
		    								{
		    									radioWidget.set('checked', true);
		    									return true;
		    								}
		    							});
		    							break;
		    						case 'dijit.form.NumberTextBox':
		    							if (value != null && value !== '' && value !== 'NaN')
		    							{
		    								widget.set('value', value, false);
		    							}
		    							break;
		    							
		    						case 'misys.form.MultiSelect':
		    							widget.domNode.innerHTML = [];
		    							
		    							if(value !== "")
	    								{
		    								var arr = value.split(",");
		    								for(i=0;i<arr.length;i++)
	    									{
		    									var op = dojo.create("option");
		    									op.innerHTML =  arr[i];
		    									op.value = arr[i];
		    									widget.domNode.appendChild(op);
	    									}
	    								}
		    							
		    							break;
		    							
		    						default:
		    							widget.set('value', value);
		    							break;
		    					}
		    					if (this.overrideDisplaymode === 'view'){
									widget.set("readOnly", true);
								}
		    					return true;
							}
						}
						return false;
					}, this);
				}
			}
			
			if(item && item.product_name && item.product_name[0])
			{
				item.product_name[0] = dojox.html.entities.encode(item.product_name[0], dojox.html.entities.html);
			}
			if(item && item.cust_ref_id && item.cust_ref_id[0])
			{
				item.cust_ref_id[0] = dojox.html.entities.encode(item.cust_ref_id[0], dojox.html.entities.html);
			}
			if(item && item.other_type && item.other_type[0])
			{
				item.other_type[0] = dojox.html.entities.encode(item.other_type[0], dojox.html.entities.html);
			}
			// Execute init function if required
			if (this.openDialogFromExistingItemInitFunction != null)
			{
				this.openDialogFromExistingItemInitFunction(item);
			}
			
			// Show the dialog
			this.dialog.show();
			
			// Activate dialog events
			setTimeout(dojo.hitch(this, "activateDialog"), 500);
			
			// If the row is inValid, then fire the full validation
			if (item.hasOwnProperty("is_valid")) {
				var isValid = (dojo.isArray(item.is_valid)) ? item.is_valid[0] : item.is_valid;
				if(isValid !== "Y") {
					this.validateDialog(true);
				}
            }

			console.debug("[GridMultipleItems] openDialogFromExistingItem end");
		},	
		editGridData: function(items, request){
			console.debug("editPopup started");
			var decodedValue = dojox.html.entities.decode(items[0].content[0], dojox.html.entities.html);
			var callBack = function(){
				var i = 0;
				dijit.byId("narrative_description_goods_popup").set("disabled",false);
				if(misys._config.codeword_enabled == true){
					if(items[0].verb[0] == "REPALL"){
						dijit.byId("adr_3").set("disabled",false);
						dijit.byId("adr_3").set("value","REPALL");
						dijit.byId("adr_1").set("disabled",false);
						dijit.byId("adr_2").set("disabled",false);
						dijit.byId("narrative_description_goods_popup").set("value","/REPALL/"+decodedValue);
					}
		
					if(items[0].verb[0] == "DELETE"){
						dijit.byId("adr_2").set("disabled",false);
						dijit.byId("adr_2").set("value","DELETE");
						dijit.byId("adr_3").set("disabled",true);
						dijit.byId("narrative_description_goods_popup").set("value","/DELETE/"+decodedValue);
					}
		
					if(items[0].verb[0] == "ADD"){
						dijit.byId("adr_1").set("disabled",false);
						dijit.byId("adr_1").set("value","ADD");
						dijit.byId("adr_3").set("disabled",true);
						dijit.byId("narrative_description_goods_popup").set("value","/ADD/"+decodedValue);
					}
				}else{
					dijit.byId("narrative_description_goods_popup").set("value", decodedValue);
				}
				dijit.byId("amendments").grid.store.deleteItem(items[0]);
			};
			misys.dialog.show("CONFIRMATION",misys.getLocalization("confirmEditGridRecord"),'',callBack);
		},
		
		activateDialog: function(){
			console.debug("[GridMultipleItems] activateDialog start");
			misys.dialog.isActive = true;
		},

		cloneArray : function (arr) {
			var arr1 = []; 
			for (var property in arr) {
				arr1[property] = arr[property];
			}
			return arr1;
		},

		checkDialog: function()
		{
			console.debug("[GridMultipleItems] checkDialog start");
			if(!this.dialog)
			{
				var dialogWidget = dijit.byId(this.dialogId); 
				if(dialogWidget)
				{
					this.dialog = dialogWidget; 
				}
				else
				{
					var id = this.dialogId ? this.dialogId : 'dialog-' +
							(xmlTag ? xmlTag + '-' : '') + dojox.uuid.generateRandomUuid();
					var dojoClass = this.dialogClassName ? this.dialogClassName : 'misys.widget.Dialog';
		    		this.dialog = dojo.eval("new " + dojoClass + "({}, dojo.byId('" + id + "'))");
		    		this.dialog.set("refocus", false);
		    		this.dialog.set("draggable", false);
		    		dojo.addClass(this.dialog.domNode, "multipleItemDialog");
		    		this.dialog.startup();
		    		document.body.appendChild(this.dialog.domNode);
				}
			}
			console.debug("[GridMultipleItems] checkDialog end");
			
			return this.dialog;
		},
		
		dialogExecute: function(formContents)
		{
			// summary: 
			// 		This is the function called when the OK button is pressed in the dialog
			// 		Override if necessary.
			console.debug("[GridMultipleItems] execute start 200ms");
			
			// We need to wait because the grid is not immediatly updated
			setTimeout(dojo.hitch(this.gridMultipleItemsWidget, "updateData"), 500);
			console.debug("[GridMultipleItems] execute end");
		},
		
		performValidation: function()
		{
			console.debug("[GridMultipleItems] validate start");
			if (this.validateDialog()){
				this.dialog._onSubmit();
			}
			console.debug("[GridMultipleItems] validate end");
		},
		
		addItem: function(event)
		{
			console.debug("[GridMultipleItems] addItem start");
			
			// Disable dialog events
			misys.dialog.isActive = false;
		
			// Check Dialog widget
			this.checkDialog();
		
			// Set dialog title
			this.dialog.set('title', this.dialogAddItemTitle);
		
			// Reset dialog fields
			this.resetDialog();

			var widgets = this.dialog.getChildren();
			dojo.some(widgets, function(widget){
				if (widget.grid)
				{
					widget.renderSections();
				}
			});
			// Attach current widget to dialog widget
			this.dialog.gridMultipleItemsWidget = this;
			
			this.dialog.execute = this.dialogExecute;
			
			// Show dialog
			this.dialog.show();
			
			if(this._itemFields && this._itemFields['product_name'])
			{
				this._itemFields['product_name'] = dojox.html.entities.encode(this._itemFields['product_name'], dojox.html.entities.html);
			}
			
			if(this._itemFields && this._itemFields['cust_ref_id'])
			{
				this._itemFields['cust_ref_id'] = dojox.html.entities.encode(this._itemFields['cust_ref_id'], dojox.html.entities.html);
			}
			
			if(this._itemFields && this._itemFields['other_type'])
			{
				this._itemFields['other_type'] = dojox.html.entities.encode(this._itemFields['other_type'], dojox.html.entities.html);
			}
			
			if(dojo.byId("pooling_enabled_row"))
			{
				console.log(dojo.byId("pooling_enabled_row"));
				dojo.style(dojo.byId("pooling_enabled_row"), 'display', 'none');
			}
			if(dojo.byId("sweeping_enabled_row"))
			{
				dojo.style(dojo.byId("sweeping_enabled_row"), 'display', 'none');
			}
			if(dojo.byId("charge_account_for_liq_row"))
			{
				dojo.style(dojo.byId("charge_account_for_liq_row"), 'display', 'none');
			}
			
			// Activate dialog events
			setTimeout(dojo.hitch(this, "activateDialog"), 500);
		
			console.debug("[GridMultipleItems] addItem end");
		},
		
		setDialogFieldRequired: function(){
			misys.toggleFields(true, null, this.requiredField, true, true);
		},
		
		setDialogFieldUnrequired: function(){
			misys.toggleFields(false, null, this.requiredField, true, true);
		},
		
		resetDialog: function()
		{
			var widgets = this.dialog.getChildren();
			dojo.forEach(widgets, function(widget){
				var declaredClass = widget.declaredClass;
				switch(declaredClass)
				{
					case 'dijit.form.RadioButton':
						widget.set('checked', false);
						break;
					case 'dijit.form.CheckBox':
						widget.set('checked', false);
						break;
					case 'dijit.form.DateTextBox':
						widget.set('value', null);
						break;
					default:
						// for hidden fields, do not reset the value
						if (widget.get('type') === 'hidden'){
							break;
						}
						widget.set('value', '');
						widget.state = '';
						if(widget._setStateClass){
							widget._setStateClass();
						}
						break;
				}
				//remove blurred of validation
				widget._hasBeenBlurred= false;
				// Clear also all grids
				if (widget.grid && widget.grid.declaredClass === 'misys.grid.DataGrid')
				{
					widget.clear();
				}
			});
			if(this.dialog.gridMultipleItemsWidget)
			{
				this.dialog.gridMultipleItemsWidget = null;
			}
			if(this.dialog.storeId)
			{
				this.dialog.storeId = null;
			}
			
			for(elm in this.handle){
				dojo.disconnect(this.handle[elm]);
			}
			this.handle = [];
		},
		
		_retrieveItemFields: function()
		{
			console.debug("[GridMultipleItems] _retrieveItemFields start");
			
			var widgets = this.dialog.getChildren();
			var itemFields = {};
		
			// First, look for the widget's properties
			for(var i = 0, len = this.gridColumns.length; i < len; i++)
			{
				var property = this.gridColumns[i];
				var searchedWidgetId = (this.propertiesMap[property] && this.propertiesMap[property]._fieldName ? this.propertiesMap[property]._fieldName : property);
				console.debug("[GridMultipleItems] _retrieveItemFields - Property: " + property + ", Widget id: " + searchedWidgetId);
				itemFields = this._retrieveWidgetsValues(widgets, property, searchedWidgetId, itemFields);
			}
			
			console.debug("[GridMultipleItems] _retrieveItemFields end");
			return itemFields;
		},
		
		_retrieveWidgetsValues: function(widgets, property, searchedWidgetId, itemFields)
		{
			dojo.some(widgets, function(widget){
				if(widget.id === searchedWidgetId || widget.name === searchedWidgetId)
				{
					var value = '';
					var declaredClass = widget.declaredClass;
					
					if (widget.isInstanceOf(misys.grid.GridMultipleItems))
					{
						// For GridMultipleItem widgets, the store contains the JSON data for this widget
						value = this._extractJSON(widget);
						if (value._values.is_valid && value._values.is_valid === "N")
						{
							itemFields.is_valid = "N";
						}
					}
					else
					{
						switch(declaredClass)
						{
							case 'dijit.form.DateTextBox':
								value = widget.get('displayedValue');
								break;
							case 'dijit.form.CheckBox':
								value = widget.get('checked') === true ? 'Y' : 'N';
								break;
							case 'dijit.form.RadioButton':
								var radioDomNodes = dojo.query("[name='" + widget.name + "']", this.dialog.domNode);
								dojo.some(radioDomNodes, function(radioDomNode){
									var radioWidget = dijit.byNode(radioDomNode.parentNode);
									var checked = radioWidget.get('checked'); 
									if (checked)
									{
										value = radioWidget.params.value;
										return true;
									}
								});
								break;
							case 'dijit.form.NumberTextBox':
								console.debug("[GridMultipleItems] _retrieveWidgetsValues NumberTextBox :" + widget.get('value'));
								value = isNaN(widget.get('value'))?"":widget.get('value');
								break;
							case 'misys.form.PercentNumberTextBox':
								console.debug("[GridMultipleItems] _retrieveWidgetsValues PercentNumberTextBox :" + widget.get('value'));
								value = isNaN(widget.get('value'))?"":widget.get('value');
								break;
							case 'misys.form.SpreadTextBox':
								console.debug("[GridMultipleItems] _retrieveWidgetsValues SpreadTextBox :" + widget.get('value'));
								value = isNaN(widget.get('value'))?"":widget.get('value');
								break;
							case 'misys.form.CurrencyTextBox':
								console.debug("[GridMultipleItems] _retrieveWidgetsValues CurrencyTextBox :" + widget.get('value'));
								value = widget.get('displayedValue');
								break;
							default:
								value = widget.get('value');
								value += '';
								break;
						}
					}
					
					if(value == null)
					{
						value = '';
					}
					itemFields[property] = value;
					console.debug("[GridMultipleItems] _retrieveItemFields - Property: " + property + ", Widget id: " + searchedWidgetId + ", Value: " + value);
					return true;
				}
				else if (widget.declaredClass === 'dijit.form.Form')
				{
					var widgets = widget.getChildren();
					itemFields = this._retrieveWidgetsValues(widgets, property, searchedWidgetId, itemFields);
				}
				return false;
			}, this);
			return itemFields;
		},
		
		_extractJSON: function(widget)
		{
			var type = widget.declaredClass;
			var json = { _type: type, _values: [] };
			if (widget && widget.grid && widget.grid.store)
			{
				widget.store.fetch({query: {store_id: '*'}, onComplete: function(items, request){
	    			dojo.forEach(items, function(item){
	    				json._values.push(widget._cloneSingleItem(item));
	    			});
	    		}});
			}
			return json;
		},
		
		_retrieveGridData: function(widgets, itemFields)
		{
			dojo.forEach(widgets, function(widget){
				var declaredClass = widget.declaredClass;
				if(widget.grid)
				{
					var widgetValues = [];
					widget.store.fetch({query: {store_id: '*'}, onComplete: dojo.hitch(this, function(items, request){
		    			dojo.forEach(items, function(item){
		    				var tempItem = widget._cloneSingleItem(item);
		    				widgetValues.push(tempItem);
		    			});
		    		})});
					itemFields[declaredClass] = widgetValues;
				}
				else if (widget.declaredClass === 'dijit.form.Form')
				{
					var widgets = widget.getChildren();
					itemFields = this._retrieveGridData(widgets, itemFields);
				}
			}, this);
			return itemFields;
		},
		
		// Clone an item but without copying internal datastore properties
		_cloneMultipleItems: function(items){
			var cloneItems = [];
			dojo.forEach(items, function(item){
				var isArray = dojo.isArray(item);
				item = dojo.isArray(item) ? item[0] : item;
				var cloneItem = {};
				for (var property in item)
				{
					if(dojo.some(this.gridColumns, function(gridColumn){
						return gridColumn == property;
					}))
					{
						if (property.match('^misys.openaccount.widget.')=='misys.openaccount.widget.')
						{
							var tempWidget = dojo.eval('new ' + property + '()');
							var tempItem = tempWidget._cloneItem(item[property]);
							cloneItem[property] = tempItem;
						}
						else
						{
							if(property.match('^_') !== '_')
							{
								cloneItem[property] = dojo.isArray(item[property]) ? item[property][0] : item[property];
							}
						}
					}
				}
				cloneItems.push(cloneItem);
			}, this);
			return cloneItems;
		},
		
		// Clone an item but without copying internal datastore properties
		_cloneSingleItem: function(item){
			var isArray = dojo.isArray(item);
			item = dojo.isArray(item) ? item[0] : item;
			var cloneItem = {};
			for (var property in item)
			{
				if(dojo.some(this.gridColumns, function(gridColumn){
					return gridColumn == property;
				}))
				{
					if(property.match('^_') !== '_')
					{
						cloneItem[property] = dojo.isArray(item[property]) ? item[property][0] : item[property];
					}
				}
			}
			return isArray ? [cloneItem] : cloneItem;
		},
		
		// Clone an item but without copying internal datastore properties and store_id field
		_cloneItemWithoutStoreId: function(item){
			var isArray = dojo.isArray(item);
			item = dojo.isArray(item) ? item[0] : item;
			var cloneItem = {};
			for (var property in item)
			{
				if(dojo.some(this.gridColumns, function(gridColumn){
					return gridColumn == property;
				}))
				{
					if (property.match('^misys.openaccount.widget.')=='misys.openaccount.widget.')
					{
						var tempWidget = dojo.eval('new ' + property + '()');
						var tempItem = tempWidget._cloneItem(item[property]);
						cloneItem[property] = tempItem;
					}
					else if (property !== 'store_id')
					{
						if(property.match('^_') !== '_')
						{
							cloneItem[property] = dojo.isArray(item[property]) ? item[property][0] : item[property];
						}
					}
				}
			}
			return isArray ? [cloneItem] : cloneItem;
		},		
		
		updateData: function()
		{
			console.debug("[GridMultipleItems] updateData start");

			// retrieve item values from the dialog
			var storeId = this.dialog.storeId;
			
			//TODO: try to remove this internal property (used because we don't know how to pass a parameter to store.fetch method
			this._itemFields = this._retrieveItemFields();	
		
			this._itemFields['store_id'] = (storeId != null ? storeId : dojox.uuid.generateRandomUuid());
			if(this._itemFields && this._itemFields['product_name'])
			{
				this._itemFields['product_name'] = dojox.html.entities.encode(this._itemFields['product_name'], dojox.html.entities.html);
			}
			
			if(this._itemFields && this._itemFields['cust_ref_id'])
			{
				this._itemFields['cust_ref_id'] = dojox.html.entities.encode(this._itemFields['cust_ref_id'], dojox.html.entities.html);
			}
			
			if(this._itemFields && this._itemFields['other_type'])
			{
				this._itemFields['other_type'] = dojox.html.entities.encode(this._itemFields['other_type'], dojox.html.entities.html);
			}
			
			// Mark the item as valid or invalid based on:
			//	- the mandatory fields for this item 
			//	- the validity of underlying sub-items
			var areAllMandatoryFieldsFilled = this.checkMandatoryProperties(this._itemFields);
			var areSubItemsValid = this.checkSubItemsValidity();
			this._itemFields['is_valid'] = areAllMandatoryFieldsFilled && areSubItemsValid ? "Y" : "N";
			
			// Hide the label section and show the grid section
			// as it must be displayed in order to instantiate the Dojo DataGrid.
			dojo.attr(this.itemsNode, 'style', { display: 'block' });
			dojo.attr(this.noItemLabelNode, 'style', { display: 'none' });
			
			// Update the grid
			if (this.grid)
			{
				this.grid.store.fetch({
					query: {store_id: storeId}, 
					onComplete: dojo.hitch(this, function(items, request){
						if (items.length > 0)
						{
							var item = items[0];
							for (var property in this._itemFields)
							{
								var value = this._itemFields[property];
								if ((value != null && value != undefined) && property != 'store_id')
								{
									this.grid.store.setValue(item, property, value);
								}
							}
						}
						else
						{
							this.grid.store.newItem(this._itemFields);
						}
					})
				});
		
		        // Unselect all rows
		        var items = this.grid.selection.getSelected();
		        if (items.length) {
		            // Iterate through the list of selected items
		        	// and unselect them
		            dojo.forEach(items, function(selectedItem) {
		                if (selectedItem !== null) {
		                    // Delete the item from the data store:
		                    this.grid.selection.setSelected(selectedItem, false);
		                }
		            }, this);
		        }    	            
			}
			else
			{
				// Create data store
				var data_list = [this._itemFields];
		    	var data = {
		    			identifier: 'store_id',
		    			label: 'store_id',
		    			items: data_list
		    		};
		
				this.store = new dojo.data.ItemFileWriteStore({data: data, typeMap: this.typeMap});
				this.createDataGrid();
				// Very important: DO NOT call this here because it is already called in createDataGrid ==> it will delete an attachment twice !!!
				//this.grid.startup();  //Don't call startup as it has always been called in createDataGrid
			}
			this.grid.store.save();
			this.grid.render();
			console.debug("[GridMultipleItems] updateData end");
		},
		
		createDataStoreFromNewItemCommand: function(newItemCommand)
		{
			console.debug("[GridMultipleItems] create data store from new item command");
			dojo.eval("this.data.items = [{store_id: '0', " + newItemCommand + "}]");
			
			this.store = new dojo.data.ItemFileWriteStore({ data: this.data });
		},
		
		clear: function()
		{
			if(this.grid && this.grid.store)
			{
				this.grid.store.fetch(
						{
							query: {store_id: '*'},
							onComplete: dojo.hitch(this, function(items, request){
								dojo.forEach(items, function(item){
									this.grid.store.deleteItem(item);
								}, this);
							})
						}
				);
				this.grid.store.save();
				
				var that = this;
				setTimeout(function(){
					that.renderSections();
					that.grid.render();	
				}, 200);
			}
		},
		
		renderAll: function()
		{
			this.renderSections();
			if (this.grid)
			{
				this.grid.render();
			}
		},
    	
		createItem: function()
		{
			if(this.hasChildren && this.hasChildren())
			{
				var items = [];
				dojo.forEach(this.getChildren(), function(child){
					if (child.createItem)
					{
						items.push(child.createItem());
					}
				}, this);
				
				var item = {};
				item[this.declaredClass] = items;
				return item;
			}
			return null;
		},

		toXML: function(){
			var xml = [];
			
			if(this.xmlTagName) {
				xml.push("<", this.xmlTagName, ">");
			}
			if(this.grid)
			{
				this.grid.store.fetch({query: {store_id: '*'}, 
						onComplete: dojo.hitch(this, function(items, request){
					xml.push(this.itemToXML(items, this.xmlSubTagName));
				})});
			}
			if(this.xmlTagName) {
				xml.push("</", this.xmlTagName, ">");
			}
			
			return xml.join("");
		},
        
		itemToXML: function(items, xmlSubTagName)
		{
			var xml = [];
			dojo.forEach(items, function(item){
				if(item) {
					if(xmlSubTagName) {
						xml.push("<", xmlSubTagName, ">");
					}
					for(var property in item)
					{
						// Process a sub-grid included in this item
						var value = dojo.isArray(item[property]) ? item[property][0] : item[property];
						if (dojo.isObject(value) && value._type)
						{
							var classname = value._type;
							var clazz = dojo.eval(classname);
							var multipleItems = new clazz({});
							xml.push('<', multipleItems.xmlTagName, '>');
							if(value._values)
							{
								xml.push(this.itemToXML(value._values, multipleItems.xmlSubTagName, xml));
							}
							else if(value._value)
							{
								xml.push(this.itemToXML(value._value, multipleItems.xmlSubTagName, xml));
							}
							xml.push('</', multipleItems.xmlTagName ,'>');
						}
						// Otherwise, process a property of the item 
						else if(property != 'store_id' && property.match('^_') != '_')
						{
							value = dojo.isArray(item[property]) ? item[property][0] : item[property];
							value += '';
							xml.push('<', property, '>', dojox.html.entities.encode(value, dojox.html.entities.html), '</', property, '>');
						}
					}
					if(xmlSubTagName) {
						xml.push('</', xmlSubTagName, '>');
					}
				}
			}, this);
							
			return xml.join("");
		},

		createItemsFromJson: function(jsonMsg)
		{
			var item;
			
			myData = dojo.fromJson(jsonMsg);
			this.dataList = [];
			for(item in myData.items){
				if(myData.items[item].ref_id) {
					this.dataList.push(myData.items[item]);
				}
			}

			if(this.dataList.length > 0)
			{
				// Create data store
				this.createDataStoreFromDataList();
				// Create data grid
				this.createDataGrid();
			}

		},
		
		createJsonItem: function()
		{
			var jsonEntry = [];
			if(this.hasChildren && this.hasChildren())
			{
				dojo.forEach(this.getChildren(), function(child){
					if (child.createJsonItem)
					{
						var mandatoryFields = this.getMandatoryProperties(child);
						var item = child.createJsonItem(this.propertiesMap, mandatoryFields);
						jsonEntry.push(item);
						if (this.get("is_valid") !== "N")
						{
							this.set("is_valid", item.is_valid ? item.is_valid : "Y");
						}
						misys._widgetsToDestroy = misys._widgetsToDestroy || [];
						misys._widgetsToDestroy.push(child.id);
					}
				}, this);
			}
			return jsonEntry;
		},

		isWidgetToBeDestroyed: function(widget)
		{
			var foundWidget = false;
			if (misys._widgetsToDestroy)
			{
				dojo.some(misys._widgetsToDestroy, function(widgetIdToDestroy){
					if (widgetIdToDestroy === widget.id)
					{
						foundWidget = true;
						return false;
					}
				});
			}
			return foundWidget;
		},
		
		destroyWidgets: function()
		{
			if (misys._widgetsToDestroy) {
				dojo.forEach(misys._widgetsToDestroy, function(widgetIdToDestroy){
					if (dijit.byId(widgetIdToDestroy))
					{
						dijit.byId(widgetIdToDestroy).destroyRecursive();
					}
				});
			}
		},
		
		validate: function() {
			if(this.store) {
				var inError = dojo.some(this.store._arrayOfAllItems, function(item) {
					if(item && item.is_valid) {
						return item.is_valid[0] !== "Y";
					}
					return false;
				});
	
				
				return !inError;
			} else if (this.is_valid) {
				return (this.is_valid === "Y");
			}
			
			return true;
		},
		
		validateDialog: function(/*Boolean*/ doRealValidation){
			// summary:
			//		returns if all field in parameter is valid .
			//		1 - it will highlight any sub-widgets that are not
			//			valid
			//		2 - it will call focus() on the first invalid
			//			sub-widget

			// We override this standard function as it currently does not deal with
			// fields that are in closed tabs. Moreover, we add a little smooth
			// scrolling for browsers that can handle it.
			var allValid = true,
				didFocus = false,
				widgets = this.dialog.getChildren();

			if(!doRealValidation) {
				var isDialogValid = dojo.every(widgets, function(w){
					return (w.disabled || !w.validate || w.validate());
		 		});
				this.is_valid = (isDialogValid)? "Y" : "N";
				this.state = (isDialogValid) ? "" : "Error";
				allValid = true;
			} else {
				dojo.some(widgets, function(widget){
				// Need to set this so that "required" widgets get their state set.

				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if(!valid && !didFocus) {
					// Set focus of the first non-valid widget
					
					// If the field is in a tabcontainer, select the correct tab
					if(widget.hasOwnProperty("parentTab")) {
						dijit.byId(widget.get("tabContainer")).selectChild(widget.get("parentTab"));
					}
					
					dojo.window.scrollIntoView(widget.containerNode || widget.domNode);
					
					// Grids cannot be focused
					if(widget.focus) {
						widget.focus();
					}
					didFocus = true;
				}
	 			if (!valid) {
	 				allValid = false;
	 			}
			  });
			}
			
			return allValid;
		},
		
		collectRequiredField: function(){
			this.checkDialog();
			var widgets = this.dialog.getChildren();
			var localRequiredFields=[];
			dojo.some(widgets, function(widget){
				if (widget.required){
					localRequiredFields.push(widget.id);
				}
			});
			this.requiredField=localRequiredFields;
		},

		checkMandatoryProperties: function(item)
		{
			var mandatoryFields = this.getMandatoryProperties(item);
			var areMandatoryFieldsMissing = dojo.some(mandatoryFields, dojo.hitch(this, function(mandatoryField){
				var value = item[mandatoryField];
				if (typeof value !== 'undefined')
				{
					value = dojo.isArray(value) ? value[0] : value;
					return (value == null || value === "");					
				}
			}));
			return !areMandatoryFieldsMissing;
		},
		
		checkSubItemsValidity: function()
		{		
			// Look for sub-item elements and check their validity
			for(var property in this._itemFields)
			{
				var value = this._itemFields[property];
				if (value._type && value._values)
				{
					var isSubItemInvalid = dojo.some(value._values, dojo.hitch(this, function(item){
						if (item.is_valid)
						{
							var isValid = dojo.isArray(value) ? item.is_valid[0] : item.is_valid;
							return (isValid === "N");
						}
						return false;
					}));
					if (isSubItemInvalid)
					{
						return false;
					}
				}
			}
			return true;
		}
	}
);

}

if(!dojo._hasResource["misys.product.widget.AttachmentFiles"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.product.widget.AttachmentFiles"] = true;
dojo.provide("misys.product.widget.AttachmentFiles");
dojo.experimental("misys.product.widget.AttachmentFiles"); 


// our declared class
dojo.declare("misys.product.widget.AttachmentFiles",
        [ misys.grid.GridMultipleItems ],
        // class properties:
        {
		data: { identifier: 'store_id', label: 'store_id', items: [] },
	
        templatePath: null,
        templateString: '',
        dialogId: 'file-attachment-dialog-template',
        xmlTagName: 'attachments',
        xmlSubTagName: 'attachment',
        attachmentGroup: '',
        dialogOKCallback: '',
        showStatusColumn: '',
        
        viewMode: 'edit',
        
        gridColumns: [ 'attachment_id', 'file_type', 'file_title', 'file_name', 'file_status', 'file_access_dttm', 'file_description', 'fileact' ],
        
        propertiesMap: {},
        
        maxFiles : 0,
        
        fileActVisible : false,
        
        addItem: function(event)
		{
        	var that = this;
			var inherit = false;
			if(that.grid && that.grid.store && that.maxFiles !== 0 && misys._config.isCustUser)
			{
				that.grid.store.fetch({ onBegin: function(total){ 
						if(total < that.maxFiles)
						{
							inherit = true;	
						}
						else
						{
							misys.dialog.show("ERROR",misys.getLocalization("maxFileUploadReached"));
						}
					} 
				});
			}
			else
			{
				inherit = true;
			}
			if(inherit)
			{
				that.inherited(arguments);
                dojo.forEach(dijit.byId('sendfiles' + this.attachmentGroup).getChildren(), function(widget){
                if (widget.name != 'attachment-type'){
                        widget.set('value', '');
                        widget.set('state', '');
                }
                else {
                    widget.set('value', dijit.byId('attachment-type').get('_resetValue'));
            }});
            }
        },
        
        layout: [],
        
		dialogExecute: function(formContents)
		{
			// summary: 
			// 		This is the function called when the OK button is pressed in the dialog
			// 		Override if necessary.
			console.debug("[AttachmentFiles] execute start 200ms");
			
			// We need to wait because the grid is not immediatly updated
			setTimeout(dojo.hitch(this.gridMultipleItemsWidget, "updateData"),500);
			var callback = this.gridMultipleItemsWidget.dialogOKCallback;
			console.debug("dialogOKCallback" + callback);
			setTimeout(function(){
				dojo.eval(callback);
			}, 600);
			console.debug("[AttachmentFiles] execute end");
		},
                 
                 
    	startup: function(){
    		if(this._started) { return; }
			console.debug("[AttachmentFiles] startup start");
			var tempGroup = this.attachmentGroup;
			if (this.attachmentGroup !== '')
			{
				this.templateString = dojo.byId('file-attachment-template'+ this.attachmentGroup).innerHTML;
				
				this.dialogId = 'file-attachment'+ this.attachmentGroup +'-dialog-template';
				
				this.xmlTagName = 'attachments-' + this.attachmentGroup;
				
				this.propertiesMap = {
				       	attachment_id: {_fieldName:'attachment_id' + tempGroup },
				       	file_type: {_fieldName:'file_type' + tempGroup },
				       	file_title: {_fieldName:'file_title' + tempGroup },
				       	file_name: {_fieldName:'file_name' + tempGroup },
				       	file_status: {_fieldName:'file_status' + tempGroup },
				       	file_status_decoded: {_fieldName:'file_status_decoded' + tempGroup },
				       	file_access_dttm: {_fieldName:'file_access_dttm' + tempGroup },
				       	file_description: {_fieldName:'file_description' + tempGroup }
						};
			}
			var viewModeTemp = this.viewMode;
			var fileact = {
				    name: 'FileAct',
				    field: 'fileact', 
				    get: function (inRowIndex, inItem){
				       // if this row is selected, then check the checkbox.
				       var isSel = this.grid.selection.isSelected(inRowIndex);
				       if(inItem && inItem.fileact && inItem.fileact[0] === 'Y' && !misys.isFormDirty)
				       {
				    	   isSel = true;
				    	   this.grid.selection.addToSelection(inRowIndex);
				       }
				       var html = '<input type="checkbox"' + (isSel ? ' checked="checked"' : '') + " />";
				       return html;
				    },
				    formatter: misys.grid.formatHTML,
				    width: '5%',
				    noresize:true,
				    styles: 'text-align: center;'
				 };
			
			this.layout = [
			                 { name: 'Picture', field: 'file_name', formatter: function(value){return misys.getFileIcon(value);}, width: '5%',noresize:true },
			                 { name: 'Title', field: 'file_title', width: '35%' ,noresize:true},
			                 { name: 'FileName', field: 'file_name', width: '35%',noresize:true ,  formatter : function(value){return misys.grid.formatSimpleHTML(value);} },
			                 { name: ' ', field: 'attachment_id', formatter: function(value){return misys.formatFileActions(value, tempGroup);}, width: '10%' ,noresize:true},
			                 fileact
			                 ];
			
			if (this.viewMode == 'view')
			{
				// status column is displayed in summary popup for transaction sent via SWIFT
				// This is related with SWIFT MT798 support
				if (this.showStatusColumn == "true"){
					this.layout = [
					                 { name: ' ', field: 'file_name', formatter: function(value){return misys.getFileIcon(value);}, width: '5%',noresize:true },
					                 { name: 'Title', field: 'file_title', width: '30%' ,noresize:true},
					                 { name: 'FileName', field: 'file_name', width: '30%' ,noresize:true, formatter : function(value){return misys.grid.formatSimpleHTML(value);} },
					                 { name: 'Status', field: 'file_status_decoded', width: '5%' ,noresize:true},
					                 { name: ' ', field: 'attachment_id', formatter: function(value){return misys.formatFileViewActions(value, tempGroup);}, width: '10%' ,noresize:true},
					                 { name: 'FileAct', field: 'fileact', width: '5%',noresize:true, styles: 'text-align: center;',
					                   formatter: function(text){
					                	   if(text === 'Y')
					                	   {
					                		   return 'Yes';
					                	   }
					                	   else if(text === 'Z')
					                	   {
					                		   return 'NA';
					                	   }
					                	   else
					                	   {
					                		   return 'No';
					                	   }
					                   }	 
					                 }
					              ];					
				}else{
					this.layout = [
					                 { name: ' ', field: 'file_name', formatter: function(value){return misys.getFileIcon(value);}, width: '5%',noresize:true },
					                 { name: 'Title', field: 'file_title', width: '30%' ,noresize:true},
					                 { name: 'FileName', field: 'file_name', width: '35%' ,noresize:true , formatter : function(value){return misys.grid.formatSimpleHTML(value);}},
					                 { name: ' ', field: 'attachment_id', formatter: function(value){return misys.formatFileViewActions(value, tempGroup);}, width: '10%' ,noresize:true},
					                 { name: 'FileAct', field: 'fileact', width: '5%',noresize:true, styles: 'text-align: center;',
					                   formatter: function(text){
					                	   if(text === 'Y')
					                	   {
					                		   return 'Yes';
					                	   }
					                	   else if(text === 'Z')
					                	   {
					                		   return 'NA';
					                	   }
					                	   else
					                	   {
					                		   return 'No';
					                	   }
					                   }	 
					                 }
					            ];
				}
			}
			
			
			// Prepare data store
			this.dataList = [];
			if(this.hasChildren())
			{
				dojo.forEach(this.getChildren(), function(child){
					var item = { 
							attachment_id: child.get('attachment_id'),
							file_type: child.get('file_type'),
							file_title: child.get('file_title'),
							file_name: child.get('file_name'),
							file_status: child.get('file_status'),
							file_status_decoded: child.get('file_status_decoded'),
							file_access_dttm: child.get('file_access_dttm'),
							file_description: child.get('file_description'),
							fileact : child.get('fileact')};
				    
					this.dataList.push(item);
				}, this);
			}
			
			dojo.parser.parse(this.dialogId);
			
    		this.inherited(arguments);
    		
			console.debug("[AttachmentFiles] startup end");
    	},
    	onGridCreate: function() {
    		var that = this;
    		dojo.connect(that.grid, 'onSelected', function (inRowIndex)
       		{
    			that.grid.updateRow(inRowIndex);
       		});
       		dojo.connect(that.grid, 'onDeselected', function (inRowIndex)
       		{
       			that.grid.updateRow(inRowIndex);
       		});
       		
       	    // Make clicking the check box changed the selection state.
       		dojo.connect(that.grid, 'onCellClick', function (evt)
       		{
       		    var t = evt.target;
       		    if ( t.tagName.toLowerCase() == 'input' && t.type == 'checkbox' )
       		    {
       		    	misys.isFormDirty = true;
       		    	var funcName = t.checked ? "addToSelection" : "deselect";
       		        that.grid.selection[funcName](evt.rowIndex);
       		        
       		    }
       		}); 

       		// And finally, disable the standard behavior of selecting by clicking the row
       		that.grid.selection.clickSelectEvent = function () { };
       		if (this.viewMode === 'edit' && ((typeof deliveryChannelFileAct !== "undefined") && (deliveryChannelFileAct !== false)))
			{
       			that.displayFileAct(true);
			}
       		else if (this.viewMode === 'edit')
			{
       			that.displayFileAct(false);
			}
       		else
       		{
       			if((typeof deliveryChannelFileAct !== "undefined") && (deliveryChannelFileAct) && (this.attachmentGroup !== "summarybank"))
       			{
       				that.displayFileAct(true);
       			}
       			else
       			{
       				that.displayFileAct(false);
       			}
       		}
		},
		createDataGrid: function()
		{
			var gridId = this.gridId;
			if(!gridId)
			{
				gridId = 'grid-' + 
							(this.xmlTagName ? this.xmlTagName + '-' : '') + 
							dojox.uuid.generateRandomUuid();
			}
			this.grid = new misys.grid.DataGrid({
				jsId: gridId,
				id: gridId,
				store: this.store,
				structure: this.layout,
				autoHeight: true,
				selectionMode: 'multiple',
				columnReordering: true,
				autoWidth: true,
				rowsPerpage: 1000,
				initialWidth: '100%',
				canSort: function(/*int*/ colIndex){
					var sortable = true;
					if(this.layout.cells){
					var actionColumnIndex = this.layout.cellCount;
					var fileActIndex = this.layout.cellCount;
						this.layout.cells.forEach(function(item, index) {
							if(item.name){
								if (item.name === " ") {
									actionColumnIndex = index + 1;
								}
								if(item.name === "FileAct"){
									fileActIndex = index + 1;
								}
							}
						});
						sortable = (Math.abs(colIndex) !== 1 && Math.abs(colIndex) !== actionColumnIndex && Math.abs(colIndex) !== fileActIndex);
					}
					return sortable;
				},
			 	showMoveOptions:  this.showMoveOptions
			}, document.createElement("div"));
			this.grid.gridMultipleItemsWidget = this;
			
			misys.connect(this.grid, "onStyleRow" , dojo.hitch(this, function(row) {
				var item = this.grid.getItem(row.index);
       
				/*if (!this.checkMandatoryFields(item))
				{
					row.customStyles += "background-color: #F9F7BA !important";
				}*/

				if (item && item.hasOwnProperty("is_valid")) {
                	var isValid = dojo.isArray(item.is_valid) ? item.is_valid[0] : item.is_valid;
                	
                	if(isValid && isValid !== "Y") {
                		// We have to use an inline style, otherwise the row colour 
                		// changes onMouseOver
                		row.customStyles += "background-color: #F9F7BA !important";
                		this.state = "Error";
                	}
                }

                 this.grid.focus.styleRow(row);
                 this.grid.edit.styleRow(row);
            }));
			
			this.addChild(this.grid);
			this.onGridCreate();
		},
		displayFileAct : function(/*boolean*/ show){
			var that = this;
			if(that.grid.layout)
			{
				dojo.forEach(that.grid.layout.cells, function(node, index){
					if(node && node.name === 'FileAct' && show)
					{
						that.grid.layout.setColumnVisibility(node.index,true);
						that.fileActVisible = true;
					}
					else if(node && node.name === 'FileAct' && !show)
					{
						if(that.grid.selection){
							that.grid.selection.deselectAll();
						}
						that.grid.layout.setColumnVisibility(node.index,false);
						that.fileActVisible = false;
					}
				});
			}
		}
       }
);

}

if(!dojo._hasResource["misys.product.widget.AttachmentFile"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.product.widget.AttachmentFile"] = true;
dojo.provide("misys.product.widget.AttachmentFile");
dojo.experimental("misys.product.widget.AttachmentFile"); 




// our declared class
dojo.declare("misys.product.widget.AttachmentFile",
		[ dijit._Widget, dijit._Contained ],
        // class properties:
        {
        
		attachment_id: '',
		file_type: '',
		file_title: '',
		file_name: '',
		file_status: '',
		file_status_decoded: '',
		file_access_dttm: '',
		file_description: '',
		fileact: ''

       }
);

}

if(!dojo._hasResource["dojox.string.tokenize"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.string.tokenize"] = true;
dojo.provide("dojox.string.tokenize");

dojox.string.tokenize = function(/*String*/ str, /*RegExp*/ re, /*Function?*/ parseDelim, /*Object?*/ instance){
	// summary:
	//		Split a string by a regular expression with the ability to capture the delimeters
	// parseDelim:
	//		Each group (excluding the 0 group) is passed as a parameter. If the function returns
	//		a value, it's added to the list of tokens.
	// instance:
	//		Used as the "this" instance when calling parseDelim
	var tokens = [];
	var match, content, lastIndex = 0;
	while(match = re.exec(str)){
		content = str.slice(lastIndex, re.lastIndex - match[0].length);
		if(content.length){
			tokens.push(content);
		}
		if(parseDelim){
			if(dojo.isOpera){
				var copy = match.slice(0);
				while(copy.length < match.length){
					copy.push(null);
				}
				match = copy;
			}
			var parsed = parseDelim.apply(instance, match.slice(1).concat(tokens.length));
			if(typeof parsed != "undefined"){
				tokens.push(parsed);
			}
		}
		lastIndex = re.lastIndex;
	}
	content = str.slice(lastIndex);
	if(content.length){
		tokens.push(content);
	}
	return tokens;
}

}

if(!dojo._hasResource["misys.grid.TopicListenerDataGrid"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.grid.TopicListenerDataGrid"] = true;
dojo.provide("misys.grid.TopicListenerDataGrid");
dojo.experimental("misys.grid.TopicListenerDataGrid"); 







//our declared class
dojo.declare("misys.grid.TopicListenerDataGrid",
		[ dojox.grid.EnhancedGrid ],
		// class properties:
		{
	subscribe_topic: "",
	onSelectionClearedScript: "",

	startup: function()
	{
		console.debug("[TopicListenerDataGrid] startup start");
		this.inherited(arguments);
		console.debug("[TopicListenerDataGrid] startup end");
	},

	handleTopicEvent: function(event, topic)
	{


		if (this.selection && this.get('selectionMode') != '')
		{
			this.selection.clear();
		}

		console.debug("[TopicListenerDataGrid] handle event: "+event+", topic: "+topic);
		this._reloadGridForEventTerms(event);

	},

	_reloadGridForEventTerms: function(event)
	{
		// Collect the search field values from event as a JSON object
		var store = this.get('store'),
			baseURL = store.url,
			query = {};
		if(baseURL.indexOf("&") !== -1) {
			baseURL = baseURL.substring(0, baseURL.indexOf("&"));
		}		

		for(key in event) {
			if(event.hasOwnProperty(key)) {
				query[key] = event[key];
			}
		}

		store.close();
		store.url = baseURL;
		this.setStore(store, query);
	}
		}
);

}

if(!dojo._hasResource["dojox.grid.enhanced.plugins.Dialog"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.enhanced.plugins.Dialog"] = true;
dojo.provide("dojox.grid.enhanced.plugins.Dialog");




dojo.declare("dojox.grid.enhanced.plugins.Dialog", dijit.Dialog, {
	refNode: null,
	_position: function(){
		if(this.refNode && !this._relativePosition){
			var refPos = dojo.position(dojo.byId(this.refNode)),
				thisPos = dojo.position(this.domNode),
				viewPort = dojo.window.getBox();
			if(refPos.x < 0){
				refPos.x = 0;
			}
			if(refPos.x + refPos.w > viewPort.w){
				refPos.w = viewPort.w - refPos.x;
			}
			if(refPos.y < 0){
				refPos.y = 0;
			}
			if(refPos.y + refPos.h > viewPort.h){
				refPos.h = viewPort.h - refPos.y;
			}
			refPos.x = refPos.x + refPos.w / 2 - thisPos.w / 2;
			refPos.y = refPos.y + refPos.h / 2 - thisPos.h / 2;
			if(refPos.x >= 0 && refPos.x + thisPos.w <= viewPort.w &&
				refPos.y >= 0 && refPos.y + thisPos.h <= viewPort.h){
				this._relativePosition = refPos;
			}
		}
		this.inherited(arguments);
	}
});

}

if(!dojo._hasResource["dojox.grid.enhanced.plugins._StoreLayer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.enhanced.plugins._StoreLayer"] = true;
dojo.provide("dojox.grid.enhanced.plugins._StoreLayer");
// summary:
//		The dojo.data.api.Read API is powerful, but it's difficult to give the store some special commands before
//		fetch, so that the store content can be temporarily modified or transformed, and acts as another store. The
//		parameter *query* or *queryOptions* in keywordArgs for *fetch* is not enough because:
//		1.	users do not have the opportunity to response to the store actions when these options or queries are applied,
//			especially when the real store is at server side.
//		2.	the store implementation must be changed to support any new options in 'query' or 'queryOptions', so it'll be
//			difficult if this implementation is not able to or very hard to be changed, or some new options are required to
//			be valid for all stores.
//		This *StoreLayer* framework is dedicated to provide a uniform way for configuring an existing store, so that
//		it can be easily extended to have special behaviors or act like a totally different store.
//		The major approach is to wrap the *fetch* function of store, layer by layer. Every layer treats the incoming
//		store.fetch as a 'black box', thus maintaining the independence between layers.
//		*fetch* is the most important data retriever in the Read API, almost all other functions are used for a single
//		item, and require that this item is already retrieved (by and only by *fetch*). So once we've controlled this
//		*fetch* function, we've controlled almost the whole store. This fact simplifies our implementation of StoreLayer.
// example:
//		//ns is for namespace, i.e.:dojox.grid.enhanced.plugins
//		ns.wrap(ns.wrap(ns.wrap(store, new ns.FilterLayer()), new ns.UniqueLayer()), new ns.TransformLayer());
//
//		//every layer has a name, it should be given in the document of this layer.
//		//if you don't know it's name, you can get it by: ns.SomeLayer.prototype.name();
//		store.layer("filter").filterDef(...);
//		store.layer("unique").setUniqueColumns(...);
//		store.layer("transform").setScheme(...);
//
//		//now use the store as usual...
//
//		store.unwrap("transform"); //remove the transform layer but retain the other two.
//
//		//now use the store as usual...
//
//		store.unwrap(); //remove all the layers, get the original store back.
(function(){
	var ns = dojox.grid.enhanced.plugins,
	
	getPrevTags = function(tags){
		var tagList = ["reorder", "sizeChange", "normal", "presentation"];
		var idx = tagList.length;
		for(var i = tags.length - 1; i >= 0; --i){
			var p = dojo.indexOf(tagList, tags[i]);
			if(p >= 0 && p <= idx){
				idx = p;
			}
		}
		if(idx < tagList.length - 1){
			return tagList.slice(0, idx + 1);
		}else{
			return tagList;
		}
	},
	
	unwrap = function(/* string? */layerName){
		// summary:
		//		Unwrap the layers of the store
		// tags:
		//		public
		// returns:
		//		The unwrapped store, for nested use only.
		var i, layers = this._layers, len = layers.length;
		if(layerName){
			for(i = len-1; i >= 0; --i){
				if(layers[i].name() == layerName){
					layers[i]._unwrap(layers[i + 1]);
					break;
				}
			}
			layers.splice(i, 1);
		}else{
			for(i = len - 1; i >= 0; --i){
				layers[i]._unwrap();
			}
		}
		if(!layers.length){
			delete this._layers;
			delete this.layer;
			delete this.unwrap;
			delete this.forEachLayer;
		}
		//console.log("layers:",this._layers);
		return this;	//Read-store
	},
	
	getLayer = function(layerName){
		// summary:
		//		Get a layer of the store, so we can configure that layer.
		// tags:
		//		public (scope is store)
		// layerName: string
		//		the name of the layer
		// returns:
		//		the store layer object
		var i, layers = this._layers;
		if(typeof layerName == "undefined"){
			return layers.length;	//Integer
		}
		if(typeof layerName == "number"){
			return layers[layerName];	//_StoreLayer
		}
		for(i = layers.length - 1; i >= 0; --i){
			if(layers[i].name() == layerName){
				return layers[i];	//_StoreLayer
			}
		}
		return null;	//_StoreLayer
	},
	
	forEachLayer = function(callback, isInnerToOuter){
		// summary:
		//		Visit the layers one by one. From the outer most to inner most by default.
		// callback: Function
		//		The function to callback.
		//		If return false, break the loop.
		// isInnerToOuter: Boolean
		//		Whether visit from the inner most layer to the outer most layer.
		var len = this._layers.length, start, end, dir;
		if(isInnerToOuter){
			start = 0;
			end = len;
			dir = 1;
		}else{
			start = len - 1;
			end = -1;
			dir = -1;
		}
		for(var i = start; i != end; i += dir){
			if(callback(this._layers[i], i) === false){
				return i;
			}
		}
		return end;
	};
	ns.wrap = function(store, funcName, layer, layerFuncName){
		// summary:
		//		Wrap the store with the given layer.
		// tags:
		//		public
		// store: Read-store
		//		The store to be wrapped.
		// layer: _StoreLayer
		//		The layer to be used
		// returns
		//		The wrapped store, for nested use only.
		if(!store._layers){
			store._layers = [];
			store.layer = dojo.hitch(store, getLayer);
			store.unwrap = dojo.hitch(store, unwrap);
			store.forEachLayer = dojo.hitch(store, forEachLayer);
		}
		var prevTags = getPrevTags(layer.tags);
		if(!dojo.some(store._layers, function(lyr, i){
			if(dojo.some(lyr.tags, function(tag){
				return dojo.indexOf(prevTags, tag) >= 0;
			})){
				return false;
			}else{
				store._layers.splice(i, 0, layer);
				layer._wrap(store, funcName, layerFuncName, lyr);
				return true;
			}
		})){
			store._layers.push(layer);
			layer._wrap(store, funcName, layerFuncName);
		}
		//console.log("wrapped layers:", dojo.map(store._layers, function(lyr){return lyr.name();}));
		return store;	//Read-store
	};

	dojo.declare("dojox.grid.enhanced.plugins._StoreLayer", null, {
		// summary:
		//		The most abstract class of store layers, provides basic utilities and some interfaces.
		// tags:
		//		abstract
/*=====
		// _store: [protected] Read-store
		//		The wrapped store.
		_store: null,
		
		// _originFetch: [protected] function
		//		The original fetch function of the store.
		_originFetch: null,
		
		// __enabled: [private] Boolean
		//		To control whether this layer is valid.
		__enabled: true,
=====*/
		tags: ["normal"],
		
		layerFuncName: "_fetch",
		
		constructor: function(){
			this._store = null;
			this._originFetch = null;
			this.__enabled = true;
		},
		initialize: function(store){
			// summary:
			//
		},
		uninitialize: function(store){
			// summary:
			//
		},
		invalidate: function(){
			
		},
		_wrap: function(store, funcName, layerFuncName, nextLayer){
			// summary:
			//		Do the actual wrapping (or 'hacking' if you like) to the store.
			// tags:
			//		internal
			// store: Read-store
			//		The store to be wrapped.
			this._store = store;
			this._funcName = funcName;
			var fetchFunc = dojo.hitch(this, function(){
				return (this.enabled() ? this[layerFuncName || this.layerFuncName] : this.originFetch).apply(this, arguments);
			});
			if(nextLayer){
				this._originFetch = nextLayer._originFetch;
				nextLayer._originFetch = fetchFunc;
			}else{
				this._originFetch = store[funcName] || function(){};
				store[funcName] = fetchFunc;
			}
			this.initialize(store);
		},
		_unwrap: function(nextLayer){
			// summary:
			//		Do the actual unwrapping to the store.
			// tags:
			//		internal
			// store: Read-store
			//		The store to be unwrapped.
			this.uninitialize(this._store);
			if(nextLayer){
				nextLayer._originFetch = this._originFetch;
			}else{
				this._store[this._funcName] = this._originFetch;
			}
			this._originFetch = null;
			this._store = null;
		},
		enabled: function(/* bool? */toEnable){
			// summary:
			//		The get/set function of the enabled status of this layer
			// tags:
			//		public
			// toEnable: Boolean?
			//		If given, is a setter, otherwise, it's getter.
			if(typeof toEnable != "undefined"){
				this.__enabled = !!toEnable;
			}
			return this.__enabled;	//Boolean
		},
		name: function(){
			// summary:
			//		Get the name of this store layer.
			//		The default name retrieved from class name, which should have a pattern of "{name}Layer".
			//		If this pattern does not exist, the whole class name will be this layer's name.
			//		It's better to override this method if your class name is too complicated.
			// tags:
			//		public extension
			// returns:
			//		The name of this layer.
			if(!this.__name){
				var m = this.declaredClass.match(/(?:\.(?:_*)([^\.]+)Layer$)|(?:\.([^\.]+)$)/i);
				this.__name = m ? (m[1] || m[2]).toLowerCase() : this.declaredClass;
			}
			return this.__name;
		},
		originFetch: function(){
			return (dojo.hitch(this._store, this._originFetch)).apply(this, arguments);
		}
	});
	dojo.declare("dojox.grid.enhanced.plugins._ServerSideLayer", ns._StoreLayer, {
		// summary:
		//		The most abstract class for all server side store layers.
		// tags:
		//		abstract
/*=====
		// _url: [protected] string
		//		The url of the server
		_url: "",
		// __cmds [private] object
		//		The command object to be sent to server.
		__cmds: {},
=====*/
		constructor: function(args){
			args = args || {};
			this._url = args.url || "";
			this._isStateful = !!args.isStateful;
			this._onUserCommandLoad = args.onCommandLoad || function(){};
			this.__cmds = {cmdlayer:this.name(), enable:true};
			
			//Only for stateful server, sending commands before fetch makes sense.
			this.useCommands(this._isStateful);
		},
		enabled: function(/* bool? */toEnable){
			// summary:
			//		Overrided from _StoreLayer.enabled
			var res = this.inherited(arguments);
			this.__cmds.enable = this.__enabled;
			return res;
		},
		useCommands: function(/* bool? */toUse){
			// summary:
			//		If you only want to modify the user request, instead of sending a separate command
			//		to server before fetch, just call:
			//			this.useCommand(false);
			// tags:
			//		public
			// toUse: Boolean?
			//		If provided, it's a setter, otherwise, it's a getter
			if(typeof toUse != "undefined"){
				this.__cmds.cmdlayer = (toUse && this._isStateful) ? this.name() : null;
			}
			return !!(this.__cmds.cmdlayer);	//Boolean
		},
		_fetch: function(/* keywordArgs */userRequest){
			// summary:
			//		Implementation of _StoreLayer._fetch
			if(this.__cmds.cmdlayer){
				//We're gonna send command to server before fetch.
				dojo.xhrPost({
					url: this._url || this._store.url,
					content: this.__cmds,
					load: dojo.hitch(this, function(responce){
						this.onCommandLoad(responce, userRequest);
						this.originFetch(userRequest);
					}),
					error: dojo.hitch(this, this.onCommandError)
				});
			}else{
				//The user only wants to modify the request object.
				this.onCommandLoad("", userRequest);
				this.originFetch(userRequest);
			}
			return userRequest;	//dojo.data.api.Request
		},
		command: function(/* string */cmdName,/* (string|number|bool|...)? */cmdContent){
			// summary:
			//		get/set a command (a name-value pair)
			// tags:
			//		public
			// cmdName: string
			//		The name of the command
			// cmdContent: anything
			//		The content of the command
			// returns:
			//		The content of the command if cmdContent is undefined
			var cmds = this.__cmds;
			if(cmdContent === null){
				delete cmds[cmdName];
			}else if(typeof cmdContent !== "undefined"){
				cmds[cmdName] = cmdContent;
			}
			return cmds[cmdName];	//anything
		},
		onCommandLoad: function(/* string */response, /* keywordArgs */userRequest){
			// summary:
			//		When the server gives back *response* for the commands, you can do something here.
			// tags:
			//		callback extension
			// response: string
			//		server response
			// userRequest: [in|out] dojo.data.api.Request
			//		The request object for *fetch*. You can modify this object according to the *response*
			//		so as to change the behavior of *fetch*
			this._onUserCommandLoad(this.__cmds, userRequest, response);
		},
		onCommandError: function(error){
			// summary:
			//		handle errors when sending commands.
			// tags:
			//		callback extension
			// error: Error
			console.log(error);
			throw error;
		}
	});
})();

}

if(!dojo._hasResource["dojox.grid.enhanced.plugins.Pagination"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.grid.enhanced.plugins.Pagination"] = true;
dojo.provide("dojox.grid.enhanced.plugins.Pagination");









dojo.declare("dojox.grid.enhanced.plugins.Pagination", dojox.grid.enhanced._Plugin, {
	// summary:
	//		The typical pagination way as an alternative to deal with huge data set besides the default virtual scrolling way
	
	name: "pagination",
	// The page size used with the store, default = 25.
	pageSize: 25,
	
	defaultRows: 25,
	
	//current page we are at
	_currentPage: 0,

	//The currently obtained max # of rows to page through.
	_maxSize: 0,
	
	init: function(){
		this.gh = null;
		this.grid.rowsPerPage = this.pageSize = this.grid.rowsPerPage ? this.grid.rowsPerPage : this.pageSize;
		this.grid.usingPagination = true;
		this.nls = dojo.i18n.getLocalization("dojox.grid.enhanced", "Pagination");
		
		this._wrapStoreLayer();
		this._createPaginators(this.option);
		
		this._regApis();
	},
	
	_createPaginators: function(paginationArgs){
		// summary:
		//		Function to create the pagination control bar.
		this.paginators = [];
		if(paginationArgs.position === "both"){
			this.paginators = [
				new dojox.grid.enhanced.plugins._Paginator(dojo.mixin(paginationArgs, {position: "bottom", plugin: this})),
				new dojox.grid.enhanced.plugins._Paginator(dojo.mixin(paginationArgs, {position: "top", plugin: this}))
			];
		}else{
			this.paginators = [new dojox.grid.enhanced.plugins._Paginator(dojo.mixin(paginationArgs, {plugin: this}))];
		}
	},
	 
	_wrapStoreLayer: function(){
		var g = this.grid,
			ns = dojox.grid.enhanced.plugins;
		this._store = g.store;
		this.query = g.query;
		
		this.forcePageStoreLayer = new ns._ForcedPageStoreLayer(this);
		ns.wrap(g, "_storeLayerFetch", this.forcePageStoreLayer);
		
		this.connect(g, "setQuery", function(query){
			if(query !== this.query){
				this.query = query;
			}
		});
	},
	
	_stopEvent: function(event){
		try{
			dojo.stopEvent(event);
		}catch(e){}
	},
	
	_onNew: function(item, parentInfo){
		var totalPages = Math.ceil(this._maxSize / this.pageSize);
		if(((this._currentPage + 1 === totalPages || totalPages === 0) && this.grid.rowCount < this.pageSize) || this.showAll){
			dojo.hitch(this.grid, this._originalOnNew)(item, parentInfo);
			this.forcePageStoreLayer.endIdx++;
		}
		this._maxSize++;
		if(this.showAll){
			this.pageSize++;
		}
		if(this.showAll && this.grid.autoHeight){
			this.grid._refresh();
		}else{
			dojo.forEach(this.paginators, function(p){
				p.update();
			});
		}
	},
	
	_removeSelectedRows: function(){
		this._multiRemoving = true;
		this._originalRemove();
		this._multiRemoving = false;
		this.grid.resize();
		this.grid._refresh();
	},
	
	_onDelete: function(){
		if(!this._multiRemoving){
			this.grid.resize();
			if(this.showAll){
				this.grid._refresh();
			}
		}
		if(this.grid.get('rowCount') === 0){
			this.prevPage();
		}
	},
	
	_regApis: function(){
		// summary:
		//		register pagination public APIs to grid.
		var g = this.grid;
		// New added APIs
		g.gotoPage = dojo.hitch(this, this.gotoPage);
		g.nextPage = dojo.hitch(this, this.nextPage);
		g.prevPage = dojo.hitch(this, this.prevPage);
		g.gotoFirstPage = dojo.hitch(this, this.gotoFirstPage);
		g.gotoLastPage = dojo.hitch(this, this.gotoLastPage);
		g.changePageSize = dojo.hitch(this, this.changePageSize);
		g.showGotoPageButton = dojo.hitch(this, this.showGotoPageButton);
		g.getTotalRowCount = dojo.hitch(this, this.getTotalRowCount);
		// Changed APIs
		this.originalScrollToRow = dojo.hitch(g, g.scrollToRow);
		g.scrollToRow = dojo.hitch(this, this.scrollToRow);
		this._originalOnNew = dojo.hitch(g, g._onNew);
		this._originalRemove = dojo.hitch(g, g.removeSelectedRows);
		g.removeSelectedRows = dojo.hitch(this, this._removeSelectedRows);
		g._onNew = dojo.hitch(this, this._onNew);
		this.connect(g, "_onDelete", dojo.hitch(this, this._onDelete));
	},
	
	destroy: function(){
		this.inherited(arguments);
		var g = this.grid;
		try{
			dojo.forEach(this.paginators, function(p){
				p.destroy();
			});
			g.unwrap(this.forcePageStoreLayer.name());
			g._onNew = this._originalOnNew;
			g.removeSelectedRows = this._originalRemove;
			g.scrollToRow = this.originalScrollToRow;
			this.paginators = null;
			this.nls = null;
		}catch(e){
			console.warn("Pagination.destroy() error: ", e);
		}
	},
	
	nextPage: function(){
		// summary:
		//		Function to handle shifting to the next page in the list.
		if(this._maxSize > ((this._currentPage + 1) * this.pageSize)){
			//Current page is indexed at 0 and gotoPage expects 1-X.  So to go
			//up  one, pass current page + 2!
			this.gotoPage(this._currentPage + 2);
		}
	},

	prevPage: function(){
		// summary:
		//		Function to handle shifting to the previous page in the list.
		if(this._currentPage > 0){
			//Current page is indexed at 0 and gotoPage expects 1-X.  So to go
			//back one, pass current page!
			this.gotoPage(this._currentPage);
		}
	},

	gotoPage: function(page){
		// summary:
		//		Function to handle shifting to an arbirtary page in the list.
		//	page:
		//		The page to go to, starting at 1.
		window.preventTableHeaderFocus = true;
		var totalPages = Math.ceil(this._maxSize / this.pageSize);
		page--;
		if(page < totalPages && page >= 0 && this._currentPage !== page){
			this._currentPage = page;
			// this._updateSelected();
			this.grid.setQuery(this.query);
			this.grid.resize();
		}
		window.preventTableHeaderFocus = false;
	},
	
	gotoFirstPage: function(){
		// summary:
		//		Go to the first page
		this.gotoPage(1);
	},
	
	gotoLastPage: function(){
		// summary:
		//		Go to the last page
		var totalPages = Math.ceil(this._maxSize / this.pageSize);
		this.gotoPage(totalPages);
	},
	
	changePageSize: function(size){
		// summary:
		//		Change size of items per page.
		//		This function will only be called by _Paginator
		if(typeof size == "string"){
			size = parseInt(size, 10);
		}
		var startIndex = this.pageSize * this._currentPage;
		dojo.forEach(this.paginators, function(f){
			f.currentPageSize = this.grid.rowsPerPage = this.pageSize = size;
			if(size >= this._maxSize){
				this.grid.rowsPerPage = this.defaultRows;
				this.grid.usingPagination = false;
			}else{
				this.grid.usingPagination = true;
			}
		}, this);
		var endIndex = startIndex + Math.min(this.pageSize, this._maxSize);
		if(endIndex > this._maxSize){
			this.gotoLastPage();
		}else{
			var cp = Math.ceil(startIndex / this.pageSize);
			if(cp !== this._currentPage){
				this.gotoPage(cp + 1);
			}else{
				this.grid._refresh(true);
			}
		}
		this.grid.resize();
	},
	
	showGotoPageButton: function(flag){
		// summary:
		//		For show/hide the go to page button dynamically
		// flag: boolean
		//		Show the go to page button when flag is true, otherwise hide it
		dojo.forEach(this.paginators, function(p){
			p._showGotoButton(flag);
		});
	},
	
	scrollToRow: function(inRowIndex){
		// summary:
		//		Override the grid.scrollToRow(), could jump to the right page
		//		and scroll to the specific row
		// inRowIndex: integer
		//		The row index
		var page = parseInt(inRowIndex / this.pageSize, 10),
			totalPages = Math.ceil(this._maxSize / this.pageSize);
		if(page > totalPages){
			return;
		}
		this.gotoPage(page + 1);
		var rowIdx = inRowIndex % this.pageSize;
		this.grid.setScrollTop(this.grid.scroller.findScrollTop(rowIdx) + 1);
	},
	
	getTotalRowCount: function(){
		// summary:
		//		Function for get total row count
		return this._maxSize;
	}
});

dojo.declare("dojox.grid.enhanced.plugins._ForcedPageStoreLayer", dojox.grid.enhanced.plugins._StoreLayer, {
	tags: ["presentation"],
	
	constructor: function(plugin){
		this._plugin = plugin;
	},
	
	_fetch: function(request){
		var self = this,
			plugin = self._plugin,
			grid = plugin.grid,
			scope = request.scope || dojo.global,
			onBegin = request.onBegin;
		
		request.start = plugin._currentPage * plugin.pageSize + (request.start < 0 ? 0 : request.start);
		self.startIdx = request.start;
		self.endIdx = request.start + plugin.pageSize - 1;
		if(onBegin && (plugin.showAll || dojo.every(plugin.paginators, function(p){
			return plugin.showAll = !p.sizeSwitch && !p.pageStepper && !p.gotoButton;
		}))){
			request.onBegin = function(size, req){
				plugin._maxSize = plugin.pageSize = size;
				self.startIdx = 0;
				self.endIdx = size - 1;
				dojo.forEach(plugin.paginators, function(f){
					f.update();
				});
				req.onBegin = onBegin;
				req.onBegin.call(scope, size, req);
			};
		}else if(onBegin){
			request.onBegin = function(size, req){
				req.start = 0;
				req.count = plugin.pageSize;
				plugin._maxSize = size;
				self.endIdx = self.endIdx >= size ? (size - 1) : self.endIdx;
				if(self.startIdx > size && size !== 0){
					grid._pending_requests[req.start] = false;
					plugin.gotoFirstPage();
				}
				dojo.forEach(plugin.paginators, function(f){
					f.update();
				});
				req.onBegin = onBegin;
				req.onBegin.call(scope, Math.min(plugin.pageSize, (size - self.startIdx)), req);
			};
		}
		return dojo.hitch(this._store, this._originFetch)(request);
	}
});

dojo.declare("dojox.grid.enhanced.plugins._Paginator", [dijit._Widget,dijit._Templated], {
	templateString:"<div dojoAttachPoint=\"paginatorBar\">\n\t<table cellpadding=\"0\" cellspacing=\"0\"  class=\"dojoxGridPaginator\">\n\t\t<tr>\n\t\t\t<td dojoAttachPoint=\"descriptionTd\" class=\"dojoxGridDescriptionTd\">\n\t\t\t\t<div aria-live=\"polite\" dojoAttachPoint=\"descriptionDiv\" class=\"dojoxGridDescription\" />\n\t\t\t</td>\n\t\t\t<td dojoAttachPoint=\"sizeSwitchTd\" class=\"dojoPageSizeSwitch\"></td>\n\t\t\t<td dojoAttachPoint=\"pageStepperTd\" class=\"dojoxGridPaginatorFastStep\">\n\t\t\t\t<div dojoAttachPoint=\"pageStepperDiv\" class=\"dojoxGridPaginatorStep\"></div>\n\t\t\t</td>\n\t\t</tr>\n\t</table>\n</div>\n",
		
	// pagination bar position - "bottom"|"top"
	position: "bottom",
	
	// max data item size
	_maxItemSize: 0,
	
	// description message status params
	description: true,
	
	// fast step page status params
	pageStepper: true,
	
	maxPageStep: 7,
	
	// items per page size switch params
	sizeSwitch: true,
	
	pageSizes: ["10", "25", "50", "100", "All"],
	
	gotoButton: false,
	
	constructor: function(params){
		dojo.mixin(this, params);
		this.grid = this.plugin.grid;
		this.itemTitle = this.itemTitle ? this.itemTitle : this.plugin.nls.itemTitle;
		this.descTemplate = this.descTemplate ? this.descTemplate : this.plugin.nls.descTemplate;
	},
	
	postCreate: function(){
		this.inherited(arguments);
		this._setWidthValue();
		var self = this;
		var g = this.grid;
		this.plugin.connect(g, "_resize", dojo.hitch(this, "_resetGridHeight"));
		this._originalResize = dojo.hitch(g, "resize");
		g.resize = function(changeSize, resultSize){
			self._changeSize = g._pendingChangeSize = changeSize;
			self._resultSize = g._pendingResultSize = resultSize;
			g.sizeChange();
		};
		this._placeSelf();
	},
	
	destroy: function(){
		this.inherited(arguments);
		this.grid.focus.removeArea("pagination" + this.position.toLowerCase());
		if(this._gotoPageDialog){
			this._gotoPageDialog.destroy();
			dojo.destroy(this.gotoPageTd);
			delete this.gotoPageTd;
			delete this._gotoPageDialog;
		}
		this.grid.resize = this._originalResize;
		this.pageSizes = null;
	},
	
	update: function(){
		// summary:
		//		Function to update paging information and update
		//		pagination bar display.
		this.currentPageSize = this.plugin.pageSize;
		this._maxItemSize = this.plugin._maxSize;
		
		// update pagination bar display information
		this._updateDescription();
		this._updatePageStepper();
		this._updateSizeSwitch();
		this._updateGotoButton();
		if(window.isAccessibilityEnabled){
			this._updateTableInfo();
		}
	},
	
	_setWidthValue: function(){
		var type = ["description", "sizeSwitch", "pageStepper"];
		var endWith = function(str1, str2){
			var reg = new RegExp(str2+"$");
			return reg.test(str1);
		};
		dojo.forEach(type, function(t){
			var width, flag = this[t];
			if(flag === undefined || typeof flag == "boolean"){
				return;
			}
			if(dojo.isString(flag)){
				width = endWith(flag, "px") || endWith(flag, "%") || endWith(flag, "em") ? flag : parseInt(flag, 10) > 0 ? parseInt(flag, 10) + "px" : null;
			}else if(typeof flag === "number" && flag > 0){
				width = flag + "px";
			}
			this[t] = width ? true : false;
			this[t + "Width"] = width;
		}, this);
	},
	
	_regFocusMgr: function(position){
		// summary:
		//		Function to register pagination bar to focus manager.
		this.grid.focus.addArea({
			name: "pagination" + position,
			onFocus: dojo.hitch(this, this._onFocusPaginator),
			onBlur: dojo.hitch(this, this._onBlurPaginator),
			onMove: dojo.hitch(this, this._moveFocus),
			onKeyDown: dojo.hitch(this, this._onKeyDown)
		});
		switch(position){
			case "top":
				this.grid.focus.placeArea("pagination" + position, "before", "header");
				break;
			case "bottom":
			default:
				this.grid.focus.placeArea("pagination" + position, "after", "content");
				break;
		}
	},
	
	_placeSelf: function(){
		// summary:
		//		Place pagination bar to a position.
		//		There are two options, top of the grid, bottom of the grid.
		var g = this.grid;
		var	position = dojo.trim(this.position.toLowerCase());
		switch(position){
			case "top":
				this.placeAt(g.viewsHeaderNode, "before");
				this._regFocusMgr("top");
				break;
			case "bottom":
			default:
				this.placeAt(g.viewsNode, "after");
				this._regFocusMgr("bottom");
				break;
		}
	},
	
	_resetGridHeight: function(changeSize, resultSize){
		// summary:
		//		Function of resize grid height to place this pagination bar.
		//		Since the grid would be able to add other element in its domNode, we have
		//		change the grid view size to place the pagination bar.
		//		This function will resize the grid viewsNode height, scorllboxNode height
		var g = this.grid;
		changeSize = changeSize || this._changeSize;
		resultSize = resultSize || this._resultSize;
		delete this._changeSize;
		delete this._resultSize;
		if(g._autoHeight){
			return;
		}
		var padBorder = g._getPadBorder().h;
		if(!this.plugin.gh){
			this.plugin.gh = dojo.contentBox(g.domNode).h + 2 * padBorder;
		}
		if(resultSize){
			changeSize = resultSize;
		}
		if(changeSize){
			this.plugin.gh = dojo.contentBox(g.domNode).h + 2 * padBorder;
		}
		var gh = this.plugin.gh,
			hh = g._getHeaderHeight(),
			ph = dojo.marginBox(this.domNode).h;
		ph = this.plugin.paginators[1] ? ph * 2 : ph;
		if(typeof g.autoHeight == "number"){
			var cgh = gh + ph - padBorder;
			dojo.style(g.domNode, "height", cgh + "px");
			dojo.style(g.viewsNode, "height", (cgh - ph - hh) + "px");
			
			this._styleMsgNode(hh, dojo.marginBox(g.viewsNode).w, cgh - ph - hh);
		}else{
			var h = gh - ph - hh - padBorder;
			dojo.style(g.viewsNode, "height", h + "px");
			var hasHScroller = dojo.some(g.views.views, function(v){
				return v.hasHScrollbar();
			});
			dojo.forEach(g.viewsNode.childNodes, function(c, idx){
				dojo.style(c, "height", h + "px");
			});
			dojo.forEach(g.views.views, function(v, idx){
				if(v.scrollboxNode){
					if(!v.hasHScrollbar() && hasHScroller){
						dojo.style(v.scrollboxNode, "height", (h - dojox.html.metrics.getScrollbar().h) + "px");
					}else{
						dojo.style(v.scrollboxNode, "height", h + "px");
					}
				}
			});
			this._styleMsgNode(hh, dojo.marginBox(g.viewsNode).w, h);
		}
	},
	
	_styleMsgNode: function(top, width, height){
		var messagesNode = this.grid.messagesNode;
		dojo.style(messagesNode, {"position": "absolute", "top": top + "px", "width": width + "px", "height": height + "px", "z-Index": "100"});
	},
	
	_updateDescription: function(){
		// summary:
		//		Update size information.
		var s = this.plugin.forcePageStoreLayer;
		if(this.description && this.descriptionDiv){
			this.descriptionDiv.innerHTML = this._maxItemSize > 0 ? dojo.string.substitute(this.descTemplate, [this.itemTitle, this._maxItemSize, s.startIdx + 1, s.endIdx + 1]) : "0 " + this.itemTitle;
		}
		if(this.descriptionWidth){
			dojo.style(this.descriptionTd, "width", this.descriptionWidth);
		}
		this._updateDownloadButton();
	},
	
	/**
	 * Disable download button if no record else enable it.
	 */
	_updateDownloadButton: function(){
		var records_count = parseInt(this._maxItemSize);
		var download_button_check = dijit.byId('dijit_form_DropDownButton_1') ? 
									dijit.byId('dijit_form_DropDownButton_1').set("disabled", false) : "";
		if(!download_button_check) {
			return; 
		}							
		if(dojo.query(".dojoxGrid") && dojo.query(".dojoxGrid").length > 1) {
			//This means there are more than 1 table. 
			var iGridLength = dojo.query(".dojoxGrid").length;
			var nonZeroRecords = false; 
			dojo.query(".dojoxGrid").forEach(function(/*DomNode*/ grid){
				var gridObj = dijit.byId(grid.id);
				try {
						if(!nonZeroRecords && gridObj.getTotalRowCount !== undefined) {	 
							nonZeroRecords = gridObj.getTotalRowCount() >= 1 ? true : nonZeroRecords; 
						}
					}
					catch(e) {
						dijit.byId('dijit_form_DropDownButton_1').set("disabled", true);
					}
				
			});
			if(!nonZeroRecords) {
				dijit.byId('dijit_form_DropDownButton_1').set("disabled", true);
			}
		} else { 
			if(records_count === 0)
			{
				dijit.byId('dijit_form_DropDownButton_1').set("disabled", true);
			}
		}
	},
	
	_updateTableInfo: function(){
		// summary:
		//		Update the hidden span for accessibility and
		var tableInfoText = "";
		if(dojo.query('#'+this.grid.id+' .dojoxGridDescription') && dojo.query('#'+this.grid.id+' .dojoxGridDescription').length > 0) {
			tableInfoText = dojo.attr(dojo.query('#'+this.grid.id+' .dojoxGridDescription')[0],'innerHTML') + ". ";
		}
		if(dojo.query('#'+this.grid.id+' .dojoxGridActivedSwitch') && dojo.query('#'+this.grid.id+' .dojoxGridActivedSwitch').length >0) {
			tableInfoText = tableInfoText + misys.getLocalization('currentPageSize') + ' ' + dojo.attr(dojo.query('#'+this.grid.id+' .dojoxGridActivedSwitch')[0],'title')+ ". ";
		}
		if(dojo.query('#'+this.grid.id+' .dojoxGridActived') && dojo.query('#'+this.grid.id+' .dojoxGridActived').length>0) {
			tableInfoText = tableInfoText + misys.getLocalization('currentPage') + ' ' + dojo.attr(dojo.query('#'+this.grid.id+' .dojoxGridActived')[0],'title');
		}
		
		if(dojo.query('span.dojoxGridInactiveSwitch',this.sizeSwitchTd) && dojo.query('span.dojoxGridInactiveSwitch',this.sizeSwitchTd).length >0) {			
			var firstSizeSwitchNode = dojo.query('span.dojoxGridInactiveSwitch',this.sizeSwitchTd)[0];
			tableInfoText = tableInfoText + " " + dojo.attr(firstSizeSwitchNode,'title');
			if(dojo.query("#table-page-size-instructions") && dojo.query("#table-page-size-instructions").length>0) {  
				tableInfoText = tableInfoText + " " + dojo.query("#table-page-size-instructions")[0].innerHTML;
			}
			dojo.attr(firstSizeSwitchNode,'aria-label',tableInfoText);
		}
		if(dojo.query('span.sr-only', this.descriptionTd).length < 1){
			var tableInfoId = this.grid.id + '_table' + '_info';
			var tableInfo = dojo.create("span", {id: tableInfoId}, this.descriptionTd, "last");
			dojo.addClass(tableInfo, "sr-only");
			dojo.attr(tableInfo,'aria-live','polite');
		}
		dojo.attr(dojo.query('span.sr-only', this.descriptionTd)[0],'innerHTML',tableInfoText);		
	},
	
	_updateSizeSwitch: function(){
		// summary:
		//		Update "items per page" information.
		if(!this.sizeSwitchTd){
			return;
		}
		if(!this.sizeSwitch || this._maxItemSize <= 0){
			dojo.style(this.sizeSwitchTd, "display", "none");
			return;
		}else{
			dojo.style(this.sizeSwitchTd, "display", "");
		}
		if(this.initializedSizeNode && !this.pageSizeValue){
			// do not update page size if page size was not changed
			return;
		}
		if(this.sizeSwitchTd.childNodes.length < 1){
			this._createSizeSwitchNodes();
		}
		this._updateSwitchNodeClass();
		
		// move focus to next activable node
		this._moveToNextActivableNode(this._getAllPageSizeNodes(), this.pageSizeValue);
		this.pageSizeValue = null;
	},
	
	_createSizeSwitchNodes: function(){
		// summary:
		//		The function to create the size switch nodes
		var node = null;
		if(!this.pageSizes || this.pageSizes.length < 1){
			return;
		}
		dojo.forEach(this.pageSizes, function(size){
			// create page size switch node
			size = dojo.trim(size);
			var labelValue = size.toLowerCase() == "all" ? this.plugin.nls.allItemsLabelTemplate : dojo.string.substitute(this.plugin.nls.pageSizeLabelTemplate, [size]);
			node = dojo.create("span", {innerHTML: size, title: labelValue, value: size, tabindex: 0}, this.sizeSwitchTd, "last");
			// for accessibility			
			if(window.isAccessibilityEnabled && dojo.query("#table-page-size-instructions") && dojo.query("#table-page-size-instructions")[0] !== undefined) {
				labelValue = labelValue +" " + dojo.query("#table-page-size-instructions")[0].innerHTML;
				dojo.attr(node,'role','menuitem');
			}
			dijit.setWaiState(node, "label", labelValue);
			// connect event
			this.plugin.connect(node, "onclick", dojo.hitch(this, "_onSwitchPageSize"));
			this.plugin.connect(node, "onmouseover", function(e){
				dojo.addClass(e.target, "dojoxGridPageTextHover");
			});
			this.plugin.connect(node, "onmouseout", function(e){
				dojo.removeClass(e.target, "dojoxGridPageTextHover");
			});
			// create a separation node
			node = dojo.create("span", {innerHTML: "|"}, this.sizeSwitchTd, "last");
			dojo.addClass(node, "dojoxGridSeparator");
		}, this);
		// delete last separation node
		dojo.destroy(node);
		this.initializedSizeNode = true;
		if(this.sizeSwitchWidth){
			dojo.style(this.sizeSwitchTd, "width", this.sizeSwitchWidth);
		}
	},
	
	_updateSwitchNodeClass: function(){
		// summary:
		//		Update the switch nodes style
		var size = null;
		var hasActivedNode = false;
		var styleNode = function(node, status){
			if(status){
				dojo.addClass(node, "dojoxGridActivedSwitch");
				dojo.attr(node, "tabindex", "-1");
				hasActivedNode = true;
			}else{
				dojo.addClass(node, "dojoxGridInactiveSwitch");
				dojo.attr(node, "tabindex", "0");
			}
		};
		dojo.forEach(this.sizeSwitchTd.childNodes, function(node){
			if(node.value){
				size = node.value;
				dojo.removeClass(node);
				if(this.pageSizeValue){
					styleNode(node, size === this.pageSizeValue && !hasActivedNode);
				}else{
					if(size.toLowerCase() == "all"){
						size = this._maxItemSize;
					}
					styleNode(node, this.currentPageSize === parseInt(size, 10) && !hasActivedNode);
				}
			}
		}, this);
	},
	
	_updatePageStepper: function(){
		// summary:
		//		Update the page step nodes
		if(!this.pageStepperTd){
			return;
		}
		if(!this.pageStepper || this._maxItemSize <= 0){
			dojo.style(this.pageStepperTd, "display", "none");
			return;
		}else{
			dojo.style(this.pageStepperTd, "display", "");
		}
		if(this.pageStepperDiv.childNodes.length < 1){
			this._createPageStepNodes();
			this._createWardBtns();
		}else{
			this._resetPageStepNodes();
		}
		this._updatePageStepNodeClass();
		
		this._moveToNextActivableNode(this._getAllPageStepNodes(), this.pageStepValue);
		this.pageStepValue = null;
	},
	
	_createPageStepNodes: function(){
		// summary:
		//		Create the page step nodes if they do not exist
		var startPage = this._getStartPage(),
			stepSize = this._getStepPageSize(),
			label = "",
			node = null;
		for(var i = startPage; i < this.maxPageStep + 1; i++){
			label = dojo.string.substitute(this.plugin.nls.pageStepLabelTemplate, [i + ""]);
			node = dojo.create("div", {innerHTML: i, value: i, title: label, tabindex: i < startPage + stepSize ? 0 : -1}, this.pageStepperDiv, "last");
			//console.log('tabindex value is set as for node' + node  + ' : tabindex' +   (i < startPage + stepSize ? 0 : -1));			
			if(window.isAccessibilityEnabled && dojo.query("#table-page-instructions") && dojo.query("#table-page-instructions")[0] !== undefined) {
				label = label +" " + dojo.query("#table-page-instructions")[0].innerHTML;
				dojo.attr(node,'role','menuitem');
			}
			dijit.setWaiState(node, "label", label);
			// connect event
			this.plugin.connect(node, "onclick", dojo.hitch(this, "_onPageStep"));
			this.plugin.connect(node, "onmouseover", function(e){
				dojo.addClass(e.target, "dojoxGridPageTextHover");
			});
			this.plugin.connect(node, "onmouseout", function(e){
				dojo.removeClass(e.target, "dojoxGridPageTextHover");
			});
			dojo.style(node, "display", i < startPage + stepSize ? "block" : "none");
		}
		if(this.pageStepperWidth){
			dojo.style(this.pageStepperTd, "width", this.pageStepperWidth);
		}
	},
	
	_createWardBtns: function(){
		// summary:
		//		Create the previous/next/first/last button
		var self = this;
		var highContrastLabel = {prevPage: "&#60;", firstPage: "&#171;", nextPage: "&#62;", lastPage: "&#187;"};
		var createWardBtn = function(value, label, position){
			var node = dojo.create("div", {value: value, title: label, tabindex: 1}, self.pageStepperDiv, position);
			self.plugin.connect(node, "onclick", dojo.hitch(self, "_onPageStep"));
			if(window.isAccessibilityEnabled && dojo.query("#table-page-instructions") && dojo.query("#table-page-instructions")[0] !== undefined) { 
				label = label +" " + dojo.query("#table-page-instructions")[0].innerHTML;
				dojo.attr(node,'role','menuitem');
			}
			dijit.setWaiState(node, "label", label);
			// for high contrast
			if(window.isAccessibilityEnabled) {
				var highConrastNode = dojo.create("span", {value: value, title: label}, node, position);
			} else {
				var highConrastNode = dojo.create("span", {value: value, title: label, innerHTML: highContrastLabel[value]}, node, position);
			}
			dojo.addClass(highConrastNode, "dojoxGridWardButtonInner");
		};
		createWardBtn("prevPage", this.plugin.nls.prevTip, "first");
		createWardBtn("firstPage", this.plugin.nls.firstTip, "first");
		createWardBtn("nextPage", this.plugin.nls.nextTip, "last");
		createWardBtn("lastPage", this.plugin.nls.lastTip, "last");
	},
	
	_resetPageStepNodes: function(){
		// summary:
		//		The page step nodes might be changed when fetch data, we need to
		//		update/reset them
		var startPage = this._getStartPage(),
			stepSize = this._getStepPageSize(),
			stepNodes = this.pageStepperDiv.childNodes,
			node = null;
		for(var i = startPage, j = 2; j < stepNodes.length - 2; j++, i++){
			node = stepNodes[j];
			if(i < startPage + stepSize){
				dojo.attr(node, "innerHTML", i);
				dojo.attr(node, "value", i);
				dojo.style(node, "display", "block");
				dijit.setWaiState(node, "label", dojo.string.substitute(this.plugin.nls.pageStepLabelTemplate, [i + ""]));
			}else{
				dojo.style(node, "display", "none");
			}
		}
	},
	
	_updatePageStepNodeClass: function(){
		// summary:
		//		Update the style of the page step nodes
		var value = null,
			curPage = this._getCurrentPageNo(),
			pageCount = this._getPageCount(),
			visibleNodeLen = 0;
			
		var updateClass = function(node, isWardBtn, status){
			var value = node.value,
				enableClass = isWardBtn ? "dojoxGrid" + value + "Btn" : "dojoxGridInactived",
				disableClass = isWardBtn ? "dojoxGrid" + value + "BtnDisable" : "dojoxGridActived";
			if(status){
				dojo.addClass(node, disableClass);
				dojo.attr(node, "tabindex", "-1");
				window.preventTabToPages = true;
			}else{
				dojo.addClass(node, enableClass);
				dojo.attr(node, "tabindex", "0");
				window.preventTabToPages = false;
			}
		};
		dojo.forEach(this.pageStepperDiv.childNodes, function(node){
			dojo.removeClass(node);
			if(isNaN(parseInt(node.value, 10))){
				dojo.addClass(node, "dojoxGridWardButton");
				var disablePageNum = node.value == "prevPage" || node.value == "firstPage" ? 1 : pageCount;
				updateClass(node, true, (curPage == disablePageNum));
			}else{
				value = parseInt(node.value, 10);
				updateClass(node, false, (value === curPage || dojo.style(node, "display") === "none"));
			}
		}, this);
	},
	
	_showGotoButton: function(flag){
		this.gotoButton = flag;
		this._updateGotoButton();
	},
	
	_updateGotoButton: function(){
		// summary:
		//		Create/destroy the goto page button
		if(!this.gotoButton){
			if(this.gotoPageTd){
				if(this._gotoPageDialog){
					this._gotoPageDialog.destroy();
				}
				dojo.destroy(this.gotoPageDiv);
				dojo.destroy(this.gotoPageTd);
				delete this.gotoPageDiv;
				delete this.gotoPageTd;
			}
			return;
		}
		if(!this.gotoPageTd){
			this._createGotoNode();
		}
		dojo.toggleClass(this.gotoPageDiv, "dojoxGridPaginatorGotoDivDisabled", this.plugin.pageSize >= this.plugin._maxSize);
	},
	
	_createGotoNode: function(){
		// summary:
		//		Create the goto page button
		this.gotoPageTd = dojo.create("td", {}, dojo.query("tr", this.domNode)[0], "last");
		dojo.addClass(this.gotoPageTd, "dojoxGridPaginatorGotoTd");
		this.gotoPageDiv = dojo.create("div", {tabindex: "0", title: this.plugin.nls.gotoButtonTitle}, this.gotoPageTd, "first");
		dojo.addClass(this.gotoPageDiv, "dojoxGridPaginatorGotoDiv");
		this.plugin.connect(this.gotoPageDiv, "onclick", dojo.hitch(this, "_openGotopageDialog"));
		dojo.attr(this.gotoPageDiv,'role','menuitem');
		// for high contrast
		if(window.isAccessibilityEnabled) {
			var highConrastNode = dojo.create("span", {title: this.plugin.nls.gotoButtonTitle}, this.gotoPageDiv, "last");
		} else {
			var highConrastNode = dojo.create("span", {title: this.plugin.nls.gotoButtonTitle, innerHTML: "&#8869;"}, this.gotoPageDiv, "last");
		}
		dojo.addClass(highConrastNode, "dojoxGridWardButtonInner");
	},
	
	_openGotopageDialog: function(event){
		// summary:
		//		Show the goto page dialog
		if(!this._gotoPageDialog){
			this._gotoPageDialog = new dojox.grid.enhanced.plugins.pagination._GotoPageDialog(this.plugin);
		}
		// focus
		if(!this._currentFocusNode){
			this.grid.focus.focusArea("pagination" + this.position, event);
		}else{
			this._currentFocusNode = this.gotoPageDiv;
		}
		if(this.focusArea != "pageStep"){
			this.focusArea = "pageStep";
		}
		this._gotoPageDialog.updatePageCount();
		this._gotoPageDialog.showDialog();
	},
	
	// ===== focus handlers ===== //
	_onFocusPaginator: function(event, step){
		// summary:
		//		Focus handler
		//console.log('step:'+step);
		if(!this._currentFocusNode){
			if(step > 0){
				return this._onFocusPageSizeNode(event) ? true : this._onFocusPageStepNode(event);
			}else if(step < 0){
				return this._onFocusPageStepNode(event) ? true : this._onFocusPageSizeNode(event);
			}else{
				return false;
			}
		}else{
			if(step > 0){
				return this.focusArea === "pageSize" ? this._onFocusPageStepNode(event) : false;
			}else if(step < 0){
				if(window.isAccessibilityEnabled) { 
					if(this.focusArea === "pageStep" || ((this.grid.focus._currentAreaIdx === 0) && dojo.hasClass(this.gotoPageDiv,'dojoxGridPaginatorGotoDivDisabled'))) {
						return this._onFocusPageSizeNode(event);
					} else {
						return false; 
					}
				} else { 
					return this.focusArea === "pageStep" ? this._onFocusPageSizeNode(event) : false;
				}	
			}else{
				return false;
			}
		}
	},
	
	_onFocusPageSizeNode: function(event){
		// summary:
		//		Focus the page size area, if there is no focusable node, return false
		var pageSizeNodes = this._getPageSizeActivableNodes();
		if(event && event.type !== "click"){
			if(pageSizeNodes[0]){
				dijit.focus(pageSizeNodes[0]);
				this._currentFocusNode = pageSizeNodes[0];
				this.focusArea = "pageSize";
				this.plugin._stopEvent(event);
				return true;
			}else{
				return false;
			}
		}
		if(event && event.type == "click"){
			if(dojo.indexOf(this._getPageSizeActivableNodes(), event.target) > -1){
				this.focusArea = "pageSize";
				this.plugin._stopEvent(event);
				return true;
			}
		}
		return false;
	},
	
	_onFocusPageStepNode: function(event){
		// summary:
		//		Focus the page step area, if there is no focusable node, return false
		var pageStepNodes = this._getPageStepActivableNodes();
		if(event && event.type !== "click"){
			if(pageStepNodes[0]){
				dijit.focus(pageStepNodes[0]);
				this._currentFocusNode = pageStepNodes[0];
				this.focusArea = "pageStep";
				this.plugin._stopEvent(event);
				return true;
			}else if(this.gotoPageDiv){
				if(window.isAccessibilityEnabled && dojo.hasClass(this.gotoPageDiv,'dojoxGridPaginatorGotoDivDisabled')){
					return false; 
				}
				dijit.focus(this.gotoPageDiv);
				this._currentFocusNode = this.gotoPageDiv;
				this.focusArea = "pageStep";
				this.plugin._stopEvent(event);
				return true;
			}else{
				return false;
			}
		}
		if(event && event.type == "click"){
			if(dojo.indexOf(this._getPageStepActivableNodes(), event.target) > -1){
				this.focusArea = "pageStep";
				this.plugin._stopEvent(event);
				return true;
			}else if(event.target == this.gotoPageDiv){
				dijit.focus(this.gotoPageDiv);
				this._currentFocusNode = this.gotoPageDiv;
				this.focusArea = "pageStep";
				this.plugin._stopEvent(event);
				return true;
			}
		}
		return false;
	},
	
	_onFocusGotoPageNode: function(event){
		// summary:
		//		Focus the goto page button, if there is no focusable node, return false
		if(!this.gotoButton || !this.gotoPageTd){
			return false;
		}
		if(event && event.type !== "click" || (event.type == "click" && event.target == this.gotoPageDiv)){
			dijit.focus(this.gotoPageDiv);
			this._currentFocusNode = this.gotoPageDiv;
			this.focusArea = "gotoButton";
			this.plugin._stopEvent(event);
			return true;
		}
		return true;
	},
	
	_onBlurPaginator: function(event, step){
		var pageSizeNodes = this._getPageSizeActivableNodes(),
			pageStepNodes = this._getPageStepActivableNodes();
		
		if(step > 0 && this.focusArea === "pageSize" && (pageStepNodes.length > 1 || this.gotoButton)){
			return false;
		}else if(step < 0 && this.focusArea === "pageStep" && pageSizeNodes.length > 1){
			return false;
		}
		this._currentFocusNode = null;
		this.focusArea = null;
		return true;
	},
	
	_onKeyDown: function(event, isBubble){
		// summary:
		//		Focus navigation
		if(isBubble){
			return;
		}
		if(event.altKey || event.metaKey){
			return;
		}
		var dk = dojo.keys;
		if(event.keyCode === dk.ENTER || event.keyCode === dk.SPACE){
			if(dojo.indexOf(this._getPageStepActivableNodes(), this._currentFocusNode) > -1){
				this._onPageStep(event);
			}else if(dojo.indexOf(this._getPageSizeActivableNodes(), this._currentFocusNode) > -1){
				this._onSwitchPageSize(event);
			}else if(this._currentFocusNode === this.gotoPageDiv){
				this._openGotopageDialog(event);
			}
		}
		this.plugin._stopEvent(event);
	},
	
	_moveFocus: function(rowDelta, colDelta, evt){
		// summary:
		//		Move focus according row delta&column delta
		var nodes;
		if(this.focusArea == "pageSize"){
			nodes = this._getPageSizeActivableNodes();
		}else if(this.focusArea == "pageStep"){
			nodes = this._getPageStepActivableNodes();
			if(this.gotoPageDiv){
				nodes.push(this.gotoPageDiv);
			}
		}
		if(nodes.length < 1){
			return;
		}
		var currentIdx = dojo.indexOf(nodes, this._currentFocusNode);
		var focusIdx = currentIdx + colDelta;
		if(focusIdx >= 0 && focusIdx < nodes.length){
			dijit.focus(nodes[focusIdx]);
			this._currentFocusNode = nodes[focusIdx];
		}
		this.plugin._stopEvent(evt);
	},
	
	_getPageSizeActivableNodes: function(){
		return dojo.query("span[tabindex='0']", this.sizeSwitchTd);
	},
	
	_getPageStepActivableNodes: function(){
		return (dojo.query("div[tabindex='0']", this.pageStepperDiv));
	},
	
	_getAllPageSizeNodes: function(){
		var nodeList = [];
		dojo.forEach(this.sizeSwitchTd.childNodes, function(node){
			if(node.value){
				nodeList.push(node);
			}
		});
		return nodeList;
	},
	
	_getAllPageStepNodes: function(){
		var nodeList = [];
		for(var i = 0, len = this.pageStepperDiv.childNodes.length; i < len; i++){
			nodeList.push(this.pageStepperDiv.childNodes[i]);
		}
		return nodeList;
	},
	
	_moveToNextActivableNode: function(nodeList, curNodeValue){
		// summary:
		//		Need to move the focus to next node since current node is inactive and unfocusable
		if(!curNodeValue){
			return;
		}
		if(nodeList.length < 2){
			this.grid.focus.tab(1);
		}
		var nl = [],
			node = null,
			index = 0;
		dojo.forEach(nodeList, function(n){
			if(n.value == curNodeValue){
				nl.push(n);
				node = n;
			}else if(dojo.attr(n, "tabindex") == "0"){
				nl.push(n);
			}
		});
		if(nl.length < 2){
			this.grid.focus.tab(1);
		}
		index = dojo.indexOf(nl, node);
		if(dojo.attr(node, "tabindex") != "0"){
			node = nl[index + 1] ? nl[index + 1] : nl[index - 1];
		}
		dijit.focus(node);
		this._currentFocusNode = node;
	},
	
	// ===== pagination events handlers ===== //
	_onSwitchPageSize: function(/*Event*/e){
		// summary:
		//		The handler of switch the page size
		window.preventTableHeaderFocus = true; 
		var size = this.pageSizeValue = e.target.value;
		if(!size){
			return;
		}
		if(dojo.trim(size.toLowerCase()) == "all"){
			size = this._maxItemSize;
			showAll = true;
		}
		this.plugin.grid.usingPagination = !this.plugin.showAll;
		
		size = parseInt(size, 10);
		if(isNaN(size) || size <= 0/* || size == this.currentPageSize*/){
			return;
		}
		
		if(!this._currentFocusNode){
			this.grid.focus.currentArea("pagination" + this.position);
		}
		if(this.focusArea != "pageSize"){
			this.focusArea = "pageSize";
		}
		this.plugin.changePageSize(size);
		
		//this.grid.scroller.scroll(this.grid.scroller.getPageHeight());
		this.grid.focus.focusArea("pagination" + this.position, event);

		window.preventTableHeaderFocus = false; 
	},
	
	_onPageStep: function(/*Event*/e){
		// summary:
		//		The handler jump page event
		var p = this.plugin,
			value = this.pageStepValue = e.target.value;
		
		if(!this._currentFocusNode){
			this.grid.focus.currentArea("pagination" + this.position);
		}
		if(this.focusArea != "pageStep"){
			this.focusArea = "pageStep";
		}
		if(!isNaN(parseInt(value, 10))){
			p.gotoPage(value);
		}else{
			switch(e.target.value){
				case "prevPage":
					p.prevPage();
					break;
				case "nextPage":
					p.nextPage();
					break;
				case "firstPage":
					p.gotoFirstPage();
					break;
				case "lastPage":
					p.gotoLastPage();
			}
		}
	},
	
	// ===== information getters ===== //
	_getCurrentPageNo: function(){
		return this.plugin._currentPage + 1;
	},
	
	_getPageCount: function(){
		if(!this._maxItemSize || !this.currentPageSize){
			return 0;
		}
		return Math.ceil(this._maxItemSize / this.currentPageSize);
	},
	
	_getStartPage: function(){
		var cp = this._getCurrentPageNo();
		var ms = parseInt(this.maxPageStep / 2, 10);
		var pc = this._getPageCount();
		if(cp < ms || (cp - ms) < 1){
			return 1;
		}else if(pc <= this.maxPageStep){
			return 1;
		}else{
			if(pc - cp < ms && cp - this.maxPageStep >= 0){
				return pc - this.maxPageStep + 1;
			}else{
				return (cp - ms);
			}
		}
	},
	
	_getStepPageSize: function(){
		var sp = this._getStartPage();
		var count = this._getPageCount();
		if((sp + this.maxPageStep) > count){
			return count - sp + 1;
		}else{
			return this.maxPageStep;
		}
	}

});

dojo.declare("dojox.grid.enhanced.plugins.pagination._GotoPageDialog", null, {
	
	pageCount: 0,
	
	constructor: function(plugin){
		this.plugin = plugin;
		this.pageCount = this.plugin.paginators[0]._getPageCount();
		this._dialogNode = dojo.create("div", {}, dojo.body(), "last");
		this._gotoPageDialog = new dojox.grid.enhanced.plugins.Dialog({
			"refNode": plugin.grid.domNode,
			"title": this.plugin.nls.dialogTitle
		}, this._dialogNode);
		this._createDialogContent();
		this._gotoPageDialog.startup();
	},
	
	_createDialogContent: function(){
		// summary:
		//		Create the dialog content
		this._specifyNode = dojo.create("div", {innerHTML: this.plugin.nls.dialogIndication}, this._gotoPageDialog.containerNode, "last");
		
		if(window.isAccessibilityEnabled === true) {
			dojo.attr(this._specifyNode,'id','page_num_text');
		}
		
		this._pageInputDiv = dojo.create("div", {}, this._gotoPageDialog.containerNode, "last");
		this._pageTextBox = new dijit.form.NumberTextBox();
		this._pageTextBox.constraints = {fractional:false, min:1, max:this.pageCount};
		this.plugin.connect(this._pageTextBox.textbox, "onkeyup", dojo.hitch(this, "_setConfirmBtnState"));
		
		if(window.isAccessibilityEnabled === true) {
			dojo.attr(this._pageTextBox.textbox,'aria-labelledby','page_num_text');
		}
		
		this._pageInputDiv.appendChild(this._pageTextBox.domNode);
		this._pageLabel = dojo.create("label", {innerHTML: dojo.string.substitute(this.plugin.nls.pageCountIndication, [this.pageCount])}, this._pageInputDiv, "last");
		
		this._buttonDiv = dojo.create("div", {}, this._gotoPageDialog.containerNode, "last");
		this._confirmBtn = new dijit.form.Button({label: this.plugin.nls.dialogConfirm, onClick: dojo.hitch(this, this._onConfirm)});
		this._confirmBtn.set("disabled", true);
		
		this._cancelBtn = new dijit.form.Button({label: this.plugin.nls.dialogCancel, onClick: dojo.hitch(this, this._onCancel)});
		this._buttonDiv.appendChild(this._confirmBtn.domNode);
		this._buttonDiv.appendChild(this._cancelBtn.domNode);
		this._styleContent();
		this._gotoPageDialog.onCancel = dojo.hitch(this, this._onCancel);
		this.plugin.connect(this._gotoPageDialog, "_onKey", dojo.hitch(this, "_onKeyDown"));
	},
	
	_styleContent: function(){
		dojo.addClass(this._specifyNode, "dojoxGridDialogMargin");
		dojo.addClass(this._pageInputDiv, "dojoxGridDialogMargin");
		dojo.addClass(this._buttonDiv, "dojoxGridDialogButton");
		dojo.style(this._pageTextBox.domNode, "width", "50px");
	},
	
	updatePageCount: function(){
		this.pageCount = this.plugin.paginators[0]._getPageCount();
		this._pageTextBox.constraints = {fractional:false, min:1, max:this.pageCount};
		dojo.attr(this._pageLabel, "innerHTML", dojo.string.substitute(this.plugin.nls.pageCountIndication, [this.pageCount]));
	},
	
	showDialog: function(){
		this._gotoPageDialog.show();
	},
	
	_onConfirm: function(event){
		// summary:
		//		Jump to the given page
		if(this._pageTextBox.isValid() && this._pageTextBox.getDisplayedValue() !== ""){
			this.plugin.gotoPage(this._pageTextBox.parse(this._pageTextBox.getDisplayedValue()));
			this._gotoPageDialog.hide();
			this._pageTextBox.reset();
		}
		this.plugin._stopEvent(event);
	},
	
	_onCancel: function(event){
		// summary:
		//		Cancel action and hide the dialog
		this._pageTextBox.reset();
		this._gotoPageDialog.hide();
		this.plugin._stopEvent(event);
	},
	
	_onKeyDown: function(event){
		if(event.altKey || event.metaKey){
			return;
		}
		var dk = dojo.keys;
		if(event.keyCode === dk.ENTER){
			this._onConfirm(event);
		}
	},
	
	_setConfirmBtnState: function(){
		if(this._pageTextBox.isValid() && this._pageTextBox.getDisplayedValue() !== ""){
			this._confirmBtn.set("disabled", false);
		}else{
			this._confirmBtn.set("disabled", true);
		}
	},
	
	destroy: function(){
		this._pageTextBox.destroy();
		this._confirmBtn.destroy();
		this._cancelBtn.destroy();
		this._gotoPageDialog.destroy();
		
		dojo.destroy(this._specifyNode);
		dojo.destroy(this._pageInputDiv);
		dojo.destroy(this._pageLabel);
		dojo.destroy(this._buttonDiv);
		dojo.destroy(this._dialogNode);
	}
});

dojox.grid.EnhancedGrid.registerPlugin(dojox.grid.enhanced.plugins.Pagination/*name:'pagination'*/);

}

if(!dojo._hasResource["misys.grid.Pagination"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.grid.Pagination"] = true;
dojo.provide("misys.grid.Pagination");
dojo.experimental("misys.grid.Pagination"); 



//our declared class
dojo.declare("misys.grid.Pagination",
		[ dojox.grid.enhanced.plugins.Pagination ],
		// class properties:
		{
			name: "paginationEnhanced",
			defaultRows: 100,
			queryOptions : {},
			gotoPage: function(page){
				
				// summary:
				//		Function to handle shifting to an arbirtary page in the list.
				//		Over ride the this method so the search criteria will be restored.
				//		While moving from one page to another page.
				//	page:
				//		The page to go to, starting at 1.
				
				//set the query options required. To retain search parameters.
				window.preventTableHeaderFocus = true;
				this.setQueryOptions();
				var totalPages = Math.ceil(this._maxSize / this.pageSize);
				page--;
				if(page < totalPages && page >= 0 && this._currentPage !== page){
					this._currentPage = page;
					// for list def's  we dont pass data from search form as get
					// its always post,and is set as query options.
					if(this.grid.store && this.grid.store.declaredClass === 'dojox.data.QueryReadStore')
					{
						if(this.grid.params.domIdArray)
						{
							 var grid = this.grid,
                             filterString = {},
                             field,
                             jsonKeys = this.grid.params.jsonArray,
                             fieldIds = this.grid.params.domIdArray;
                    
							 if(grid && (jsonKeys.length === fieldIds.length)) {
								 dojo.forEach(jsonKeys, function(key, i){
                                    field = dijit.byId(fieldIds[i]);
                                     if(field) {
                                             var fieldValue = field.get("value");
                                             fieldValue = fieldValue.replace("'", "\'");
                                             if(fieldValue != ""){
                                             	filterString[key] = fieldValue; 
                                             }
                                     }
								 });
                             
							}
							this.queryOptions=  filterString;
						}
						this.grid.setQuery(this.queryOptions);
					}
					else
					{
						this.grid.setQuery(this.grid.query);
					}
					this.grid.resize();
				}
				if(this.grid.rowSelectCell)
				{
					this.grid.rowSelectCell.toggleAllSelection(false);
				}
				window.preventTableHeaderFocus = false;
			},
			
			/**
			 * Set the query options which are on the screen. Browse through 
			 * search criteria on the screen and build the query options.
			 */
			
			setQueryOptions : function() {
				// summary: 
				//
				
				var form = dijit.byId("TransactionSearchForm"),
					grids = dojo.query(".dojoxGrid"),
					queryOptions = {},
					gridContainer = dojo.query(".gridContainer")[0],
					dateRegex = /Date/,
					timeRegex = /Time/;

				if(form)
				 {
					form.getDescendants().forEach(function(field, i){
						if(field.name) {
							var value ;
							// special case if the field is a radio button
							if(field.declaredClass == 'dijit.form.RadioButton')
							{
								var radioDomNodes = dojo.query("[name='" + field.name + "']", form.domNode);
								// iterate through radio buttons
								dojo.some(radioDomNodes, function(radioDomNode){
									var radioWidget=dijit.byNode(radioDomNode.parentNode);
									// if the radio button checked get its value
									if(radioWidget.checked)
									 {
										value = radioWidget.params.value;
									 }
									
								});
							}
							else
							{
								value = field.get("value");
							}
							if(dateRegex.test(field.declaredClass) || (timeRegex.test(field.declaredClass))) {
								value = field.get("displayedValue");
							}
							if(value === " ") {
								value = "";
							}
							queryOptions[field.get("name")] = value;
						}
					});
					queryOptions["searchFlag"] = true;
					this.queryOptions = queryOptions;
				  }
			}
			
		}
);

dojox.grid.EnhancedGrid.registerPlugin(misys.grid.Pagination/*name:'paginationEnhanced'*/);

}

if(!dojo._hasResource["misys.grid.IndirectSelection"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.grid.IndirectSelection"] = true;
dojo.provide("misys.grid.IndirectSelection");





dojo.declare("misys.grid.IndirectSelection", dojox.grid.enhanced._Plugin, {
	// summary:
	//		A handy way for adding check boxe/radio button for rows, and selecting rows by swiping(or keyboard)

	// description:
	//		For better rendering performance, div(images) are used to simulate radio button|check boxes
	//
	// example:
	//		<div dojoType="dojox.grid.EnhancedGrid" plugins="{indirectSelection: true}" ...></div>
	//		or <div dojoType="dojox.grid.EnhancedGrid" plugins="{indirectSelection: {name: 'xxx', width:'30px', styles:'text-align: center;'}}" ...></div>

	//name: String
	//		Plugin name
	name: "misysIndirectSelection", 
	
	constructor: function(){
		//Hook layout.setStructure(), so that indirectSelection is always included
		var layout = this.grid.layout;
		this.connect(layout, 'setStructure', dojo.hitch(layout, this.addRowSelectCell, this.option));
	},
	addRowSelectCell: function(option){
		// summary:
		//		Add indirectSelection cell(mapped to a column of radio button|check boxes)
		if(!this.grid.misysIndirectSelection || this.grid.selectionMode == 'none'){
			return;
		}
		var rowSelectCellAdded = false, inValidFields = ['get', 'formatter', 'field', 'fields'],
		defaultCellDef = {type: misys.grid.MultipleRowSelector, name: '', width:'30px', styles:'text-align: center;'};
		if(option.headerSelector){ option.name = ''; }//mutual conflicting attrs

		if(this.grid.rowSelectCell){//remove the existed one
			this.grid.rowSelectCell.destroy();
		}
		
		dojo.forEach(this.structure, function(view){
			var cells = view.cells;
			if(cells && cells.length > 0 && !rowSelectCellAdded){
				var firstRow = cells[0];
				if(firstRow[0] && firstRow[0].isRowSelector){
					console.debug('addRowSelectCell() - row selector cells already added, return.');
					rowSelectCellAdded = true;
					return;
				}
				var selectDef, cellType = this.grid.selectionMode == 'single' ? misys.grid.SingleRowSelector : misys.grid.MultipleRowSelector;
				selectDef = dojo.mixin(defaultCellDef, option, {type: cellType, editable: false, notselectable: true, filterable: false, navigatable: true, nosort: true});
				dojo.forEach(inValidFields, function(field){//remove invalid fields
					if(field in selectDef){ delete selectDef[field]; }
				});
				if(cells.length > 1){ selectDef.rowSpan = cells.length; }//for complicate layout
				dojo.forEach(this.cells, function(cell, i){
					if(cell.index >= 0){
						cell.index += 1;
						//console.debug('cell '+ (cell.index - 1) +  ' is updated to index ' + cell.index);
					}else{
						console.warn('Error:IndirectSelection.addRowSelectCell()-  cell ' + i + ' has no index!');
					}
				});
				var rowSelectCell = this.addCellDef(0, 0, selectDef);
				rowSelectCell.index = 0;
				firstRow.unshift(rowSelectCell);
				this.cells.unshift(rowSelectCell);
				this.grid.rowSelectCell = rowSelectCell;
				rowSelectCellAdded = true;
			}
		}, this);
		this.cellCount = this.cells.length;
	},
	destroy: function(){
		if(this.grid && this.grid.rowSelectCell) {
			this.grid.rowSelectCell.destroy();
			delete this.grid.rowSelectCell;
		}
		this.inherited(arguments);
	}
});

dojo.declare("misys.grid.RowSelector", dojox.grid.cells._Widget, {
	// summary:
	//		 Common attributes & functions for row selectors(Radio|CheckBox)

	//inputType: String
	//		Input type - Radio|CheckBox
	inputType: "",
	
	//map: Object
	//		Cache div refs of radio|checkbox to avoid querying each time
	map: null,
	
	//disabledMap: Object
	//		Cache index of disabled rows
	disabledMap: null,
	
	//isRowSelector: Boolean
	//		Marker of indirectSelection cell(column)
	isRowSelector: true,

	//_connects: Array
	//		List of all connections.
	_connects: null,
	
	//_subscribes: Array
	//		List of all subscribes.
	_subscribes: null,

	//checkedText: String
	//		Checked character for high contrast mode
	checkedText: '&#8730;',

	//unCheckedText: String
	//		Unchecked character for high contrast mode
	unCheckedText: 'O',

	constructor: function(){
		this.map = {}; this.disabledMap = {}; this.disabledCount= 0;
		this._connects = []; this._subscribes = [];
		this.inA11YMode = dojo.hasClass(dojo.body(), "dijit_a11y");
		
		this.baseClass = "dojoxGridRowSelector dijitReset dijitInline dijit" + this.inputType;
		this.checkedClass = " dijit" + this.inputType + "Checked";
		this.disabledClass = " dijit" + this.inputType + "Disabled";
		this.checkedDisabledClass = " dijit" + this.inputType + "CheckedDisabled";
		this.statusTextClass = " dojoxGridRowSelectorStatusText";//a11y use

		this._connects.push(dojo.connect(this.grid, 'dokeyup', this, '_dokeyup'));
		this._connects.push(dojo.connect(this.grid.selection, 'onSelected', this, '_onSelected'));
		this._connects.push(dojo.connect(this.grid.selection, 'onDeselected', this, '_onDeselected'));
		this._connects.push(dojo.connect(this.grid.scroller, 'invalidatePageNode', this, '_pageDestroyed'));
		this._connects.push(dojo.connect(this.grid, 'onCellClick', this, '_onClick'));
		this._connects.push(dojo.connect(this.grid, 'updateRow', this, '_onUpdateRow'));
	},
	formatter: function(data, rowIndex){
		// summary:
		//		Overwritten, see dojox.grid.cells._Widget
		var clazz = this.baseClass;
		var checked = this.getValue(rowIndex);
		var disabled = !!this.disabledMap[rowIndex];//normalize 'undefined'
		
		if(checked){
			clazz += this.checkedClass;
			if(disabled){ clazz += this.checkedDisabledClass; }
		}else if(disabled){
			clazz += this.disabledClass;
		}
		
		if(window.isAccessibilityEnabled && window.isAccessibilityEnabled === true) {
			var contextText = "";
			try { 
				
				var context=dojo.attr(this.grid.id +"_rowSelector_a11y-1-context","innerHTML");
				var keys = dojo.attr(this.grid.id +"_rowSelector_a11y-1-keys","innerHTML").split(",");
				var store = this.grid.store;
				var item = store._items[rowIndex];
				var keysMappedToValues = dojo.map(keys, function(key){
					return store.getValue(item, key);
				});
				contextText = misys.getLocalization('unchecked') +  dojo.string.substitute(context, keysMappedToValues); //console.log(contextText);
			} catch(exc) {
				contextText = "Onclick selects/deselects the row "; //Setting the default value on exception 
			}
			
			
			return ["<div tabindex = -1 ",
							"id = '" + this.grid.id + "_rowSelector_" + rowIndex + "' ",
							"name = '" + this.grid.id + "_rowSelector' class = '" + clazz + "' ",
							"role = 'checkbox' aria-checked = '" + checked + "' aria-disabled = '" + disabled +
							//"' aria-describedby = '" + this.grid.id + "_rowSelector_" + rowIndex + "_a11y_text",
							"' aria-label = '" + dojo.string.substitute(this.grid._nls["indirectSelection" + this.inputType], [rowIndex + 1]) + (checked ? this.checkedText : this.unCheckedText) + "'>",
							"<span class = '" + this.statusTextClass + "'>" + (checked ? this.checkedText : this.unCheckedText) + "</span>",
							"<span class = 'sr-only' aria-live='polite' id='"+ this.grid.id + "_rowSelector_" + rowIndex + "_a11y_text' class='sr-only'>" + contextText +  " </span>",
							"</div>"].join("");
		} else {
			return ["<div tabindex = -1 ",
							"id = '" + this.grid.id + "_rowSelector_" + rowIndex + "' ",
							"name = '" + this.grid.id + "_rowSelector' class = '" + clazz + "' ",
							"role = 'presentation' aria-checked = '" + checked + "' aria-disabled = '" + disabled +
							"' aria-label = '" + dojo.string.substitute(this.grid._nls["indirectSelection" + this.inputType], [rowIndex + 1]) + "'>",
							"<span class = '" + this.statusTextClass + "'>" + (checked ? this.checkedText : this.unCheckedText) + "</span>",
							"</div>"].join("");
		}
	},
	setValue: function(rowIndex, inValue){
		// summary:
		//		Overwritten, see dojox.grid.cells._Widget
		//		Simply return, no action
	},
	getValue: function(rowIndex){
		// summary:
		//		Overwritten, see dojox.grid.cells._Widget
		return this.grid.selection.isSelected(rowIndex);
	},
	toggleRow: function(index, value){
		// summary:
		//		toggle checked | unchecked state for given row
		// index: Integer
		//		Row index
		// value: Boolean
		//		True - checked | False - unchecked
		this._nativeSelect(index, value);
	},
	setDisabled: function(index, disabled){
		// summary:
		//		toggle disabled | enabled state for given row
		// idx: Integer
		//		Row index
		// disabled: Boolean
		//		True - disabled | False - enabled
		if(index < 0){ return; }
		this._toggleDisabledStyle(index, disabled);
	},
	disabled: function(index){
		// summary:
		//		Check if one row is disabled
		return !!this.disabledMap[index];
	},
	_onClick: function(e){
		// summary:
		//		When mouse click on the selector cell, select/deselect the row.
		if(e.cell === this){
			this._selectRow(e);
		}
	},
	_dokeyup: function(e){
		// summary:
		//		Event handler for key up event
		//		- from dojox.grid.enhanced._Events.dokeyup()
		// e: Event
		//		Key up event
		if(e.cellIndex == this.index && e.rowIndex >= 0 && (e.keyCode == dojo.keys.SPACE || e.keyCode == dojo.keys.ENTER)){
			this._selectRow(e);
		}
	},
	focus: function(rowIndex){
		// summary:
		//		Set focus to given row
		// rowIndex: Integer
		//		Target row
		var selector = this.map[rowIndex];
		if(selector){ selector.focus(); }
	},
	_focusEndingCell: function(rowIndex, cellIndex){
		// summary:
		//		Set focus to the ending grid cell(rowIndex,cellIndex) when swipe selection finished
		// rowIndex: Integer
		//		Row index
		// cellIndex: Integer
		//		Column index
		var cell = this.grid.getCell(cellIndex);
		this.grid.focus.setFocusCell(cell, rowIndex);
	},
	_nativeSelect: function(index, value){
		// summary:
		//		Use grid's native selection
		this.grid.selection[value ? 'select' : 'deselect'](index);
	},
	_onSelected: function(index){
		// summary:
		//		Triggered when a row is selected
		this._toggleCheckedStyle(index, true);
	},
	_onDeselected: function(index){
		// summary:
		//		Triggered when a row is deselected
		this._toggleCheckedStyle(index, false);
	},
	_onUpdateRow: function(index){
		// summary:
		//		Clear cache when row is re-built.
		delete this.map[index];
	},
	_toggleCheckedStyle: function(index, value){
		// summary:
		//		Change css styles for checked | unchecked
		var selector = this._getSelector(index);
		if(selector){
			dojo.toggleClass(selector, this.checkedClass, value);
			if(this.disabledMap[index]){
				dojo.toggleClass(selector, this.checkedDisabledClass, value);
			}
			dijit.setWaiState(selector, 'checked', value);
			if(this.inA11YMode){
				dojo.attr(selector.firstChild, 'innerHTML', value ? this.checkedText : this.unCheckedText);
			}
			//To reset the checkbox context on selection/deselection
			if(window.isAccessibilityEnabled && window.isAccessibilityEnabled === true) {
				
				var tempHtmlText1 =  (value) ? (this.inputType + " " + misys.getLocalization('checked') + ".") :  (this.inputType + " " + misys.getLocalization('unchecked') + ".") ;
				dojo.attr(dojo.query("#" + this.grid.id + "_rowSelector_"+index)[0],'aria-label', 
						dojo.string.substitute(this.grid._nls["indirectSelection" + this.inputType], [index + 1]) + " " + tempHtmlText1);				
				
				try {
					var a11yText = dojo.attr(dojo.query("#"+this.grid.id+"_rowSelector_"+index+"_a11y_text")[0],"innerHTML");//grid1523317409947817048_rowSelector_0_a11y_text
					a11yText = a11yText.replace(misys.getLocalization('unchecked'),"");
					a11yText = a11yText.replace(misys.getLocalization('checked'),"");
					var appendText = (value)? misys.getLocalization('checked'): misys.getLocalization('unchecked');
					dojo.attr(dojo.query("#"+this.grid.id+"_rowSelector_"+index+"_a11y_text")[0],"innerHTML",appendText + a11yText);  
				} catch (exc) {
					console.log(exc.stacktrace);
				}
			}			
		}
	},
	_toggleDisabledStyle: function(index, disabled){
		// summary:
		//		Change css styles for disabled | enabled
		var selector = this._getSelector(index);
		if(selector){
			dojo.toggleClass(selector, this.disabledClass, disabled);
			if(this.getValue(index)){
				dojo.toggleClass(selector, this.checkedDisabledClass, disabled);
			}
			dijit.setWaiState(selector, 'disabled', disabled);
		}
		this.disabledMap[index] = disabled;
		if(index >= 0){
			this.disabledCount += disabled ? 1 : -1;
		}
	},
	_getSelector: function(index){
		// summary:
		//		Find selector for given row caching it if 1st time found
		var selector = this.map[index];
		if(!selector){//use accurate query for better performance
			var rowNode = this.view.rowNodes[index];
			if(rowNode){
				selector = dojo.query('.dojoxGridRowSelector', rowNode)[0];
				if(selector){ this.map[index] = selector; }
			}
		}
		return selector;
	},
	_pageDestroyed: function(pageIndex){
		// summary:
		//		Explicitly empty map cache when a page destroyed
		//		See dojox.grid._Scroller.invalidatePageNode()
		// pageIndex: Integer
		//		Index of destroyed page
		var rowsPerPage = this.grid.scroller.rowsPerPage;
		var start = pageIndex * rowsPerPage, end = start + rowsPerPage - 1;
		for(var i = start; i <= end; i++){
			if(!this.map[i]){continue;}
			dojo.destroy(this.map[i]);
			delete this.map[i];
		}
		//console.log("Page ",pageIndex, " destroyed, Map=",this.map);
	},
	destroy: function(){
		for(var i in this.map){
			dojo.destroy(this.map[i]);
			delete this.map[i];
		}
		for(i in this.disabledMap){ delete this.disabledMap[i]; }
		dojo.forEach(this._connects, dojo.disconnect);
		dojo.forEach(this._subscribes, dojo.unsubscribe);
		delete this._connects;
		delete this._subscribes;
		//console.log('Single(Multiple)RowSelector.destroy() executed!');
	}
});

dojo.declare("misys.grid.SingleRowSelector", misys.grid.RowSelector, {
	// summary:
	//		IndirectSelection cell(column) for single selection mode, using styles of dijit.form.RadioButton
	inputType: "Radio",

	_selectRow: function(e){
		// summary:
		//		Select the target row
		// e: Event
		//		Event fired on the target row
		var index = e.rowIndex;
		if(this.disabledMap[index]){ return; }
		this._focusEndingCell(index, 0);
		this._nativeSelect(index, !this.grid.selection.selected[index]);
	}
});

dojo.declare("misys.grid.MultipleRowSelector", misys.grid.RowSelector, {
	// summary:
	//		Indirect selection cell for multiple or extended mode, using dijit.form.CheckBox
	inputType: "CheckBox",
	
	//swipeStartRowIndex: Integer
	//		Start row index for swipe selection
	swipeStartRowIndex: -1,

	//swipeMinRowIndex: Integer
	//		Min row index for swipe selection
	swipeMinRowIndex: -1,
	
	//swipeMinRowIndex: Integer
	//		Max row index for swipe selection
	swipeMaxRowIndex: -1,
	
	//toSelect: Boolean
	//		new state for selection
	toSelect: false,
	
	//lastClickRowIdx: Integer
	//		Row index for last click, used for range selection via Shift + click
	lastClickRowIdx: -1,
	
	//toggleAllTrigerred: Boolean
	//		Whether toggle all has been triggered or not
	toggleAllTrigerred: false,
	
	unCheckedText: '&#9633;',

	constructor: function(){
		this._connects.push(dojo.connect(dojo.doc, 'onmouseup', this, '_domouseup'));
		this._connects.push(dojo.connect(this.grid, 'onRowMouseOver', this, '_onRowMouseOver'));
		this._connects.push(dojo.connect(this.grid.focus, 'move', this, '_swipeByKey'));
		this._connects.push(dojo.connect(this.grid, 'onCellMouseDown', this, '_onMouseDown'));
		if(this.headerSelector){//option set by user to add a select-all checkbox in column header
			this._connects.push(dojo.connect(this.grid.views, 'render', this, '_addHeaderSelector'));
			this._connects.push(dojo.connect(this.grid, 'onSelectionChanged', this, '_onSelectionChanged'));
			this._connects.push(dojo.connect(this.grid, 'onKeyDown', this, function(e){
				if(e.rowIndex == -1 && e.cellIndex == this.index && (e.keyCode == dojo.keys.SPACE || e.keyCode == dojo.keys.ENTER)){
					this._toggletHeader();//TBD - a better way
				}
			}));
		}
	},
	toggleAllSelection:function(checked){
		// summary:
		//		Toggle select all|deselect all
		// checked: Boolean
		//		True - select all, False - deselect all
		var grid = this.grid, selection = grid.selection;
		if(checked){
			selection.selectRange(0, grid.rowCount-1);
		}else{
			selection.deselectAll();
		}
		this.toggleAllTrigerred = true;
		
		var rowCount =  this.grid.rowCount; 
    	for(var i=0;i<rowCount;i++){
    		var item = this.grid.getItem(i);
    		var flag;
			if(item){ 
				flag = this.grid.store.getValue(item,'disable_selection'); 
			} 
			if(flag === 'Y'){
				this.grid.rowSelectCell.toggleRow(i, false);
			}
    	}
	},
	_onMouseDown: function(e){
		if(e.cell == this){
			this._startSelection(e.rowIndex);
			dojo.stopEvent(e);
		}
	},
	_onRowMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over a data row(outside of this column).
		//      - from dojox.grid.enhanced._Events.onRowMouseOver()
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this._updateSelection(e, 0);
	},
	_domouseup: function(e){
		// summary:
		//		Event handler for mouse up event - from dojo.doc.domouseup()
		// e: Event
		//		Mouse up event
		if(dojo.isIE){
			this.view.content.decorateEvent(e);//TODO - why only e in IE hasn't been decorated?
		}
		var inSwipeSelection = e.cellIndex >= 0 && this.inSwipeSelection() && !this.grid.edit.isEditRow(e.rowIndex);
		if(inSwipeSelection){
			this._focusEndingCell(e.rowIndex, e.cellIndex);
		}
		this._finishSelect();
	},
	_dokeyup: function(e){
		// summary:
		//		Event handler for key up event
		//		- from dojox.grid.enhanced._Events.dokeyup()
		// e: Event
		//		Key up event
		this.inherited(arguments);
		if(!e.shiftKey){
			this._finishSelect();
		}
	},
	_startSelection: function(rowIndex){
		// summary:
		//		Initialize parameters to start a new swipe selection
		// rowIndex: Integer
		//		Index of the start row
		this.swipeStartRowIndex = this.swipeMinRowIndex = this.swipeMaxRowIndex = rowIndex;
		this.toSelect = !this.getValue(rowIndex);
	},
	_updateSelection: function(e, delta){
		// summary:
		//		Update row selections, fired during a swipe selection
		// e: Event
		//		Event of the current row,
		// delta: Integer
		//		Row index delta, used for swipe selection via Shift + Arrow key
		//		0: not via key, -1 : Shift +  Up, 1 : Shift + Down
		if(!this.inSwipeSelection()){ return; }
		
		var byKey = delta !== 0;//whether via Shift + Arrow Key
		var currRow = e.rowIndex, deltaRow = currRow - this.swipeStartRowIndex + delta;
		if(deltaRow > 0 && this.swipeMaxRowIndex < currRow + delta){
			this.swipeMaxRowIndex = currRow + delta;
		}
		if(deltaRow < 0 && this.swipeMinRowIndex > currRow + delta){
			this.swipeMinRowIndex = currRow + delta;
		}

		var min = deltaRow > 0 ? this.swipeStartRowIndex : currRow + delta;
		var max = deltaRow > 0 ? currRow + delta : this.swipeStartRowIndex;
		for(var i = this.swipeMinRowIndex; i <= this.swipeMaxRowIndex; i++){
			if(this.disabledMap[i] || i < 0){ continue; }
			if(i >= min && i <= max){//deltaRow != 0 || this.toSelect
				this._nativeSelect(i, this.toSelect);
			}else if(!byKey){
				this._nativeSelect(i, !this.toSelect);
			}
		}
	},
	_swipeByKey: function(rowOffset, colOffset, e){
		// summary:
		//		Update row selections, fired when Shift + Cursor is used for swipe selection
		//		See dojox.grid.enhanced._Events.onKeyDown
		// e: Event
		//		Event of the current row,
		// rowOffset: Integer
		//		Row offset, used for swipe selection via Shift + Cursor
		//		-1 : Shift +  Up, 1 : Shift + Down
		if(!e || rowOffset === 0 || !e.shiftKey || e.cellIndex != this.index ||
			this.grid.focus.rowIndex < 0){ //TBD - e.rowIndex == 0 && delta == -1
			return;
		}
		var rowIndex = e.rowIndex;
		if(this.swipeStartRowIndex < 0){
			//A new swipe selection starts via Shift + Arrow key
			this.swipeStartRowIndex = rowIndex;
			if(rowOffset > 0){//Shift + Down
				this.swipeMaxRowIndex = rowIndex + rowOffset;
				this.swipeMinRowIndex = rowIndex;
			}else{//Shift + UP
				this.swipeMinRowIndex = rowIndex + rowOffset;
				this.swipeMaxRowIndex = rowIndex;
			}
			this.toSelect = this.getValue(rowIndex);
		}
		this._updateSelection(e, rowOffset);
	},
	_finishSelect: function(){
		// summary:
		//		Reset parameters to end a swipe selection
		this.swipeStartRowIndex = -1;
		this.swipeMinRowIndex = -1;
		this.swipeMaxRowIndex = -1;
		this.toSelect = false;
	},
	inSwipeSelection: function(){
		// summary:
		//		Check if during a swipe selection
		// return: Boolean
		//		Whether in swipe selection
		return this.swipeStartRowIndex >= 0;
	},
	_nativeSelect: function(index, value){
		// summary:
		//		Overwritten
		this.grid.selection[value ? 'addToSelection' : 'deselect'](index);		
	},
	_selectRow: function(e){
		// summary:
		//		Select the target row or range or rows
		// e: Event
		//		Event fired on the target row
		var rowIndex = e.rowIndex;
		if(this.disabledMap[rowIndex]){ return; }
		dojo.stopEvent(e);
		this._focusEndingCell(rowIndex, 0);
		
		var delta = rowIndex - this.lastClickRowIdx;
		var newValue = !this.grid.selection.selected[rowIndex];
		if(this.lastClickRowIdx >= 0 && !e.ctrlKey && !e.altKey && e.shiftKey){
			var min = delta > 0 ? this.lastClickRowIdx : rowIndex;
			var max = delta > 0 ? rowIndex : this.lastClickRowIdx;
			for(var i = min; i >= 0 && i <= max; i++){
				this._nativeSelect(i, newValue);
			}
		}else{
			this._nativeSelect(rowIndex, newValue);
		}
		this.lastClickRowIdx = rowIndex;
	},
	getValue: function(rowIndex){
		// summary:
		//		Overwritten
		if(rowIndex == -1){//header selector
			var g = this.grid;
			return g.rowCount > 0 && g.rowCount <= g.selection.getSelectedCount();
		}
		return this.inherited(arguments);
	},
	_addHeaderSelector: function(){
		// summary:
		//		Add selector in column header for selecting|deselecting all
		var headerCellNode = this.view.getHeaderCellNode(this.index);
		if(!headerCellNode){ return; }
		dojo.empty(headerCellNode);
		var g = this.grid;
		var selector = null;
		if(window.isAccessibilityEnabled && window.isAccessibilityEnabled === true) {
			if(!dojo.byId(g.id +"_rowSelector_a11y-1-context")) {
				
			var a11ySelectionContextCols = dojo.filter(this.grid.layout.cells, function(headerCell) {
				return (headerCell.a11ySelectionContext === "true");
			});
			var a11ySelectionContextText = "";
			var a11ySelectionContextKeys = "";
			var iTemp = 0; 
				dojo.map(a11ySelectionContextCols, function(headerCell) {
					if(a11ySelectionContextText == "") {
						a11ySelectionContextText =  headerCell.name +": ${" +(iTemp++) + "}";
						a11ySelectionContextKeys = headerCell.field;
					} else {
						a11ySelectionContextText = a11ySelectionContextText + ", " + misys.getLocalization('with') +" " + headerCell.name  +" ${" +(iTemp++) + "}";
						a11ySelectionContextKeys = a11ySelectionContextKeys + "," + headerCell.field;
					}
				});
				
				this.grid.domNode.appendChild(dojo.create("span", { "id" : g.id +"_rowSelector_a11y-1-context", "class": "sr-only", "innerHTML":a11ySelectionContextText}));
				this.grid.domNode.appendChild(dojo.create("span", { "id" : g.id +"_rowSelector_a11y-1-keys", "class": "sr-only", "innerHTML":a11ySelectionContextKeys}));
				
			}

			selector = headerCellNode.appendChild(dojo.create("div", {
				"tabindex": -1, "id": g.id + "_rowSelector_-1", "class": this.baseClass, "role": "checkbox", "aria-checked":"false", 
				"aria-describedby": g.id +"_rowSelector_a11y-1-text",
				"innerHTML": "<span  class = 'sr-only' aria-live='polite' id='"+ g.id +"_rowSelector_a11y-1-text' class='sr-only'/>"
			}));
			
		} else {
			selector = headerCellNode.appendChild(dojo.create("div", {
						"tabindex": -1, "id": g.id + "_rowSelector_-1", "class": this.baseClass, "role": "presentation",
						"innerHTML": "<span class = '" + this.statusTextClass +
							"'></span><span style='height: 0; width: 0; overflow: hidden; display: block;'>" +
							g._nls["selectAll"] + "</span>"
			}));	
		}
		this.map[-1] = selector;
		var idx = this._headerSelectorConnectIdx;
		if(idx !== undefined){
			dojo.disconnect(this._connects[idx]);
			this._connects.splice(idx, 1);
		}
		this._headerSelectorConnectIdx = this._connects.length;
		this._connects.push(dojo.connect(selector, 'onclick', this, '_toggletHeader'));
		//To reset the header a11y text 
		if(window.isAccessibilityEnabled && window.isAccessibilityEnabled === true) {
			try {
				var a11yText = misys.getLocalization('unchecked') + this.grid.paginationEnhanced.plugin.paginators[0].descriptionDiv.innerHTML; 
				dojo.attr(this.grid.id +'_rowSelector_a11y-1-text','innerHTML',a11yText);
			} catch (exc) { }
		}		
		this._onSelectionChanged();
	},
	_toggletHeader: function(){
		// summary:
		//		Toggle state for head selector
		if(!!this.disabledMap[-1]){ return; }
		this.grid._selectingRange = true;
		this.toggleAllSelection(!this.getValue(-1));
		this._onSelectionChanged();
		this.grid._selectingRange = false;
		
		//To reset the header a11y text 
		if(window.isAccessibilityEnabled && window.isAccessibilityEnabled === true) {
			try {
				var a11yText = this.grid.paginationEnhanced.plugin.paginators[0].descriptionDiv.innerHTML; 
				var appendText = !this.getValue(-1) ? misys.getLocalization('unchecked'): misys.getLocalization('checked');
				dojo.attr(this.grid.id +'_rowSelector_a11y-1-text','innerHTML',appendText + a11yText);
			} catch (exc) { }
		}		
	},
	_onSelectionChanged: function(){
		// summary:
		//		Update header selector anytime selection changed
		var g = this.grid;
		if(!this.map[-1] || g._selectingRange){ return; }
		this._toggleCheckedStyle(-1, this.getValue(-1));
	},
	_toggleDisabledStyle: function(index, disabled){
		// summary:
		//		Overwritten
		this.inherited(arguments);
		if(this.headerSelector){
			var allDisabled = (this.grid.rowCount == this.disabledCount);
			if(allDisabled != !!this.disabledMap[-1]){//only if needed
				arguments[0] = -1;
				arguments[1] = allDisabled;
				this.inherited(arguments);
			}
		}
	}
});

dojox.grid.EnhancedGrid.registerPlugin(misys.grid.IndirectSelection/*name:'misysIndirectSelection'*/, {"preInit": true});

}

if(!dojo._hasResource["misys.calendar.Calendar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.calendar.Calendar"] = true;
dojo.provide("misys.calendar.Calendar");
dojo.experimental("misys.calendar.Calendar"); 




dojo.declare("misys.calendar.Calendar",
        [ dijit.Calendar ],
        {
			// summary:
			//		A dynamic calendar for the main page
			//
			// description:
			//		Creates a calendar, similar to the one that pops up in form fields
			//		except in this instance MTP events will be highlighted, with details
			//		in a balloon popup.
			//
			// example:
			// |	<div dojoType='misys.calendar.MTPCalendar' monthOffset='0' style='width:100%'></div>
			//

		 templateString: dojo.cache("misys.calendar", "templates/Calendar.html", "<table cellspacing=\"0\" cellpadding=\"0\" class=\"dijitCalendarContainer\" role=\"grid\" dojoAttachEvent=\"onkeypress: _onKeyPress\" aria-labelledby=\"${id}_year calendar-instructions\">\n\t<thead>\n\t\t<tr class=\"dijitReset dijitCalendarMonthContainer\" valign=\"top\">\n\t\t\t<th id=\"decrement_month\" class='dijitReset dijitCalendarArrow' dojoAttachPoint=\"decrementMonth\">\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarDecrease\" role=\"presentation\"/>\n\t\t\t\t<span dojoAttachPoint=\"decreaseArrowNode\" class=\"dijitA11ySideArrow\">-</span>\n\t\t\t</th>\n\t\t\t\n\t\t\t<th id=\"dijit_reset\" dojoAttachPoint=\"monthLabel\" class='dijitReset' colspan=\"5\">\n\t\t\t\t<div class=\"dijitVisible\">\n\t\t\t\t\t<div class=\"dijitPopup dijitMenu dijitMenuPassive dijitHidden\" dojoAttachPoint=\"monthDropDownButton\">\n\t\t\t\t\t\t<div class=\"dijitCalendarMonthLabelTemplate dijitCalendarMonthLabel\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div dojoAttachPoint=\"monthLabelSpacer\" class=\"dijitSpacer\"></div>\n\t\t\t\t<div dojoAttachPoint=\"monthLabelNode\" class=\"dijitCalendarMonthLabel dijitInline dijitVisible\" dojoAttachEvent=\"onmousedown: _onMonthToggle\"></div>\n\t\t\t</th>\n\t\t\t\n\n\t\t\t<!--  th dojoAttachPoint=\"monthLabel\" class='dijitReset' colspan=\"5\">\n\t\t\t\t<div dojoType=\"dijit.form.DropDownButton\" dojoAttachPoint=\"monthDropDownButton\"\n\t\t\t\t\tid=\"${id}_mddb\" tabIndex=\"-1\">\n\t\t\t\t</div>\n\t\t\t</th>\n \t\t\t-->\n\t\t\t<th id=\"increment_month\" class='dijitReset dijitCalendarArrow' dojoAttachPoint=\"incrementMonth\">\n\t\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitCalendarIncrementControl dijitCalendarIncrease\" role=\"presentation\"/>\n\t\t\t\t<span dojoAttachPoint=\"increaseArrowNode\" class=\"dijitA11ySideArrow\">+</span>\n\t\t\t</th>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<th id=\"header\" class=\"dijitReset dijitCalendarDayLabelTemplate\" role=\"columnheader\"><span class=\"dijitCalendarDayLabel\"></span></th>\n\t\t</tr>\n\t</thead>\n\t<tbody dojoAttachEvent=\"onclick: _onDayClick, onmouseover: _onDayMouseOver, onmouseout: _onDayMouseOut, onmousedown: _onDayMouseDown, onmouseup: _onDayMouseUp\" class=\"dijitReset dijitCalendarBodyContainer\">\n\t\t<tr class=\"dijitReset dijitCalendarWeekTemplate\" role=\"row\">\n\t\t\t<td class=\"dijitReset dijitCalendarDateTemplate\" role=\"gridcell\"><span class=\"dijitCalendarDateLabel\"></span></td>\n\t\t</tr>\n\t</tbody>\n\t<tfoot class=\"dijitReset dijitCalendarYearContainer\">\n\t\t<tr>\n\t\t\t<td class='dijitReset' valign=\"top\" colspan=\"7\">\n\t\t\t\t<h3 class=\"dijitCalendarYearLabel\">\n\t\t\t\t\t<span dojoAttachPoint=\"previousYearLabelNode\" class=\"dijitInline dijitCalendarPreviousYear\"></span>\n\t\t\t\t\t<span dojoAttachPoint=\"currentYearLabelNode\" class=\"dijitInline dijitCalendarSelectedYear\" id=\"${id}_year\"></span>\n\t\t\t\t\t<span dojoAttachPoint=\"nextYearLabelNode\" class=\"dijitInline dijitCalendarNextYear\"></span>\n\t\t\t\t</h3>\n\t\t\t</td>\n\t\t</tr>\n\t</tfoot>\n</table>\n"),
		 
		 tooltipTemplateString : "<span class=\'cal-event\'>{content}</span>",
		 
		 tooltipDuration : 10000,
		 
		 // Tooltips active for the current month
		 activeTooltips : [],
		 
		 // monthOffset: Integer
		 //             How many months to offset the calendar to
		 monthOffset: 0,

		 // calendarDateHasChanged: boolean
		 //	                Whether the user has changed the calendar by clicking on a next/prev date/year
		 calendarDateHasChanged: false,
		 
		 // Max number of events to show
		 eventLimit: 10,
		 
		 eventsLoaded: false,
		 
		 // TODO Find a better solution to this
		 _onDayClick: function(/*Event*/ evt){
			// summary:
			//      Handler for when user clicks a day
			// tags:
			//      protected
			for(var node = evt.target; node && !node.dijitDateValue; node = node.parentNode){
				/*jsl:pass*/
			}
			 
			if(node && !dojo.hasClass(node, "dijitCalendarDisabledDate")){
				this.set('value', node.dijitDateValue);
			}
			
			var calDate = dojo.date.locale.format(this.value, {
				selector :'date',
				datePattern : 'yyyyMMdd'
			});
			console.debug("[misys.calendar] Forwarding to Full Events screen for " + calDate);
			dojo.global.location = misys.getServletURL("/screen/FullEventsScreen?operation=LIST_FEATURES&date=" + calDate);
		 },
		 
		 postCreate: function(){
			var relatedIdBefore = 0;
			var calendarId = this.id;
			if(calendarId.indexOf('_', 1)>0){
				currentId = calendarId.substring(9, calendarId.length);
				relatedIdBefore = parseInt(currentId, 10) - 1;
				if(relatedIdBefore < 0){
					relatedIdBefore=11;
				}
			}
			if(dijit.byId('calendar_'+relatedIdBefore)){
				console.debug('[misys.calendar] Hide navigation buttons for calendar with id : ' + this.id);
				dojo.style(this.incrementMonth, "display", "none");
				dojo.style(this.decrementMonth, "display", "none");
				dojo.style(this.nextYearLabelNode, "display", "none");
				dojo.style(this.previousYearLabelNode, "display", "none");
				this.monthLabel.setAttribute("colSpan", 7);
			}
			 this.inherited(arguments);
			 if(this.monthOffset !== 0)
			 {
				this._adjustDisplay("month", this.monthOffset);
			 }
			 var onGoingTaskDIv = dojo.byId('CustomerOngoingTasksList')?true:false;
			 var internalNewsDiv= dojo.byId('InternalNewsPortlet')?true:false;
			 var outstandingChartDiv = dojo.byId('OutstandingPerProductChartPortlet')?true:false;
			 var tradeEventDiv = dojo.byId('TradeEventsGridPortlet')?true:false;
			 var accountSummaryDiv = dojo.byId("HomeAccountSummaryListPortlet")?true:false;
			 var actionRequiredDiv = dojo.byId("ActionRequiredPortlet")?true:false;
			 var opicsListBalanceDiv = dojo.byId("OpicsAccountListPortletPlusBalance")?true:false;
			 var tradecalDiv = dojo.byId("TradeCalendarPortlet")?true:false; 
			 if(!onGoingTaskDIv && !internalNewsDiv && !outstandingChartDiv && !tradeEventDiv && !accountSummaryDiv && !actionRequiredDiv && !opicsListBalanceDiv)
			 {
				 /** MPS-59116 To show the Calender on home page if customer has less/limited permissions **/ 	
				 var currentCalendar = this.id;
				 var calendarIndex;
				 if(currentCalendar.indexOf('_', 1) > 0){
					 calendarIndex = currentCalendar.substring(9, currentCalendar.length);
				 }
				 var currentCalendarId = 'calendar_'+calendarIndex;
				 if(dijit.byId(currentCalendarId)){
					 if(tradecalDiv){
						 dojo.style(currentCalendarId, "width", 0);
						 dojo.style(currentCalendarId, "position", "relative");
						 dojo.style(currentCalendarId, "left", "100%");
					 }
				 }
			 }
		 },

		 _onMonthToggle: function(/*Event*/ evt){
				// catch the event
				dojo.stopEvent(evt);
				// get the date
				var dateValue = dojo.date.locale.format(this.currentFocus, {
					selector :'date',
					datePattern : 'yyyyMM'
				});
				// open the appropriate screen.
				// test if it has a next or previous calendar ; add Milestones option to the url.
				var relatedIdNext = 0;
				var relatedIdBefore = 0;
				var calendarId = this.id;
				if(calendarId.indexOf('_', 1)>0){
					currentId = calendarId.substring(9, calendarId.length);
					relatedIdNext = parseInt(currentId, 10) + 1;
					relatedIdBefore = parseInt(currentId, 10) - 1;
					if(relatedIdNext > 11)
					{
						relatedIdNext=0;
					}
					if(relatedIdBefore < 0)
					{
						relatedIdBefore=11;
					}
				}
				
				var suffix = '&date=' + dateValue;
//				if(dijit.byId('calendar_' + relatedIdNext) || dijit.byId('calendar_' + relatedIdBefore)){
//					suffix = '&option=MILESTONE' + suffix;
//				}
				
				console.debug("[misys.calendar] Forwarding to Full Events screen for " + dateValue);
				dojo.global.location = misys.getServletURL("/screen/FullEventsScreen?operation=LIST_FEATURES" + suffix);
			},

		 _adjustDisplay: function(/*String*/ part, /*int*/ amount){
			    // summary:
				//      Moves calendar forwards or backwards by months or years
				// part:
				//      "month" or "year"
				// amount:
				//      Number of months or years
				// tags:
				//      private
		    this.calendarDateHasChanged = true;
			this.inherited(arguments);
		 },

		 _updateNextDisplay: function(currentId, dateProp, adj, nodeProp){
				var relatedIdNext = currentId + 1;
				if(dijit.byId('calendar_'+relatedIdNext)){
					this._updateNextDisplay(relatedIdNext, dateProp, adj);
					dijit.byId('calendar_'+relatedIdNext)._adjustDisplay(dateProp, adj);
				}
		 },

		 _populateGrid: function(){
				// summary:
				//      Fills in the calendar grid with each day (1-31)
				// tags:
				//      private
		 
			 	// Add event CSS and tooltips
			 	//this._populateCalendar('', '');
			 
				var month = new this.dateClassObj(this.currentFocus);
				month.setDate(1);
				var firstDay = month.getDay(),
				daysInMonth = this.dateFuncObj.getDaysInMonth(month),
				daysInPreviousMonth = this.dateFuncObj.getDaysInMonth(this.dateFuncObj.add(month, "month", -1)),
				today = null;
				if(misys && misys._config && misys._config.bankBusinessDate && misys._config.bankBusinessDate !== ""){
					var yearServer = misys._config.bankBusinessDate.substring(0,4);
					var monthServer = misys._config.bankBusinessDate.substring(5,7);
					var dateServer = misys._config.bankBusinessDate.substring(8,10);
					today = new this.dateClassObj(yearServer,monthServer - 1,dateServer);
				}
				else{
					today = new this.dateClassObj();
				}
				var dayOffset = dojo.cldr.supplemental.getFirstDayOfWeek(this.lang);
				if(dayOffset > firstDay){ 
					dayOffset -= 7; 
				}

				// Iterate through dates in the calendar and fill in date numbers and style info
				var activeDates = dojo.query(".dijitCalendarDateTemplate", this.domNode);
				activeDates.forEach(function(template, i){
					i += dayOffset;
					var date = new this.dateClassObj(month),
					number, clazz = "dijitCalendar", adj = 0;

					if(i < firstDay){
						number = daysInPreviousMonth - firstDay + i + 1;
						adj = -1;
						clazz += "Previous";
					}else if(i >= (firstDay + daysInMonth)){
						number = i - firstDay - daysInMonth + 1;
						adj = 1;
						clazz += "Next";
					}else{
						number = i - firstDay + 1;
						clazz += "Current";
					}

					if(adj){
						date = this.dateFuncObj.add(date, "month", adj);
					}
					date.setDate(number);

					if(!this.dateFuncObj.compare(date, today, "date")){
					clazz = "dijitCalendarCurrentDate " + clazz;
					}

					if(this._isSelectedDate(date, this.lang)){
						clazz = "dijitCalendarSelectedDate " + clazz;
					}

					if(this.isDisabledDate(date, this.lang)){
						clazz = "dijitCalendarDisabledDate " + clazz;
					}

					var clazz2 = this.getClassForDate(date, this.lang);
					if(clazz2){
						clazz = clazz2 + " " + clazz;
					}
					
					// Keep any event classes, if we haven't clicked on a next/prev month/year
					var eventClass = '';
					if(!this.calendarDateHasChanged && template.className.indexOf('calevent') !== -1)
					{
							eventClass = template.className.substring(template.className.indexOf('calevent'));
					}
					
					template.className = clazz + "Month dijitCalendarDateTemplate " + eventClass;
					template.dijitDateValue = date.valueOf();				// original code
					dojo.attr(template, "dijitDateValue", date.valueOf());	// so I can dojo.query() it
					var label = dojo.query(".dijitCalendarDateLabel", template)[0],
						text = date.getDateLocalized ? date.getDateLocalized(this.lang) : date.getDate();
					this._setText(label, text);
				}, this);
				
				// Fill in localized month name
				var monthNames = dojo.date.locale.getNames('months', 'wide', 'standAlone', this.lang);
				this._setText(this.monthLabelNode, monthNames[month.getMonth()]);

				// Fill in localized prev/current/next years
				var y = month.getFullYear() - 1;
				var d = new this.dateClassObj();
				dojo.forEach(["previous", "current", "next"], function(name){
					d.setFullYear(y++);
					this._setText(this[name+"YearLabelNode"],
						this.dateLocaleModule.format(d, {selector:'year', locale:this.lang}));
				}, this);
				
				dojo.query('.calendarLoader').forEach(function(d){
					dojo.replaceClass(d, '');
					});
				
				// Populate calendar	
				var _this = this;
				if(!this.eventsLoaded) {
					console.debug('[misys.calendar] Loading events for calendar with id=' + this.id);
					var onGoingTaskDIv = dojo.byId('CustomerOngoingTasksList')? true:false;
					 var internalNewsDiv= dojo.byId('InternalNewsPortlet')? true:false;
					 var outstandingChartDiv = dojo.byId('OutstandingPerProductChartPortlet')? true:false;
					 var tradeEventDiv = dojo.byId('TradeEventsGridPortlet')? true:false;
					 var accountSummaryDiv = dojo.byId("HomeAccountSummaryListPortlet")? true:false;
					 var actionRequiredDiv = dojo.byId("ActionRequiredPortlet")? true:false;
					 var opicsListBalanceDiv = dojo.byId("OpicsAccountListPortletPlusBalance")? true:false;
					 if(!onGoingTaskDIv && !internalNewsDiv && !outstandingChartDiv && !tradeEventDiv && !accountSummaryDiv && !actionRequiredDiv && !opicsListBalanceDiv)
						 {
						 if(dojo.byId("EventsPortlet"))
							 {
							 dojo.style("EventsPortlet", "width", 10);
								dojo.style("EventsPortlet", "position", "relative");
								dojo.style("EventsPortlet", "left", "100%");
							 }
						 
						 }
					var startDateStr = '';
					var endDateStr = '';
					var startDateLong = (startDateStr !== '') ? new Date(startDateStr).getTime() : '';
		        	var endDateLong = (endDateStr !== '') ? new Date(endDateStr).getTime() : '';
					var events = [];
		        	var deferred = misys.xhrPost( {
		        		url : misys.getServletURL("/screen/AjaxScreen/action/GetCalendarEvents"),
		        		handleAs : "json",
		        		content : {
		        			inputdate: this.currentFocus.getTime(),
		        			startdate: startDateLong,
		        			enddate: endDateLong
		        		},
		        		load : function(response, ioArgs){
		        			dojo.forEach(response.events, function(ev){
		        				events.push(ev);
		        			});
		        		}
		        	});
		        
		        	deferred.then(function(){
		        		// Destroy any existing tooltips
		        		dojo.forEach(_this.activeTooltips, function(tId)
		        			{
		        			dijit.byId(tId).destroy();
		        			});
		        		_this.activeTooltips = [];
		        		
		        		setTimeout(function(){
		        			var calendarMonth = _this.currentFocus.getMonth();
		        			activeDates.forEach(function(td){
		        				var calendarCellDate = new Date(td.dijitDateValue);
	        					 
	        					 // Don't create events or tooltips for ghosted months
	        					 if(calendarCellDate.getMonth() === calendarMonth)
	        					 {
	        						// Get events for this date
	        						 var filteredEvents = dojo.filter(events, function(event) {	
	        					            return (dojo.date.compare(calendarCellDate, new Date(event.DATE), "date") === 0);
	        					     });
	        						 
	        						 if(filteredEvents.length > 0) {
	        							 var tooltipText = '';
	        							 var lastTdId = '';
	        							 // Limit number of events shown to EVENT_LIMIT
	        							 console.debug('[misys.calendar] Iterating over ' + filteredEvents.length + ' for the date ' + calendarCellDate + ' and limit ' + _this.eventLimit);
	        							 dojo.forEach(filteredEvents, function(event, i){
	        								 if(i <= _this.eventLimit)
	        								 {
	        								  // For first event, set the id and appropriate CSS class
	        								  if(i === 0) {
	        									 lastTdId = _this.id + event.DATE;
	        									 td.id = lastTdId;
	        									 td.className += ' ' + event.CSS;
	        								  }

	        								  tooltipText += event.TITLE;
	        								  if(event.REF_ID) {
	        									tooltipText += ' - ' + event.REF_ID;
	        								  }
	        								  tooltipText += '<br/>';
	        								 }
	        							 });
	        							 
	        							 if(filteredEvents.length > _this.eventLimit){
	        								 tooltipText += ' ...';
	        							 }

	        							 // Add the tooltip
	        							 var tooltipId = lastTdId + calendarCellDate.getTime();
	        							 _this.activeTooltips.push(tooltipId);
	        					    	 new dijit.Tooltip({
	        						          connectId : [lastTdId],
	        						          id: tooltipId, 
	        						          duration : _this.tooltipDuration,
	        						          label : dojo.replace(_this.tooltipTemplateString, {content: tooltipText})
	        						     });
	        						 }
	        					 }
		        			});
		        		}, 500);
		        	});
		        	this.eventsLoaded = true;
				}

				// Set up repeating mouse behavior
				var typematic = function(nodeProp, dateProp, adj){
					_this._connects.push(
						dijit.typematic.addMouseListener(_this[nodeProp], _this, function(count){
							if(count >= 0){
								var currentId = parseInt(this.id.substring(9, this.id.length), 10);
								
							    // FIXME : post update milestone view using dojo widgets.
								// stop recursive update for the moment
								_this._updateNextDisplay(currentId, dateProp, adj, nodeProp);
								_this._adjustDisplay(dateProp, adj);

								var relatedIdNext = parseInt(currentId, 10) + 1;
								var relatedIdNextPlus = parseInt(currentId, 10) + 2;
								var relatedIdBefore = parseInt(currentId, 10) - 1;
								var relatedCalendar = dijit.byId('calendar_'+relatedIdNext);

								if(relatedIdNext > 11)
								{
									relatedIdNext=0;
								}
								if(relatedIdBefore < 0)
								{
									relatedIdBefore=11;
								}
								var newDate = dojo.date.locale.format(_this.currentFocus, {
									selector :'date',
									datePattern : 'yyyyMM'
								});
								var currentMonth = new _this.dateClassObj(_this.currentFocus);
								currentMonth.setDate(1);
								var currentDate = dojo.date.locale.format(currentMonth, {
									selector :'date',
									fullYear : true
								});
								var range = 1;
								if(relatedCalendar){
									range = 3;
								}

								var endDate = dojo.date.add(currentMonth, "month", range);
								endDate = dojo.date.add(endDate, "day", -1);
								endDate = dojo.date.locale.format(endDate, {
									selector :'date',
									fullYear : true
								});
								var endPeriod = "";
								var product_code = "";
								var ref_id = "";
								var entity = "";
								// if search form exist
								if(dojo.byId('TransactionSearchForm')){
									//get search params
									product_code = dijit.byId('product_code') ? dijit.byId('product_code').get('value') : ''; 
									ref_id = dijit.byId('ref_id') ? dijit.byId('ref_id').get('value') : ''; 
									entity = dijit.byId('entity') ? dijit.byId('entity').get('value') : ''; 
									//set new date params
									if(dijit.byId('startdate') && dijit.byId('enddate'))
									{
										if(adj !== -1)
											{
												dijit.byId('enddate').set('displayedValue', currentDate);
											}
										dijit.byId('startdate').set('displayedValue', currentDate);
										dijit.byId('enddate').set('displayedValue', endDate);
									}
								}
								
								misys.grid.reloadForSearchTerms();
								
								_this.eventsLoaded = false;
								_this._populateGrid();
								if(relatedCalendar) {
									relatedCalendar.eventsLoaded = false;
									relatedCalendar._populateGrid();
									var relatedCalendarPlus = dijit.byId('calendar_'+relatedIdNextPlus);
									relatedCalendarPlus.eventsLoaded = false;
									relatedCalendarPlus._populateGrid();
								}
							}
						}, 0.8, 500));
				};
				typematic("incrementMonth", "month", 1);
				typematic("decrementMonth", "month", -1);
				typematic("nextYearLabelNode", "year", 1);
				typematic("previousYearLabelNode", "year", -1);

				this.calendarDateHasChanged = false;
			}
        } 
);

}

if(!dojo._hasResource["dijit.TitlePane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.TitlePane"] = true;
dojo.provide("dijit.TitlePane");






dojo.declare(
	"dijit.TitlePane",
	[dijit.layout.ContentPane, dijit._Templated, dijit._CssStateMixin],
{
	// summary:
	//		A pane with a title on top, that can be expanded or collapsed.
	//
	// description:
	//		An accessible container with a title Heading, and a content
	//		section that slides open and closed. TitlePane is an extension to
	//		`dijit.layout.ContentPane`, providing all the useful content-control aspects from it.
	//
	// example:
	// | 	// load a TitlePane from remote file:
	// |	var foo = new dijit.TitlePane({ href: "foobar.html", title:"Title" });
	// |	foo.startup();
	//
	// example:
	// |	<!-- markup href example: -->
	// |	<div dojoType="dijit.TitlePane" href="foobar.html" title="Title"></div>
	//
	// example:
	// |	<!-- markup with inline data -->
	// | 	<div dojoType="dijit.TitlePane" title="Title">
	// |		<p>I am content</p>
	// |	</div>

	// title: String
	//		Title of the pane
	title: "",

	// open: Boolean
	//		Whether pane is opened or closed.
	open: true,

	// toggleable: Boolean
	//		Whether pane can be opened or closed by clicking the title bar.
	toggleable: true,

	// tabIndex: String
	//		Tabindex setting for the title (so users can tab to the title then
	//		use space/enter to open/close the title pane)
	tabIndex: "0",

	// duration: Integer
	//		Time in milliseconds to fade in/fade out
	duration: dijit.defaultDuration,

	// baseClass: [protected] String
	//		The root className to be placed on this widget's domNode.
	baseClass: "dijitTitlePane",

	templateString: dojo.cache("dijit", "templates/TitlePane.html", "<div>\n\t<div dojoAttachEvent=\"onclick:_onTitleClick, onkeypress:_onTitleKey\"\n\t\t\tclass=\"dijitTitlePaneTitle\" dojoAttachPoint=\"titleBarNode\">\n\t\t<div class=\"dijitTitlePaneTitleFocus\" dojoAttachPoint=\"focusNode\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint=\"arrowNode\" class=\"dijitArrowNode\" role=\"presentation\"\n\t\t\t/><span dojoAttachPoint=\"arrowNodeInner\" class=\"dijitArrowNodeInner\"></span\n\t\t\t><span dojoAttachPoint=\"titleNode\" class=\"dijitTitlePaneTextNode\"></span>\n\t\t</div>\n\t</div>\n\t<div class=\"dijitTitlePaneContentOuter\" dojoAttachPoint=\"hideNode\" role=\"presentation\">\n\t\t<div class=\"dijitReset\" dojoAttachPoint=\"wipeNode\" role=\"presentation\">\n\t\t\t<div class=\"dijitTitlePaneContentInner\" dojoAttachPoint=\"containerNode\" role=\"region\" id=\"${id}_pane\">\n\t\t\t\t<!-- nested divs because wipeIn()/wipeOut() doesn't work right on node w/padding etc.  Put padding on inner div. -->\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n"),

	attributeMap: dojo.delegate(dijit.layout.ContentPane.prototype.attributeMap, {
		title: { node: "titleNode", type: "innerHTML" },
		tooltip: {node: "focusNode", type: "attribute", attribute: "title"},	// focusNode spans the entire width, titleNode doesn't
		id:""
	}),

	buildRendering: function(){
		this.inherited(arguments);
		dojo.setSelectable(this.titleNode, false);
	},

	postCreate: function(){
		this.inherited(arguments);
		
		// Hover and focus effect on title bar, except for non-toggleable TitlePanes
		// This should really be controlled from _setToggleableAttr() but _CssStateMixin
		// doesn't provide a way to disconnect a previous _trackMouseState() call
		if(this.toggleable){
			this._trackMouseState(this.titleBarNode, "dijitTitlePaneTitle");
		}

		// setup open/close animations
		var hideNode = this.hideNode, wipeNode = this.wipeNode;
		this._wipeIn = dojo.fx.wipeIn({
			node: this.wipeNode,
			duration: this.duration,
			beforeBegin: function(){
				hideNode.style.display="";
			}
		});
		this._wipeOut = dojo.fx.wipeOut({
			node: this.wipeNode,
			duration: this.duration,
			onEnd: function(){
				hideNode.style.display="none";
			}
		});
	},

	_setOpenAttr: function(/*Boolean*/ open, /*Boolean*/ animate){
		// summary:
		//		Hook to make set("open", boolean) control the open/closed state of the pane.
		// open: Boolean
		//		True if you want to open the pane, false if you want to close it.

		dojo.forEach([this._wipeIn, this._wipeOut], function(animation){
			if(animation && animation.status() == "playing"){
				animation.stop();
			}
		});

		if(animate){
			var anim = this[open ? "_wipeIn" : "_wipeOut"];
			anim.play();
		}else{
			this.hideNode.style.display = this.wipeNode.style.display = open ? "" : "none";
		}

		// load content (if this is the first time we are opening the TitlePane
		// and content is specified as an href, or href was set when hidden)
		if(this._started){
			if(open){
				this._onShow();
			}else{
				this.onHide();
			}
		}

		this.arrowNodeInner.innerHTML = open ? "-" : "+";

		dijit.setWaiState(this.containerNode,"hidden", open ? "false" : "true");
		dijit.setWaiState(this.focusNode, "pressed", open ? "true" : "false");

		this._set("open", open);

		this._setCss();
	},

	_setToggleableAttr: function(/*Boolean*/ canToggle){
		// summary:
		//		Hook to make set("toggleable", boolean) work.
		// canToggle: Boolean
		//		True to allow user to open/close pane by clicking title bar.

		dijit.setWaiRole(this.focusNode, canToggle ? "button" : "heading");
		if(canToggle){
			// TODO: if canToggle is switched from true to false shouldn't we remove this setting?
			dijit.setWaiState(this.focusNode, "controls", this.id+"_pane");
			dojo.attr(this.focusNode, "tabIndex", this.tabIndex);
		}else{
			dojo.removeAttr(this.focusNode, "tabIndex");
		}

		this._set("toggleable", canToggle);

		this._setCss();
	},

	_setContentAttr: function(/*String|DomNode|Nodelist*/ content){
		// summary:
		//		Hook to make set("content", ...) work.
		// 		Typically called when an href is loaded.  Our job is to make the animation smooth.

		if(!this.open || !this._wipeOut || this._wipeOut.status() == "playing"){
			// we are currently *closing* the pane (or the pane is closed), so just let that continue
			this.inherited(arguments);
		}else{
			if(this._wipeIn && this._wipeIn.status() == "playing"){
				this._wipeIn.stop();
			}

			// freeze container at current height so that adding new content doesn't make it jump
			dojo.marginBox(this.wipeNode, { h: dojo.marginBox(this.wipeNode).h });

			// add the new content (erasing the old content, if any)
			this.inherited(arguments);

			// call _wipeIn.play() to animate from current height to new height
			if(this._wipeIn){
				this._wipeIn.play();
			}else{
				this.hideNode.style.display = "";
			}
		}
	},

	toggle: function(){
		// summary:
		//		Switches between opened and closed state
		// tags:
		//		private

		this._setOpenAttr(!this.open, true);
	},

	_setCss: function(){
		// summary:
		//		Set the open/close css state for the TitlePane
		// tags:
		//		private

		var node = this.titleBarNode || this.focusNode;
		var oldCls = this._titleBarClass;
		this._titleBarClass = "dijit" + (this.toggleable ? "" : "Fixed") + (this.open ? "Open" : "Closed");
		dojo.replaceClass(node, this._titleBarClass, oldCls || "");

		this.arrowNodeInner.innerHTML = this.open ? "-" : "+";
	},

	_onTitleKey: function(/*Event*/ e){
		// summary:
		//		Handler for when user hits a key
		// tags:
		//		private

		if(e.charOrCode == dojo.keys.ENTER || e.charOrCode == ' '){
			if(this.toggleable){
				this.toggle();
			}
			dojo.stopEvent(e);
		}else if(e.charOrCode == dojo.keys.DOWN_ARROW && this.open){
			this.containerNode.focus();
			e.preventDefault();
	 	}
	},

	_onTitleClick: function(){
		// summary:
		//		Handler when user clicks the title bar
		// tags:
		//		private
		if(this.toggleable){
			this.toggle();
		}
	},

	setTitle: function(/*String*/ title){
		// summary:
		//		Deprecated.  Use set('title', ...) instead.
		// tags:
		//		deprecated
		dojo.deprecated("dijit.TitlePane.setTitle() is deprecated.  Use set('title', ...) instead.", "", "2.0");
		this.set("title", title);
	}
});

}

if(!dojo._hasResource["dojox.html._base"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.html._base"] = true;
/*
	Status: dont know where this will all live exactly
	Need to pull in the implementation of the various helper methods
	Some can be static method, others maybe methods of the ContentSetter (?)
	
	Gut the ContentPane, replace its _setContent with our own call to dojox.html.set()
	

*/

dojo.provide("dojox.html._base");



(function() {

	if(dojo.isIE){
		var alphaImageLoader = /(AlphaImageLoader\([^)]*?src=(['"]))(?![a-z]+:|\/)([^\r\n;}]+?)(\2[^)]*\)\s*[;}]?)/g;
	}

	// css at-rules must be set before any css declarations according to CSS spec
	// match:
	// @import 'http://dojotoolkit.org/dojo.css';
	// @import 'you/never/thought/' print;
	// @import url("it/would/work") tv, screen;
	// @import url(/did/you/now.css);
	// but not:
	// @namespace dojo "http://dojotoolkit.org/dojo.css"; /* namespace URL should always be a absolute URI */
	// @charset 'utf-8';
	// @media print{ #menuRoot {display:none;} }
		
	// we adjust all paths that dont start on '/' or contains ':'
	//(?![a-z]+:|\/)

	var cssPaths = /(?:(?:@import\s*(['"])(?![a-z]+:|\/)([^\r\n;{]+?)\1)|url\(\s*(['"]?)(?![a-z]+:|\/)([^\r\n;]+?)\3\s*\))([a-z, \s]*[;}]?)/g;

	var adjustCssPaths = dojox.html._adjustCssPaths = function(cssUrl, cssText){
		//	summary:
		//		adjusts relative paths in cssText to be relative to cssUrl
		//		a path is considered relative if it doesn't start with '/' and not contains ':'
		//	description:
		//		Say we fetch a HTML page from level1/page.html
		//		It has some inline CSS:
		//			@import "css/page.css" tv, screen;
		//			...
		//			background-image: url(images/aplhaimage.png);
		//
		//		as we fetched this HTML and therefore this CSS
		//		from level1/page.html, these paths needs to be adjusted to:
		//			@import 'level1/css/page.css' tv, screen;
		//			...
		//			background-image: url(level1/images/alphaimage.png);
		//
		//		In IE it will also adjust relative paths in AlphaImageLoader()
		//			filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='images/alphaimage.png');
		//		will be adjusted to:
		//			filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='level1/images/alphaimage.png');
		//
		//		Please note that any relative paths in AlphaImageLoader in external css files wont work, as
		//		the paths in AlphaImageLoader is MUST be declared relative to the HTML page,
		//		not relative to the CSS file that declares it

		if(!cssText || !cssUrl){ return; }

		// support the ImageAlphaFilter if it exists, most people use it in IE 6 for transparent PNGs
		// We are NOT going to kill it in IE 7 just because the PNGs work there. Somebody might have
		// other uses for it.
		// If user want to disable css filter in IE6  he/she should
		// unset filter in a declaration that just IE 6 doesn't understands
		// like * > .myselector { filter:none; }
		if(alphaImageLoader){
			cssText = cssText.replace(alphaImageLoader, function(ignore, pre, delim, url, post){
				return pre + (new dojo._Url(cssUrl, './'+url).toString()) + post;
			});
		}

		return cssText.replace(cssPaths, function(ignore, delimStr, strUrl, delimUrl, urlUrl, media){
			if(strUrl){
				return '@import "' + (new dojo._Url(cssUrl, './'+strUrl).toString()) + '"' + media;
			}else{
				return 'url(' + (new dojo._Url(cssUrl, './'+urlUrl).toString()) + ')' + media;
			}
		});
	};

	// attributepaths one tag can have multiple paths, example:
	// <input src="..." style="url(..)"/> or <a style="url(..)" href="..">
	// <img style='filter:progid...AlphaImageLoader(src="noticeTheSrcHereRunsThroughHtmlSrc")' src="img">
	var htmlAttrPaths = /(<[a-z][a-z0-9]*\s[^>]*)(?:(href|src)=(['"]?)([^>]*?)\3|style=(['"]?)([^>]*?)\5)([^>]*>)/gi;

	var adjustHtmlPaths = dojox.html._adjustHtmlPaths = function(htmlUrl, cont){
		var url = htmlUrl || "./";

		return cont.replace(htmlAttrPaths,
			function(tag, start, name, delim, relUrl, delim2, cssText, end){
				return start + (name ?
							(name + '=' + delim + (new dojo._Url(url, relUrl).toString()) + delim)
						: ('style=' + delim2 + adjustCssPaths(url, cssText) + delim2)
				) + end;
			}
		);
	};
	
	var snarfStyles = dojox.html._snarfStyles = function	(/*String*/cssUrl, /*String*/cont, /*Array*/styles){
		/****************  cut out all <style> and <link rel="stylesheet" href=".."> **************/
		// also return any attributes from this tag (might be a media attribute)
		// if cssUrl is set it will adjust paths accordingly
		styles.attributes = [];

		return cont.replace(/(?:<style([^>]*)>([\s\S]*?)<\/style>|<link\s+(?=[^>]*rel=['"]?stylesheet)([^>]*?href=(['"])([^>]*?)\4[^>\/]*)\/?>)/gi,
			function(ignore, styleAttr, cssText, linkAttr, delim, href){
				// trim attribute
				var i, attr = (styleAttr||linkAttr||"").replace(/^\s*([\s\S]*?)\s*$/i, "$1");
				if(cssText){
					i = styles.push(cssUrl ? adjustCssPaths(cssUrl, cssText) : cssText);
				}else{
					i = styles.push('@import "' + href + '";');
					attr = attr.replace(/\s*(?:rel|href)=(['"])?[^\s]*\1\s*/gi, ""); // remove rel=... and href=...
				}
				if(attr){
					attr = attr.split(/\s+/);// split on both "\n", "\t", " " etc
					var atObj = {}, tmp;
					for(var j = 0, e = attr.length; j < e; j++){
						tmp = attr[j].split('='); // split name='value'
						atObj[tmp[0]] = tmp[1].replace(/^\s*['"]?([\s\S]*?)['"]?\s*$/, "$1"); // trim and remove ''
					}
					styles.attributes[i - 1] = atObj;
				}
				return "";
			}
		);
	};

	var snarfScripts = dojox.html._snarfScripts = function(cont, byRef){
		// summary
		//		strips out script tags from cont
		// invoke with
		//	byRef = {errBack:function(){/*add your download error code here*/, downloadRemote: true(default false)}}
		//	byRef will have {code: 'jscode'} when this scope leaves
		byRef.code = "";

		//Update script tags nested in comments so that the script tag collector doesn't pick
		//them up.
		cont = cont.replace(/<[!][-][-](.|\s)*?[-][-]>/g,
			function(comment){
				return comment.replace(/<(\/?)script\b/ig,"&lt;$1Script");
			}
		);

		function download(src){
			if(byRef.downloadRemote){
				// console.debug('downloading',src);
				//Fix up src, in case there were entity character encodings in it.
				//Probably only need to worry about a subset.
				src = src.replace(/&([a-z0-9#]+);/g, function(m, name) {
					switch(name) {
						case "amp"	: return "&";
						case "gt"	: return ">";
						case "lt"	: return "<";
						default:
							return name.charAt(0)=="#" ? String.fromCharCode(name.substring(1)) : "&"+name+";";
					}
				});
				dojo.xhrGet({
					url: src,
					sync: true,
					load: function(code){
						byRef.code += code+";";
					},
					error: byRef.errBack
				});
			}
		}
		
		// match <script>, <script type="text/..., but not <script type="dojo(/method)...
		return cont.replace(/<script\s*(?![^>]*type=['"]?(?:dojo\/|text\/html\b))(?:[^>]*?(?:src=(['"]?)([^>]*?)\1[^>]*)?)*>([\s\S]*?)<\/script>/gi,
			function(ignore, delim, src, code){
				if(src){
					download(src);
				}else{
					byRef.code += code;
				}
				return "";
			}
		);
	};
	
	var evalInGlobal = dojox.html.evalInGlobal = function(code, appendNode){
		// we do our own eval here as dojo.eval doesn't eval in global crossbrowser
		// This work X browser but but it relies on a DOM
		// plus it doesn't return anything, thats unrelevant here but not for dojo core
		appendNode = appendNode || dojo.doc.body;
		var n = appendNode.ownerDocument.createElement('script');
		n.type = "text/javascript";
		appendNode.appendChild(n);
		n.text = code; // DOM 1 says this should work
	};

	dojo.declare("dojox.html._ContentSetter", [dojo.html._ContentSetter], {
		// adjustPaths: Boolean
		//		Adjust relative paths in html string content to point to this page
		//		Only useful if you grab content from a another folder than the current one
		adjustPaths: false,
		referencePath: ".",
		renderStyles: false,

		executeScripts: false,
		scriptHasHooks: false,
		scriptHookReplacement: null,
		
		_renderStyles: function(styles){
			// insert css from content into document head
			this._styleNodes = [];
			var st, att, cssText, doc = this.node.ownerDocument;
			var head = doc.getElementsByTagName('head')[0];

			for(var i = 0, e = styles.length; i < e; i++){
				cssText = styles[i]; att = styles.attributes[i];
				st = doc.createElement('style');
				st.setAttribute("type", "text/css"); // this is required in CSS spec!

				for(var x in att){
					st.setAttribute(x, att[x]);
				}

				this._styleNodes.push(st);
				head.appendChild(st); // must insert into DOM before setting cssText

				if(st.styleSheet){ // IE
					st.styleSheet.cssText = cssText;
				}else{ // w3c
					st.appendChild(doc.createTextNode(cssText));
				}
			}
		},

		empty: function() {
			this.inherited("empty", arguments);
			
			// empty out the styles array from any previous use
			this._styles = [];
		},
		
		onBegin: function() {
			// summary
			//		Called after instantiation, but before set();
			//		It allows modification of any of the object properties - including the node and content
			//		provided - before the set operation actually takes place
			//		This implementation extends that of dojo.html._ContentSetter
			//		to add handling for adjustPaths, renderStyles on the html string content before it is set
			this.inherited("onBegin", arguments);
			
			var cont = this.content,
				node = this.node;
				
			var styles = this._styles;// init vars

			if(dojo.isString(cont)){
				if(this.adjustPaths && this.referencePath){
					cont = adjustHtmlPaths(this.referencePath, cont);
				}

				if(this.renderStyles || this.cleanContent){
					cont = snarfStyles(this.referencePath, cont, styles);
				}

				// because of a bug in IE, script tags that is first in html hierarchy doesnt make it into the DOM
				//	when content is innerHTML'ed, so we can't use dojo.query to retrieve scripts from DOM
				if(this.executeScripts){
					var _t = this;
					var byRef = {
						downloadRemote: true,
						errBack:function(e){
							_t._onError.call(_t, 'Exec', 'Error downloading remote script in "'+_t.id+'"', e);
						}
					};
					cont = snarfScripts(cont, byRef);
					this._code = byRef.code;
				}
			}
			this.content = cont;
		},
		
		onEnd: function() {
			// summary
			//		Called after set(), when the new content has been pushed into the node
			//		It provides an opportunity for post-processing before handing back the node to the caller
			//		This implementation extends that of dojo.html._ContentSetter
			
			var code = this._code,
				styles = this._styles;
				
			// clear old stylenodes from the DOM
			// these were added by the last set call
			// (in other words, if you dont keep and reuse the ContentSetter for a particular node
			// .. you'll have no practical way to do this)
			if(this._styleNodes && this._styleNodes.length){
				while(this._styleNodes.length){
					dojo.destroy(this._styleNodes.pop());
				}
			}
			// render new style nodes
			if(this.renderStyles && styles && styles.length){
				this._renderStyles(styles);
			}

			if(this.executeScripts && code){
				if(this.cleanContent){
					// clean JS from html comments and other crap that browser
					// parser takes care of in a normal page load
					code = code.replace(/(<!--|(?:\/\/)?-->|<!\[CDATA\[|\]\]>)/g, '');
				}
				if(this.scriptHasHooks){
					// replace _container_ with this.scriptHookReplace()
					// the scriptHookReplacement can be a string
					// or a function, which when invoked returns the string you want to substitute in
					code = code.replace(/_container_(?!\s*=[^=])/g, this.scriptHookReplacement);
				}
				try{
					evalInGlobal(code, this.node);
				}catch(e){
					this._onError('Exec', 'Error eval script in '+this.id+', '+e.message, e);
				}
			}
			this.inherited("onEnd", arguments);
		},
		tearDown: function() {
			this.inherited(arguments);
			delete this._styles;
			// only tear down -or another set() - will explicitly throw away the
			// references to the style nodes we added
			if(this._styleNodes && this._styleNodes.length){
				while(this._styleNodes.length){
					dojo.destroy(this._styleNodes.pop());
				}
			}
			delete this._styleNodes;
			// reset the defaults from the prototype
			dojo.mixin(this, dojo.getObject(this.declaredClass).prototype);
		}
		
	});
	
	dojox.html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
		// TODO: add all the other options
			// summary:
			//		inserts (replaces) the given content into the given node
			//	node:
			//		the parent element that will receive the content
			//	cont:
			//		the content to be set on the parent element.
			//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
			//	params:
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			//	example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage:
			//		dojo.html.set(node, "some string");
			//		dojo.html.set(node, contentNode, {options});
			//		dojo.html.set(node, myNode.childNodes, {options});
	 
		if(!params){
			// simple and fast
			return dojo.html._setNodeContent(node, cont, true);
		}else{
			// more options but slower
			var op = new dojox.html._ContentSetter(dojo.mixin(
					params,
					{ content: cont, node: node }
			));
			return op.set();
		}
	};
	
})();

}

if(!dojo._hasResource["dojox.layout.ContentPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.layout.ContentPane"] = true;
dojo.provide("dojox.layout.ContentPane");




dojo.declare("dojox.layout.ContentPane", dijit.layout.ContentPane, {
	// summary:
	//		An extended version of dijit.layout.ContentPane.
	//		Supports infile scripts and external ones declared by <script src=''
	//		relative path adjustments (content fetched from a different folder)
	//		<style> and <link rel='stylesheet' href='..'> tags,
	//		css paths inside cssText is adjusted (if you set adjustPaths = true)
	//
	//		NOTE that dojo.require in script in the fetched file isn't recommended
	//		Many widgets need to be required at page load to work properly

	// adjustPaths: Boolean
	//		Adjust relative paths in html string content to point to this page.
	//		Only useful if you grab content from a another folder then the current one
	adjustPaths: false,

	// cleanContent: Boolean
	//	summary:
	//		cleans content to make it less likely to generate DOM/JS errors.
	//	description:
	//		useful if you send ContentPane a complete page, instead of a html fragment
	//		scans for
	//
	//			* title Node, remove
	//			* DOCTYPE tag, remove
	cleanContent: false,

	// renderStyles: Boolean
	//		trigger/load styles in the content
	renderStyles: false,

	// executeScripts: Boolean
	//		Execute (eval) scripts that is found in the content
	executeScripts: true,

	// scriptHasHooks: Boolean
	//		replace keyword '_container_' in scripts with 'dijit.byId(this.id)'
	// NOTE this name might change in the near future
	scriptHasHooks: false,

	/*======
	// ioMethod: dojo.xhrGet|dojo.xhrPost
	//		reference to the method that should grab the content
	ioMethod: dojo.xhrGet,
	
	// ioArgs: Object
	//		makes it possible to add custom args to xhrGet, like ioArgs.headers['X-myHeader'] = 'true'
	ioArgs: {},
	======*/

	constructor: function(){
		// init per instance properties, initializer doesn't work here because how things is hooked up in dijit._Widget
		this.ioArgs = {};
		this.ioMethod = dojo.xhrGet;
	},

	onExecError: function(e){
		// summary:
		//		event callback, called on script error or on java handler error
		//		overide and return your own html string if you want a some text
		//		displayed within the ContentPane
	},

	_setContent: function(cont){
		// override dijit.layout.ContentPane._setContent, to enable path adjustments
		
		var setter = this._contentSetter;
		if(! (setter && setter instanceof dojox.html._ContentSetter)) {
			setter = this._contentSetter = new dojox.html._ContentSetter({
				node: this.containerNode,
				_onError: dojo.hitch(this, this._onError),
				onContentError: dojo.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		};

		// stash the params for the contentSetter to allow inheritance to work for _setContent
		this._contentSetterParams = {
			adjustPaths: Boolean(this.adjustPaths && (this.href||this.referencePath)),
			referencePath: this.href || this.referencePath,
			renderStyles: this.renderStyles,
			executeScripts: this.executeScripts,
			scriptHasHooks: this.scriptHasHooks,
			scriptHookReplacement: "dijit.byId('"+this.id+"')"
		};

		this.inherited("_setContent", arguments);
	}
	// could put back _renderStyles by wrapping/aliasing dojox.html._ContentSetter.prototype._renderStyles
});

}

if(!dojo._hasResource["dojox.layout.ResizeHandle"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.layout.ResizeHandle"] = true;
dojo.provide("dojox.layout.ResizeHandle");
dojo.experimental("dojox.layout.ResizeHandle");






dojo.declare("dojox.layout.ResizeHandle",
	[dijit._Widget, dijit._Templated],
	{
	// summary: A dragable handle used to resize an attached node.
	//
	// description:
	//	The handle on the bottom-right corner of FloatingPane or other widgets that allows
	//	the widget to be resized.
	//	Typically not used directly.
	//
	// targetId: String
	//	id of the Widget OR DomNode that I will size
	targetId: "",
	
	// targetContainer: DomNode
	//	over-ride targetId and attch this handle directly to a reference of a DomNode
	targetContainer: null,
	
	// resizeAxis: String
	//	one of: x|y|xy limit resizing to a single axis, default to xy ...
	resizeAxis: "xy",
	
	// activeResize: Boolean
	// 	if true, node will size realtime with mouse movement,
	//	if false, node will create virtual node, and only resize target on mouseUp
	activeResize: false,
	
	// activeResizeClass: String
	//	css class applied to virtual resize node.
	activeResizeClass: "dojoxResizeHandleClone",
	
	// animateSizing: Boolean
	//	only applicable if activeResize = false. onMouseup, animate the node to the
	//	new size
	animateSizing: true,
	
	// animateMethod: String
	// 	one of "chain" or "combine" ... visual effect only. combine will "scale"
	// 	node to size, "chain" will alter width, then height
	animateMethod: "chain",

	// animateDuration: Integer
	//	time in MS to run sizing animation. if animateMethod="chain", total animation
	//	playtime is 2*animateDuration
	animateDuration: 225,

	// minHeight: Integer
	//	smallest height in px resized node can be
	minHeight: 100,

	// minWidth: Integer
	//	smallest width in px resize node can be
	minWidth: 100,

	// constrainMax: Boolean
	//	Toggle if this widget cares about the maxHeight and maxWidth
	//	parameters.
	constrainMax: false,

	// maxHeight: Integer
	//	Largest height size in px the resize node can become.
	maxHeight:0,
	
	// maxWidth: Integer
	//	Largest width size in px the reize node can become.
	maxWidth:0,

	// fixedAspect: Boolean
	//		Toggle to enable this widget to maintain the aspect
	//		ratio of the attached node.
	fixedAspect: false,

	// intermediateChanges: Boolean
	//		Toggle to enable/disable this widget from firing onResize
	//		events at every step of a resize. If `activeResize` is true,
	//		and this is false, onResize only fires _after_ the drop
	//		operation. Animated resizing is not affected by this setting.
	intermediateChanges: false,

	// startTopic: String
	//		The name of the topic this resizehandle publishes when resize is starting
	startTopic: "/dojo/resize/start",
	
	// endTopic: String
	//		The name of the topic this resizehandle publishes when resize is complete
	endTopic:"/dojo/resize/stop",

	templateString: '<div dojoAttachPoint="resizeHandle" class="dojoxResizeHandle"><div></div></div>',

	postCreate: function(){
		// summary: setup our one major listener upon creation
		this.connect(this.resizeHandle, "onmousedown", "_beginSizing");
		if(!this.activeResize){
			// there shall be only a single resize rubberbox that at the top
			// level so that we can overlay it on anything whenever the user
			// resizes something. Since there is only one mouse pointer he
			// can't at once resize multiple things interactively.
			this._resizeHelper = dijit.byId('dojoxGlobalResizeHelper');
			if(!this._resizeHelper){
				this._resizeHelper = new dojox.layout._ResizeHelper({
						id: 'dojoxGlobalResizeHelper'
				}).placeAt(dojo.body());
				dojo.addClass(this._resizeHelper.domNode, this.activeResizeClass);
			}
		}else{ this.animateSizing = false; }

		if(!this.minSize){
			this.minSize = { w: this.minWidth, h: this.minHeight };
		}
		
		if(this.constrainMax){
			this.maxSize = { w: this.maxWidth, h: this.maxHeight }
		}
		
		// should we modify the css for the cursor hover to n-resize nw-resize and w-resize?
		this._resizeX = this._resizeY = false;
		var addClass = dojo.partial(dojo.addClass, this.resizeHandle);
		switch(this.resizeAxis.toLowerCase()){
			case "xy" :
				this._resizeX = this._resizeY = true;
				// FIXME: need logic to determine NW or NE class to see
				// based on which [todo] corner is clicked
				addClass("dojoxResizeNW");
				break;
			case "x" :
				this._resizeX = true;
				addClass("dojoxResizeW");
				break;
			case "y" :
				this._resizeY = true;
				addClass("dojoxResizeN");
				break;
		}
	},

	_beginSizing: function(/*Event*/ e){
		// summary: setup movement listeners and calculate initial size
		
		if(this._isSizing){ return false; }

		dojo.publish(this.startTopic, [ this ]);
		this.targetWidget = dijit.byId(this.targetId);

		this.targetDomNode = this.targetWidget ? this.targetWidget.domNode : dojo.byId(this.targetId);
		if(this.targetContainer){ this.targetDomNode = this.targetContainer; }
		if(!this.targetDomNode){ return false; }

		if(!this.activeResize){
			var c = dojo.position(this.targetDomNode, true);
			console.log(c);
			console.log(dojo.window.getBox());
			this._resizeHelper.resize({l: c.x, t: c.y, w: c.w, h: c.h});
			this._resizeHelper.show();
		}

		this._isSizing = true;
		this.startPoint  = { x:e.clientX, y:e.clientY};

		// FIXME: this is funky: marginBox adds height, contentBox ignores padding (expected, but foo!)
		var mb = this.targetWidget ? dojo.marginBox(this.targetDomNode) : dojo.contentBox(this.targetDomNode);
		this.startSize  = { w:mb.w, h:mb.h };
		
		if(this.fixedAspect){
			var max, val;
			if(mb.w > mb.h){
				max = "w";
				val = mb.w / mb.h
			}else{
				max = "h";
				val = mb.h / mb.w
			}
			this._aspect = { prop: max };
			this._aspect[max] = val;
		}

		this._pconnects = [];
		this._pconnects.push(dojo.connect(dojo.doc,"onmousemove",this,"_updateSizing"));
		this._pconnects.push(dojo.connect(dojo.doc,"onmouseup", this, "_endSizing"));
		
		dojo.stopEvent(e);
	},

	_updateSizing: function(/*Event*/ e){
		// summary: called when moving the ResizeHandle ... determines
		//	new size based on settings/position and sets styles.

		if(this.activeResize){
			this._changeSizing(e);
		}else{
			var tmp = this._getNewCoords(e);
			if(tmp === false){ return; }
			this._resizeHelper.resize(tmp);
		}
		e.preventDefault();
	},

	_getNewCoords: function(/* Event */ e){
		
		// On IE, if you move the mouse above/to the left of the object being resized,
		// sometimes clientX/Y aren't set, apparently.  Just ignore the event.
		try{
			if(!e.clientX  || !e.clientY){ return false; }
		}catch(e){
			// sometimes you get an exception accessing above fields...
			return false;
		}
		this._activeResizeLastEvent = e;

		var dx = (this.isLeftToRight()? this.startPoint.x - e.clientX: e.clientX - this.startPoint.x),
			dy = this.startPoint.y - e.clientY,
			newW = this.startSize.w - (this._resizeX ? dx : 0),
			newH = this.startSize.h - (this._resizeY ? dy : 0)
		;
			
		return this._checkConstraints(newW, newH); // Object
	},
	
	_checkConstraints: function(newW, newH){
		// summary: filter through the various possible constaint possibilities.
				
		// minimum size check
		if(this.minSize){
			var tm = this.minSize;
			if(newW < tm.w){
				newW = tm.w;
			}
			if(newH < tm.h){
				newH = tm.h;
			}
		}
		
		// maximum size check:
		if(this.constrainMax && this.maxSize){
			var ms = this.maxSize;
			if(newW > ms.w){
				newW = ms.w;
			}
			if(newH > ms.h){
				newH = ms.h;
			}
		}
		
		if(this.fixedAspect){
			var ta = this._aspect[this._aspect.prop];
			if(newW < newH){
				newH = newW * ta;
			}else if(newH < newW){
				newW = newH * ta;
			}
		}
		
		return { w: newW, h: newH }; // Object
	},
		
	_changeSizing: function(/*Event*/ e){
		// summary: apply sizing information based on information in (e) to attached node
		var tmp = this._getNewCoords(e);
		if(tmp === false){ return; }

		if(this.targetWidget && dojo.isFunction(this.targetWidget.resize)){
			this.targetWidget.resize(tmp);
		}else{
			if(this.animateSizing){
				var anim = dojo.fx[this.animateMethod]([
					dojo.animateProperty({
						node: this.targetDomNode,
						properties: {
							width: { start: this.startSize.w, end: tmp.w }
						},
						duration: this.animateDuration
					}),
					dojo.animateProperty({
						node: this.targetDomNode,
						properties: {
							height: { start: this.startSize.h, end: tmp.h }
						},
						duration: this.animateDuration
					})
				]);
				anim.play();
			}else{
				dojo.style(this.targetDomNode,{
					width: tmp.w + "px",
					height: tmp.h + "px"
				});
			}
		}
		if(this.intermediateChanges){
			this.onResize(e);
		}
	},

	_endSizing: function(/*Event*/ e){
		// summary: disconnect listenrs and cleanup sizing
		dojo.forEach(this._pconnects, dojo.disconnect);
		var pub = dojo.partial(dojo.publish, this.endTopic, [ this ]);
		if(!this.activeResize){
			this._resizeHelper.hide();
			this._changeSizing(e);
			setTimeout(pub, this.animateDuration + 15);
		}else{
			pub();
		}
		this._isSizing = false;
		this.onResize(e);
	},
	
	onResize: function(e){
		// summary: Stub fired when sizing is done. Fired once
		//	after resize, or often when `intermediateChanges` is
		//	set to true.
	}
	
});

dojo.declare("dojox.layout._ResizeHelper",
	dijit._Widget,
	{
	// summary: A global private resize helper shared between any
	//		`dojox.layout.ResizeHandle` with activeSizing off.
	
	show: function(){
		// summary: show helper to start resizing
		dojo.fadeIn({
			node: this.domNode,
			duration: 120,
			beforeBegin: function(n){ dojo.style(n, "display", "") }
		}).play();
	},
	
	hide: function(){
		// summary: hide helper after resizing is complete
		dojo.fadeOut({
			node: this.domNode,
			duration: 250,
			onEnd: function(n){ dojo.style(n, "display", "none") }
		}).play();
	},
	
	resize: function(/* Object */dim){
		// summary: size the widget and place accordingly

		// FIXME: this is off when padding present
		dojo.marginBox(this.domNode, dim);
	}
	
});

}

if(!dojo._hasResource["dojox.layout.FloatingPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojox.layout.FloatingPane"] = true;
dojo.provide("dojox.layout.FloatingPane");
dojo.experimental("dojox.layout.FloatingPane");










dojo.declare("dojox.layout.FloatingPane",
	[ dojox.layout.ContentPane, dijit._Templated ],
	{
	// summary:
	//		A non-modal Floating window.
	//
	// description:
	// 		Makes a `dojox.layout.ContentPane` float and draggable by it's title [similar to TitlePane]
	// 		and over-rides onClick to onDblClick for wipeIn/Out of containerNode
	// 		provides minimize(dock) / show() and hide() methods, and resize [almost]
	//
	// closable: Boolean
	//		Allow closure of this Node
	closable: true,

	// dockable: Boolean
	//		Allow minimizing of pane if true
	dockable: true,

	// resizable: Boolean
	//		Allow resizing of pane true if true
	resizable: false,

	// maxable: Boolean
	//		Horrible param name for "Can you maximize this floating pane?"
	maxable: false,

	// resizeAxis: String
	//		One of: x | xy | y to limit pane's sizing direction
	resizeAxis: "xy",

	// title: String
	//		Title to use in the header
	title: "",

	// dockTo: DomNode?
	//		if empty, will create private layout.Dock that scrolls with viewport
	//		on bottom span of viewport.
	dockTo: "",

	// duration: Integer
	//		Time is MS to spend toggling in/out node
	duration: 400,

	/*=====
	// iconSrc: String
	//		[not implemented yet] will be either icon in titlepane to left
	//		of Title, and/or icon show when docked in a fisheye-like dock
	//		or maybe dockIcon would be better?
	iconSrc: null,
	=====*/

	// contentClass: String
	// 		The className to give to the inner node which has the content
	contentClass: "dojoxFloatingPaneContent",

	// animation holders for toggle
	_showAnim: null,
	_hideAnim: null,
	// node in the dock (if docked)
	_dockNode: null,

	// privates:
	_restoreState: {},
	_allFPs: [],
	_startZ: 100,

	templateString: dojo.cache("dojox.layout", "resources/FloatingPane.html", "<div class=\"dojoxFloatingPane\" id=\"${id}\">\n\t<div tabindex=\"0\" role=\"button\" class=\"dojoxFloatingPaneTitle\" dojoAttachPoint=\"focusNode\">\n\t\t<span dojoAttachPoint=\"closeNode\" dojoAttachEvent=\"onclick: close\" class=\"dojoxFloatingCloseIcon\"></span>\n\t\t<span dojoAttachPoint=\"maxNode\" dojoAttachEvent=\"onclick: maximize\" class=\"dojoxFloatingMaximizeIcon\">&thinsp;</span>\n\t\t<span dojoAttachPoint=\"restoreNode\" dojoAttachEvent=\"onclick: _restore\" class=\"dojoxFloatingRestoreIcon\">&thinsp;</span>\t\n\t\t<span dojoAttachPoint=\"dockNode\" dojoAttachEvent=\"onclick: minimize\" class=\"dojoxFloatingMinimizeIcon\">&thinsp;</span>\n\t\t<span dojoAttachPoint=\"titleNode\" class=\"dijitInline dijitTitleNode\"></span>\n\t</div>\n\t<div dojoAttachPoint=\"canvas\" class=\"dojoxFloatingPaneCanvas\">\n\t\t<div dojoAttachPoint=\"containerNode\" role=\"region\" tabindex=\"-1\" class=\"${contentClass}\">\n\t\t</div>\n\t\t<span dojoAttachPoint=\"resizeHandle\" class=\"dojoxFloatingResizeHandle\"></span>\n\t</div>\n</div>\n"),
	
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		title: { type:"innerHTML", node:"titleNode" }
	}),
	
	postCreate: function(){
		this.inherited(arguments);
		new dojo.dnd.Moveable(this.domNode,{ handle: this.focusNode });
		//this._listener = dojo.subscribe("/dnd/move/start",this,"bringToTop");

		if(!this.dockable){ this.dockNode.style.display = "none"; }
		if(!this.closable){ this.closeNode.style.display = "none"; }
		if(!this.maxable){
			this.maxNode.style.display = "none";
			this.restoreNode.style.display = "none";
		}
		if(!this.resizable){
			this.resizeHandle.style.display = "none";
		}else{
			this.domNode.style.width = dojo.marginBox(this.domNode).w + "px";
		}
		this._allFPs.push(this);
		this.domNode.style.position = "absolute";
		
		this.bgIframe = new dijit.BackgroundIframe(this.domNode);
		this._naturalState = dojo.coords(this.domNode);
	},
	
	startup: function(){
		if(this._started){ return; }
		
		this.inherited(arguments);

		if(this.resizable){
			if(dojo.isIE){
				this.canvas.style.overflow = "auto";
			}else{
				this.containerNode.style.overflow = "auto";
			}
			
			this._resizeHandle = new dojox.layout.ResizeHandle({
				targetId: this.id,
				resizeAxis: this.resizeAxis
			},this.resizeHandle);

		}

		if(this.dockable){
			// FIXME: argh.
			var tmpName = this.dockTo;

			if(this.dockTo){
				this.dockTo = dijit.byId(this.dockTo);
			}else{
				this.dockTo = dijit.byId('dojoxGlobalFloatingDock');
			}

			if(!this.dockTo){
				var tmpId, tmpNode;
				// we need to make our dock node, and position it against
				// .dojoxDockDefault .. this is a lot. either dockto="node"
				// and fail if node doesn't exist or make the global one
				// once, and use it on empty OR invalid dockTo="" node?
				if(tmpName){
					tmpId = tmpName;
					tmpNode = dojo.byId(tmpName);
				}else{
					tmpNode = dojo.create('div', null, dojo.body());
					dojo.addClass(tmpNode,"dojoxFloatingDockDefault");
					tmpId = 'dojoxGlobalFloatingDock';
				}
				this.dockTo = new dojox.layout.Dock({ id: tmpId, autoPosition: "south" }, tmpNode);
				this.dockTo.startup();
			}
			
			if((this.domNode.style.display == "none")||(this.domNode.style.visibility == "hidden")){
				// If the FP is created dockable and non-visible, start up docked.
				this.minimize();
			}
		}
		this.connect(this.focusNode,"onmousedown","bringToTop");
		this.connect(this.domNode,	"onmousedown","bringToTop");

		// Initial resize to give child the opportunity to lay itself out
		this.resize(dojo.coords(this.domNode));
		
		this._started = true;
	},

	setTitle: function(/* String */ title){
		// summary: Update the Title bar with a new string
		dojo.deprecated("pane.setTitle", "Use pane.set('title', someTitle)", "2.0");
		this.set("title", title);
		// this.setTitle = dojo.hitch(this, "setTitle") ??
	},
		
	close: function(){
		// summary: Close and destroy this widget
		if(!this.closable){ return; }
		dojo.unsubscribe(this._listener);
		this.hide(dojo.hitch(this,function(){
			this.destroyRecursive();
		}));
	},

	hide: function(/* Function? */ callback){
		// summary: Close, but do not destroy this FloatingPane
		dojo.fadeOut({
			node:this.domNode,
			duration:this.duration,
			onEnd: dojo.hitch(this,function() {
				this.domNode.style.display = "none";
				this.domNode.style.visibility = "hidden";
				if(this.dockTo && this.dockable){
					this.dockTo._positionDock(null);
				}
				if(callback){
					callback();
				}
			})
		}).play();
	},

	show: function(/* Function? */callback){
		// summary: Show the FloatingPane
		var anim = dojo.fadeIn({node:this.domNode, duration:this.duration,
			beforeBegin: dojo.hitch(this,function(){
				this.domNode.style.display = "";
				this.domNode.style.visibility = "visible";
				if (this.dockTo && this.dockable) { this.dockTo._positionDock(null); }
				if (typeof callback == "function") { callback(); }
				this._isDocked = false;
				if (this._dockNode) {
					this._dockNode.destroy();
					this._dockNode = null;
				}
			})
		}).play();
		this.resize(dojo.coords(this.domNode));
		this._onShow(); // lazy load trigger
	},

	minimize: function(){
		// summary: Hide and dock the FloatingPane
		if(!this._isDocked){ this.hide(dojo.hitch(this,"_dock")); }
	},

	maximize: function(){
		// summary: Make this FloatingPane full-screen (viewport)
		if(this._maximized){ return; }
		this._naturalState = dojo.position(this.domNode);
		if(this._isDocked){
			this.show();
			setTimeout(dojo.hitch(this,"maximize"),this.duration);
		}
		dojo.addClass(this.focusNode,"floatingPaneMaximized");
		this.resize(dojo.window.getBox());
		this._maximized = true;
	},

	_restore: function(){
		if(this._maximized){
			this.resize(this._naturalState);
			dojo.removeClass(this.focusNode,"floatingPaneMaximized");
			this._maximized = false;
		}
	},

	_dock: function(){
		if(!this._isDocked && this.dockable){
			this._dockNode = this.dockTo.addNode(this);
			this._isDocked = true;
		}
	},
	
	resize: function(/* Object */dim){
		// summary: Size the FloatingPane and place accordingly
		dim = dim || this._naturalState;
		this._currentState = dim;

		// From the ResizeHandle we only get width and height information
		var dns = this.domNode.style;
		if("t" in dim){ dns.top = dim.t + "px"; }
		if("l" in dim){ dns.left = dim.l + "px"; }
		dns.width = dim.w + "px";
		dns.height = dim.h + "px";

		// Now resize canvas
		var mbCanvas = { l: 0, t: 0, w: dim.w, h: (dim.h - this.focusNode.offsetHeight) };
		dojo.marginBox(this.canvas, mbCanvas);

		// If the single child can resize, forward resize event to it so it can
		// fit itself properly into the content area
		this._checkIfSingleChild();
		if(this._singleChild && this._singleChild.resize){
			this._singleChild.resize(mbCanvas);
		}
	},
	
	bringToTop: function(){
		// summary: bring this FloatingPane above all other panes
		var windows = dojo.filter(
			this._allFPs,
			function(i){
				return i !== this;
			},
		this);
		windows.sort(function(a, b){
			return a.domNode.style.zIndex - b.domNode.style.zIndex;
		});
		windows.push(this);
		
		dojo.forEach(windows, function(w, x){
			w.domNode.style.zIndex = this._startZ + (x * 2);
			dojo.removeClass(w.domNode, "dojoxFloatingPaneFg");
		}, this);
		dojo.addClass(this.domNode, "dojoxFloatingPaneFg");
	},
	
	destroy: function(){
		// summary: Destroy this FloatingPane completely
		this._allFPs.splice(dojo.indexOf(this._allFPs, this), 1);
		if(this._resizeHandle){
			this._resizeHandle.destroy();
		}
		this.inherited(arguments);
	}
});


dojo.declare("dojox.layout.Dock",
	[dijit._Widget,dijit._Templated],
	{
	// summary:
	//		A widget that attaches to a node and keeps track of incoming / outgoing FloatingPanes
	// 		and handles layout

	templateString: '<div class="dojoxDock"><ul dojoAttachPoint="containerNode" class="dojoxDockList"></ul></div>',

	// private _docked: array of panes currently in our dock
	_docked: [],
	
	_inPositioning: false,
	
	autoPosition: false,
	
	addNode: function(refNode){
		// summary: Instert a dockNode refernce into the dock
		
		var div = dojo.create('li', null, this.containerNode),
			node = new dojox.layout._DockNode({
				title: refNode.title,
				paneRef: refNode
			}, div)
		;
		node.startup();
		return node;
	},

	startup: function(){
				
		if (this.id == "dojoxGlobalFloatingDock" || this.isFixedDock) {
			// attach window.onScroll, and a position like in presentation/dialog
			this.connect(window, 'onresize', "_positionDock");
			this.connect(window, 'onscroll', "_positionDock");
			if(dojo.isIE){
				this.connect(this.domNode, "onresize", "_positionDock");
			}
		}
		this._positionDock(null);
		this.inherited(arguments);

	},
	
	_positionDock: function(/* Event? */e){
		if(!this._inPositioning){
			if(this.autoPosition == "south"){
				// Give some time for scrollbars to appear/disappear
				setTimeout(dojo.hitch(this, function() {
					this._inPositiononing = true;
					var viewport = dojo.window.getBox();
					var s = this.domNode.style;
					s.left = viewport.l + "px";
					s.width = (viewport.w-2) + "px";
					s.top = (viewport.h + viewport.t) - this.domNode.offsetHeight + "px";
					this._inPositioning = false;
				}), 125);
			}
		}
	}


});

dojo.declare("dojox.layout._DockNode",
	[dijit._Widget,dijit._Templated],
	{
	// summary:
	//		dojox.layout._DockNode is a private widget used to keep track of
	//		which pane is docked.
	//
	// title: String
	// 		Shown in dock icon. should read parent iconSrc?
	title: "",

	// paneRef: Widget
	//		reference to the FloatingPane we reprasent in any given dock
	paneRef: null,

	templateString:
		'<li dojoAttachEvent="onclick: restore" class="dojoxDockNode">'+
			'<span dojoAttachPoint="restoreNode" class="dojoxDockRestoreButton" dojoAttachEvent="onclick: restore"></span>'+
			'<span class="dojoxDockTitleNode" dojoAttachPoint="titleNode">${title}</span>'+
		'</li>',

	restore: function(){
		// summary: remove this dock item from parent dock, and call show() on reffed floatingpane
		this.paneRef.show();
		this.paneRef.bringToTop();
		this.destroy();
	}

});

}

if(!dojo._hasResource["misys.layout.FloatingPane"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.layout.FloatingPane"] = true;
dojo.provide("misys.layout.FloatingPane");
dojo.experimental("misys.layout.FloatingPane"); 

/**
 * Collaboration Floating Window
 */




// our declared class
dojo.declare("misys.layout.FloatingPane",
        // we inherit from this class, which in turn mixes
        // in _Templated and _Layout
        [ dojox.layout.FloatingPane ],
        // class properties:
        {

		templateString: dojo.cache("misys.layout", "resources/CollaborationFloatingPane.html", "<div class=\"dojoxFloatingPane\" id=\"${id}\" dojoAttachPoint=\"floatingWindow\">\n <div tabindex=\"0\" waiRole=\"button\" class=\"dojoxFloatingPaneTitle\" dojoAttachPoint=\"titleBarNode,focusNode\">\n  <span dojoAttachPoint=\"pinNode\" dojoAttachEvent=\"onclick: pin\" class=\"pinButton\"></span>\n  <img src=\"${_blankGif}\" dojoAttachEvent=\"onclick:toggle\" alt=\"\" dojoAttachPoint=\"arrowNode\" class=\"dijitArrowNode\" waiRole=\"presentation\">\n  <span dojoAttachPoint=\"arrowNodeInner\" dojoAttachEvent=\"onclick:toggle\" class=\"dijitArrowNodeInner\"></span>\n  <span dojoAttachPoint=\"titleNode\" dojoAttachEvent=\"onclick:toggle\" class=\"dijitInline dijitTitleNode\"></span>\n </div>\n <div dojoAttachPoint=\"canvas,collabContentNode\" class=\"dojoxFloatingPaneCanvas\" id=\"collaborationWindowContent\">\n  <div dojoAttachPoint=\"containerNode\" waiRole=\"region\" tabindex=\"-1\" class=\"${contentClass}\"></div>\n  <span dojoAttachPoint=\"resizeHandle\" class=\"dojoxFloatingResizeHandle\"></span>\n </div>\n <!-- These are needed by the inherited class, but we don't use them -->\n <span style=\"display:none\">\n  <span dojoAttachPoint=\"closeNode\" class=\"dojoxFloatingCloseIcon\"></span>\n  <span dojoAttachPoint=\"maxNode\" class=\"dojoxFloatingMaximizeIcon\"></span>\n  <span dojoAttachPoint=\"restoreNode\" class=\"dojoxFloatingRestoreIcon\"></span>    \n  <span dojoAttachPoint=\"dockNode\" class=\"dojoxFloatingMinimizeIcon\"></span>\n </span>\n</div>\n"),
        
        // Whether the window is open or collapsed by default
        open: false,
        
        // Whether the window is pinned or floating by default 
        pinned: true,
        
        // Variable to hold the event reference for the pin button
        _pinnedReference: null,
        
        // Current size of the window
        _windowHeight: null,

        // duration: Integer
    	//		Time in milliseconds to fade in/fade out
    	duration: dijit.defaultDuration,
    	
    	_blankGif: misys.getContextualURL("/content/js/dojo/resources/blank.gif"),
    	
    	postCreate: function(){
    		this.inherited(arguments);

    		this.moveable = new dojo.dnd.move.parentConstrainedMoveable(
    	            this.domNode, {
    	                handle: this.focusNode,
    	                constraints: {
    	                        l: 0,
    	                        t: 20,
    	                        w: window.innerWidth,
                                h: window.innerHeight                            
    	                    },
    	                within: true
    	            }
    	        );
    		
    		var collabContentNode = this.collabContentNode,
    			floatingWindow = this.floatingWindow;
    		
    		if(this.open) {
    			collabContentNode.style.height = "auto"; //"150px";
    			floatingWindow.style.height = "auto";
    			dojo.style(this.domNode, "height", "auto");
    		} else {
    			collabContentNode.style.display = "none";
    			dojo.style(this.domNode, "height", "30px");
    		}
    		
    		this._setCss();
    		dojo.setSelectable(this.titleNode, false);
    		dijit.setWaiState(this.containerNode, "labelledby", this.titleNode.id);
    		dijit.setWaiState(this.focusNode, "haspopup", "true");

    		this._showPanes = function(){
    			collabContentNode.style.height = "auto"; //this._windowHeight + "px";
    			floatingWindow.style.height = "auto";
    		};
    		this._hidePanes = function(){
    			this._windowHeight = dojo.style('collaborationWindowContent', 'height');
    			floatingWindow.style.height = "auto";
    			collabContentNode.style.height = "0";
    		};
    		
    		if(!dojo.isIE || dojo.isIE > 6) {
	    		this._fadeOut = dojo.fadeOut({
	    			node: collabContentNode,
	    			duration: this.duration,
	    			onEnd: function(){
	    				collabContentNode.style.display = "none";	
	    			}
	    		});
    		} else {
    			this._fadeOut = function() {
    				collabContentNode.style.display = "none";
    			};
    		}
    		// setup open/close animations
    		if(!dojo.isIE || dojo.isIE > 6) {
    			this._fadeIn = dojo.fadeIn({
        			node: collabContentNode,
        			duration: this.duration,
        			beforeBegin: function(){
        				collabContentNode.style.display = "inherit";
        			}
        		});
    		} else {
    			this._fadeIn = function() {
    				collabContentNode.style.display = "block";
    			};
    		}
    		
    		// Initialise the pin
    		this.pin();
    	},
    	
    	toggle: function(){
    		// summary:
    		//		Switches between opened and closed state
    		// tags:
    		//		private
    		
//    		dojo.forEach([this._wipeIn, this._wipeOut], function(animation){
//    			if(animation && animation.status() == "playing"){
//    				animation.stop();
//    			}
//    		});

    		var fadeAnim = this[this.open ? "_fadeOut" : "_fadeIn"];
    		var hideAnim = this[this.open ? "_hidePanes" : "_showPanes"];
    		if(fadeAnim && hideAnim){
    			hideAnim();
    			if(fadeAnim.play) {
    				fadeAnim.play();
    			} else {
    				fadeAnim();
    			}
    			
    		}else{
    			this.collabContentNode.style.display = this.open ? "" : "none";
    		}
    		this.open = !(this.open);

    		// load content (if this is the first time we are opening the TitlePane
    		// and content is specified as an href, or href was set when hidden)
    		this._onShow();
    		this._setCss();
    	},

    	pin: function(){
    		// summary:
    		//		Pins the window in position, or allows it to move as the user scrolls
    		// tags:
    		//		private
    		if(!this.pinned)
    		{
    			this.pinNode.style.background = "url('"+misys.getContextualURL('/content/images/pic_pinup.gif')+"')";
    			this._pinnedReference = dojo.connect(window, 'onscroll', this, "_positionWindow");
    			misys.connections.push(this._pinnedReference);
    		}
    		else
    		{
    			this.pinNode.style.background = "url('"+misys.getContextualURL('/content/images/pic_pindown.gif')+"')";
    			if(this._pinnedReference) {
    				dojo.disconnect(this._pinnedReference);
    			}
    		}
    		
    		this.pinned = ! this.pinned;
    	},
    	
    	resize: function(/* Object */dim){
    		// summary: Size the FloatingPane and place accordingly
    		dim = dim || this._naturalState; //dojo.coords(this.domNode); //dim || this._naturalState;
    		this._currentState = dim;
    		// From the ResizeHandle we only get width and height information
    		var dns = this.domNode.style;

    		var c = dojo.coords(this.domNode);

    		if("t" in dim){ dns.top = c.t + "px"; }
    		if("l" in dim){ dns.left = c.l + "px"; }
    		dns.width = dim.w + "px";
    		dns.height = (this.open) ? dim.h + "px" : "auto";

    		// Now resize canvas (unless the pane is closed)
    		var height = (this.open) ? (dim.h - this.focusNode.offsetHeight) : 0;

    		var mbCanvas = { l: 0, t: 0, w: dim.w, h: height };
    		dojo.marginBox(this.canvas, mbCanvas);

    		// If the single child can resize, forward resize event to it so it can
    		// fit itself properly into the content area
    		this._checkIfSingleChild();
    		if(this._singleChild && this._singleChild.resize){
    			this._singleChild.resize(mbCanvas);
    		}
    	},
    	
    	bringToTop: function(){
    		return;
    	},
    	
    	_config : {
    		timer : null,
    		heightOffset : null
    	},
    	
    	_positionWindow: function(){
    		// summary:
    		//		Position the window with reference to the viewport and scrollbar.
    		// tags:
    		//		private
    		
    		// Give some time for scrollbars to appear/disappear
    		if(this._config.timer){
    			clearTimeout(this.timer);
    		}
    		if(!this._config.heightOffset) {
    			var headers = dojo.query(".header");
    			this._config.heightOffset = (headers.length === 1) ?
    										dojo.coords(headers[0]).h : 0;
    		}
    		
    		var viewport = dijit.getViewport(),
				floatingWindow = this.domNode;
			this.timer = setTimeout(dojo.hitch(this, function(){
				dojo.fx.slideTo({ 
					node: floatingWindow,
					top: viewport.t + (floatingWindow.offsetHeight/2) + this._config.heightOffset,
					right: floatingWindow.style.right,
					left: floatingWindow.style.left,
					unit: "px" }).play();
			}), 300);	
    	},
    	
    	_setCss: function(){
    		// summary:
    		//		Set the open/close css state for the TitlePane
    		// tags:
    		//		private

    		var classes = ["dijitClosed", "dijitOpen"];
    		var boolIndex = this.open;
    		var node = this.titleBarNode || this.focusNode;
    		dojo.removeClass(node, classes[!boolIndex+0]);
    		node.className += " " + classes[boolIndex+0];

    		// provide a character based indicator for images-off mode
    		this.arrowNodeInner.innerHTML = this.open ? "-" : "+";
    	}
       }
);

}

if(!dojo._hasResource["misys.widget.Collaboration"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.widget.Collaboration"] = true;
dojo.provide("misys.widget.Collaboration");









// TODO This needs to be rebuilt as a proper widget, extending FloatingPane. Once done, 
// drop the "collaboration" from the function names below

(function(/*Dojo*/d, /*Dijit*/dj, /*Misys*/m) {

	 // ECMA5 Strict Mode
	
	// Private functions & variables go here

	function _generateId(/*String*/ type) {
		// summary:
		//		TODO
		
		var lastId, id;
		
		// TODO Probably should find someway to avoid wrapping an XHR in a loop,
		//		even if in practice I think it will only ever be called once
		do {
			m.xhrPost( {
				url : m.getServletURL("/screen/AjaxScreen/action/GetTaskId"),
				sync : true,
				load : function(response, args){
					id = response;
				},
				error : function(response) {
					throw {
						name : "CollaborationError",
						message : "An error occurred when retrieving a Collaboration " + 
								  "task ID " + response
					};
				}
			});
			
			if(id === "false" || id === lastId) {
				// Something wrong if we return the same ID twice, could signal 
				// infinite loop. If id == "false", we also have a problem
				throw {
					name : "CollaborationError",
					message : "An error occurred when retrieving a Collaboration " + 
							  "task ID " + response
				};
			}
			lastId = id;
		} while(d.byId(type + "_row_" + id));
		
		return id;
	}
	
	function _addCollaborationItem( /*String*/ type, 
									/*String*/ id, 
									/*String*/postSave,
									/*Boolean*/ isTaskUpdate){
		//  summary:
	    //            Add an item to the task list.
		
		var publicTasks1  = dj.byId("public_task_details_assignee_type_nosend_1"),
			publicTasks2 = dj.byId("public_task_details_assignee_type_nosend_2"),
			publicTasks3 = dj.byId("public_task_details_assignee_type_nosend_3"),
			publicTasks4 = dj.byId("public_task_details_assignee_type_nosend_4"),
			xml;
		
		// This parameter is set to Y or N it allows the SaveTask portlet to know if this is 
		// post or pre save operation.
		postSave = postSave ? postSave : "N";
		type = type.toLowerCase();
		
		// Send the task to the server 
		// Extract transaction id
	    var tnxId = dj.byId("tnx_id"),
			refId = dj.byId("ref_id"),
			oldInpDttm = dj.byId("old_inp_dttm"),
			todoListId = dj.byId("todo_list_id").get("value"),
			taskInfo = [dj.byId("sentence_posted_by").get("value"), " ",
			            	dj.byId("sentence_you").get("value"), " "],
			taskType = "01",
			masterTaskList = d.byId(type + "_master_list"),
			hiddenFields, taskDescription, li, text;

		if(!tnxId || !refId || !oldInpDttm){
			m.dialog.show("ERROR", m.getLocalization("generalCollaborationError"));
			return false;
		}
		
		switch(type) {
		case "private_tasks":
			hiddenFields = _getPrivateTasksHiddenFields(id);
			taskDescription = dj.byId("private_description_nosend").get("value");
			break;
		case "public_tasks":
			hiddenFields = _getPublicTasksHiddenFields(id);
			taskType = "02";
			if(dj.byId("public_task_details_type_nosend_3").get("checked")) {
				taskType = "03";
			}
			taskDescription = dj.byId("public_task_details_description_nosend").get("value"); 
			break;
		default:
			hiddenFields = _getNotificationTasksHiddenFields(id);
			taskType = "03";
			taskInfo.push(dj.byId("sentence_to").get("value"), " ");
			taskInfo.push(dj.byId("notification_task_details_other_user_assignee_login_id_nosend").get("value"), " ");
			taskDescription = dj.byId("notification_description_nosend").get("value");
			break;
		}

		var container;
		if (d.byId(id + "_container"))
		{
			container = d.byId(id + "_container");
		}
		else
		{
			container = d.create("div", {
				id : id + "_container"
			});
		}
			
		// Add custom hidden fields
		hiddenFields.push({
	    	name : "task_id",
	    	id : "task_id_" + id,
	    	value : id
	    },
	    {
	    	name : "tnx_id",
	    	id : "tnx_id_" + id,
	    	value : tnxId.get("value")
	    },
	    {
	    	name : "ref_id",
	    	id : "ref_id_" + id,
	    	value : refId.get("value")
	    },
	    {
	    	name : "todo_list_id",
	    	id : "todo_list_id_" + id,
	    	value : todoListId
	    },
	    {
	    	name : "old_inp_dttm",
	    	id : "old_inp_dttm_" + id,
	    	value : oldInpDttm.get("value")
	    },
	    {
	    	name : "postSave",
	    	id : "postSave_" + id,
	    	value : postSave
	    });

		if (isTaskUpdate)
		{
			// In case of update, destroy hidden fields first
			d.forEach(hiddenFields, function(hiddenField){
				if (dj.byId(hiddenField.id || hiddenField.name))
				{
					dj.byId(hiddenField.id || hiddenField.name).destroy();
				}
			});
		}
		d.forEach(hiddenFields, function(hiddenField){
			new dj.form.TextBox({
				id : hiddenField.id || hiddenField.name,
				name : hiddenField.name,
				readOnly : true,
				value : hiddenField.value,
				type : "hidden"
			}).placeAt(container);
		});
		
		//if (!isTaskUpdate)
		//{
			dojo.place(container, dojo.byId(type + "_form"));
		//}
		
		// Build up the XML to send
		xml = m.formToXML({selector: "#" + type + "_form", xmlRoot : type, ignoreDisabled : true});	
		
		// Retrieve the elements of the form
		//xmlString.push("<task_id>", id, "</task_id>");
		//xmlString.push("<tnx_id>", tnxId.value, "</tnx_id>");
		//xmlString.push("<ref_id>", refId.value, "</ref_id>");
		//xmlString.push("<todo_list_id>", todoListId, "</todo_list_id>");
		//xmlString.push("<old_inp_dttm>", oldInpDttm.value, "</old_inp_dttm>");
		//xmlString.push("<postSave>", postSave, "</postSave>");
		//xmlString.push("</", type, ">");
		
		console.debug("[Collaboration] Adding Collaboration Task - Request XML", xml);	
		m.xhrPost({
			url : m.getServletURL("/screen/AjaxScreen/action/SaveTask"),
			content: {xml_string : xml}
		});
		
		
		console.debug("[Collaboration] Adding Collaboration Task, TodoList ID", todoListId);
		
		if(taskType === "03") {
			taskInfo.push(dj.byId("sentence_to").get("value"), " ");
	
			if(publicTasks1 && publicTasks1.get("checked")){
				taskInfo.push(dj.byId("public_task_details_other_user_assignee_login_id_nosend").get("value"), " ");
			}
			else if(publicTasks2 && publicTasks2.get("checked")) {
				taskInfo.push(dj.byId("public_task_details_bank_assignee_name_nosend").get("value"), " ");
				taskInfo.push(dj.byId("public_task_details_bank_assignee_abbv_name_nosend").get("value"), " ");
			}
			else if(publicTasks3 && publicTasks3.get("checked")) {
				taskInfo.push(dj.byId("public_task_details_counterparty_assignee_name_nosend").get("value"), " ");
				taskInfo.push(dj.byId("public_task_details_counterparty_assignee_abbv_name_nosend").get("value"), " ");
			}
			else if(publicTasks4 && publicTasks4.get("checked")) {
				taskInfo.push(dj.byId("public_details_bank_other_user_assignee_first_name_nosend").get("value"), " ");
				taskInfo.push(dj.byId("public_details_bank_other_user_assignee_last_name_nosend").get("value"), " ");
			}
		}
		
		// 2. Set the list to visible, if we have to
		if(d.style(masterTaskList, "display") === "none" ||
				d.style(masterTaskList, "opacity") === 0){
			d.style(masterTaskList, "opacity", 0);
			m.animate("fadeIn", masterTaskList);
		}
		
		// TODO This really should be refactored as d.create
		text =
			["<label for='", type, "_dismiss_", id, "' id='", type, "_dismiss_", id, "_label'>" , 
				"<span id='", type, "_desc_", id,  "'>", m.grid.sanitizeHTMLDataForUI(taskDescription), "</span></label>" , 
				"<span class='taskInfo'>", taskInfo.join(""), "</span>", 
				"<span class='commentInfo' id='", "task_edit_", id, "'>", " | ", 
				"<a href=\"javascript:void(0)\" onClick=\"misys.openTaskForUpdate(", id, ")\">",m.getLocalization("Edit"),"</a></span>", 				
				"<span class='commentInfo'>" , " | ",
				"<a href=\"javascript:void(0)\" onClick=\"misys.openCollaborationComment('", type, 
				"',", id, ")\">",m.getLocalization("comments")," (<span id=\"", type, 
				"_comment_count_", id, "\">0</span>)</a></span>"];

		if (!isTaskUpdate)
		{
			li = d.create("li",{
				id: type + "_item_" + id,
				style: "display:none;opacity:0",
				innerHTML: text.join("")
			}, masterTaskList);
		}
		else
		{
			dj.byId(type + "_dismiss_" + id).destroy();
			li = d.byId(type + "_item_" + id);
			li.innerHTML = text.join("");
		}
			
		new dj.form.CheckBox({
			id: type + "_dismiss_" + id,
			name: type + "_dismiss_" + id,
			onClick: function(){
				m.finishCollaborationTask(this, type, id);
			}
		}).placeAt(type+"_dismiss_"+id+"_label", "first");
			
		// 5. Add an empty hidden list, for comments
		if (!isTaskUpdate)
		{
			var ol = d.create("ol", {
				id: type + "_comments_" + id,
				style: "display:none"
			}, type + "_comment_fields", "first");
			d.addClass(ol, "comment-list");
		}
			
		// 7. Show the row
		m.animate("fadeIn", li, function(){
			// 8. Hide the notice
			d.style(d.byId(type + "_notice"), "display", "none");
		});
		
		// Destroy the hidden fields container
		d.forEach(dijit.findWidgets(container), function(w){
			if(w) {
				w.destroyRecursive();
			}
		});
		//d.destroy(container);

		return true;
	}
	
	function _checkEntityForCollaboration() {
		// summary:
		//		TODO
		
		var entityObj = dj.byId("entity");
		if(entityObj && !entityObj.get("value")){
			m.dialog.show("ERROR", m.getLocalization("mandatoryEntityMessage"));
			return false;
		}

		return true;
	}
	
	function _toggleAssigneeRadioButtons() {
		//  summary:
	    //            Display the Assignee Radio Buttons
		
		var publicTaskAssigneeType1 = dj.byId("public_task_details_assignee_type_nosend_1"),
			publicTaskAssigneeType2 = dj.byId("public_task_details_assignee_type_nosend_2"),
			publicTaskAssigneeType3 = dj.byId("public_task_details_assignee_type_nosend_3"),
			publicTaskDetailsType3 = dj.byId("public_task_details_type_nosend_3"),
			isPublicChecked = (publicTaskDetailsType3) ? 
					publicTaskDetailsType3.get("checked") : false,
			assigneeTypeFields = d.byId("assigneeTypeFields");
		
		m.toggleFields(isPublicChecked, 
				["public_task_details_assignee_type_nosend_1", 
				 "public_task_details_assignee_type_nosend_2", 
				 "public_task_details_assignee_type_nosend_3", 
				 "public_task_details_assignee_type_nosend_4"]);
		
		// Provide a hook to modify the assignee type radio buttons before display
		if(isPublicChecked)
		{
			var assigneeTypes = [
			                          {
			                        	  id : "public_task_details_assignee_type_nosend_1",
			                        	  description: "user_to_user"
			                          },
			                          {
			                        	  id : "public_task_details_assignee_type_nosend_2",
			                        	  description: "user_to_bank"
			                          },
			                          {
			                        	  id : "public_task_details_assignee_type_nosend_3",
			                        	  description: "counterparty"
			                          },
			                          {
			                        	  id : "public_task_details_assignee_type_nosend_4",
			                        	  description: "bank"
			                          }
		                        ];
			m.preDisplayAssigneeType = m.preDisplayAssigneeType || function(){ return true; };
			m.preDisplayAssigneeType(assigneeTypes);
		}	
		
		if(isPublicChecked) { 
			m.animate("fadeIn", assigneeTypeFields, function(){
				_toggleFieldsByPermissions();
				_toggleAssigneeType();
				_checkEntityForCollaboration();
			}, false, {duration: 20});
		} else {
			m.animate("fadeOut", assigneeTypeFields, function(){
				if (publicTaskAssigneeType1) {
					publicTaskAssigneeType1.set("checked", false);
				}
				if (publicTaskAssigneeType2) {
					publicTaskAssigneeType2.set("checked", false);
				}
				if (publicTaskAssigneeType3) {
					publicTaskAssigneeType3.set("checked", false);
				}
				_toggleAssigneeType();
			}, false, {duration: 20});
		}
	}
	
	function _toggleAssigneeType() {
		//  summary:
	    //            Display the assignee type
		
		var isAssignee1Checked = dj.byId("public_task_details_assignee_type_nosend_1") ?
				dj.byId("public_task_details_assignee_type_nosend_1").get("checked") : false,
			isAssignee2Checked = dj.byId("public_task_details_assignee_type_nosend_2") ?
					dj.byId("public_task_details_assignee_type_nosend_2").get("checked") : false,
			isAssignee3Checked = dj.byId("public_task_details_assignee_type_nosend_3") ?
					dj.byId("public_task_details_assignee_type_nosend_3").get("checked") : false,
			isAssignee4Checked = dj.byId("public_task_details_assignee_type_nosend_4") ?
				dj.byId("public_task_details_assignee_type_nosend_4").get("checked") : false,
			notifyBankFields = d.byId("notifyBankFields"),
			notifyUserFields = d.byId("notifyUserFields"),
			notifyCounterpartyFields = d.byId("notifyCounterpartyFields"),
			bankAssigneeTasks = d.byId("bankAssigneeTasks");
	    
		m.toggleFields(isAssignee1Checked, 
				null, ["public_task_details_other_user_assignee_login_id_nosend"]);
		m.toggleFields(isAssignee2Checked, 
				null, ["public_task_details_bank_assignee_name_nosend"], true, true);
		m.toggleFields(isAssignee3Checked, null,
					["public_task_details_counterparty_assignee_name_nosend"], true, true);
		m.toggleFields(isAssignee4Checked, null, 
				["public_task_details_bank_other_user_assignee_login_id_nosend", 
				 "public_task_details_bank_other_user_assignee_email_nosend"], true, true);
		
		dj.byId("public_task_details_other_user_assignee_login_id_nosend").set("readonly", true);
		dj.byId("public_task_details_other_user_assignee_login_id_nosend").set("disabled", true);
		
		m.animate("fadeOut", [notifyBankFields, notifyUserFields, notifyCounterpartyFields], function(){
			if(isAssignee1Checked){
				m.animate("fadeIn", notifyUserFields);
			} else if (isAssignee2Checked){
				m.animate("fadeIn", notifyBankFields, function (){
					var checked = dj.byId("public_task_details_assignee_type_nosend_2").get("checked");
					console.log("Bank field is selected : "+checked);
					if(checked){
						dj.byId("public_task_details_bank_assignee_name_nosend").set("readonly", true);
						dj.byId("public_task_details_bank_assignee_name_nosend").set("disabled", true);
					}
			}, false, {duration: 1});
		
			} else if(isAssignee3Checked) {
				m.animate("fadeIn", notifyCounterpartyFields);
				
				var accessOpened = dj.byId("access_opened"),
				collaborationCounterparty = dj.byId("public_task_details_counterparty_assignee_name_nosend"),
				//collaborationCounterpartyLookup =  dj.byId("public_task_details_counterparty_assignee_name_nosend_img"),				
				productCode= dj.byId("product_code").get('value'),
				counterpartyName=null,
				counterpartyHiddenEmail = dj.byId("counterparty_email_id_hidden"),
				collaborationCounterpartyAbbvName = dj.byId("public_task_details_counterparty_assignee_abbv_name_nosend");
				
				if(productCode && (productCode ==="IP" || productCode ==="CR"))
				{
					counterpartyName = dj.byId("seller_name")? dj.byId("seller_name"):dj.byId("seller_abbv_name");
				}
				else if (productCode && (productCode ==="IN" || productCode ==="CN"))
				{
					counterpartyName = dj.byId("buyer_name")?dj.byId("buyer_name"):dj.byId("buyer_abbv_name");
				}
				if(accessOpened && counterpartyName)
				{
					if(counterpartyName.get('value')!=="")
					{
						if (accessOpened.get("value") === 'Y')
						{
							collaborationCounterparty.set('value',counterpartyName.get('value'));
							counterpartyHiddenEmail.set('value',dj.byId('transaction_counterparty_email').get('value'));
							collaborationCounterpartyAbbvName.set('value',dj.byId('ben_company_abbv_name').get('value'));
							//collaborationCounterpartyLookup.set('disabled',true);
						}
						else
						{
							collaborationCounterparty.set('value',"");
							collaborationCounterpartyAbbvName.set("value", "");
							m.dialog.show("ERROR", m.getLocalization("errorCounterpartyCollaborationNotEnabled"));
							m.animate("fadeOut", notifyCounterpartyFields);
						}
					}
					else
					{
						collaborationCounterparty.set('value',"");
						collaborationCounterpartyAbbvName.set("value", "");
						m.dialog.show("ERROR", m.getLocalization("errorSelectCounterpartyCollaboration"));
						m.animate("fadeOut", notifyCounterpartyFields);
					}
				}
				
			} else if(isAssignee4Checked) {
				m.animate("fadeIn", bankAssigneeTasks);
			}
			
			_getCollaborationBankName();
			_resetCollaborationFields();
		}, false, {duration: 20});
	}
	
	function _getPublicTasksMandatoryFields() {
		//  summary: 
	    //      Get mandatory public task fields
		
		var mandatoryFields = [{
		      name : "public_task_details_description_nosend",
		      value : ""
		}];

    	if(dj.byId("public_task_details_email_notification_nosend").get("checked")) {
    		mandatoryFields.push({
    			name : "public_task_details_email_nosend",
    			value :""
    		});
    	}
		                	
    	if(dj.byId("public_task_details_assignee_type_nosend_1").get("checked")) {
    		mandatoryFields.push({
    			name : "public_task_details_other_user_assignee_login_id_nosend",
    			value :""
    		});
    	}
		                	
    	if(dj.byId("public_task_details_assignee_type_nosend_2") &&
    			dj.byId("public_task_details_assignee_type_nosend_2").get("checked")) {
    		mandatoryFields.push({
    			name :"public_task_details_bank_assignee_name_nosend",
    			value :""
    		});
    	}
		                	
    	if(dj.byId("public_task_details_assignee_type_nosend_3") &&
    			dj.byId("public_task_details_assignee_type_nosend_3").get("checked")) {
    		mandatoryFields.push({
    			name : "public_task_details_counterparty_assignee_name_nosend",
    			value :""
    		});
    		
    		if(dj.byId("public_task_details_counterparty_assignee_email_notification_nosend").get("checked")) {
    			mandatoryFields.push({
    				name :"public_task_details_counterparty_assignee_email_nosend",
    				value :""
    			});
    		}
    	}
		                	
    	if(dj.byId("public_task_details_assignee_type_nosend_4") &&
    			dj.byId("public_task_details_assignee_type_nosend_4").get("checked")) {
    		mandatoryFields.push({
    			name :"public_task_details_bank_other_user_assignee_login_id_nosend",
    			value :""
    		});
    		
    		if(dj.byId("public_task_details_bank_other_user_assignee_email_notification_nosend").get("checked")) {
    			mandatoryFields.push({
    				name :"public_task_details_bank_other_user_assignee_email_nosend",
    				value :""
    			});
    		}
    	}

		return mandatoryFields;
	}
	
	function _getNotificationTasksMandatoryFields() {
		var mandatoryFields = [{
			name : "notification_task_details_other_user_assignee_login_id_nosend",
		    value : ""
		},
		{
		    name : "notification_description_nosend",
		    value : ""
		}];

		if(dj.byId("notification_task_details_email_notification_nosend").get("checked")) {
			mandatoryFields.push({
				name :"notification_task_details_email_nosend",
				value : ""
			});
		}
		
		return mandatoryFields;
	}
	
	function _getPrivateTasksMandatoryFields() {
		return [{
		    name : "private_description_nosend",
		    value : ""
		}];
	}
	
	function _getPublicTasksHiddenFields(/*String*/ id) {
		//  summary: 
		//		Get hidden fields for public tasks
		
		var emailNotification = "N",
			taskType = "02",
			counterpartyEmailNotification = "N",
			otherUserEmailNotification = "N",
			bankEmailNotification = "N",
			assigneeType;

		if(dj.byId("public_task_details_email_notification_nosend") &&
				dj.byId("public_task_details_email_notification_nosend").get("checked")) {
			emailNotification = "Y";
		}
		
		if(dj.byId("public_task_details_type_nosend_3") &&
				dj.byId("public_task_details_type_nosend_3").get("checked")) {
			taskType = "03";
		}
		
		if(dj.byId("public_task_details_counterparty_assignee_email_notification_nosend") &&
				dj.byId("public_task_details_counterparty_assignee_email_notification_nosend").get("checked")) {
			counterpartyEmailNotification = "Y";
		}
		
		if(dj.byId("public_task_details_other_user_assignee_email_notification_nosend") &&
				dj.byId("public_task_details_other_user_assignee_email_notification_nosend").get("checked")) {
			otherUserEmailNotification = "Y";
		}
		
		if(dj.byId("public_task_details_assignee_type_nosend_1") &&
				dj.byId("public_task_details_assignee_type_nosend_1").get("checked")) {
			assigneeType = "01";
		
		}
		else if(dj.byId("public_task_details_assignee_type_nosend_2") &&
				dj.byId("public_task_details_assignee_type_nosend_2").get("checked")) {
			assigneeType = "02";
		}
		else if(dj.byId("public_task_details_assignee_type_nosend_3") &&
				dj.byId("public_task_details_assignee_type_nosend_3").get("checked")) {
			assigneeType = "03";
		}
		else if(dj.byId("public_task_details_assignee_type_nosend_4") &&
				dj.byId("public_task_details_assignee_type_nosend_4").get("checked")) {
			assigneeType = "04";
		}
		
		if(dj.byId("public_task_details_bank_assignee_email_notification_nosend") &&
				dj.byId("public_task_details_bank_assignee_email_notification_nosend").get("checked")) {
			bankEmailNotification = "Y";
		}
		
		var hiddenFields = [
			{
				name : "public_task_details_task_id_" + id,
				value : id
			},
			{
				name : "public_task_details_issue_user_id_" + id,
				value : dj.byId("connected_user_id").get("value")
			},
			{
				name :"public_task_details_issue_company_abbv_name_" + id,
				value : dj.byId("connected_company_abbv_name").get("value")
			},
			{
				name : "public_task_details_description_" + id,
				value : dj.byId("public_task_details_description_nosend").get("value")
			},
			{
				name :"public_task_details_email_notification_" + id,
				value : emailNotification
			},
			{
				name : "public_task_details_email_" + id,
				value : dj.byId("public_task_details_email_nosend").get("value")
			}, 
			{
				name : "public_task_details_type_" + id,
				id : "",
				value : taskType
			}, 
			{
				name : "public_task_details_assignee_type_" + id,
				id : "",
				value : assigneeType
			},
			{
				name : "public_task_details_counterparty_assignee_name_" + id,
				value : dj.byId("public_task_details_counterparty_assignee_name_nosend").get("value")
			},
			{
				name : "public_task_details_counterparty_assignee_abbv_name_" + id,
				value : dj.byId("public_task_details_counterparty_assignee_abbv_name_nosend").get("value")
			},
			{
				name : "public_task_details_counterparty_assignee_email_notification_" + id,
				value : counterpartyEmailNotification
			},
			{
				name : "public_task_details_counterparty_assignee_email_" + id,
				value : dj.byId("public_task_details_counterparty_assignee_email_nosend").get("value")
			},
			{
				name : "public_task_details_other_user_assignee_login_id_" + id,
				value : dj.byId("public_task_details_other_user_assignee_login_id_nosend").get("value")
			},
			{
				name :"public_task_details_other_user_assignee_user_id_" + id,
				value : dj.byId("public_task_details_other_user_assignee_user_id_nosend").get("value")
			},
			{
				name : "public_task_details_other_user_assignee_email_notification_" + id,
				value : otherUserEmailNotification
			},
			{
				name :"public_task_details_other_user_assignee_email_" + id,
				value :dj.byId("public_task_details_other_user_assignee_email_nosend").get("value")
			},
			{
				name :"public_task_details_bank_assignee_name_" + id,
				value : dj.byId("public_task_details_bank_assignee_name_nosend").get("value")
			},
			{
				name :"public_task_details_bank_assignee_abbv_name_" + id,
				value : dj.byId("public_task_details_bank_assignee_abbv_name_nosend").get("value")
			},
			{
				name : "public_task_details_bank_assignee_email_notification_" + id,
				value : bankEmailNotification
			},
			{
				name : "public_tasks_details_issue_date_" + id,
				value : ""
			},
			{
				name:"public_tasks_details_bank_other_user_assignee_user_id_" + id,
				value: ""//dj.byId("connected_user_id").get("value")
			}
		];
		
		if(assigneeType == "04")
		{
			hiddenFields.push( {
				name :"public_task_details_bank_other_user_assignee_login_id_" + id,
				value :dj.byId("public_task_details_bank_other_user_assignee_login_id_nosend").get("value")
			});
			
			var bankOtherEmailNotification = "N";
			if(dj.byId("public_task_details_bank_other_user_assignee_email_notification_nosend") &&
					dj.byId("public_task_details_bank_other_user_assignee_email_notification_nosend").get("checked")) {
				bankOtherEmailNotification = "Y";
			}
			
			hiddenFields.push( {
				name : "public_task_details_bank_other_user_assignee_email_notification_" + id,
				value : bankOtherEmailNotification
			});
			hiddenFields.push( {
				name : "public_task_details_bank_other_user_assignee_email_" + id,
				value : dj.byId("public_task_details_bank_other_user_assignee_email_nosend").get("value")
			});
		}
		
		return hiddenFields;
	}
	
	function _getNotificationTasksHiddenFields( /*String*/ id) {
		var emailNotification = "N",
			assigneeType = "01",
			taskType = "03";
		
		if(dj.byId("notification_task_details_email_notification_nosend") &&
				dj.byId("notification_task_details_email_notification_nosend").get("checked")) {
			emailNotification = "Y";
		}

		var hiddenFields = [
			{
				name : "public_task_details_task_id_" + id,
				id : "",
				value : id
			},
			{
				name : "public_task_details_issue_user_id_" + id,
				id : "",
				value : dj.byId("connected_user_id").get("value")
			},
			{
				name :"public_task_details_issue_company_abbv_name_" + id,
				id : "",
				value :dj.byId("connected_company_abbv_name").get("value")
			},
			{
				name :"public_task_details_description_" + id,
				id : "public_task_details_description_nosend",
				value : dj.byId("notification_description_nosend").get("value")
			},
			{
				name :"public_task_details_email_notification_" + id,
				id : "",
				value : emailNotification
			},
			{
				name :"public_task_details_email_" + id,
				id : "public_task_details_email_nosend",
				value :dj.byId("notification_task_details_email_nosend").get("value")
			}, 
			{
				name :"public_task_details_type_" + id,
				id : "",
				value :taskType
			}, 
			{
				name :"public_task_details_assignee_type_" + id,
				id : "",
				value :assigneeType
			},
			{
				name :"public_task_details_other_user_assignee_login_id_" + id,
				id : "public_task_details_other_user_assignee_login_id_nosend",
				value : dj.byId("notification_task_details_other_user_assignee_login_id_nosend").get("value")
			},
			{
				name :"public_tasks_details_issue_date_" + id,
				id : "",
				value : ""
			},
			{
				name:"public_tasks_details_bank_other_user_assignee_user_id_" + id,
				id: "public_tasks_details_bank_other_user_assignee_user_id_nosend",
				value: dj.byId("notification_task_details_other_user_assignee_user_id_nosend").get("value")
			}
		];
		
		return hiddenFields;
	}
	
	function _getPrivateTasksHiddenFields(/*String*/ id) {
		var taskType = "01";

		var hiddenFields = [
			{
				name :"private_task_details_task_id_" + id,
				id : "",
				value : id
			},
			{
				name :"public_tasks_details_issue_date_" + id,
				id : "",
				value : ""
			},
			{
				name :"private_task_details_issue_user_id_" + id,
				id : "",
				value : dj.byId("connected_user_id").get("value")
			},
			{
				name :"private_task_details_issue_company_abbv_name_" + id,
				id : "",
				value : dj.byId("connected_company_abbv_name").get("value")
			},
			{
				name :"private_task_details_description_" + id,
				id : "private_task_details_description_nosend",
				value : dj.byId("private_description_nosend").get("value")
			},
			{
				name :"public_task_details_type_" + id,
				id : "",
				value :taskType
			}
		];
		
		return hiddenFields;
	}

	function _toggleFieldsByPermissions() {
		// summary:
		//	To enable and hide or show based on the permission to the user
		
		var publicTaskAssigneeType1 = dj.byId("public_task_details_assignee_type_nosend_1"),
			publicTaskAssigneeType2 = dj.byId("public_task_details_assignee_type_nosend_2"),
			publicTaskAssigneeType3 = dj.byId("public_task_details_assignee_type_nosend_3");
		
		if(!publicTaskAssigneeType1) {
			publicTaskAssigneeType1.set("checked", false);

			if(publicTaskAssigneeType2) {
				publicTaskAssigneeType2.set("checked", true);
				publicTaskAssigneeType1.set("checked", false);
				if (publicTaskAssigneeType3) {
					publicTaskAssigneeType3.set("checked", false);
				}
			}
			else  {

				if(publicTaskAssigneeType3) {
					publicTaskAssigneeType3.set("checked", true);
					publicTaskAssigneeType1.set("checked", false);
				} else {
					publicTaskAssigneeType1.set("checked", false);
				}
			}
		} else {
			publicTaskAssigneeType1.set("checked", true);
			if (publicTaskAssigneeType2) {
				publicTaskAssigneeType2.set("checked", false);
			}
			if (publicTaskAssigneeType3) {
				publicTaskAssigneeType3.set("checked", false);
			}
		}
	}
	
	function _handleEmails( /*dj._widget*/ checkBoxWidget, 
							/*String*/emailWidgetId,
							/*String*/ emailContainingWidgetId,
							/*String*/ emailHiddenWidgetId) {
		// summary:
		//		To fadeout and fadeIn Email Input based on notification 
		
		var email = dj.byId(emailHiddenWidgetId).get("value");
		if(dj.byId(checkBoxWidget).get("checked")) {
		   m.animate("fadeIn", d.byId(emailContainingWidgetId), function(){
			   if(email) {
				   dj.byId(emailWidgetId).set("value", email);
				   dj.byId(emailWidgetId).set("readonly", true);
				   dj.byId(emailWidgetId).set("disabled", true);
			   }
		   }, false, {duration: 20});
		   
		}
		else
		{
		   m.animate("fadeOut", emailContainingWidgetId, function(){
			   dj.byId(emailWidgetId).set("value", "");
		   }, false, {duration: 20});
		}
	}
	
	function _getCollaborationBankName(){
		var bankAbbvNameFieldId,
			bankAbbvName,
			bankNameFieldId,
			bankName;
			
		if(dj.byId("public_task_details_assignee_type_nosend_2") && dj.byId("public_task_details_assignee_type_nosend_2").get("checked")) {
			if(dj.byId("bank_abbv_name_widget_id_hidden") && 
					dj.byId("bank_name_widget_id_hidden")) {
				bankAbbvNameFieldId = dj.byId("bank_abbv_name_widget_id_hidden").get("value");
				bankNameFieldId = dj.byId("bank_name_widget_id_hidden").get("value");
					
				if(dj.byId(bankAbbvNameFieldId)){
					bankAbbvName = dj.byId(bankAbbvNameFieldId);
					dj.byId(
							"public_task_details_bank_assignee_abbv_name_nosend").set("value", bankAbbvName.get("value"));
				}
				if(dj.byId(bankNameFieldId)) {
					bankName = dj.byId(bankNameFieldId);
					dj.byId(
								"public_task_details_bank_assignee_name_nosend").set("value", bankName.get("value"));
				}
			}
		} else {
			dj.byId("public_task_details_bank_assignee_name_nosend").set("value", "");
			dj.byId("public_task_details_bank_assignee_abbv_name_nosend").set("value", "");
		}
	}
	
	function _resetCollaborationFields(){
		// summary:
		//		TODO
			
		var publicTask = dj.byId("public_task_details_type_nosend_2"),
			assigneeTask = dj.byId("public_task_details_type_nosend_3"),
			publicTaskAssigneeType1 = dj.byId("public_task_details_assignee_type_nosend_1"),
			publicTaskAssigneeType2 = dj.byId("public_task_details_assignee_type_nosend_2"),
			publicTaskAssigneeType3 = dj.byId("public_task_details_assignee_type_nosend_3");
			
		if(publicTask.get("checked")) {
			m.animate("fadeOut", 
					[d.byId("counterparty_email_input_field_div"), 
							d.byId("other_user_email_input_field_div")], function(){
				dj.byId("public_task_details_other_user_assignee_login_id_nosend").reset();
				dj.byId("public_task_details_other_user_assignee_email_notification_nosend").set("checked", false);
				dj.byId("other_user_email_id_hidden").reset();
				dj.byId("public_task_details_other_user_assignee_user_id_nosend").reset();
				dj.byId("public_task_details_other_user_assignee_email_nosend").reset();
				dj.byId("public_task_details_counterparty_assignee_name_nosend").reset();
				dj.byId("public_task_details_counterparty_assignee_abbv_name_nosend").reset();
				dj.byId("public_task_details_counterparty_assignee_email_notification_nosend").set("checked", false);
				dj.byId("counterparty_email_id_hidden").reset();
				dj.byId("public_task_details_counterparty_assignee_email_nosend").reset();
				dj.byId("public_task_details_bank_assignee_email_notification_nosend").set("checked", false);
				dj.byId("public_task_details_bank_assignee_name_nosend").reset();
			}, false, {duration: 20});
		} else {
			if(publicTaskAssigneeType1 && !publicTaskAssigneeType1.get("checked")) {
				m.animate("fadeOut", d.byId("other_user_email_input_field_div"), function(){
					dj.byId("public_task_details_other_user_assignee_login_id_nosend").reset();
					dj.byId("public_task_details_other_user_assignee_email_notification_nosend").set("checked", false);
					dj.byId("public_task_details_other_user_assignee_user_id_nosend").reset();
					dj.byId("other_user_email_id_hidden").reset();
					dj.byId("public_task_details_other_user_assignee_email_nosend").reset();
				});
			}
			if(publicTaskAssigneeType2 && !publicTaskAssigneeType2.get("checked")) {
				dj.byId("public_task_details_bank_assignee_email_notification_nosend").set("checked", false);
				dj.byId("public_task_details_bank_assignee_name_nosend").reset();
			}
			if(publicTaskAssigneeType3 && !publicTaskAssigneeType3.get("checked")) {
				m.animate("fadeOut", d.byId("counterparty_email_input_field_div"), function(){
					dj.byId("public_task_details_counterparty_assignee_name_nosend").reset();
					dj.byId("public_task_details_counterparty_assignee_email_notification_nosend").set("checked", false);
					dj.byId("counterparty_email_id_hidden").reset();
					dj.byId("public_task_details_counterparty_assignee_abbv_name_nosend").reset();
					dj.byId("public_task_details_counterparty_assignee_email_nosend").reset();
				});
			}
		}
	}
	
	function validateContent(widget)
	{
		var errorMessage= null;
		if(dj.byId(widget))
		{
			var widgetContent = dj.byId(widget).get("value");
			if((widgetContent.indexOf("<") != -1) || (widgetContent.indexOf(">") != -1)) 
			{
				errorMessage =  m.getLocalization("invalidContent");
				dj.byId(widget).set("state","Error");
				dj.hideTooltip(dj.byId(widget).domNode);
				dj.showTooltip(errorMessage, dj.byId(widget).domNode, 0);
			}
		}
	}
	var _assigneeHandles = []; 
	
	d.mixin(m, {
		
		bindCollaboration : function(){
			m.setValidation("public_task_details_email_nosend", m.validateEmailAddr);
			m.setValidation("public_task_details_bank_other_user_assignee_email_nosend",
					m.validateEmailAddr);
			m.setValidation("public_task_details_counterparty_assignee_email_nosend",
					m.validateEmailAddr);

			m.connect("public_task_details_email_notification_nosend", "onClick", function(){
			  m.toggleFields(this.get("checked"), null, ["public_task_details_email_nosend"]);
			  _handleEmails(this, "public_task_details_email_nosend", 
					  "email_input_field_div", "user_email_id_hidden");
			});
			
			m.connect("notification_task_details_email_notification_nosend", "onClick",
					function(){
						m.toggleFields(this.get("checked"), null, 
								["notification_task_details_email_nosend"]);
					}
			);
			
			m.connect(
					"public_task_details_counterparty_assignee_email_notification_nosend", 
					"onClick", function(){
						
			  m.toggleFields(this.get("checked"), null,
								["public_task_details_counterparty_assignee_email_nosend"]);
			  if(!dj.byId("public_task_details_counterparty_assignee_name_nosend").get("value")){
				  dj.byId("counterparty_email_id_hidden").set("value", "");
				  dj.byId("public_task_details_counterparty_assignee_email_notification_nosend").set(
						  "checked", false);
			  } else {
				  _handleEmails(this,"public_task_details_counterparty_assignee_email_nosend",
						  "counterparty_email_input_field_div","counterparty_email_id_hidden"); 
			  }
			});
			
			m.connect("public_task_details_other_user_assignee_email_notification_nosend",
					"onClick", function(){
			  m.toggleFields(this.get("checked"), null,
					  ["public_task_details_other_user_assignee_email_nosend"]);
			  if(!dj.byId("public_task_details_other_user_assignee_login_id_nosend").get("value")) {
				  dj.byId("other_user_email_id_hidden").set("value", "");
				  dj.byId("public_task_details_other_user_assignee_email_notification_nosend").set("checked", false);
			  } else {
				  _handleEmails(this,"public_task_details_other_user_assignee_email_nosend",
						  "other_user_email_input_field_div","other_user_email_id_hidden"); 
			  }	  
			});
			
			_assigneeHandles.push(m.connect("public_task_details_type_nosend_2", "onClick", 
					_toggleAssigneeRadioButtons));
			_assigneeHandles.push(m.connect("public_task_details_type_nosend_3", "onClick",
					_toggleAssigneeRadioButtons));
			_assigneeHandles.push(m.connect("public_task_details_assignee_type_nosend_1", "onClick",
					_checkEntityForCollaboration));
			_assigneeHandles.push(m.connect("public_task_details_assignee_type_nosend_1", "onClick", 
					_toggleAssigneeType));
			_assigneeHandles.push(m.connect("public_task_details_assignee_type_nosend_2", "onClick", 
					_toggleAssigneeType));
			_assigneeHandles.push(m.connect("public_task_details_assignee_type_nosend_3", "onClick", 
					_toggleAssigneeType));
			_assigneeHandles.push(m.connect("public_task_details_assignee_type_nosend_4", "onClick", 
					_toggleAssigneeType));

			m.connect("public_task_details_description_nosend","onBlur",
					function(){
					validateContent("public_task_details_description_nosend");
					});
			m.connect("private_description_nosend","onBlur",
					function(){
				validateContent("private_description_nosend");
				});
			m.connect("public_tasks_description_nosend","onBlur",
					function(){
				validateContent("public_tasks_description_nosend");
				});
			m.connect("private_tasks_description_nosend","onBlur",
					function(){
				validateContent("private_tasks_description_nosend");
				});
			m.connect("notification_description_nosend","onBlur",
					function(){
				validateContent("notification_description_nosend");
				});
			m.connect("notification_tasks_description_nosend","onBlur",
					function(){
				validateContent("notification_tasks_description_nosend");
			});
			m.connect("public_task_details_description_nosend","onBlur",
					function(){
					validateContent("public_task_details_description_nosend");
					});
		},
		
		cancelCollaborationTask : function(/*String*/ type)
		{
			if(dj.byId("public_task_id_nosend"))
			{
				dj.byId("public_task_id_nosend").set("value", "");
			}
			 dj.byId('public_tasks_dialog').hide();
		},
		
		addCollaborationTask : function( /*String*/ type,
										 /*String*/ postSave) {
			// summary: 
			//		TODO
			
			if(dj.byId(type + "_description_nosend") && dj.byId(type + "_description_nosend").state !== "Error")
			{
				console.debug("[Collaboration] Adding a collaboration task of type " + type);	
				var mandatoryFields = [],
					isValid = false,
					id = "",
					isTaskUpdate = true,
					dialog = dj.byId(type + "_dialog"),
					field, declaredClass, value;
				
				type = type.toLowerCase();
				switch(type) {
				case "private_tasks":
					mandatoryFields = _getPrivateTasksMandatoryFields();
					id = dj.byId("private_task_id_nosend").get("value");
					break;
				case "public_tasks":
					mandatoryFields = _getPublicTasksMandatoryFields();
					id = dj.byId("public_task_id_nosend").get("value");
					break;
				default:
					mandatoryFields = _getNotificationTasksMandatoryFields();
					id = dj.byId("notification_task_id_nosend").get("value");
					break;
				}
				
				// Generate task if in case of new task
				if (id === "")
				{
					id = _generateId(type);
					isTaskUpdate = false;
				}
				
				// Validate fields
				isValid = d.every(mandatoryFields, function(fieldDetails){
					field = dj.byId(fieldDetails.name);
					if(field) {
						// TODO This looks a bit hacky, try to find a way to make it act like
						//		standard form validation
						
						declaredClass = field.declaredClass;
						value = field.get("displayedValue");
						if(/NumberTextBox/.test(declaredClass) ||
								(/CurrencyTextBox/.test(declaredClass))) {
							value = field.get("value");
							value = isNaN(value) ? "" : value;
						}
						else if(field.id)
						{
							validateContent(field.id);
						}
						if(type === "private_tasks" && field.state === "Error")
							{
							return false;
							}
						
						if(!value || field.state === "Error"){
							// Show the widget specific error message on click of Ok button
							m.showTooltip(field.invalidMessage,
									field.domNode);
							m.setFieldState(field, false);
							return false;
						}
					}
					return true;
				});
				
				if(!isValid) {
					return false;
				}
				
				// Add an item to the list
				_addCollaborationItem(type, id, postSave, isTaskUpdate);
				
				// If we're editing an entry, delete the original row
				if(dialog) {
					dialog.hide();
				}
				
				// Retrieve and reset all fields
				d.query("#" + type + "_fields *[id^=" + type + "]").forEach(function(node){
					var field = dj.byId(node.id);
					if(field){
						field.reset();
					}
				});
				m._config.taskEditMode = false;
				m._config.currentTaskID = "";
				//After updating an task should clear the task id from below hidden filed respectively
				//otherwise after editing an existing task, if user try to add a new task system consider the new task 
				//as an previously edited task.
				if(isTaskUpdate)
				{
					switch(type) {
					case "private_tasks":
						if(dj.byId("private_task_id_nosend"))
						{
							dj.byId("private_task_id_nosend").set("value", "");
						}
						break;
					case "public_tasks":
						if(dj.byId("public_task_id_nosend"))
						{
							dj.byId("public_task_id_nosend").set("value", "");
						}
						break;
					default:
						if(dj.byId("notification_task_id_nosend"))
						{
							dj.byId("notification_task_id_nosend").set("value", "");
						}
						break;
					}
				}
		    	return true;
			}
		},
		
		finishCollaborationTask : function( /*String || dj._widget*/ node,
											/*String*/ type, 
											/*String*/ id) {
			// summary:
			//		TODO
			
			var widget = dj.byId(node),
				inputDate = d.byId("old_inp_dttm") ? d.byId("old_inp_dttm").value : "",
				isChecked = widget.get("checked"),
				descId;
			
			if (d.byId("task_edit_" + id))
			{
				var editTaskNode = d.byId("task_edit_" + id);
				d.style(editTaskNode, "display", isChecked ? "none" : "inline");
			}
				
		    m.xhrPost( {
				url : m.getServletURL("/screen/AjaxScreen/action/SetPerformed?taskid=" +
				      id + "&performed=" + (isChecked ? "Y": "N") + "&inputdate=" + inputDate),
				load : function(response, args){
			    	descId = d.byId(type+"_desc_"+id);
			    	
			    	// TODO Should use classes
		    		if(isChecked) {
		    			d.style(descId, "textDecoration", "line-through");
		    			d.style(descId, "color", "#999");
		    		} else {
		    			d.style(descId, "textDecoration", "none");
		    			d.style(descId, "color", "black");
		    		}
				}
			});
		},
		
		openCollaborationComment : function( /*String*/ type,
											 /*String*/ id) {
			//  summary:
			//        Open the comments dialog

			var dialog = dj.byId(type + "_comments_dialog"),
				currentIdField, oldId;
			
			console.debug("[Collaboration] Opening dialog " + type + "_comments_dialog");
			if(!dialog) {
				// TODO We should just parse on page load, perf not worth doing this
				d.parser.parse(type + "_comments_div");
				dialog = dj.byId(type + "_comments_dialog");
				m.bindCollaboration();
			}
		
			currentIdField = dj.byId(type + "_comments_current_id_nosend");
			
			dj.byId(type + "_description_nosend").set("value", "");
			oldId = currentIdField.get("value");

			if(oldId) {
				d.style(d.byId(type+"_comments_" + oldId), "display", "none");
			}

			currentIdField.set("value", id);
			dialog.show();
			d.style(d.byId(type+"_comments_" + id), "display", "block");
			d.style(d.byId(type+"_comments_" + id), "width", "425px");
			d.style(d.byId(type+"_comments_" + id), "height", "173px");
			d.style(d.byId(type+"_comments_" + id), "overflow", "auto");
		}, 
		
		addCollaborationComment : function(/*String*/ type) {
			// summary:
			//		Add a comment to a task
			
			if(dj.byId(type + "_description_nosend") && dj.byId(type + "_description_nosend").state !== "Error")
			{
				var comment = dj.byId(type + "_description_nosend").get("value"),
					xml = ["<?xml version='1.0' encoding='UTF-8'?><comment>"],
					oldInpDttm = dj.byId("old_inp_dttm").get("value"),
					xmlComment, id;
	
				if((comment)&&(comment.length <= 204)) {
					id = dj.byId(type + "_comments_current_id_nosend").get("value");
					xml.push("<description>", m.grid.sanitizeHTMLDataForUI(dj.byId(type + "_description_nosend").get("value")), "</description>");
					xml.push("<task_id>", id, "</task_id>");
					xml.push("<old_inp_dttm>", oldInpDttm, "</old_inp_dttm></comment>");
					
					console.debug("[Collaboration] Adding Collaboration Task Comment - Request XML");
					console.debug("[Collaboration] " + xml.join(""));
					
					xml = xml.join("");
					// TODO Refactor, defer changing DOM until later
					m.xhrPost( {
						url : m.getServletURL("/screen/AjaxScreen/action/SaveComment"),
						content: {xml_string : xml},
						load : function(response, args){
							console.debug("[Collaboration] Adding Collaboration Task Comment - Response = " + xml);
							 
							// Add a new comment
							var masterOl = d.byId(type + "_comments_" + id),
								lastId = masterOl.getElementsByTagName("li").length,
								desc = dj.byId(type+"_description_nosend"),
								taskInfo =  dj.byId("sentence_posted_by").get("value")+ " " +
												dj.byId("sentence_you").get("value");
					
							d.create("li", {
								id: type + "_comment_" + id + "_" + lastId,
								innerHTML: desc.get("value") + "<br><div class='taskInfo'>" +
												taskInfo + "</div>"
							}, masterOl);
					
							// Update the number of comments
							var count =
								parseInt(d.byId(type + "_comment_count_" + id).innerHTML, 10);
							count++;
							d.byId(type  + "_comment_count_" + id).innerHTML = count;
								
							// Clear box
							desc.set("value", "");
						},
						error : function(response, args){
							console.error("[collaboration] Technical error while saving Comment");
							console.error(response);
						}
					});
				}
			}
		}, 
			
		openPublicTaskDialog : function() {
			//  summary:
			//            Reset all task fields
			    
			var dialog = dj.byId("public_tasks_dialog");
			if(!dialog) {
				d.parser.parse("public-tasks-fields");
				dialog = dj.byId("public_tasks_dialog");
				m.bindCollaboration();
			}
			
			var nodes = [];
			nodes.push(d.byId("collaboration_type_view_div"));
			nodes.push(d.byId("email_input_field_div"));
			nodes.push(d.byId("counterparty_email_input_field_div"));
			nodes.push(d.byId("other_user_email_input_field_div"));
			
			m.animate("fadeOut", nodes, function(){
				dialog.show();
			}, false, {duration: 20});

			dj.byId("public_task_details_description_nosend").reset();
			dj.byId("public_task_details_other_user_assignee_user_id_nosend").reset();
			dj.byId("public_task_details_email_nosend").reset();
			dj.byId("public_task_details_email_notification_nosend").set("checked", false);
			if(dj.byId("public_task_details_email_notification_nosend")) {
				m.toggleFields(
						dj.byId("public_task_details_email_notification_nosend").get("checked"),
						null, ["public_task_details_email_nosend"]);
			}
					
			dj.byId("public_task_details_type_nosend_2").set("checked", true);
			dj.byId("public_task_details_type_nosend_3").set("checked", false);
				
			_toggleAssigneeRadioButtons();

			dj.byId("public_task_details_other_user_assignee_login_id_nosend").reset();
			dj.byId("public_task_details_bank_assignee_name_nosend").reset();
			dj.byId("public_task_details_bank_assignee_abbv_name_nosend").reset();
			dj.byId("public_task_details_bank_assignee_email_notification_nosend").set(
						"checked", false);
			dj.byId("public_task_details_counterparty_assignee_name_nosend").reset();
			dj.byId("public_task_details_counterparty_assignee_email_notification_nosend").set(
						"checked", false);
		//	dj.byId("public_task_details_counterparty_assignee_email_nosend").reset();
			dj.byId("public_task_details_counterparty_assignee_email_nosend").set(
						"disabled", true);	
		}, 
			
		openNotificationTaskDialog : function() {
			//  summary:
		    //        Open a dialog to add a notification (after product submission by the client)

			var dialog = dj.byId("notification_tasks_dialog");
			if(!dialog) {
				d.parser.parse("notification-task-fields");
				dialog = dj.byId("notification_tasks_dialog");
				m.bindCollaboration();
			}
				
			if(dj.byId("notification_task_details_email_notification_nosend")) {
				m.toggleFields(
						dj.byId("notification_task_details_email_notification_nosend").get("checked"), 
						null, ["notification_task_details_email_nosend"]);
			}
				
			dj.byId("notification_task_details_other_user_assignee_login_id_nosend").reset();
			dj.byId("notification_description_nosend").reset();
			dialog.show();
		},
			
		openPrivateTaskDialog : function() {
			//  summary:
		    //        Open a dialog to add a private task
				
			var dialog = dj.byId("private_tasks_dialog");
			if(!dialog) {
				d.parser.parse("private-task-fields");
				dialog = dj.byId("private_tasks_dialog");
				m.bindCollaboration();
			}
				
			dialog.show();
			dj.byId("private_description_nosend").reset();
		},
		
		openTaskForUpdate : function(taskId) {
			//  summary:
		    //        Open a dialog to update a task

			console.log("openTaskForUpdate: " + taskId);
		    m.xhrPost( {
				url : m.getServletURL("/screen/AjaxScreen/action/GetTask?taskid=" + taskId),
				load : function(response, args){
					response = d.fromJson(response);
					if (response.type[1] === "01")
					{
						m.openPrivateTaskDialog();
						dj.byId("private_task_id_nosend").set("value", response.task_id);
						dj.byId("private_description_nosend").set("value", response.description);
					}
					else
					{
						_toggleAssigneeRadioButtons = function(){
							console.log("_toggleAssigneeRadioButtonsSave");
						};
						_toggleAssigneeType = function(){
							console.log("_toggleAssigneeTypeSave");
						};
						m.openPublicTaskDialog();
						d.forEach(_assigneeHandles, function(handle){
							d.disconnect(handle);
						});
						dj.byId("public_task_id_nosend").set("value", response.task_id);
						dj.byId("public_task_details_description_nosend").set("value", response.description);
						dj.byId("public_task_details_email_notification_nosend").set("checked", response.email_notification === "Y");
						dj.byId("public_task_details_email_nosend").set("value", response.email);

						dj.byId("public_task_details_type_nosend_2").set("checked", response.type[1] === "02");
						dj.byId("public_task_details_type_nosend_3").set("checked", response.type[1] === "03");
						if (response.type[1] === "03")
						{
							m.toggleFields(true, 
									["public_task_details_assignee_type_nosend_1", 
									 "public_task_details_assignee_type_nosend_2",
									 "public_task_details_assignee_type_nosend_3"]);

							d.style("assigneeTypeFields", "display", "block");

							if(dj.byId("public_task_details_assignee_type_nosend_1"))
							{
								dj.byId("public_task_details_assignee_type_nosend_1").set("checked", response.assignee_type[1] === "01");
							}
							if(dj.byId("public_task_details_assignee_type_nosend_2"))
							{
								dj.byId("public_task_details_assignee_type_nosend_2").set("checked", response.assignee_type[1] === "02");
							}
							if(dj.byId("public_task_details_assignee_type_nosend_3"))
							{
								dj.byId("public_task_details_assignee_type_nosend_3").set("checked", response.assignee_type[1] === "03");
							}
							if (response.assignee_type[1] === "01")
							{
								d.style("notifyUserFields", "display", "block");
								dj.byId("public_task_details_other_user_assignee_login_id_nosend").set("value", response.dest_user_login_id);
								dj.byId("public_task_details_other_user_assignee_user_id_nosend").set("value", response.dest_user_id);
								dj.byId("public_task_details_other_user_assignee_email_notification_nosend").set("value", response.dest_user_email_notif === "Y");
								dj.byId("public_task_details_other_user_assignee_email_nosend").set("value", response.dest_user_email);
								dj.byId("other_user_email_id_hidden").set("value", response.dest_user_email);
								if(response.dest_user_email_notif === "Y")
								{
									d.style("other_user_email_input_field_div", "display", "block");
									m.toggleFields(true, null,
										["public_task_details_other_user_assignee_email_nosend"]);
									_handleEmails(dj.byId("public_task_details_other_user_assignee_email_notification_nosend"),
										"public_task_details_other_user_assignee_email_nosend",
										"other_user_email_input_field_div",
										"other_user_email_id_hidden");
								}	
							}
							if (response.assignee_type[1] === "02")
							{
								d.style("notifyBankFields", "display", "block");
								dj.byId("public_task_details_bank_assignee_name_nosend").set("value", response.dest_company_name);
								dj.byId("public_task_details_bank_assignee_abbv_name_nosend").set("value", response.dest_company_abbv_name);
								dj.byId("public_task_details_bank_assignee_email_notification_nosend").set("checked", response.dest_company_email_notif === "Y");
							}
							if (response.assignee_type[1] === "03")
							{
								d.style("notifyCounterpartyFields", "display", "block");
								dj.byId("public_task_details_counterparty_assignee_name_nosend").set("value", response.dest_company_name);
								dj.byId("public_task_details_counterparty_assignee_abbv_name_nosend").set("value", response.dest_company_abbv_name);
								dj.byId("public_task_details_counterparty_assignee_email_notification_nosend").set("checked", response.dest_company_email_notif === "Y");
							}
							//added the below block of code to modify the assignee type radio buttons before display when task is opened in edit mode
							//fix for MPS-23593
							var publicTaskAssigneeType1 = dj.byId("public_task_details_assignee_type_nosend_1"),
							publicTaskAssigneeType2 = dj.byId("public_task_details_assignee_type_nosend_2"),
							publicTaskAssigneeType3 = dj.byId("public_task_details_assignee_type_nosend_3"),
							publicTaskDetailsType3 = dj.byId("public_task_details_type_nosend_3"),
							isPublicChecked = (publicTaskDetailsType3) ? 
									publicTaskDetailsType3.get("checked") : false,
							assigneeTypeFields = d.byId("assigneeTypeFields");

							//Provide a hook to modify the assignee type radio buttons before display
							if(isPublicChecked)
							{
								var assigneeTypes = [
								                          {
								                        	  id : "public_task_details_assignee_type_nosend_1",
								                        	  description: "user_to_user"
								                          },
								                          {
								                        	  id : "public_task_details_assignee_type_nosend_2",
								                        	  description: "user_to_bank"
								                          },
								                          {
								                        	  id : "public_task_details_assignee_type_nosend_3",
								                        	  description: "counterparty"
								                          },
								                          {
								                        	  id : "public_task_details_assignee_type_nosend_4",
								                        	  description: "bank"
								                          }
							                        ];
								m.preDisplayAssigneeType = m.preDisplayAssigneeType || function(){ return true; };
								m.preDisplayAssigneeType(assigneeTypes);
							}	
						}
						
						// TODO: find a way to not duplicate this function
						_toggleAssigneeRadioButtons = function() {
							//  summary:
						    //            Display the Assignee Radio Buttons
							
							var publicTaskAssigneeType1 = dj.byId("public_task_details_assignee_type_nosend_1"),
								publicTaskAssigneeType2 = dj.byId("public_task_details_assignee_type_nosend_2"),
								publicTaskAssigneeType3 = dj.byId("public_task_details_assignee_type_nosend_3"),
								publicTaskDetailsType3 = dj.byId("public_task_details_type_nosend_3"),
								isPublicChecked = (publicTaskDetailsType3) ? 
										publicTaskDetailsType3.get("checked") : false,
								assigneeTypeFields = d.byId("assigneeTypeFields");
							
							m.toggleFields(isPublicChecked, 
									["public_task_details_assignee_type_nosend_1", 
									 "public_task_details_assignee_type_nosend_2", 
									 "public_task_details_assignee_type_nosend_3", 
									 "public_task_details_assignee_type_nosend_4"]);
							//added the below block of code to modify the assignee type(Bank, User) radio buttons on toggling the Assignee radio button
							//fix for MPS-23593
							if(isPublicChecked)
							{
								var assigneeTypes = [
								                          {
								                        	  id : "public_task_details_assignee_type_nosend_1",
								                        	  description: "user_to_user"
								                          },
								                          {
								                        	  id : "public_task_details_assignee_type_nosend_2",
								                        	  description: "user_to_bank"
								                          },
								                          {
								                        	  id : "public_task_details_assignee_type_nosend_3",
								                        	  description: "counterparty"
								                          },
								                          {
								                        	  id : "public_task_details_assignee_type_nosend_4",
								                        	  description: "bank"
								                          }
							                        ];
								m.preDisplayAssigneeType = m.preDisplayAssigneeType || function(){ return true; };
								m.preDisplayAssigneeType(assigneeTypes);
							}	
							
							if(isPublicChecked) { 
								m.animate("fadeIn", assigneeTypeFields, function(){
									if (publicTaskAssigneeType2 && publicTaskAssigneeType2.get("checked")) {
										publicTaskAssigneeType2.set("checked", true);
										m.animate("fadeOut",  d.byId("notifyUserFields"),function(){},false,{duration: 20});
										m.animate("fadeOut", d.byId("notifyCounterpartyFields"),function(){},false,{duration: 20});
										m.animate("fadeIn", d.byId("notifyBankFields"));
									}
									else if (publicTaskAssigneeType1 && publicTaskAssigneeType1.get("checked")) {
										publicTaskAssigneeType1.set("checked", true);
										m.animate("fadeOut",  d.byId("notifyBankFields"),function(){},false,{duration: 20});
										m.animate("fadeOut", d.byId("notifyCounterpartyFields"),function(){},false,{duration: 20});
										m.animate("fadeIn", d.byId("notifyUserFields"));
									}
									else if (publicTaskAssigneeType3 && publicTaskAssigneeType3.get("checked")) {
										publicTaskAssigneeType3.set("checked", true);
										m.animate("fadeOut",  d.byId("notifyUserFields"),function(){},false,{duration: 20});
										m.animate("fadeOut",  d.byId("notifyBankFields"),function(){},false,{duration: 20});
										m.animate("fadeIn", d.byId("notifyCounterpartyFields"));
									}
									else{
										publicTaskAssigneeType1.set("checked", true);
										m.animate("fadeOut",  d.byId("notifyBankFields"),function(){},false,{duration: 20});
										m.animate("fadeOut", d.byId("notifyCounterpartyFields"),function(){},false,{duration: 20});
										m.animate("fadeIn", d.byId("notifyUserFields"));
									}
									//_toggleFieldsByPermissions();
									//_toggleAssigneeType();
								}, false, {duration: 20});
							} else {
								m.animate("fadeOut", assigneeTypeFields, function(){
									if (publicTaskAssigneeType1) {
										publicTaskAssigneeType1.set("checked", false);
									}
									if (publicTaskAssigneeType2) {
										publicTaskAssigneeType2.set("checked", false);
									}
									if (publicTaskAssigneeType3) {
										publicTaskAssigneeType3.set("checked", false);
									}
									_toggleAssigneeType();
								}, false, {duration: 20});
							}
						};
						
						// TODO: find a way to not duplicate this function
						_toggleAssigneeType = function() {
							//  summary:
						    //            Display the assignee type
							
							var isAssignee1Checked = dj.byId("public_task_details_assignee_type_nosend_1") ?
									dj.byId("public_task_details_assignee_type_nosend_1").get("checked") : false,
								isAssignee2Checked = dj.byId("public_task_details_assignee_type_nosend_2") ?
										dj.byId("public_task_details_assignee_type_nosend_2").get("checked") : false,
								isAssignee3Checked = dj.byId("public_task_details_assignee_type_nosend_3") ?
										dj.byId("public_task_details_assignee_type_nosend_3").get("checked") : false,
								isAssignee4Checked = dj.byId("public_task_details_assignee_type_nosend_4") ?
									dj.byId("public_task_details_assignee_type_nosend_4").get("checked") : false,
								notifyBankFields = d.byId("notifyBankFields"),
								notifyUserFields = d.byId("notifyUserFields"),
								notifyCounterpartyFields = d.byId("notifyCounterpartyFields"),
								bankAssigneeTasks = d.byId("bankAssigneeTasks");
						    
							m.toggleFields(isAssignee1Checked, 
									null, ["public_task_details_other_user_assignee_login_id_nosend"]);
							m.toggleFields(isAssignee2Checked, 
									null, ["public_task_details_bank_assignee_name_nosend"], true, true);
							m.toggleFields(isAssignee3Checked, null,
										["public_task_details_counterparty_assignee_name_nosend"], true, true);
							m.toggleFields(isAssignee4Checked, null, 
									["public_task_details_bank_other_user_assignee_login_id_nosend", 
									 "public_task_details_bank_other_user_assignee_email_nosend"], true, true);
							
							dj.byId("public_task_details_other_user_assignee_login_id_nosend").set("readonly", true);
							dj.byId("public_task_details_other_user_assignee_login_id_nosend").set("disabled", true);
							
							m.animate("fadeOut", [notifyBankFields, notifyUserFields, notifyCounterpartyFields], function(){
								if(isAssignee1Checked){
									m.animate("fadeIn", notifyUserFields);
								} else if (isAssignee2Checked){
									m.animate("fadeIn", notifyBankFields);
								} else if(isAssignee3Checked) {
									m.animate("fadeIn", notifyCounterpartyFields);
									var accessOpened = dj.byId("access_opened"),
									collaborationCounterparty = dj.byId("public_task_details_counterparty_assignee_name_nosend"),		
									productCode= dj.byId("product_code").get('value'),
									counterpartyName=null,
									counterpartyHiddenEmail = dj.byId("counterparty_email_id_hidden"),
									collaborationCounterpartyAbbvName = dj.byId("public_task_details_counterparty_assignee_abbv_name_nosend");
									if(productCode && productCode=="IP")
										{
											counterpartyName=dj.byId("seller_name") ? dj.byId("seller_name") : dj.byId("seller_abbv_name");
										}
									else if (productCode && productCode=="IN")
										{
											counterpartyName=dj.byId("buyer_name") ? dj.byId("buyer_name") : dj.byId("buyer_abbv_name");
										}
										if(accessOpened && counterpartyName)
										{
											if(counterpartyName.get('value')!=="")
											{
												if (accessOpened.get("value") === 'Y')
												{
													collaborationCounterparty.set('value',counterpartyName.get('value'));
													counterpartyHiddenEmail.set('value',dj.byId('transaction_counterparty_email').get('value'));
													collaborationCounterpartyAbbvName.set('value',dj.byId('ben_company_abbv_name').get('value'));
													//collaborationCounterpartyLookup.set('disabled',true);
												}
												else
												{
													collaborationCounterparty.set('value',"");
													collaborationCounterpartyAbbvName.set("value", "");
													m.dialog.show("ERROR", m.getLocalization("errorCounterpartyCollaborationNotEnabled"));
													m.animate("fadeOut", notifyCounterpartyFields);
												}
											}
											else
											{
												collaborationCounterparty.set('value',"");
												collaborationCounterpartyAbbvName.set("value", "");
												m.dialog.show("ERROR", m.getLocalization("errorSelectCounterpartyCollaboration"));
												m.animate("fadeOut", notifyCounterpartyFields);
											}
										}
								} else if(isAssignee4Checked) {
									m.animate("fadeIn", bankAssigneeTasks);
								}
								
								_getCollaborationBankName();
								_resetCollaborationFields();
							}, false, {duration: 20});
						};
						
						_assigneeHandles = [];
						_assigneeHandles.push(m.connect("public_task_details_type_nosend_2", "onClick", 
								_toggleAssigneeRadioButtons));
						_assigneeHandles.push(m.connect("public_task_details_type_nosend_3", "onClick",
								_toggleAssigneeRadioButtons));
						_assigneeHandles.push(m.connect("public_task_details_assignee_type_nosend_1", "onClick",
								_checkEntityForCollaboration));
						_assigneeHandles.push(m.connect("public_task_details_assignee_type_nosend_1", "onClick", 
								_toggleAssigneeType));
						_assigneeHandles.push(m.connect("public_task_details_assignee_type_nosend_2", "onClick", 
								_toggleAssigneeType));
						_assigneeHandles.push(m.connect("public_task_details_assignee_type_nosend_3", "onClick", 
								_toggleAssigneeType));
						_assigneeHandles.push(m.connect("public_task_details_assignee_type_nosend_4", "onClick", 
								_toggleAssigneeType));
						
						if(response.type[1] === "02")
						{
							dj.byId("public_task_details_type_nosend_2").onClick();
						}else{
							dj.byId("public_task_details_type_nosend_3").onClick();
						}
					}
				}
		    });
		},

		showCollaborationTaskDetails : function() {
			m.animate("fadeIn", d.byId("collaboration-more-tasks"), function(){
				m.animate("fadeOut", d.byId("show-tasks-details-link"), false, {duration: 20});
			}, false, {duration: 20});
				}
	});
})(dojo, dijit, misys);

}

if(!dojo._hasResource["dijit.MenuBar"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuBar"] = true;
dojo.provide("dijit.MenuBar");



dojo.declare("dijit.MenuBar", dijit._MenuBase, {
	// summary:
	//		A menu bar, listing menu choices horizontally, like the "File" menu in most desktop applications

	templateString: dojo.cache("dijit", "templates/MenuBar.html", "<div class=\"dijitMenuBar dijitMenuPassive\" dojoAttachPoint=\"containerNode\"  role=\"menubar\" tabIndex=\"${tabIndex}\" dojoAttachEvent=\"onkeypress: _onKeyPress\"></div>\n"),

	baseClass: "dijitMenuBar",

	// _isMenuBar: [protected] Boolean
	//		This is a MenuBar widget, not a (vertical) Menu widget.
	_isMenuBar: true,

	postCreate: function(){
		var k = dojo.keys, l = this.isLeftToRight();
		this.connectKeyNavHandlers(
			l ? [k.LEFT_ARROW] : [k.RIGHT_ARROW],
			l ? [k.RIGHT_ARROW] : [k.LEFT_ARROW]
		);

		// parameter to dijit.popup.open() about where to put popup (relative to this.domNode)
		this._orient = this.isLeftToRight() ? {BL: 'TL'} : {BR: 'TR'};
	},

	focusChild: function(item){
		// overload focusChild so that whenever the focus is moved to a new item,
		// check the previous focused whether it has its popup open, if so, after
		// focusing the new item, open its submenu immediately
		var prev_item = this.focusedChild,
			showpopup = prev_item && prev_item.popup && prev_item.popup.isShowingNow;
		this.inherited(arguments);
		if(showpopup && item.popup && !item.disabled){
			this._openPopup();		// TODO: on down arrow, _openPopup() is called here and in onItemClick()
		}
	},

	_onKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handle keyboard based menu navigation.
		// tags:
		//		protected

		if(evt.ctrlKey || evt.altKey){ return; }

		switch(evt.charOrCode){
			case dojo.keys.DOWN_ARROW:
				this._moveToPopup(evt);
				dojo.stopEvent(evt);
		}
	},

	onItemClick: function(/*dijit._Widget*/ item, /*Event*/ evt){
		// summary:
		//		Handle clicks on an item. Cancels a dropdown if already open.
		// tags:
		//		private
		if(item.popup && item.popup.isShowingNow){
			item.popup.onCancel();
		}else{
			this.inherited(arguments);
		}
	}
});

}

if(!dojo._hasResource["dijit.MenuBarItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.MenuBarItem"] = true;
dojo.provide("dijit.MenuBarItem");



dojo.declare("dijit._MenuBarItemMixin", null, {
	templateString: dojo.cache("dijit", "templates/MenuBarItem.html", "<div class=\"dijitReset dijitInline dijitMenuItem dijitMenuItemLabel\" dojoAttachPoint=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\"\n\t\tdojoAttachEvent=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<span dojoAttachPoint=\"containerNode\"></span>\n</div>\n"),

	// overriding attributeMap because we don't have icon
	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		label: { node: "containerNode", type: "innerHTML" }
	})
});

dojo.declare("dijit.MenuBarItem", [dijit.MenuItem, dijit._MenuBarItemMixin], {
	// summary:
	//		Item in a MenuBar that's clickable, and doesn't spawn a submenu when pressed (or hovered)

});

}

if(!dojo._hasResource["dijit.PopupMenuBarItem"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.PopupMenuBarItem"] = true;
dojo.provide("dijit.PopupMenuBarItem");




dojo.declare("dijit.PopupMenuBarItem", [dijit.PopupMenuItem, dijit._MenuBarItemMixin], {
	// summary:
	//		Item in a MenuBar like "File" or "Edit", that spawns a submenu when pressed (or hovered)
});

}

if(!dojo._hasResource["misys.widget.BookmarkMenu"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.widget.BookmarkMenu"] = true;
dojo.provide("misys.widget.BookmarkMenu");


(function(/*Dojo*/d, /*Dijit*/dj, /*Misys*/m) 
{
	function _saveBookmarkAction(/*String*/ link, /*String*/ actionValue, /*String*/ screenValue)
	{  
		//      summary:
	    //            Saves a screen bookmark
	    //      tags:
	    //            protected
		var text = '';
		var xmlString =['<?xml version=\"1.0\" encoding=\"UTF-8\"?><bookmark>'];
		var nodeBookmark = dijit.byId('sendBookmark');
		dojo.forEach(nodeBookmark.getDescendants(),
				function(field){
					xmlString.push("<", field.get("name"), ">",
									field.get("value"),
									"</", field.get("name"), ">");
				}
		);
		if(dijit.byId("bookmarkName"))
		{
			xmlString.push('<bookmark_name>', dijit.byId("bookmarkName").get('value'), '</bookmark_name>'); 
		}
		xmlString.push('<bookmark_url>',"**" , '</bookmark_url>');
		xmlString.push('<bookmark_source>', "**", '</bookmark_source>');
		xmlString.push('<bookmark_id>', link, '</bookmark_id>');
		xmlString.push('<action>', link, '</action></bookmark>');
		console.debug('[Bookmarks] Adding Bookmark - Request XML');
		console.debug('[Bookmarks] ' + xmlString.join(''));
		var deferred = misys.xhrPost( {
			url : misys.getServletURL('/screen/BookmarkMenuScreen'),
			handleAs: "json",
			content: {
				formContent: xmlString.join(""),
				bookmarkAction: "SAVE",
				currentActionCode: actionValue,
				currentScreen: screenValue
			},
			load : function(response){
				text = response.content[0];
			}
		});
		deferred.then(function(){
			//console.debug('[Bookmarks] Adding Bookmrk - Response = ' + text);
			var favorites = dojo.byId('favorites');
			if(!dijit.byId('sendBookmark')){
			 dojo.parser.parse(dojo.byId('favorites'));
			}
			misys.animate("wipeOut", favorites, function(){
				dijit.byId('sendBookmark').destroyRecursive(true);
				//Destroy all previous widgets and containers
				var widgets = dj.findWidgets(dojo.byId("favorites"));
				dojo.forEach(widgets, function(w) {
				    w.destroyRecursive(false);
				});
				//Destroy all the Children
				dojo.empty("favorites");
				// substring is used to avoid duplicated favorites node
				favorites.innerHTML = text.substring(20, text.length - 6);
				dojo.parser.parse(dojo.byId('favorites'));
				misys.animate("wipeIn",favorites);
			});
		});
		return deferred;
	}
	function _deleteBookmarkAction(/*String*/ id, /*String*/ action, /*String*/ actionValue, /*String*/ screenValue)
	{
	    //  summary:
	    //            Deletes a bookmark
	    //      tags:
	    //            protected
		var xmlString = ['<?xml version=\"1.0\" encoding=\"UTF-8\"?><bookmark>'];
		var nodeBookmark = dijit.byId('sendBookmark');
		dojo.forEach(nodeBookmark.getDescendants(),
				function(field){
					if(field.id !== 'bookmark_'+id && field.id !== 'bookmark_name_'+id && field.id !== 'bookmark_source_'+id && field.id !== 'bookmark_url_'+id) {
						xmlString.push("<", field.get("name"), ">",
								field.get("value"),
								"</", field.get("name"), ">");
					}
				}
		);
		xmlString.push('<action>', action, '</action></bookmark>');
		console.debug('[Bookmarks] Deleting Bookmark - Request XML');
		console.debug('[Bookmarks] ' + xmlString.join(''));
		var text = '';
		var deferred = misys.xhrPost( {
			url : misys.getServletURL('/screen/BookmarkMenuScreen'),
			handleAs: "json",
			content: {
				formContent: xmlString.join(""),
				bookmarkAction: "DELETE",
				currentActionCode: actionValue,
				currentScreen: screenValue
			},
			load : function(response){
				text = response.content[0];
			}
		});
		deferred.then(function(){
			console.debug('[Bookmarks] Deleting Bookmark - Response = ' + text);
			var favorites = dojo.byId('favorites');
			if(!dijit.byId('sendBookmark')){
				dojo.parser.parse(dojo.byId('favorites'));
			}
			misys.animate("wipeOut", favorites, function(){
				// destroy java script object that will be changed by the innerHTML update
				dijit.byId('sendBookmark').destroyRecursive(true);
				//Destroy all previous widgets and containers
				var widgets = dj.findWidgets(dojo.byId("favorites"));
				dojo.forEach(widgets, function(w) {
				    w.destroyRecursive(false);
				});
				//Destroy all the Children
				dojo.empty("favorites");
				// substring is used to avoid duplicated favorites node
				favorites.innerHTML = text.substring(20, text.length - 6);
				dojo.parser.parse(dojo.byId('favorites'));
				// parse the new html block to register new java script objects.
				misys.animate("wipeIn", favorites);
			});
		});
		return deferred;
	}

	d.mixin(m,{
		doBookmarkAction : function( /*String*/ type, /*String*/ action,  /*String*/ id,  /*String*/ actionValue,  /*String*/ screenValue)
		{
			//		      summary:
			//		            Save or Deletes a bookmark, and ensures everything is parsed and loaded first.
			//		      tags:
			//		            protected
			if(!dijit.byId('sendBookmark'))
			{
				dojo.parser.parse('favorites');
			}
			if (type === 'SAVE') 
			{
				_saveBookmarkAction(action, actionValue, screenValue);
			} 
			else
			{ 
				_deleteBookmarkAction(id, action, actionValue, screenValue);
			}
		}
	});
})(dojo, dijit, misys);

}

if(!dojo._hasResource["dojo.DeferredList"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dojo.DeferredList"] = true;
dojo.provide("dojo.DeferredList");


dojo.DeferredList = function(/*Array*/ list, /*Boolean?*/ fireOnOneCallback, /*Boolean?*/ fireOnOneErrback, /*Boolean?*/ consumeErrors, /*Function?*/ canceller){
	// summary:
	//		Provides event handling for a group of Deferred objects.
	// description:
	//		DeferredList takes an array of existing deferreds and returns a new deferred of its own
	//		this new deferred will typically have its callback fired when all of the deferreds in
	//		the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	//		fireOnOneErrback, will fire before all the deferreds as appropriate
	//
	//	list:
	//		The list of deferreds to be synchronizied with this DeferredList
	//	fireOnOneCallback:
	//		Will cause the DeferredLists callback to be fired as soon as any
	//		of the deferreds in its list have been fired instead of waiting until
	//		the entire list has finished
	//	fireonOneErrback:
	//		Will cause the errback to fire upon any of the deferreds errback
	//	canceller:
	//		A deferred canceller function, see dojo.Deferred
	var resultList = [];
	dojo.Deferred.call(this);
	var self = this;
	if(list.length === 0 && !fireOnOneCallback){
		this.resolve([0, []]);
	}
	var finished = 0;
	dojo.forEach(list, function(item, i){
		item.then(function(result){
			if(fireOnOneCallback){
				self.resolve([i, result]);
			}else{
				addResult(true, result);
			}
		},function(error){
			if(fireOnOneErrback){
				self.reject(error);
			}else{
				addResult(false, error);
			}
			if(consumeErrors){
				return null;
			}
			throw error;
		});
		function addResult(succeeded, result){
			resultList[i] = [succeeded, result];
			finished++;
			if(finished === list.length){
				self.resolve(resultList);
			}
			
		}
	});
};
dojo.DeferredList.prototype = new dojo.Deferred();

dojo.DeferredList.prototype.gatherResults= function(deferredList){
	// summary:
	//	Gathers the results of the deferreds for packaging
	//	as the parameters to the Deferred Lists' callback

	var d = new dojo.DeferredList(deferredList, false, true, false);
	d.addCallback(function(results){
		var ret = [];
		dojo.forEach(results, function(result){
			ret.push(result[1]);
		});
		return ret;
	});
	return d;
};

}

if(!dojo._hasResource["dijit.tree.TreeStoreModel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree.TreeStoreModel"] = true;
dojo.provide("dijit.tree.TreeStoreModel");


dojo.declare(
		"dijit.tree.TreeStoreModel",
		null,
	{
		// summary:
		//		Implements dijit.Tree.model connecting to a store with a single
		//		root item.  Any methods passed into the constructor will override
		//		the ones defined here.

		// store: dojo.data.Store
		//		Underlying store
		store: null,

		// childrenAttrs: String[]
		//		One or more attribute names (attributes in the dojo.data item) that specify that item's children
		childrenAttrs: ["children"],

		// newItemIdAttr: String
		//		Name of attribute in the Object passed to newItem() that specifies the id.
		//
		//		If newItemIdAttr is set then it's used when newItem() is called to see if an
		//		item with the same id already exists, and if so just links to the old item
		//		(so that the old item ends up with two parents).
		//
		//		Setting this to null or "" will make every drop create a new item.
		newItemIdAttr: "id",

		// labelAttr: String
		//		If specified, get label for tree node from this attribute, rather
		//		than by calling store.getLabel()
		labelAttr: "",

	 	// root: [readonly] dojo.data.Item
		//		Pointer to the root item (read only, not a parameter)
		root: null,

		// query: anything
		//		Specifies datastore query to return the root item for the tree.
		//		Must only return a single item.   Alternately can just pass in pointer
		//		to root item.
		// example:
		//	|	{id:'ROOT'}
		query: null,

		// deferItemLoadingUntilExpand: Boolean
		//		Setting this to true will cause the TreeStoreModel to defer calling loadItem on nodes
		// 		until they are expanded. This allows for lazying loading where only one
		//		loadItem (and generally one network call, consequently) per expansion
		// 		(rather than one for each child).
		// 		This relies on partial loading of the children items; each children item of a
		// 		fully loaded item should contain the label and info about having children.
		deferItemLoadingUntilExpand: false,

		constructor: function(/* Object */ args){
			// summary:
			//		Passed the arguments listed above (store, etc)
			// tags:
			//		private

			dojo.mixin(this, args);

			this.connects = [];

			var store = this.store;
			if(!store.getFeatures()['dojo.data.api.Identity']){
				throw new Error("dijit.Tree: store must support dojo.data.Identity");
			}

			// if the store supports Notification, subscribe to the notification events
			if(store.getFeatures()['dojo.data.api.Notification']){
				this.connects = this.connects.concat([
					dojo.connect(store, "onNew", this, "onNewItem"),
					dojo.connect(store, "onDelete", this, "onDeleteItem"),
					dojo.connect(store, "onSet", this, "onSetItem")
				]);
			}
		},

		destroy: function(){
			dojo.forEach(this.connects, dojo.disconnect);
			// TODO: should cancel any in-progress processing of getRoot(), getChildren()
		},

		// =======================================================================
		// Methods for traversing hierarchy

		getRoot: function(onItem, onError){
			// summary:
			//		Calls onItem with the root item for the tree, possibly a fabricated item.
			//		Calls onError on error.
			if(this.root){
				onItem(this.root);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: dojo.hitch(this, function(items){
						if(items.length != 1){
							throw new Error(this.declaredClass + ": query " + dojo.toJson(this.query) + " returned " + items.length +
							 	" items, but must return exactly one item");
						}
						this.root = items[0];
						onItem(this.root);
					}),
					onError: onError
				});
			}
		},

		mayHaveChildren: function(/*dojo.data.Item*/ item){
			// summary:
			//		Tells if an item has or may have children.  Implementing logic here
			//		avoids showing +/- expando icon for nodes that we know don't have children.
			//		(For efficiency reasons we may not want to check if an element actually
			//		has children until user clicks the expando node)
			return dojo.some(this.childrenAttrs, function(attr){
				return this.store.hasAttribute(item, attr);
			}, this);
		},

		getChildren: function(/*dojo.data.Item*/ parentItem, /*function(items)*/ onComplete, /*function*/ onError){
			// summary:
			// 		Calls onComplete() with array of child items of given parent item, all loaded.

			var store = this.store;
			if(!store.isItemLoaded(parentItem)){
				// The parent is not loaded yet, we must be in deferItemLoadingUntilExpand
				// mode, so we will load it and just return the children (without loading each
				// child item)
				var getChildren = dojo.hitch(this, arguments.callee);
				store.loadItem({
					item: parentItem,
					onItem: function(parentItem){
						getChildren(parentItem, onComplete, onError);
					},
					onError: onError
				});
				return;
			}
			// get children of specified item
			var childItems = [];
			for(var i=0; i<this.childrenAttrs.length; i++){
				var vals = store.getValues(parentItem, this.childrenAttrs[i]);
				childItems = childItems.concat(vals);
			}

			// count how many items need to be loaded
			var _waitCount = 0;
			if(!this.deferItemLoadingUntilExpand){
				dojo.forEach(childItems, function(item){ if(!store.isItemLoaded(item)){ _waitCount++; } });
			}

			if(_waitCount == 0){
				// all items are already loaded (or we aren't loading them).  proceed...
				onComplete(childItems);
			}else{
				// still waiting for some or all of the items to load
				dojo.forEach(childItems, function(item, idx){
					if(!store.isItemLoaded(item)){
						store.loadItem({
							item: item,
							onItem: function(item){
								childItems[idx] = item;
								if(--_waitCount == 0){
									// all nodes have been loaded, send them to the tree
									onComplete(childItems);
								}
							},
							onError: onError
						});
					}
				});
			}
		},

		// =======================================================================
		// Inspecting items

		isItem: function(/* anything */ something){
			return this.store.isItem(something);	// Boolean
		},

		fetchItemByIdentity: function(/* object */ keywordArgs){
			this.store.fetchItemByIdentity(keywordArgs);
		},

		getIdentity: function(/* item */ item){
			return this.store.getIdentity(item);	// Object
		},

		getLabel: function(/*dojo.data.Item*/ item){
			// summary:
			//		Get the label for an item
			if(this.labelAttr){
				return this.store.getValue(item,this.labelAttr);	// String
			}else{
				return this.store.getLabel(item);	// String
			}
		},

		// =======================================================================
		// Write interface

		newItem: function(/* dojo.dnd.Item */ args, /*Item*/ parent, /*int?*/ insertIndex){
			// summary:
			//		Creates a new item.   See `dojo.data.api.Write` for details on args.
			//		Used in drag & drop when item from external source dropped onto tree.
			// description:
			//		Developers will need to override this method if new items get added
			//		to parents with multiple children attributes, in order to define which
			//		children attribute points to the new item.

			var pInfo = {parent: parent, attribute: this.childrenAttrs[0]}, LnewItem;

			if(this.newItemIdAttr && args[this.newItemIdAttr]){
				// Maybe there's already a corresponding item in the store; if so, reuse it.
				this.fetchItemByIdentity({identity: args[this.newItemIdAttr], scope: this, onItem: function(item){
					if(item){
						// There's already a matching item in store, use it
						this.pasteItem(item, null, parent, true, insertIndex);
					}else{
						// Create new item in the tree, based on the drag source.
						LnewItem=this.store.newItem(args, pInfo);
						if (LnewItem && (insertIndex!=undefined)){
							// Move new item to desired position
							this.pasteItem(LnewItem, parent, parent, false, insertIndex);
						}
					}
				}});
			}else{
				// [as far as we know] there is no id so we must assume this is a new item
				LnewItem=this.store.newItem(args, pInfo);
				if (LnewItem && (insertIndex!=undefined)){
					// Move new item to desired position
					this.pasteItem(LnewItem, parent, parent, false, insertIndex);
				}
			}
		},

		pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
			// summary:
			//		Move or copy an item from one parent item to another.
			//		Used in drag & drop
			var store = this.store,
				parentAttr = this.childrenAttrs[0];	// name of "children" attr in parent item

			// remove child from source item, and record the attribute that child occurred in
			if(oldParentItem){
				dojo.forEach(this.childrenAttrs, function(attr){
					if(store.containsValue(oldParentItem, attr, childItem)){
						if(!bCopy){
							var values = dojo.filter(store.getValues(oldParentItem, attr), function(x){
								return x != childItem;
							});
							store.setValues(oldParentItem, attr, values);
						}
						parentAttr = attr;
					}
				});
			}

			// modify target item's children attribute to include this item
			if(newParentItem){
				if(typeof insertIndex == "number"){
					// call slice() to avoid modifying the original array, confusing the data store
					var childItems = store.getValues(newParentItem, parentAttr).slice();
					childItems.splice(insertIndex, 0, childItem);
					store.setValues(newParentItem, parentAttr, childItems);
				}else{
					store.setValues(newParentItem, parentAttr,
						store.getValues(newParentItem, parentAttr).concat(childItem));
				}
			}
		},

		// =======================================================================
		// Callbacks

		onChange: function(/*dojo.data.Item*/ item){
			// summary:
			//		Callback whenever an item has changed, so that Tree
			//		can update the label, icon, etc.   Note that changes
			//		to an item's children or parent(s) will trigger an
			//		onChildrenChange() so you can ignore those changes here.
			// tags:
			//		callback
		},

		onChildrenChange: function(/*dojo.data.Item*/ parent, /*dojo.data.Item[]*/ newChildrenList){
			// summary:
			//		Callback to do notifications about new, updated, or deleted items.
			// tags:
			//		callback
		},

		onDelete: function(/*dojo.data.Item*/ parent, /*dojo.data.Item[]*/ newChildrenList){
			// summary:
			//		Callback when an item has been deleted.
			// description:
			//		Note that there will also be an onChildrenChange() callback for the parent
			//		of this item.
			// tags:
			//		callback
		},

		// =======================================================================
		// Events from data store

		onNewItem: function(/* dojo.data.Item */ item, /* Object */ parentInfo){
			// summary:
			//		Handler for when new items appear in the store, either from a drop operation
			//		or some other way.   Updates the tree view (if necessary).
			// description:
			//		If the new item is a child of an existing item,
			//		calls onChildrenChange() with the new list of children
			//		for that existing item.
			//
			// tags:
			//		extension

			// We only care about the new item if it has a parent that corresponds to a TreeNode
			// we are currently displaying
			if(!parentInfo){
				return;
			}

			// Call onChildrenChange() on parent (ie, existing) item with new list of children
			// In the common case, the new list of children is simply parentInfo.newValue or
			// [ parentInfo.newValue ], although if items in the store has multiple
			// child attributes (see `childrenAttr`), then it's a superset of parentInfo.newValue,
			// so call getChildren() to be sure to get right answer.
			this.getChildren(parentInfo.item, dojo.hitch(this, function(children){
				this.onChildrenChange(parentInfo.item, children);
			}));
		},

		onDeleteItem: function(/*Object*/ item){
			// summary:
			//		Handler for delete notifications from underlying store
			this.onDelete(item);
		},

		onSetItem: function(/* item */ item,
						/* attribute-name-string */ attribute,
						/* object | array */ oldValue,
						/* object | array */ newValue){
			// summary:
			//		Updates the tree view according to changes in the data store.
			// description:
			//		Handles updates to an item's children by calling onChildrenChange(), and
			//		other updates to an item by calling onChange().
			//
			//		See `onNewItem` for more details on handling updates to an item's children.
			// tags:
			//		extension

			if(dojo.indexOf(this.childrenAttrs, attribute) != -1){
				// item's children list changed
				this.getChildren(item, dojo.hitch(this, function(children){
					// See comments in onNewItem() about calling getChildren()
					this.onChildrenChange(item, children);
				}));
			}else{
				// item's label/icon/etc. changed.
				this.onChange(item);
			}
		}
	});

}

if(!dojo._hasResource["dijit.tree.ForestStoreModel"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree.ForestStoreModel"] = true;
dojo.provide("dijit.tree.ForestStoreModel");



dojo.declare("dijit.tree.ForestStoreModel", dijit.tree.TreeStoreModel, {
	// summary:
	//		Interface between a dijit.Tree and a dojo.data store that doesn't have a root item,
	//		a.k.a. a store that has multiple "top level" items.
	//
	// description
	//		Use this class to wrap a dojo.data store, making all the items matching the specified query
	//		appear as children of a fabricated "root item".  If no query is specified then all the
	//		items returned by fetch() on the underlying store become children of the root item.
	//		This class allows dijit.Tree to assume a single root item, even if the store doesn't have one.
	//
	//		When using this class the developer must override a number of methods according to their app and
	//		data, including:
	//			- onNewRootItem
	//			- onAddToRoot
	//			- onLeaveRoot
	//			- onNewItem
	//			- onSetItem

	// Parameters to constructor

	// rootId: String
	//		ID of fabricated root item
	rootId: "$root$",

	// rootLabel: String
	//		Label of fabricated root item
	rootLabel: "ROOT",

	// query: String
	//		Specifies the set of children of the root item.
	// example:
	//	|	{type:'continent'}
	query: null,

	// End of parameters to constructor

	constructor: function(params){
		// summary:
		//		Sets up variables, etc.
		// tags:
		//		private

		// Make dummy root item
		this.root = {
			store: this,
			root: true,
			id: params.rootId,
			label: params.rootLabel,
			children: params.rootChildren	// optional param
		};
	},

	// =======================================================================
	// Methods for traversing hierarchy

	mayHaveChildren: function(/*dojo.data.Item*/ item){
		// summary:
		//		Tells if an item has or may have children.  Implementing logic here
		//		avoids showing +/- expando icon for nodes that we know don't have children.
		//		(For efficiency reasons we may not want to check if an element actually
		//		has children until user clicks the expando node)
		// tags:
		//		extension
		return item === this.root || this.inherited(arguments);
	},

	getChildren: function(/*dojo.data.Item*/ parentItem, /*function(items)*/ callback, /*function*/ onError){
		// summary:
		// 		Calls onComplete() with array of child items of given parent item, all loaded.
		if(parentItem === this.root){
			if(this.root.children){
				// already loaded, just return
				callback(this.root.children);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: dojo.hitch(this, function(items){
						this.root.children = items;
						callback(items);
					}),
					onError: onError
				});
			}
		}else{
			this.inherited(arguments);
		}
	},

	// =======================================================================
	// Inspecting items

	isItem: function(/* anything */ something){
		return (something === this.root) ? true : this.inherited(arguments);
	},

	fetchItemByIdentity: function(/* object */ keywordArgs){
		if(keywordArgs.identity == this.root.id){
			var scope = keywordArgs.scope?keywordArgs.scope:dojo.global;
			if(keywordArgs.onItem){
				keywordArgs.onItem.call(scope, this.root);
			}
		}else{
			this.inherited(arguments);
		}
	},

	getIdentity: function(/* item */ item){
		return (item === this.root) ? this.root.id : this.inherited(arguments);
	},

	getLabel: function(/* item */ item){
		return	(item === this.root) ? this.root.label : this.inherited(arguments);
	},

	// =======================================================================
	// Write interface

	newItem: function(/* dojo.dnd.Item */ args, /*Item*/ parent, /*int?*/ insertIndex){
		// summary:
		//		Creates a new item.   See dojo.data.api.Write for details on args.
		//		Used in drag & drop when item from external source dropped onto tree.
		if(parent === this.root){
			this.onNewRootItem(args);
			return this.store.newItem(args);
		}else{
			return this.inherited(arguments);
		}
	},

	onNewRootItem: function(args){
		// summary:
		//		User can override this method to modify a new element that's being
		//		added to the root of the tree, for example to add a flag like root=true
	},

	pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
		// summary:
		//		Move or copy an item from one parent item to another.
		//		Used in drag & drop
		if(oldParentItem === this.root){
			if(!bCopy){
				// It's onLeaveRoot()'s responsibility to modify the item so it no longer matches
				// this.query... thus triggering an onChildrenChange() event to notify the Tree
				// that this element is no longer a child of the root node
				this.onLeaveRoot(childItem);
			}
		}
		dijit.tree.TreeStoreModel.prototype.pasteItem.call(this, childItem,
			oldParentItem === this.root ? null : oldParentItem,
			newParentItem === this.root ? null : newParentItem,
			bCopy,
			insertIndex
		);
		if(newParentItem === this.root){
			// It's onAddToRoot()'s responsibility to modify the item so it matches
			// this.query... thus triggering an onChildrenChange() event to notify the Tree
			// that this element is now a child of the root node
			this.onAddToRoot(childItem);
		}
	},

	// =======================================================================
	// Handling for top level children

	onAddToRoot: function(/* item */ item){
		// summary:
		//		Called when item added to root of tree; user must override this method
		//		to modify the item so that it matches the query for top level items
		// example:
		//	|	store.setValue(item, "root", true);
		// tags:
		//		extension
		console.log(this, ": item ", item, " added to root");
	},

	onLeaveRoot: function(/* item */ item){
		// summary:
		//		Called when item removed from root of tree; user must override this method
		//		to modify the item so it doesn't match the query for top level items
		// example:
		// 	|	store.unsetAttribute(item, "root");
		// tags:
		//		extension
		console.log(this, ": item ", item, " removed from root");
	},

	// =======================================================================
	// Events from data store

	_requeryTop: function(){
		// reruns the query for the children of the root node,
		// sending out an onSet notification if those children have changed
		var oldChildren = this.root.children || [];
		this.store.fetch({
			query: this.query,
			onComplete: dojo.hitch(this, function(newChildren){
				this.root.children = newChildren;

				// If the list of children or the order of children has changed...
				if(oldChildren.length != newChildren.length ||
					dojo.some(oldChildren, function(item, idx){ return newChildren[idx] != item;})){
					this.onChildrenChange(this.root, newChildren);
				}
			})
		});
	},

	onNewItem: function(/* dojo.data.Item */ item, /* Object */ parentInfo){
		// summary:
		//		Handler for when new items appear in the store.  Developers should override this
		//		method to be more efficient based on their app/data.
		// description:
		//		Note that the default implementation requeries the top level items every time
		//		a new item is created, since any new item could be a top level item (even in
		//		addition to being a child of another item, since items can have multiple parents).
		//
		//		If developers can detect which items are possible top level items (based on the item and the
		//		parentInfo parameters), they should override this method to only call _requeryTop() for top
		//		level items.  Often all top level items have parentInfo==null, but
		//		that will depend on which store you use and what your data is like.
		// tags:
		//		extension
		this._requeryTop();

		this.inherited(arguments);
	},

	onDeleteItem: function(/*Object*/ item){
		// summary:
		//		Handler for delete notifications from underlying store

		// check if this was a child of root, and if so send notification that root's children
		// have changed
		if(dojo.indexOf(this.root.children, item) != -1){
			this._requeryTop();
		}

		this.inherited(arguments);
	},

	onSetItem: function(/* item */ item,
					/* attribute-name-string */ attribute,
					/* object | array */ oldValue,
					/* object | array */ newValue){
		// summary:
		//		Updates the tree view according to changes to an item in the data store.
		//		Developers should override this method to be more efficient based on their app/data.
		// description:
		//		Handles updates to an item's children by calling onChildrenChange(), and
		//		other updates to an item by calling onChange().
		//
		//		Also, any change to any item re-executes the query for the tree's top-level items,
		//		since this modified item may have started/stopped matching the query for top level items.
		//
		//		If possible, developers should override this function to only call _requeryTop() when
		//		the change to the item has caused it to stop/start being a top level item in the tree.
		// tags:
		//		extension

		this._requeryTop();
		this.inherited(arguments);
	}

});

}

if(!dojo._hasResource["dijit.tree._dndContainer"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree._dndContainer"] = true;
dojo.provide("dijit.tree._dndContainer");




dojo.getObject("tree", true, dojo);

dijit.tree._compareNodes = function(n1, n2){
	if(n1 === n2){
		return 0;
	}
	
	if('sourceIndex' in document.documentElement){ //IE
		//TODO: does not yet work if n1 and/or n2 is a text node
		return n1.sourceIndex - n2.sourceIndex;
	}else if('compareDocumentPosition' in document.documentElement){ //FF, Opera
		return n1.compareDocumentPosition(n2) & 2 ? 1: -1;
	}else if(document.createRange){ //Webkit
		var r1 = doc.createRange();
		r1.setStartBefore(n1);

		var r2 = doc.createRange();
		r2.setStartBefore(n2);

		return r1.compareBoundaryPoints(r1.END_TO_END, r2);
	}else{
		throw Error("dijit.tree._compareNodes don't know how to compare two different nodes in this browser");
	}
};

dojo.declare("dijit.tree._dndContainer",
	null,
	{

		// summary:
		//		This is a base class for `dijit.tree._dndSelector`, and isn't meant to be used directly.
		//		It's modeled after `dojo.dnd.Container`.
		// tags:
		//		protected

		/*=====
		// current: DomNode
		//		The currently hovered TreeNode.rowNode (which is the DOM node
		//		associated w/a given node in the tree, excluding it's descendants)
		current: null,
		=====*/

		constructor: function(tree, params){
			// summary:
			//		A constructor of the Container
			// tree: Node
			//		Node or node's id to build the container on
			// params: dijit.tree.__SourceArgs
			//		A dict of parameters, which gets mixed into the object
			// tags:
			//		private
			this.tree = tree;
			this.node = tree.domNode;	// TODO: rename; it's not a TreeNode but the whole Tree
			dojo.mixin(this, params);

			// class-specific variables
			this.map = {};
			this.current = null;	// current TreeNode's DOM node

			// states
			this.containerState = "";
			dojo.addClass(this.node, "dojoDndContainer");

			// set up events
			this.events = [
				// container level events
				dojo.connect(this.node, "onmouseenter", this, "onOverEvent"),
				dojo.connect(this.node, "onmouseleave",	this, "onOutEvent"),

				// switching between TreeNodes
				dojo.connect(this.tree, "_onNodeMouseEnter", this, "onMouseOver"),
				dojo.connect(this.tree, "_onNodeMouseLeave", this, "onMouseOut"),

				// cancel text selection and text dragging
				dojo.connect(this.node, "ondragstart", dojo, "stopEvent"),
				dojo.connect(this.node, "onselectstart", dojo, "stopEvent")
			];
		},

		getItem: function(/*String*/ key){
			// summary:
			//		Returns the dojo.dnd.Item (representing a dragged node) by it's key (id).
			//		Called by dojo.dnd.Source.checkAcceptance().
			// tags:
			//		protected

			var widget = this.selection[key],
				ret = {
					data: widget,
					type: ["treeNode"]
				};

			return ret;	// dojo.dnd.Item
		},

		destroy: function(){
			// summary:
			//		Prepares this object to be garbage-collected

			dojo.forEach(this.events, dojo.disconnect);
			// this.clearItems();
			this.node = this.parent = null;
		},

		// mouse events
		onMouseOver: function(/*TreeNode*/ widget, /*Event*/ evt){
			// summary:
			//		Called when mouse is moved over a TreeNode
			// tags:
			//		protected
			this.current = widget;
		},

		onMouseOut: function(/*TreeNode*/ widget, /*Event*/ evt){
			// summary:
			//		Called when mouse is moved away from a TreeNode
			// tags:
			//		protected
			this.current = null;
		},

		_changeState: function(type, newState){
			// summary:
			//		Changes a named state to new state value
			// type: String
			//		A name of the state to change
			// newState: String
			//		new state
			var prefix = "dojoDnd" + type;
			var state = type.toLowerCase() + "State";
			//dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
			dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
			this[state] = newState;
		},

		_addItemClass: function(node, type){
			// summary:
			//		Adds a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			dojo.addClass(node, "dojoDndItem" + type);
		},

		_removeItemClass: function(node, type){
			// summary:
			//		Removes a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			dojo.removeClass(node, "dojoDndItem" + type);
		},

		onOverEvent: function(){
			// summary:
			//		This function is called once, when mouse is over our container
			// tags:
			//		protected
			this._changeState("Container", "Over");
		},

		onOutEvent: function(){
			// summary:
			//		This function is called once, when mouse is out of our container
			// tags:
			//		protected
			this._changeState("Container", "");
		}
});

}

if(!dojo._hasResource["dijit.tree._dndSelector"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.tree._dndSelector"] = true;
dojo.provide("dijit.tree._dndSelector");




dojo.declare("dijit.tree._dndSelector",
	dijit.tree._dndContainer,
	{
		// summary:
		//		This is a base class for `dijit.tree.dndSource` , and isn't meant to be used directly.
		//		It's based on `dojo.dnd.Selector`.
		// tags:
		//		protected

		/*=====
		// selection: Hash<String, DomNode>
		//		(id, DomNode) map for every TreeNode that's currently selected.
		//		The DOMNode is the TreeNode.rowNode.
		selection: {},
		=====*/

		constructor: function(tree, params){
			// summary:
			//		Initialization
			// tags:
			//		private

			this.selection={};
			this.anchor = null;

			dijit.setWaiState(this.tree.domNode, "multiselect", !this.singular);

			this.events.push(
				dojo.connect(this.tree.domNode, "onmousedown", this,"onMouseDown"),
				dojo.connect(this.tree.domNode, "onmouseup", this,"onMouseUp"),
				dojo.connect(this.tree.domNode, "onmousemove", this,"onMouseMove")
			);
		},

		//	singular: Boolean
		//		Allows selection of only one element, if true.
		//		Tree hasn't been tested in singular=true mode, unclear if it works.
		singular: false,

		// methods
		getSelectedTreeNodes: function(){
			// summary:
			//		Returns a list of selected node(s).
			//		Used by dndSource on the start of a drag.
			// tags:
			//		protected
			var nodes=[], sel = this.selection;
			for(var i in sel){
				nodes.push(sel[i]);
			}
			return nodes;
		},

		selectNone: function(){
			// summary:
			//		Unselects all items
			// tags:
			//		private

			this.setSelection([]);
			return this;	// self
		},

		destroy: function(){
			// summary:
			//		Prepares the object to be garbage-collected
			this.inherited(arguments);
			this.selection = this.anchor = null;
		},
		addTreeNode: function(/*dijit._TreeNode*/node, /*Boolean?*/isAnchor){
			// summary
			//		add node to current selection
			// node: Node
			//		node to add
			// isAnchor: Boolean
			//		Whether the node should become anchor.

			this.setSelection(this.getSelectedTreeNodes().concat( [node] ));
			if(isAnchor){ this.anchor = node; }
			return node;
		},
		removeTreeNode: function(/*dijit._TreeNode*/node){
			// summary
			//		remove node from current selection
			// node: Node
			//		node to remove
			this.setSelection(this._setDifference(this.getSelectedTreeNodes(), [node]))
			return node;
		},
		isTreeNodeSelected: function(/*dijit._TreeNode*/node){
			// summary
			//		return true if node is currently selected
			// node: Node
			//		the node to check whether it's in the current selection

			return node.id && !!this.selection[node.id];
		},
		setSelection: function(/*dijit._treeNode[]*/ newSelection){
			// summary
			//      set the list of selected nodes to be exactly newSelection. All changes to the
			//      selection should be passed through this function, which ensures that derived
			//      attributes are kept up to date. Anchor will be deleted if it has been removed
			//      from the selection, but no new anchor will be added by this function.
			// newSelection: Node[]
			//      list of tree nodes to make selected
			var oldSelection = this.getSelectedTreeNodes();
			dojo.forEach(this._setDifference(oldSelection, newSelection), dojo.hitch(this, function(node){
				node.setSelected(false);
				if(this.anchor == node){
					delete this.anchor;
				}
				delete this.selection[node.id];
			}));
			dojo.forEach(this._setDifference(newSelection, oldSelection), dojo.hitch(this, function(node){
				node.setSelected(true);
				this.selection[node.id] = node;
			}));
			this._updateSelectionProperties();
		},
		_setDifference: function(xs,ys){
			// summary
			//      Returns a copy of xs which lacks any objects
			//      occurring in ys. Checks for membership by
			//      modifying and then reading the object, so it will
			//      not properly handle sets of numbers or strings.
			
			dojo.forEach(ys, function(y){ y.__exclude__ = true; });
			var ret = dojo.filter(xs, function(x){ return !x.__exclude__; });

			// clean up after ourselves.
			dojo.forEach(ys, function(y){ delete y['__exclude__'] });
			return ret;
		},
		_updateSelectionProperties: function() {
			// summary
			//      Update the following tree properties from the current selection:
			//      path[s], selectedItem[s], selectedNode[s]
			
			var selected = this.getSelectedTreeNodes();
			var paths = [], nodes = [];
			dojo.forEach(selected, function(node) {
				nodes.push(node);
				paths.push(node.getTreePath());
			});
			var items = dojo.map(nodes,function(node) { return node.item; });
			this.tree._set("paths", paths);
			this.tree._set("path", paths[0] || []);
			this.tree._set("selectedNodes", nodes);
			this.tree._set("selectedNode", nodes[0] || null);
			this.tree._set("selectedItems", items);
			this.tree._set("selectedItem", items[0] || null);
		},
		// mouse events
		onMouseDown: function(e){
			// summary:
			//		Event processor for onmousedown
			// e: Event
			//		mouse event
			// tags:
			//		protected

			// ignore click on expando node
			if(!this.current || this.tree.isExpandoNode( e.target, this.current)){ return; }

			if(e.button == dojo.mouseButtons.RIGHT){ return; }	// ignore right-click

			dojo.stopEvent(e);

			var treeNode = this.current,
			  copy = dojo.isCopyKey(e), id = treeNode.id;

			// if shift key is not pressed, and the node is already in the selection,
			// delay deselection until onmouseup so in the case of DND, deselection
			// will be canceled by onmousemove.
			if(!this.singular && !e.shiftKey && this.selection[id]){
				this._doDeselect = true;
				return;
			}else{
				this._doDeselect = false;
			}
			this.userSelect(treeNode, copy, e.shiftKey);
		},

		onMouseUp: function(e){
			// summary:
			//		Event processor for onmouseup
			// e: Event
			//		mouse event
			// tags:
			//		protected

			// _doDeselect is the flag to indicate that the user wants to either ctrl+click on
			// a already selected item (to deselect the item), or click on a not-yet selected item
			// (which should remove all current selection, and add the clicked item). This can not
			// be done in onMouseDown, because the user may start a drag after mousedown. By moving
			// the deselection logic here, the user can drags an already selected item.
			if(!this._doDeselect){ return; }
			this._doDeselect = false;
			this.userSelect(this.current, dojo.isCopyKey( e ), e.shiftKey);
		},
		onMouseMove: function(e){
			// summary
			//		event processor for onmousemove
			// e: Event
			//		mouse event
			this._doDeselect = false;
		},

		userSelect: function(node, multi, range){
			// summary:
			//		Add or remove the given node from selection, responding
			//      to a user action such as a click or keypress.
			// multi: Boolean
			//		Indicates whether this is meant to be a multi-select action (e.g. ctrl-click)
			// range: Boolean
			//		Indicates whether this is meant to be a ranged action (e.g. shift-click)
			// tags:
			//		protected

			if(this.singular){
				if(this.anchor == node && multi){
					this.selectNone();
				}else{
					this.setSelection([node]);
					this.anchor = node;
				}
			}else{
				if(range && this.anchor){
					var cr = dijit.tree._compareNodes(this.anchor.rowNode, node.rowNode),
					begin, end, anchor = this.anchor;
					
					if(cr < 0){ //current is after anchor
						begin = anchor;
						end = node;
					}else{ //current is before anchor
						begin = node;
						end = anchor;
					}
					nodes = [];
					//add everything betweeen begin and end inclusively
					while(begin != end) {
						nodes.push(begin)
						begin = this.tree._getNextNode(begin);
					}
					nodes.push(end)

					this.setSelection(nodes);
				}else{
				    if( this.selection[ node.id ] && multi ) {
						this.removeTreeNode( node );
				    } else if(multi) {
						this.addTreeNode(node, true);
					} else {
						this.setSelection([node]);
						this.anchor = node;
				    }
				}
			}
		},

		forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
			// summary:
			//		Iterates over selected items;
			//		see `dojo.dnd.Container.forInItems()` for details
			o = o || dojo.global;
			for(var id in this.selection){
				// console.log("selected item id: " + id);
				f.call(o, this.getItem(id), id, this);
			}
		}
});

}

if(!dojo._hasResource["dijit.Tree"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["dijit.Tree"] = true;
dojo.provide("dijit.Tree");













dojo.declare(
	"dijit._TreeNode",
	[dijit._Widget, dijit._Templated, dijit._Container, dijit._Contained, dijit._CssStateMixin],
{
	// summary:
	//		Single node within a tree.   This class is used internally
	//		by Tree and should not be accessed directly.
	// tags:
	//		private

	// item: [const] dojo.data.Item
	//		the dojo.data entry this tree represents
	item: null,

	// isTreeNode: [protected] Boolean
	//		Indicates that this is a TreeNode.   Used by `dijit.Tree` only,
	//		should not be accessed directly.
	isTreeNode: true,

	// label: String
	//		Text of this tree node
	label: "",

	// isExpandable: [private] Boolean
	//		This node has children, so show the expando node (+ sign)
	isExpandable: null,

	// isExpanded: [readonly] Boolean
	//		This node is currently expanded (ie, opened)
	isExpanded: false,

	// state: [private] String
	//		Dynamic loading-related stuff.
	//		When an empty folder node appears, it is "UNCHECKED" first,
	//		then after dojo.data query it becomes "LOADING" and, finally "LOADED"
	state: "UNCHECKED",

	templateString: dojo.cache("dijit", "templates/TreeNode.html", "<div class=\"dijitTreeNode\" role=\"presentation\"\n\t><div dojoAttachPoint=\"rowNode\" class=\"dijitTreeRow\" role=\"presentation\" dojoAttachEvent=\"onmouseenter:_onMouseEnter, onmouseleave:_onMouseLeave, onclick:_onClick, ondblclick:_onDblClick\"\n\t\t><img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint=\"expandoNode\" class=\"dijitTreeExpando\" role=\"presentation\"\n\t\t/><span dojoAttachPoint=\"expandoNodeText\" class=\"dijitExpandoText\" role=\"presentation\"\n\t\t></span\n\t\t><span dojoAttachPoint=\"contentNode\"\n\t\t\tclass=\"dijitTreeContent\" role=\"presentation\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" dojoAttachPoint=\"iconNode\" class=\"dijitIcon dijitTreeIcon\" role=\"presentation\"\n\t\t\t/><span dojoAttachPoint=\"labelNode\" class=\"dijitTreeLabel\" role=\"treeitem\" tabindex=\"-1\" aria-selected=\"false\" dojoAttachEvent=\"onfocus:_onLabelFocus\"></span>\n\t\t</span\n\t></div>\n\t<div dojoAttachPoint=\"containerNode\" class=\"dijitTreeContainer\" role=\"presentation\" style=\"display: none;\"></div>\n</div>\n"),

	baseClass: "dijitTreeNode",

	// For hover effect for tree node, and focus effect for label
	cssStateNodes: {
		rowNode: "dijitTreeRow",
		labelNode: "dijitTreeLabel"
	},

	attributeMap: dojo.delegate(dijit._Widget.prototype.attributeMap, {
		label: {node: "labelNode", type: "innerText"},
		tooltip: {node: "rowNode", type: "attribute", attribute: "title"}
	}),

	buildRendering: function(){
		this.inherited(arguments);

		// set expand icon for leaf
		this._setExpando();

		// set icon and label class based on item
		this._updateItemClasses(this.item);

		if(this.isExpandable){
			dijit.setWaiState(this.labelNode, "expanded", this.isExpanded);
		}

		//aria-selected should be false on all selectable elements.
		this.setSelected(false);
	},

	_setIndentAttr: function(indent){
		// summary:
		//		Tell this node how many levels it should be indented
		// description:
		//		0 for top level nodes, 1 for their children, 2 for their
		//		grandchildren, etc.

		// Math.max() is to prevent negative padding on hidden root node (when indent == -1)
		var pixels = (Math.max(indent, 0) * this.tree._nodePixelIndent) + "px";

		dojo.style(this.domNode, "backgroundPosition",	pixels + " 0px");
		dojo.style(this.rowNode, this.isLeftToRight() ? "paddingLeft" : "paddingRight", pixels);

		dojo.forEach(this.getChildren(), function(child){
			child.set("indent", indent+1);
		});
		
		this._set("indent", indent);
	},

	markProcessing: function(){
		// summary:
		//		Visually denote that tree is loading data, etc.
		// tags:
		//		private
		this.state = "LOADING";
		this._setExpando(true);
	},

	unmarkProcessing: function(){
		// summary:
		//		Clear markup from markProcessing() call
		// tags:
		//		private
		this._setExpando(false);
	},

	_updateItemClasses: function(item){
		// summary:
		//		Set appropriate CSS classes for icon and label dom node
		//		(used to allow for item updates to change respective CSS)
		// tags:
		//		private
		var tree = this.tree, model = tree.model;
		if(tree._v10Compat && item === model.root){
			// For back-compat with 1.0, need to use null to specify root item (TODO: remove in 2.0)
			item = null;
		}
		this._applyClassAndStyle(item, "icon", "Icon");
		this._applyClassAndStyle(item, "label", "Label");
		this._applyClassAndStyle(item, "row", "Row");
	},

	_applyClassAndStyle: function(item, lower, upper){
		// summary:
		//		Set the appropriate CSS classes and styles for labels, icons and rows.
		//
		// item:
		//		The data item.
		//
		// lower:
		//		The lower case attribute to use, e.g. 'icon', 'label' or 'row'.
		//
		// upper:
		//		The upper case attribute to use, e.g. 'Icon', 'Label' or 'Row'.
		//
		// tags:
		//		private

		var clsName = "_" + lower + "Class";
		var nodeName = lower + "Node";
		var oldCls = this[clsName];

		this[clsName] = this.tree["get" + upper + "Class"](item, this.isExpanded);
		dojo.replaceClass(this[nodeName], this[clsName] || "", oldCls || "");
 
		dojo.style(this[nodeName], this.tree["get" + upper + "Style"](item, this.isExpanded) || {});
 	},

	_updateLayout: function(){
		// summary:
		//		Set appropriate CSS classes for this.domNode
		// tags:
		//		private
		var parent = this.getParent();
		if(!parent || parent.rowNode.style.display == "none"){
			/* if we are hiding the root node then make every first level child look like a root node */
			dojo.addClass(this.domNode, "dijitTreeIsRoot");
		}else{
			dojo.toggleClass(this.domNode, "dijitTreeIsLast", !this.getNextSibling());
		}
	},

	_setExpando: function(/*Boolean*/ processing){
		// summary:
		//		Set the right image for the expando node
		// tags:
		//		private

		var styles = ["dijitTreeExpandoLoading", "dijitTreeExpandoOpened",
						"dijitTreeExpandoClosed", "dijitTreeExpandoLeaf"],
			_a11yStates = ["*","-","+","*"],
			idx = processing ? 0 : (this.isExpandable ?	(this.isExpanded ? 1 : 2) : 3);

		// apply the appropriate class to the expando node
		dojo.replaceClass(this.expandoNode, styles[idx], styles);

		// provide a non-image based indicator for images-off mode
		this.expandoNodeText.innerHTML = _a11yStates[idx];

	},

	expand: function(){
		// summary:
		//		Show my children
		// returns:
		//		Deferred that fires when expansion is complete

		// If there's already an expand in progress or we are already expanded, just return
		if(this._expandDeferred){
			return this._expandDeferred;		// dojo.Deferred
		}

		// cancel in progress collapse operation
		this._wipeOut && this._wipeOut.stop();

		// All the state information for when a node is expanded, maybe this should be
		// set when the animation completes instead
		this.isExpanded = true;
		dijit.setWaiState(this.labelNode, "expanded", "true");
		if(this.tree.showRoot || this !== this.tree.rootNode){
			dijit.setWaiRole(this.containerNode, "group");
		}
		dojo.addClass(this.contentNode,'dijitTreeContentExpanded');
		this._setExpando();
		this._updateItemClasses(this.item);
		if(this == this.tree.rootNode){
			dijit.setWaiState(this.tree.domNode, "expanded", "true");
		}

		var def,
			wipeIn = dojo.fx.wipeIn({
				node: this.containerNode, duration: dijit.defaultDuration,
				onEnd: function(){
					def.callback(true);
				}
			});

		// Deferred that fires when expand is complete
		def = (this._expandDeferred = new dojo.Deferred(function(){
			// Canceller
			wipeIn.stop();
		}));

		wipeIn.play();

		return def;		// dojo.Deferred
	},

	collapse: function(){
		// summary:
		//		Collapse this node (if it's expanded)

		if(!this.isExpanded){ return; }

		// cancel in progress expand operation
		if(this._expandDeferred){
			this._expandDeferred.cancel();
			delete this._expandDeferred;
		}

		this.isExpanded = false;
		dijit.setWaiState(this.labelNode, "expanded", "false");
		if(this == this.tree.rootNode){
			dijit.setWaiState(this.tree.domNode, "expanded", "false");
		}
		dojo.removeClass(this.contentNode,'dijitTreeContentExpanded');
		this._setExpando();
		this._updateItemClasses(this.item);

		if(!this._wipeOut){
			this._wipeOut = dojo.fx.wipeOut({
				node: this.containerNode, duration: dijit.defaultDuration
			});
		}
		this._wipeOut.play();
	},

	// indent: Integer
	//		Levels from this node to the root node
	indent: 0,

	setChildItems: function(/* Object[] */ items){
		// summary:
		//		Sets the child items of this node, removing/adding nodes
		//		from current children to match specified items[] array.
		//		Also, if this.persist == true, expands any children that were previously
		// 		opened.
		// returns:
		//		Deferred object that fires after all previously opened children
		//		have been expanded again (or fires instantly if there are no such children).

		var tree = this.tree,
			model = tree.model,
			defs = [];	// list of deferreds that need to fire before I am complete


		// Orphan all my existing children.
		// If items contains some of the same items as before then we will reattach them.
		// Don't call this.removeChild() because that will collapse the tree etc.
		dojo.forEach(this.getChildren(), function(child){
			dijit._Container.prototype.removeChild.call(this, child);
		}, this);

		this.state = "LOADED";

		if(items && items.length > 0){
			this.isExpandable = true;

			// Create _TreeNode widget for each specified tree node, unless one already
			// exists and isn't being used (presumably it's from a DnD move and was recently
			// released
			dojo.forEach(items, function(item){
				var id = model.getIdentity(item),
					existingNodes = tree._itemNodesMap[id],
					node;
				if(existingNodes){
					for(var i=0;i<existingNodes.length;i++){
						if(existingNodes[i] && !existingNodes[i].getParent()){
							node = existingNodes[i];
							node.set('indent', this.indent+1);
							break;
						}
					}
				}
				if(!node){
					node = this.tree._createTreeNode({
							item: item,
							tree: tree,
							isExpandable: model.mayHaveChildren(item),
							label: tree.getLabel(item),
							tooltip: tree.getTooltip(item),
							dir: tree.dir,
							lang: tree.lang,
							indent: this.indent + 1
						});
					if(existingNodes){
						existingNodes.push(node);
					}else{
						tree._itemNodesMap[id] = [node];
					}
				}
				this.addChild(node);

				// If node was previously opened then open it again now (this may trigger
				// more data store accesses, recursively)
				if(this.tree.autoExpand || this.tree._state(item)){
					defs.push(tree._expandNode(node));
				}
			}, this);

			// note that updateLayout() needs to be called on each child after
			// _all_ the children exist
			dojo.forEach(this.getChildren(), function(child, idx){
				child._updateLayout();
			});
		}else{
			this.isExpandable=false;
		}

		if(this._setExpando){
			// change expando to/from dot or + icon, as appropriate
			this._setExpando(false);
		}

		// Set leaf icon or folder icon, as appropriate
		this._updateItemClasses(this.item);

		// On initial tree show, make the selected TreeNode as either the root node of the tree,
		// or the first child, if the root node is hidden
		if(this == tree.rootNode){
			var fc = this.tree.showRoot ? this : this.getChildren()[0];
			if(fc){
				fc.setFocusable(true);
				tree.lastFocused = fc;
			}else{
				// fallback: no nodes in tree so focus on Tree <div> itself
				tree.domNode.setAttribute("tabIndex", "0");
			}
		}

		return new dojo.DeferredList(defs);	// dojo.Deferred
	},

	getTreePath: function(){
		var node = this;
		var path = [];
		while(node && node !== this.tree.rootNode){
				path.unshift(node.item);
				node = node.getParent();
		}
		path.unshift(this.tree.rootNode.item);

		return path;
	},

	getIdentity: function() {
		return this.tree.model.getIdentity(this.item);
	},

	removeChild: function(/* treeNode */ node){
		this.inherited(arguments);

		var children = this.getChildren();
		if(children.length == 0){
			this.isExpandable = false;
			this.collapse();
		}

		dojo.forEach(children, function(child){
				child._updateLayout();
		});
	},

	makeExpandable: function(){
		// summary:
		//		if this node wasn't already showing the expando node,
		//		turn it into one and call _setExpando()

		// TODO: hmm this isn't called from anywhere, maybe should remove it for 2.0

		this.isExpandable = true;
		this._setExpando(false);
	},

	_onLabelFocus: function(evt){
		// summary:
		//		Called when this row is focused (possibly programatically)
		//		Note that we aren't using _onFocus() builtin to dijit
		//		because it's called when focus is moved to a descendant TreeNode.
		// tags:
		//		private
		this.tree._onNodeFocus(this);
	},

	setSelected: function(/*Boolean*/ selected){
		// summary:
		//		A Tree has a (single) currently selected node.
		//		Mark that this node is/isn't that currently selected node.
		// description:
		//		In particular, setting a node as selected involves setting tabIndex
		//		so that when user tabs to the tree, focus will go to that node (only).
		dijit.setWaiState(this.labelNode, "selected", selected);
		dojo.toggleClass(this.rowNode, "dijitTreeRowSelected", selected);
	},

	setFocusable: function(/*Boolean*/ selected){
		// summary:
		//		A Tree has a (single) node that's focusable.
		//		Mark that this node is/isn't that currently focsuable node.
		// description:
		//		In particular, setting a node as selected involves setting tabIndex
		//		so that when user tabs to the tree, focus will go to that node (only).

		this.labelNode.setAttribute("tabIndex", selected ? "0" : "-1");
	},

	_onClick: function(evt){
		// summary:
		//		Handler for onclick event on a node
		// tags:
		//		private
		this.tree._onClick(this, evt);
	},
	_onDblClick: function(evt){
		// summary:
		//		Handler for ondblclick event on a node
		// tags:
		//		private
		this.tree._onDblClick(this, evt);
	},

	_onMouseEnter: function(evt){
		// summary:
		//		Handler for onmouseenter event on a node
		// tags:
		//		private
		this.tree._onNodeMouseEnter(this, evt);
	},

	_onMouseLeave: function(evt){
		// summary:
		//		Handler for onmouseenter event on a node
		// tags:
		//		private
		this.tree._onNodeMouseLeave(this, evt);
	}
});

dojo.declare(
	"dijit.Tree",
	[dijit._Widget, dijit._Templated],
{
	// summary:
	//		This widget displays hierarchical data from a store.

	// store: [deprecated] String||dojo.data.Store
	//		Deprecated.  Use "model" parameter instead.
	//		The store to get data to display in the tree.
	store: null,

	// model: dijit.Tree.model
	//		Interface to read tree data, get notifications of changes to tree data,
	//		and for handling drop operations (i.e drag and drop onto the tree)
	model: null,

	// query: [deprecated] anything
	//		Deprecated.  User should specify query to the model directly instead.
	//		Specifies datastore query to return the root item or top items for the tree.
	query: null,

	// label: [deprecated] String
	//		Deprecated.  Use dijit.tree.ForestStoreModel directly instead.
	//		Used in conjunction with query parameter.
	//		If a query is specified (rather than a root node id), and a label is also specified,
	//		then a fake root node is created and displayed, with this label.
	label: "",

	// showRoot: [const] Boolean
	//		Should the root node be displayed, or hidden?
	showRoot: true,

	// childrenAttr: [deprecated] String[]
	//		Deprecated.   This information should be specified in the model.
	//		One ore more attributes that holds children of a tree node
	childrenAttr: ["children"],

	// paths: String[][] or Item[][]
	//		Full paths from rootNode to selected nodes expressed as array of items or array of ids.
	//		Since setting the paths may be asynchronous (because ofwaiting on dojo.data), set("paths", ...)
	//		returns a Deferred to indicate when the set is complete.
	paths: [],
	
	// path: String[] or Item[]
	//      Backward compatible singular variant of paths.
	path: [],

	// selectedItems: [readonly] Item[]
	//		The currently selected items in this tree.
	//		This property can only be set (via set('selectedItems', ...)) when that item is already
	//		visible in the tree.   (I.e. the tree has already been expanded to show that node.)
	//		Should generally use `paths` attribute to set the selected items instead.
	selectedItems: null,

	// selectedItem: [readonly] Item
	//      Backward compatible singular variant of selectedItems.
	selectedItem: null,

	// openOnClick: Boolean
	//		If true, clicking a folder node's label will open it, rather than calling onClick()
	openOnClick: false,

	// openOnDblClick: Boolean
	//		If true, double-clicking a folder node's label will open it, rather than calling onDblClick()
	openOnDblClick: false,

	templateString: dojo.cache("dijit", "templates/Tree.html", "<div class=\"dijitTree dijitTreeContainer\" role=\"tree\"\n\tdojoAttachEvent=\"onkeypress:_onKeyPress\">\n\t<div class=\"dijitInline dijitTreeIndent\" style=\"position: absolute; top: -9999px\" dojoAttachPoint=\"indentDetector\"></div>\n</div>\n"),

	// persist: Boolean
	//		Enables/disables use of cookies for state saving.
	persist: true,

	// autoExpand: Boolean
	//		Fully expand the tree on load.   Overrides `persist`.
	autoExpand: false,

	// dndController: [protected] String
	//		Class name to use as as the dnd controller.  Specifying this class enables DnD.
	//		Generally you should specify this as "dijit.tree.dndSource".
	//      Default of "dijit.tree._dndSelector" handles selection only (no actual DnD).
	dndController: "dijit.tree._dndSelector",

	// parameters to pull off of the tree and pass on to the dndController as its params
	dndParams: ["onDndDrop","itemCreator","onDndCancel","checkAcceptance", "checkItemAcceptance", "dragThreshold", "betweenThreshold"],

	//declare the above items so they can be pulled from the tree's markup

	// onDndDrop: [protected] Function
	//		Parameter to dndController, see `dijit.tree.dndSource.onDndDrop`.
	//		Generally this doesn't need to be set.
	onDndDrop: null,

	/*=====
	itemCreator: function(nodes, target, source){
		// summary:
		//		Returns objects passed to `Tree.model.newItem()` based on DnD nodes
		//		dropped onto the tree.   Developer must override this method to enable
		// 		dropping from external sources onto this Tree, unless the Tree.model's items
		//		happen to look like {id: 123, name: "Apple" } with no other attributes.
		// description:
		//		For each node in nodes[], which came from source, create a hash of name/value
		//		pairs to be passed to Tree.model.newItem().  Returns array of those hashes.
		// nodes: DomNode[]
		//		The DOMNodes dragged from the source container
		// target: DomNode
		//		The target TreeNode.rowNode
		// source: dojo.dnd.Source
		//		The source container the nodes were dragged from, perhaps another Tree or a plain dojo.dnd.Source
		// returns: Object[]
		//		Array of name/value hashes for each new item to be added to the Tree, like:
		// |	[
		// |		{ id: 123, label: "apple", foo: "bar" },
		// |		{ id: 456, label: "pear", zaz: "bam" }
		// |	]
		// tags:
		//		extension
		return [{}];
	},
	=====*/
	itemCreator: null,

	// onDndCancel: [protected] Function
	//		Parameter to dndController, see `dijit.tree.dndSource.onDndCancel`.
	//		Generally this doesn't need to be set.
	onDndCancel: null,

/*=====
	checkAcceptance: function(source, nodes){
		// summary:
		//		Checks if the Tree itself can accept nodes from this source
		// source: dijit.tree._dndSource
		//		The source which provides items
		// nodes: DOMNode[]
		//		Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
		//		source is a dijit.Tree.
		// tags:
		//		extension
		return true;	// Boolean
	},
=====*/
	checkAcceptance: null,

/*=====
	checkItemAcceptance: function(target, source, position){
		// summary:
		//		Stub function to be overridden if one wants to check for the ability to drop at the node/item level
		// description:
		//		In the base case, this is called to check if target can become a child of source.
		//		When betweenThreshold is set, position="before" or "after" means that we
		//		are asking if the source node can be dropped before/after the target node.
		// target: DOMNode
		//		The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
		//		Use dijit.getEnclosingWidget(target) to get the TreeNode.
		// source: dijit.tree.dndSource
		//		The (set of) nodes we are dropping
		// position: String
		//		"over", "before", or "after"
		// tags:
		//		extension
		return true;	// Boolean
	},
=====*/
	checkItemAcceptance: null,

	// dragThreshold: Integer
	//		Number of pixels mouse moves before it's considered the start of a drag operation
	dragThreshold: 5,

	// betweenThreshold: Integer
	//		Set to a positive value to allow drag and drop "between" nodes.
	//
	//		If during DnD mouse is over a (target) node but less than betweenThreshold
	//		pixels from the bottom edge, dropping the the dragged node will make it
	//		the next sibling of the target node, rather than the child.
	//
	//		Similarly, if mouse is over a target node but less that betweenThreshold
	//		pixels from the top edge, dropping the dragged node will make it
	//		the target node's previous sibling rather than the target node's child.
	betweenThreshold: 0,

	// _nodePixelIndent: Integer
	//		Number of pixels to indent tree nodes (relative to parent node).
	//		Default is 19 but can be overridden by setting CSS class dijitTreeIndent
	//		and calling resize() or startup() on tree after it's in the DOM.
	_nodePixelIndent: 19,

	_publish: function(/*String*/ topicName, /*Object*/ message){
		// summary:
		//		Publish a message for this widget/topic
		dojo.publish(this.id, [dojo.mixin({tree: this, event: topicName}, message || {})]);
	},

	postMixInProperties: function(){
		this.tree = this;

		if(this.autoExpand){
			// There's little point in saving opened/closed state of nodes for a Tree
			// that initially opens all it's nodes.
			this.persist = false;
		}

		this._itemNodesMap={};

		if(!this.cookieName){
			this.cookieName = this.id + "SaveStateCookie";
		}

		this._loadDeferred = new dojo.Deferred();

		this.inherited(arguments);
	},

	postCreate: function(){
		this._initState();

		// Create glue between store and Tree, if not specified directly by user
		if(!this.model){
			this._store2model();
		}

		// monitor changes to items
		this.connect(this.model, "onChange", "_onItemChange");
		this.connect(this.model, "onChildrenChange", "_onItemChildrenChange");
		this.connect(this.model, "onDelete", "_onItemDelete");

		this._load();

		this.inherited(arguments);

		if(this.dndController){
			if(dojo.isString(this.dndController)){
				this.dndController = dojo.getObject(this.dndController);
			}
			var params={};
			for(var i=0; i<this.dndParams.length;i++){
				if(this[this.dndParams[i]]){
					params[this.dndParams[i]] = this[this.dndParams[i]];
				}
			}
			this.dndController = new this.dndController(this, params);
		}
	},

	_store2model: function(){
		// summary:
		//		User specified a store&query rather than model, so create model from store/query
		this._v10Compat = true;
		dojo.deprecated("Tree: from version 2.0, should specify a model object rather than a store/query");

		var modelParams = {
			id: this.id + "_ForestStoreModel",
			store: this.store,
			query: this.query,
			childrenAttrs: this.childrenAttr
		};

		// Only override the model's mayHaveChildren() method if the user has specified an override
		if(this.params.mayHaveChildren){
			modelParams.mayHaveChildren = dojo.hitch(this, "mayHaveChildren");
		}

		if(this.params.getItemChildren){
			modelParams.getChildren = dojo.hitch(this, function(item, onComplete, onError){
				this.getItemChildren((this._v10Compat && item === this.model.root) ? null : item, onComplete, onError);
			});
		}
		this.model = new dijit.tree.ForestStoreModel(modelParams);

		// For backwards compatibility, the visibility of the root node is controlled by
		// whether or not the user has specified a label
		this.showRoot = Boolean(this.label);
	},

	onLoad: function(){
		// summary:
		//		Called when tree finishes loading and expanding.
		// description:
		//		If persist == true the loading may encompass many levels of fetches
		//		from the data store, each asynchronous.   Waits for all to finish.
		// tags:
		//		callback
	},

	_load: function(){
		// summary:
		//		Initial load of the tree.
		//		Load root node (possibly hidden) and it's children.
		this.model.getRoot(
			dojo.hitch(this, function(item){
				var rn = (this.rootNode = this.tree._createTreeNode({
					item: item,
					tree: this,
					isExpandable: true,
					label: this.label || this.getLabel(item),
					indent: this.showRoot ? 0 : -1
				}));
				if(!this.showRoot){
					rn.rowNode.style.display="none";
					// if root is not visible, move tree role to the invisible
					// root node's containerNode, see #12135
					dijit.setWaiRole(this.domNode, 'presentation');
					
					dijit.setWaiRole(rn.labelNode, 'presentation');
					dijit.setWaiRole(rn.containerNode, 'tree');
				}
				this.domNode.appendChild(rn.domNode);
				var identity = this.model.getIdentity(item);
				if(this._itemNodesMap[identity]){
					this._itemNodesMap[identity].push(rn);
				}else{
					this._itemNodesMap[identity] = [rn];
				}

				rn._updateLayout();		// sets "dijitTreeIsRoot" CSS classname

				// load top level children and then fire onLoad() event
				this._expandNode(rn).addCallback(dojo.hitch(this, function(){
					this._loadDeferred.callback(true);
					this.onLoad();
				}));
			}),
			function(err){
				console.error(this, ": error loading root: ", err);
			}
		);
	},

	getNodesByItem: function(/*dojo.data.Item or id*/ item){
		// summary:
		//		Returns all tree nodes that refer to an item
		// returns:
		//		Array of tree nodes that refer to passed item

		if(!item){ return []; }
		var identity = dojo.isString(item) ? item : this.model.getIdentity(item);
		// return a copy so widget don't get messed up by changes to returned array
		return [].concat(this._itemNodesMap[identity]);
	},

	_setSelectedItemAttr: function(/*dojo.data.Item or id*/ item){
		this.set('selectedItems', [item]);
	},

	_setSelectedItemsAttr: function(/*dojo.data.Items or ids*/ items){
		// summary:
		//		Select tree nodes related to passed items.
		//		WARNING: if model use multi-parented items or desired tree node isn't already loaded
		//		behavior is undefined. Use set('paths', ...) instead.
		var tree = this;
		this._loadDeferred.addCallback( dojo.hitch(this, function(){
			var identities = dojo.map(items, function(item){
				return (!item || dojo.isString(item)) ? item : tree.model.getIdentity(item);
			});
			var nodes = [];
			dojo.forEach(identities, function(id){
				nodes = nodes.concat(tree._itemNodesMap[id] || []);
			});
			this.set('selectedNodes', nodes);
		}));
	},

	_setPathAttr: function(/*Item[] || String[]*/ path){
		// summary:
		//      Singular variant of _setPathsAttr
		if(path.length) {
			return this.set("paths", [path]);
		} else {
			//Empty list is interpreted as "select nothing"
			return this.set("paths", []);
		}
	},
	
	_setPathsAttr: function(/*Item[][] || String[][]*/ paths){
		// summary:
		//		Select the tree nodes identified by passed paths.
		// paths:
		//		Array of arrays of items or item id's
		// returns:
		//		Deferred to indicate when the set is complete
		var tree = this;

		// We may need to wait for some nodes to expand, so setting
		// each path will involve a Deferred. We bring those deferreds
		// together witha DeferredList.
		return new dojo.DeferredList(dojo.map(paths, function(path){
			var d = new dojo.Deferred();
			
			// normalize path to use identity
			path = dojo.map(path, function(item){
				return dojo.isString(item) ? item : tree.model.getIdentity(item);
			});

			if(path.length){
				// Wait for the tree to load, if it hasn't already.
				tree._loadDeferred.addCallback(function(){ selectPath(path, [tree.rootNode], d); });
			}else{
				d.errback("Empty path");
			}
			return d;
		})).addCallback(setNodes);

		function selectPath(path, nodes, def){
			// Traverse path; the next path component should be among "nodes".
			var nextPath = path.shift();
			var nextNode = dojo.filter(nodes, function(node){
				return node.getIdentity() == nextPath;
			})[0];
			if(!!nextNode){
				if(path.length){
					tree._expandNode(nextNode).addCallback(function(){ selectPath(path, nextNode.getChildren(), def); });
				}else{
					//Successfully reached the end of this path
					def.callback(nextNode);
				}
			} else {
				def.errback("Could not expand path at " + nextPath);
			}
		}
		
		function setNodes(newNodes){
			//After all expansion is finished, set the selection to
			//the set of nodes successfully found.
			tree.set("selectedNodes", dojo.map(
				dojo.filter(newNodes,function(x){return x[0];}),
				function(x){return x[1];}));
		}
	},

	_setSelectedNodeAttr: function(node){
		this.set('selectedNodes', [node]);
	},
	_setSelectedNodesAttr: function(nodes){
		this._loadDeferred.addCallback( dojo.hitch(this, function(){
			this.dndController.setSelection(nodes);
		}));
	},


	////////////// Data store related functions //////////////////////
	// These just get passed to the model; they are here for back-compat

	mayHaveChildren: function(/*dojo.data.Item*/ item){
		// summary:
		//		Deprecated.   This should be specified on the model itself.
		//
		//		Overridable function to tell if an item has or may have children.
		//		Controls whether or not +/- expando icon is shown.
		//		(For efficiency reasons we may not want to check if an element actually
		//		has children until user clicks the expando node)
		// tags:
		//		deprecated
	},

	getItemChildren: function(/*dojo.data.Item*/ parentItem, /*function(items)*/ onComplete){
		// summary:
		//		Deprecated.   This should be specified on the model itself.
		//
		// 		Overridable function that return array of child items of given parent item,
		//		or if parentItem==null then return top items in tree
		// tags:
		//		deprecated
	},

	///////////////////////////////////////////////////////
	// Functions for converting an item to a TreeNode
	getLabel: function(/*dojo.data.Item*/ item){
		// summary:
		//		Overridable function to get the label for a tree node (given the item)
		// tags:
		//		extension
		return this.model.getLabel(item);	// String
	},

	getIconClass: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS class name to display icon
		// tags:
		//		extension
		return (!item || this.model.mayHaveChildren(item)) ? (opened ? "dijitFolderOpened" : "dijitFolderClosed") : "dijitLeaf"
	},

	getLabelClass: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS class name to display label
		// tags:
		//		extension
	},

	getRowClass: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS class name to display row
		// tags:
		//		extension
	},

	getIconStyle: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS styles to display icon
		// returns:
		//		Object suitable for input to dojo.style() like {backgroundImage: "url(...)"}
		// tags:
		//		extension
	},

	getLabelStyle: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS styles to display label
		// returns:
		//		Object suitable for input to dojo.style() like {color: "red", background: "green"}
		// tags:
		//		extension
	},

	getRowStyle: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS styles to display row
		// returns:
		//		Object suitable for input to dojo.style() like {background-color: "#bbb"}
		// tags:
		//		extension
	},

	getTooltip: function(/*dojo.data.Item*/ item){
		// summary:
		//		Overridable function to get the tooltip for a tree node (given the item)
		// tags:
		//		extension
		return "";	// String
	},

	/////////// Keyboard and Mouse handlers ////////////////////

	_onKeyPress: function(/*Event*/ e){
		// summary:
		//		Translates keypress events into commands for the controller
		if(e.altKey){ return; }
		var dk = dojo.keys;
		var treeNode = dijit.getEnclosingWidget(e.target);
		if(!treeNode){ return; }

		var key = e.charOrCode;
		if(typeof key == "string" && key != " "){	// handle printables (letter navigation)
			// Check for key navigation.
			if(!e.altKey && !e.ctrlKey && !e.shiftKey && !e.metaKey){
				this._onLetterKeyNav( { node: treeNode, key: key.toLowerCase() } );
				dojo.stopEvent(e);
			}
		}else{	// handle non-printables (arrow keys)
			// clear record of recent printables (being saved for multi-char letter navigation),
			// because "a", down-arrow, "b" shouldn't search for "ab"
			if(this._curSearch){
				clearTimeout(this._curSearch.timer);
				delete this._curSearch;
			}

			var map = this._keyHandlerMap;
			if(!map){
				// setup table mapping keys to events
				map = {};
				map[dk.ENTER]="_onEnterKey";
				//On WebKit based browsers, the combination ctrl-enter
				//does not get passed through. To allow accessible
				//multi-select on those browsers, the space key is
				//also used for selection.
				map[dk.SPACE]= map[" "] = "_onEnterKey";
				map[this.isLeftToRight() ? dk.LEFT_ARROW : dk.RIGHT_ARROW]="_onLeftArrow";
				map[this.isLeftToRight() ? dk.RIGHT_ARROW : dk.LEFT_ARROW]="_onRightArrow";
				map[dk.UP_ARROW]="_onUpArrow";
				map[dk.DOWN_ARROW]="_onDownArrow";
				map[dk.HOME]="_onHomeKey";
				map[dk.END]="_onEndKey";
				this._keyHandlerMap = map;
			}
			if(this._keyHandlerMap[key]){
				this[this._keyHandlerMap[key]]( { node: treeNode, item: treeNode.item, evt: e } );
				dojo.stopEvent(e);
			}
		}
	},

	_onEnterKey: function(/*Object*/ message){
		this._publish("execute", { item: message.item, node: message.node } );
		this.dndController.userSelect(message.node, dojo.isCopyKey( message.evt ), message.evt.shiftKey);
		this.onClick(message.item, message.node, message.evt);
	},

	_onDownArrow: function(/*Object*/ message){
		// summary:
		//		down arrow pressed; get next visible node, set focus there
		var node = this._getNextNode(message.node);
		if(node && node.isTreeNode){
			this.focusNode(node);
		}
	},

	_onUpArrow: function(/*Object*/ message){
		// summary:
		//		Up arrow pressed; move to previous visible node

		var node = message.node;

		// if younger siblings
		var previousSibling = node.getPreviousSibling();
		if(previousSibling){
			node = previousSibling;
			// if the previous node is expanded, dive in deep
			while(node.isExpandable && node.isExpanded && node.hasChildren()){
				// move to the last child
				var children = node.getChildren();
				node = children[children.length-1];
			}
		}else{
			// if this is the first child, return the parent
			// unless the parent is the root of a tree with a hidden root
			var parent = node.getParent();
			if(!(!this.showRoot && parent === this.rootNode)){
				node = parent;
			}
		}

		if(node && node.isTreeNode){
			this.focusNode(node);
		}
	},

	_onRightArrow: function(/*Object*/ message){
		// summary:
		//		Right arrow pressed; go to child node
		var node = message.node;

		// if not expanded, expand, else move to 1st child
		if(node.isExpandable && !node.isExpanded){
			this._expandNode(node);
		}else if(node.hasChildren()){
			node = node.getChildren()[0];
			if(node && node.isTreeNode){
				this.focusNode(node);
			}
		}
	},

	_onLeftArrow: function(/*Object*/ message){
		// summary:
		//		Left arrow pressed.
		//		If not collapsed, collapse, else move to parent.

		var node = message.node;

		if(node.isExpandable && node.isExpanded){
			this._collapseNode(node);
		}else{
			var parent = node.getParent();
			if(parent && parent.isTreeNode && !(!this.showRoot && parent === this.rootNode)){
				this.focusNode(parent);
			}
		}
	},

	_onHomeKey: function(){
		// summary:
		//		Home key pressed; get first visible node, and set focus there
		var node = this._getRootOrFirstNode();
		if(node){
			this.focusNode(node);
		}
	},

	_onEndKey: function(/*Object*/ message){
		// summary:
		//		End key pressed; go to last visible node.

		var node = this.rootNode;
		while(node.isExpanded){
			var c = node.getChildren();
			node = c[c.length - 1];
		}

		if(node && node.isTreeNode){
			this.focusNode(node);
		}
	},

	// multiCharSearchDuration: Number
	//		If multiple characters are typed where each keystroke happens within
	//		multiCharSearchDuration of the previous keystroke,
	//		search for nodes matching all the keystrokes.
	//
	//		For example, typing "ab" will search for entries starting with
	//		"ab" unless the delay between "a" and "b" is greater than multiCharSearchDuration.
	multiCharSearchDuration: 250,

	_onLetterKeyNav: function(message){
		// summary:
		//		Called when user presses a prinatable key; search for node starting with recently typed letters.
		// message: Object
		//		Like { node: TreeNode, key: 'a' } where key is the key the user pressed.

		// Branch depending on whether this key starts a new search, or modifies an existing search
		var cs = this._curSearch;
		if(cs){
			// We are continuing a search.  Ex: user has pressed 'a', and now has pressed
			// 'b', so we want to search for nodes starting w/"ab".
			cs.pattern = cs.pattern + message.key;
			clearTimeout(cs.timer);
		}else{
			// We are starting a new search
			cs = this._curSearch = {
					pattern: message.key,
					startNode: message.node
			};
		}

		// set/reset timer to forget recent keystrokes
		var self = this;
		cs.timer = setTimeout(function(){
			delete self._curSearch;
		}, this.multiCharSearchDuration);

		// Navigate to TreeNode matching keystrokes [entered so far].
		var node = cs.startNode;
		do{
			node = this._getNextNode(node);
			//check for last node, jump to first node if necessary
			if(!node){
				node = this._getRootOrFirstNode();
			}
		}while(node !== cs.startNode && (node.label.toLowerCase().substr(0, cs.pattern.length) != cs.pattern));
		if(node && node.isTreeNode){
			// no need to set focus if back where we started
			if(node !== cs.startNode){
				this.focusNode(node);
			}
		}
	},

	isExpandoNode: function(node, widget){
		// summary:
		//		check whether a dom node is the expandoNode for a particular TreeNode widget
		return dojo.isDescendant(node, widget.expandoNode);
	},
	_onClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
		// summary:
		//		Translates click events into commands for the controller to process

		var domElement = e.target,
			isExpandoClick = this.isExpandoNode(domElement, nodeWidget);

		if( (this.openOnClick && nodeWidget.isExpandable) || isExpandoClick ){
			// expando node was clicked, or label of a folder node was clicked; open it
			if(nodeWidget.isExpandable){
				this._onExpandoClick({node:nodeWidget});
			}
		}else{
			this._publish("execute", { item: nodeWidget.item, node: nodeWidget, evt: e } );
			this.onClick(nodeWidget.item, nodeWidget, e);
			this.focusNode(nodeWidget);
		}
		dojo.stopEvent(e);
	},
	_onDblClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
		// summary:
		//		Translates double-click events into commands for the controller to process

		var domElement = e.target,
			isExpandoClick = (domElement == nodeWidget.expandoNode || domElement == nodeWidget.expandoNodeText);

		if( (this.openOnDblClick && nodeWidget.isExpandable) ||isExpandoClick ){
			// expando node was clicked, or label of a folder node was clicked; open it
			if(nodeWidget.isExpandable){
				this._onExpandoClick({node:nodeWidget});
			}
		}else{
			this._publish("execute", { item: nodeWidget.item, node: nodeWidget, evt: e } );
			this.onDblClick(nodeWidget.item, nodeWidget, e);
			this.focusNode(nodeWidget);
		}
		dojo.stopEvent(e);
	},

	_onExpandoClick: function(/*Object*/ message){
		// summary:
		//		User clicked the +/- icon; expand or collapse my children.
		var node = message.node;

		// If we are collapsing, we might be hiding the currently focused node.
		// Also, clicking the expando node might have erased focus from the current node.
		// For simplicity's sake just focus on the node with the expando.
		var toFocus = true;
		if(window.preventTableHeaderFocus || window.isToPreventTableHeaderFocusAlways || window.isTopElementToBeFocussed) { 
			toFocus = ! (window.preventTableHeaderFocus || window.isToPreventTableHeaderFocusAlways || window.isTopElementToBeFocussed); 
		}
		if(toFocus) {		
			this.focusNode(node);
		}

		if(node.isExpanded){
			this._collapseNode(node);
		}else{
			this._expandNode(node);
		}
	},

	onClick: function(/* dojo.data */ item, /*TreeNode*/ node, /*Event*/ evt){
		// summary:
		//		Callback when a tree node is clicked
		// tags:
		//		callback
	},
	onDblClick: function(/* dojo.data */ item, /*TreeNode*/ node, /*Event*/ evt){
		// summary:
		//		Callback when a tree node is double-clicked
		// tags:
		//		callback
	},
	onOpen: function(/* dojo.data */ item, /*TreeNode*/ node){
		// summary:
		//		Callback when a node is opened
		// tags:
		//		callback
	},
	onClose: function(/* dojo.data */ item, /*TreeNode*/ node){
		// summary:
		//		Callback when a node is closed
		// tags:
		//		callback
	},

	_getNextNode: function(node){
		// summary:
		//		Get next visible node

		if(node.isExpandable && node.isExpanded && node.hasChildren()){
			// if this is an expanded node, get the first child
			return node.getChildren()[0];		// _TreeNode
		}else{
			// find a parent node with a sibling
			while(node && node.isTreeNode){
				var returnNode = node.getNextSibling();
				if(returnNode){
					return returnNode;		// _TreeNode
				}
				node = node.getParent();
			}
			return null;
		}
	},

	_getRootOrFirstNode: function(){
		// summary:
		//		Get first visible node
		return this.showRoot ? this.rootNode : this.rootNode.getChildren()[0];
	},

	_collapseNode: function(/*_TreeNode*/ node){
		// summary:
		//		Called when the user has requested to collapse the node

		if(node._expandNodeDeferred){
			delete node._expandNodeDeferred;
		}

		if(node.isExpandable){
			if(node.state == "LOADING"){
				// ignore clicks while we are in the process of loading data
				return;
			}

			node.collapse();
			this.onClose(node.item, node);

			if(node.item){
				this._state(node.item,false);
				this._saveState();
			}
		}
	},

	_expandNode: function(/*_TreeNode*/ node, /*Boolean?*/ recursive){
		// summary:
		//		Called when the user has requested to expand the node
		// recursive:
		//		Internal flag used when _expandNode() calls itself, don't set.
		// returns:
		//		Deferred that fires when the node is loaded and opened and (if persist=true) all it's descendants
		//		that were previously opened too

		if(node._expandNodeDeferred && !recursive){
			// there's already an expand in progress (or completed), so just return
			return node._expandNodeDeferred;	// dojo.Deferred
		}

		var model = this.model,
			item = node.item,
			_this = this;

		switch(node.state){
			case "UNCHECKED":
				// need to load all the children, and then expand
				node.markProcessing();

				// Setup deferred to signal when the load and expand are finished.
				// Save that deferred in this._expandDeferred as a flag that operation is in progress.
				var def = (node._expandNodeDeferred = new dojo.Deferred());

				// Get the children
				model.getChildren(
					item,
					function(items){
						node.unmarkProcessing();

						// Display the children and also start expanding any children that were previously expanded
						// (if this.persist == true).   The returned Deferred will fire when those expansions finish.
						var scid = node.setChildItems(items);

						// Call _expandNode() again but this time it will just to do the animation (default branch).
						// The returned Deferred will fire when the animation completes.
						// TODO: seems like I can avoid recursion and just use a deferred to sequence the events?
						var ed = _this._expandNode(node, true);

						// After the above two tasks (setChildItems() and recursive _expandNode()) finish,
						// signal that I am done.
						scid.addCallback(function(){
							ed.addCallback(function(){
								def.callback();
							})
						});
					},
					function(err){
						console.error(_this, ": error loading root children: ", err);
					}
				);
				break;

			default:	// "LOADED"
				// data is already loaded; just expand node
				def = (node._expandNodeDeferred = node.expand());

				this.onOpen(node.item, node);

				if(item){
					this._state(item, true);
					this._saveState();
				}
		}

		return def;	// dojo.Deferred
	},

	////////////////// Miscellaneous functions ////////////////

	focusNode: function(/* _tree.Node */ node){
		// summary:
		//		Focus on the specified node (which must be visible)
		// tags:
		//		protected

		// set focus so that the label will be voiced using screen readers
		dijit.focus(node.labelNode);
	},

	_onNodeFocus: function(/*dijit._Widget*/ node){
		// summary:
		//		Called when a TreeNode gets focus, either by user clicking
		//		it, or programatically by arrow key handling code.
		// description:
		//		It marks that the current node is the selected one, and the previously
		//		selected node no longer is.

		if(node && node != this.lastFocused){
			if(this.lastFocused && !this.lastFocused._destroyed){
				// mark that the previously focsable node is no longer focusable
				this.lastFocused.setFocusable(false);
			}

			// mark that the new node is the currently selected one
			node.setFocusable(true);
			this.lastFocused = node;
		}
	},

	_onNodeMouseEnter: function(/*dijit._Widget*/ node){
		// summary:
		//		Called when mouse is over a node (onmouseenter event),
		//		this is monitored by the DND code
	},

	_onNodeMouseLeave: function(/*dijit._Widget*/ node){
		// summary:
		//		Called when mouse leaves a node (onmouseleave event),
		//		this is monitored by the DND code
	},

	//////////////// Events from the model //////////////////////////

	_onItemChange: function(/*Item*/ item){
		// summary:
		//		Processes notification of a change to an item's scalar values like label
		var model = this.model,
			identity = model.getIdentity(item),
			nodes = this._itemNodesMap[identity];

		if(nodes){
			var label = this.getLabel(item),
				tooltip = this.getTooltip(item);
			dojo.forEach(nodes, function(node){
				node.set({
					item: item,		// theoretically could be new JS Object representing same item
					label: label,
					tooltip: tooltip
				});
				node._updateItemClasses(item);
			});
		}
	},

	_onItemChildrenChange: function(/*dojo.data.Item*/ parent, /*dojo.data.Item[]*/ newChildrenList){
		// summary:
		//		Processes notification of a change to an item's children
		var model = this.model,
			identity = model.getIdentity(parent),
			parentNodes = this._itemNodesMap[identity];

		if(parentNodes){
			dojo.forEach(parentNodes,function(parentNode){
				parentNode.setChildItems(newChildrenList);
			});
		}
	},

	_onItemDelete: function(/*Item*/ item){
		// summary:
		//		Processes notification of a deletion of an item
		var model = this.model,
			identity = model.getIdentity(item),
			nodes = this._itemNodesMap[identity];

		if(nodes){
			dojo.forEach(nodes,function(node){
				// Remove node from set of selected nodes (if it's selected)
				this.dndController.removeTreeNode(node);

				var parent = node.getParent();
				if(parent){
					// if node has not already been orphaned from a _onSetItem(parent, "children", ..) call...
					parent.removeChild(node);
				}
				node.destroyRecursive();
			}, this);
			delete this._itemNodesMap[identity];
		}
	},

	/////////////// Miscellaneous funcs

	_initState: function(){
		// summary:
		//		Load in which nodes should be opened automatically
		if(this.persist){
			var cookie = dojo.cookie(this.cookieName);
			this._openedItemIds = {};
			if(cookie){
				dojo.forEach(cookie.split(','), function(item){
					this._openedItemIds[item] = true;
				}, this);
			}
		}
	},
	_state: function(item,expanded){
		// summary:
		//		Query or set expanded state for an item,
		if(!this.persist){
			return false;
		}
		var id=this.model.getIdentity(item);
		if(arguments.length === 1){
			return this._openedItemIds[id];
		}
		if(expanded){
			this._openedItemIds[id] = true;
		}else{
			delete this._openedItemIds[id];
		}
	},
	_saveState: function(){
		// summary:
		//		Create and save a cookie with the currently expanded nodes identifiers
		if(!this.persist){
			return;
		}
		var ary = [];
		for(var id in this._openedItemIds){
			ary.push(id);
		}
		dojo.cookie(this.cookieName, ary.join(","), {expires:365});
	},

	destroy: function(){
		if(this._curSearch){
			clearTimeout(this._curSearch.timer);
			delete this._curSearch;
		}
		if(this.rootNode){
			this.rootNode.destroyRecursive();
		}
		if(this.dndController && !dojo.isString(this.dndController)){
			this.dndController.destroy();
		}
		this.rootNode = null;
		this.inherited(arguments);
	},

	destroyRecursive: function(){
		// A tree is treated as a leaf, not as a node with children (like a grid),
		// but defining destroyRecursive for back-compat.
		this.destroy();
	},

	resize: function(changeSize){
		if(changeSize){
			dojo.marginBox(this.domNode, changeSize);
		}

		// The only JS sizing involved w/tree is the indentation, which is specified
		// in CSS and read in through this dummy indentDetector node (tree must be
		// visible and attached to the DOM to read this)
		this._nodePixelIndent = dojo._getMarginSize(this.tree.indentDetector).w;

		if(this.tree.rootNode){
			// If tree has already loaded, then reset indent for all the nodes
			this.tree.rootNode.set('indent', this.showRoot ? 0 : -1);
		}
	},

	_createTreeNode: function(/*Object*/ args){
		// summary:
		//		creates a TreeNode
		// description:
		//		Developers can override this method to define their own TreeNode class;
		//		However it will probably be removed in a future release in favor of a way
		//		of just specifying a widget for the label, rather than one that contains
		//		the children too.
		return new dijit._TreeNode(args);
	}
});

// For back-compat.  TODO: remove in 2.0

}

if(!dojo._hasResource["misys.widget.Tree"]){ //_hasResource checks added by build. Do not use _hasResource directly in your code.
dojo._hasResource["misys.widget.Tree"] = true;
dojo.provide("misys.widget.Tree");
dojo.experimental("misys.widget.Tree");



dojo.declare(
	"misys.widget.Tree",
	[dijit.Tree],
	{
		onLoadId : 0,
		
		parentId : '',
		
		childId : '',
		
		rootIdTree : '',
		
		onLoad: function(){
			this.onLoadOpen();
		},
		
		onLoadOpen : function (){
			// summary:
			//		Translates click events into commands for the controller to process

			if(this.onLoadId > 0)
			{
				var nodeWidget = this._itemNodesMap[this.onLoadId];
				var domElement = nodeWidget[0].domNode;
				
				// expando node was clicked, or label of a folder node was clicked; open it
				if(nodeWidget[0].isExpandable){
					this._onExpandoClick({node:nodeWidget[0]});
				}
			}
			if(this.parentId !== null && this.parentId !== '')
			{
				var array = [];
				var childArray = [];
				childArray.push(this.rootIdTree);
				childArray.push(this.parentId);
				if(this.childId !== '0')
				{
					childArray.push(this.childId);
				}
				array.push(childArray);
				this.set("paths",array);
			}
		},
		
		onClick: function(/* dojo.data */ item, /*TreeNode*/ node, /*Event*/ evt){
			if(item.url) {
				document.location.href = item.url;
			} else {
				if(node.isExpanded){
					this._collapseNode(node);
				}else{
					this._expandNode(node);
				}
			}
		},
		
		
		_onClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){	
				
				var evt = e;
			//	var targetUrl =misys._getTargetUrl(evt);
				var targetUrl = nodeWidget.item.url;
				if(targetUrl !== "" && targetUrl!=undefined)
				{
					if(misys.isPopupRequired())					
					{
					dojo.stopEvent(evt);
					misys.showUnsavedDataDialog();
					var handle = dojo.connect(misys, "setUnsavedDataOption", function(){
						if(misys.unsavedDataOption !== 'notset')
						{
							var errorMsg = "";
							if(misys.unsavedDataOption == 'save')
							{
							//	errorMsg = _submitAsync("SAVE");
								misys.saveAsync(targetUrl);
								this.inherited(arguments);
							}
							else if(targetUrl !== "" && errorMsg === "" && misys.unsavedDataOption == 'nosave')
							{
								location.href = targetUrl;
								this.inherited(arguments);
							}
						}	
						dojo.disconnect(handle);
					});
				}
					else
						{
						this.inherited(arguments);
						}
			}
				else
					{
			this.inherited(arguments);
					}
		}
	}
);



}


dojo.i18n._preloadLocalizations("dojo.nls.misys_common", ["ROOT","ar","ar-ar","de","de-de","en","en-gb","en-us","fr","fr-fr","pt","pt-br","th","th-th","xx","zh","zh-cn"]);
